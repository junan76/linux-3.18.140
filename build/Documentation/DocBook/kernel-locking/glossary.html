<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>Glossary</title><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot"><link rel="home" href="index.html" title="Unreliable Guide To Locking"><link rel="up" href="index.html" title="Unreliable Guide To Locking"><link rel="prev" href="thanks.html" title="Chapter 14. Thanks"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Glossary</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="thanks.html">Prev</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> </td></tr></table><hr></div><div class="glossary"><div class="titlepage"><div><div><h1 class="title"><a name="glossary"></a>Glossary</h1></div></div></div><dl><dt><a name="gloss-preemption"></a><span class="glossterm">preemption</span></dt><dd class="glossdef"><p>
        Prior to 2.5, or when <span class="symbol">CONFIG_PREEMPT</span> is
        unset, processes in user context inside the kernel would not
        preempt each other (ie. you had that CPU until you gave it up,
        except for interrupts).  With the addition of
        <span class="symbol">CONFIG_PREEMPT</span> in 2.5.4, this changed: when
        in user context, higher priority tasks can "cut in": spinlocks
        were changed to disable preemption, even on UP.
     </p></dd><dt><a name="gloss-bh"></a><span class="glossterm">bh</span></dt><dd class="glossdef"><p>
        Bottom Half: for historical reasons, functions with
        '_bh' in them often now refer to any software interrupt, e.g.
        <code class="function">spin_lock_bh()</code> blocks any software interrupt 
        on the current CPU.  Bottom halves are deprecated, and will 
        eventually be replaced by tasklets.  Only one bottom half will be 
        running at any time.
     </p></dd><dt><a name="gloss-hwinterrupt"></a><span class="glossterm">Hardware Interrupt / Hardware IRQ</span></dt><dd class="glossdef"><p>
       Hardware interrupt request.  <code class="function">in_irq()</code> returns 
       <span class="returnvalue">true</span> in a hardware interrupt handler.
     </p></dd><dt><a name="gloss-interruptcontext"></a><span class="glossterm">Interrupt Context</span></dt><dd class="glossdef"><p>
       Not user context: processing a hardware irq or software irq.
       Indicated by the <code class="function">in_interrupt()</code> macro 
       returning <span class="returnvalue">true</span>.
     </p></dd><dt><a name="gloss-smp"></a><span class="glossterm"><acronym class="acronym">SMP</acronym></span></dt><dd class="glossdef"><p>
       Symmetric Multi-Processor: kernels compiled for multiple-CPU
       machines.  (CONFIG_SMP=y).
     </p></dd><dt><a name="gloss-softirq"></a><span class="glossterm">Software Interrupt / softirq</span></dt><dd class="glossdef"><p>
       Software interrupt handler.  <code class="function">in_irq()</code> returns
       <span class="returnvalue">false</span>; <code class="function">in_softirq()</code>
       returns <span class="returnvalue">true</span>.  Tasklets and softirqs
	both fall into the category of 'software interrupts'.
     </p><p>
       Strictly speaking a softirq is one of up to 32 enumerated software
       interrupts which can run on multiple CPUs at once.
       Sometimes used to refer to tasklets as
       well (ie. all software interrupts).
     </p></dd><dt><a name="gloss-tasklet"></a><span class="glossterm">tasklet</span></dt><dd class="glossdef"><p>
       A dynamically-registrable software interrupt,
       which is guaranteed to only run on one CPU at a time.
     </p></dd><dt><a name="gloss-timers"></a><span class="glossterm">timer</span></dt><dd class="glossdef"><p>
       A dynamically-registrable software interrupt, which is run at
       (or close to) a given time.  When running, it is just like a
       tasklet (in fact, they are called from the TIMER_SOFTIRQ).
     </p></dd><dt><a name="gloss-up"></a><span class="glossterm"><acronym class="acronym">UP</acronym></span></dt><dd class="glossdef"><p>
       Uni-Processor: Non-SMP.  (CONFIG_SMP=n).
     </p></dd><dt><a name="gloss-usercontext"></a><span class="glossterm">User Context</span></dt><dd class="glossdef"><p>
       The kernel executing on behalf of a particular process (ie. a
       system call or trap) or kernel thread.  You can tell which
       process with the <span class="symbol">current</span> macro.)  Not to
       be confused with userspace.  Can be interrupted by software or
       hardware interrupts.
     </p></dd><dt><a name="gloss-userspace"></a><span class="glossterm">Userspace</span></dt><dd class="glossdef"><p>
       A process executing its own code outside the kernel.
     </p></dd></dl></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="thanks.html">Prev</a> </td><td width="20%" align="center"> </td><td width="40%" align="right"> </td></tr><tr><td width="40%" align="left" valign="top">Chapter 14. Thanks </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> </td></tr></table></div></body></html>
