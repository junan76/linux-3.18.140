<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN"
	"http://www.oasis-open.org/docbook/xml/4.1.2/docbookx.dtd" []>

<book id="USB-Gadget-API">
  <bookinfo>
    <title>USB Gadget API for Linux</title>
    <date>20 August 2004</date>
    <edition>20 August 2004</edition>
  
    <legalnotice>
       <para>
	 This documentation is free software; you can redistribute
	 it and/or modify it under the terms of the GNU General Public
	 License as published by the Free Software Foundation; either
	 version 2 of the License, or (at your option) any later
	 version.
       </para>
	  
       <para>
	 This program is distributed in the hope that it will be
	 useful, but WITHOUT ANY WARRANTY; without even the implied
	 warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
	 See the GNU General Public License for more details.
       </para>
	  
       <para>
	 You should have received a copy of the GNU General Public
	 License along with this program; if not, write to the Free
	 Software Foundation, Inc., 59 Temple Place, Suite 330, Boston,
	 MA 02111-1307 USA
       </para>
	  
       <para>
	 For more details see the file COPYING in the source
	 distribution of Linux.
       </para>
    </legalnotice>
    <copyright>
      <year>2003-2004</year>
      <holder>David Brownell</holder>
    </copyright>

    <author>
      <firstname>David</firstname> 
      <surname>Brownell</surname>
      <affiliation>
        <address><email>dbrownell@users.sourceforge.net</email></address>
      </affiliation>
    </author>
  </bookinfo>

<toc></toc>

<chapter id="intro"><title>Introduction</title>

<para>This document presents a Linux-USB "Gadget"
kernel mode
API, for use within peripherals and other USB devices
that embed Linux.
It provides an overview of the API structure,
and shows how that fits into a system development project.
This is the first such API released on Linux to address
a number of important problems, including: </para>

<itemizedlist>
    <listitem><para>Supports USB 2.0, for high speed devices which
	can stream data at several dozen megabytes per second.
	</para></listitem>
    <listitem><para>Handles devices with dozens of endpoints just as
	well as ones with just two fixed-function ones.  Gadget drivers
	can be written so they're easy to port to new hardware.
	</para></listitem>
    <listitem><para>Flexible enough to expose more complex USB device
	capabilities such as multiple configurations, multiple interfaces,
	composite devices,
	and alternate interface settings.
	</para></listitem>
    <listitem><para>USB "On-The-Go" (OTG) support, in conjunction
	with updates to the Linux-USB host side.
	</para></listitem>
    <listitem><para>Sharing data structures and API models with the
	Linux-USB host side API.  This helps the OTG support, and
	looks forward to more-symmetric frameworks (where the same
	I/O model is used by both host and device side drivers).
	</para></listitem>
    <listitem><para>Minimalist, so it's easier to support new device
	controller hardware.  I/O processing doesn't imply large
	demands for memory or CPU resources.
	</para></listitem>
</itemizedlist>


<para>Most Linux developers will not be able to use this API, since they
have USB "host" hardware in a PC, workstation, or server.
Linux users with embedded systems are more likely to
have USB peripheral hardware.
To distinguish drivers running inside such hardware from the
more familiar Linux "USB device drivers",
which are host side proxies for the real USB devices,
a different term is used:
the drivers inside the peripherals are "USB gadget drivers".
In USB protocol interactions, the device driver is the master
(or "client driver")
and the gadget driver is the slave (or "function driver").
</para>

<para>The gadget API resembles the host side Linux-USB API in that both
use queues of request objects to package I/O buffers, and those requests
may be submitted or canceled.
They share common definitions for the standard USB
<emphasis>Chapter 9</emphasis> messages, structures, and constants.
Also, both APIs bind and unbind drivers to devices.
The APIs differ in detail, since the host side's current
URB framework exposes a number of implementation details
and assumptions that are inappropriate for a gadget API.
While the model for control transfers and configuration
management is necessarily different (one side is a hardware-neutral master,
the other is a hardware-aware slave), the endpoint I/0 API used here
should also be usable for an overhead-reduced host side API.
</para>

</chapter>

<chapter id="structure"><title>Structure of Gadget Drivers</title>

<para>A system running inside a USB peripheral
normally has at least three layers inside the kernel to handle
USB protocol processing, and may have additional layers in
user space code.
The "gadget" API is used by the middle layer to interact
with the lowest level (which directly handles hardware).
</para>

<para>In Linux, from the bottom up, these layers are:
</para>

<variablelist>

    <varlistentry>
        <term><emphasis>USB Controller Driver</emphasis></term>

	<listitem>
	<para>This is the lowest software level.
	It is the only layer that talks to hardware,
	through registers, fifos, dma, irqs, and the like.
	The <filename>&lt;linux/usb/gadget.h&gt;</filename> API abstracts
	the peripheral controller endpoint hardware.
	That hardware is exposed through endpoint objects, which accept
	streams of IN/OUT buffers, and through callbacks that interact
	with gadget drivers.
	Since normal USB devices only have one upstream
	port, they only have one of these drivers.
	The controller driver can support any number of different
	gadget drivers, but only one of them can be used at a time.
	</para>

	<para>Examples of such controller hardware include
	the PCI-based NetChip 2280 USB 2.0 high speed controller,
	the SA-11x0 or PXA-25x UDC (found within many PDAs),
	and a variety of other products.
	</para>

	</listitem></varlistentry>

    <varlistentry>
	<term><emphasis>Gadget Driver</emphasis></term>

	<listitem>
	<para>The lower boundary of this driver implements hardware-neutral
	USB functions, using calls to the controller driver.
	Because such hardware varies widely in capabilities and restrictions,
	and is used in embedded environments where space is at a premium,
	the gadget driver is often configured at compile time
	to work with endpoints supported by one particular controller.
	Gadget drivers may be portable to several different controllers,
	using conditional compilation.
	(Recent kernels substantially simplify the work involved in
	supporting new hardware, by <emphasis>autoconfiguring</emphasis>
	endpoints automatically for many bulk-oriented drivers.)
	Gadget driver responsibilities include:
	</para>
	<itemizedlist>
	    <listitem><para>handling setup requests (ep0 protocol responses)
		possibly including class-specific functionality
		</para></listitem>
	    <listitem><para>returning configuration and string descriptors
		</para></listitem>
	    <listitem><para>(re)setting configurations and interface
		altsettings, including enabling and configuring endpoints
		</para></listitem>
	    <listitem><para>handling life cycle events, such as managing
		bindings to hardware,
		USB suspend/resume, remote wakeup,
		and disconnection from the USB host.
		</para></listitem>
	    <listitem><para>managing IN and OUT transfers on all currently
		enabled endpoints
		</para></listitem>
	</itemizedlist>

	<para>
	Such drivers may be modules of proprietary code, although
	that approach is discouraged in the Linux community.
	</para>
	</listitem></varlistentry>

    <varlistentry>
	<term><emphasis>Upper Level</emphasis></term>

	<listitem>
	<para>Most gadget drivers have an upper boundary that connects
	to some Linux driver or framework in Linux.
	Through that boundary flows the data which the gadget driver
	produces and/or consumes through protocol transfers over USB.
	Examples include:
	</para>
	<itemizedlist>
	    <listitem><para>user mode code, using generic (gadgetfs)
	        or application specific files in
		<filename>/dev</filename>
		</para></listitem>
	    <listitem><para>networking subsystem (for network gadgets,
		like the CDC Ethernet Model gadget driver)
		</para></listitem>
	    <listitem><para>data capture drivers, perhaps video4Linux or
		 a scanner driver; or test and measurement hardware.
		 </para></listitem>
	    <listitem><para>input subsystem (for HID gadgets)
		</para></listitem>
	    <listitem><para>sound subsystem (for audio gadgets)
		</para></listitem>
	    <listitem><para>file system (for PTP gadgets)
		</para></listitem>
	    <listitem><para>block i/o subsystem (for usb-storage gadgets)
		</para></listitem>
	    <listitem><para>... and more </para></listitem>
	</itemizedlist>
	</listitem></varlistentry>

    <varlistentry>
	<term><emphasis>Additional Layers</emphasis></term>

	<listitem>
	<para>Other layers may exist.
	These could include kernel layers, such as network protocol stacks,
	as well as user mode applications building on standard POSIX
	system call APIs such as
	<emphasis>open()</emphasis>, <emphasis>close()</emphasis>,
	<emphasis>read()</emphasis> and <emphasis>write()</emphasis>.
	On newer systems, POSIX Async I/O calls may be an option.
	Such user mode code will not necessarily be subject to
	the GNU General Public License (GPL).
	</para>
	</listitem></varlistentry>


</variablelist>

<para>OTG-capable systems will also need to include a standard Linux-USB
host side stack,
with <emphasis>usbcore</emphasis>,
one or more <emphasis>Host Controller Drivers</emphasis> (HCDs),
<emphasis>USB Device Drivers</emphasis> to support
the OTG "Targeted Peripheral List",
and so forth.
There will also be an <emphasis>OTG Controller Driver</emphasis>,
which is visible to gadget and device driver developers only indirectly.
That helps the host and device side USB controllers implement the
two new OTG protocols (HNP and SRP).
Roles switch (host to peripheral, or vice versa) using HNP
during USB suspend processing, and SRP can be viewed as a
more battery-friendly kind of device wakeup protocol.
</para>

<para>Over time, reusable utilities are evolving to help make some
gadget driver tasks simpler.
For example, building configuration descriptors from vectors of
descriptors for the configurations interfaces and endpoints is
now automated, and many drivers now use autoconfiguration to
choose hardware endpoints and initialize their descriptors.

A potential example of particular interest
is code implementing standard USB-IF protocols for
HID, networking, storage, or audio classes.
Some developers are interested in KDB or KGDB hooks, to let
target hardware be remotely debugged.
Most such USB protocol code doesn't need to be hardware-specific,
any more than network protocols like X11, HTTP, or NFS are.
Such gadget-side interface drivers should eventually be combined,
to implement composite devices.
</para>

</chapter>


<chapter id="api"><title>Kernel Mode Gadget API</title>

<para>Gadget drivers declare themselves through a
<emphasis>struct usb_gadget_driver</emphasis>, which is responsible for
most parts of enumeration for a <emphasis>struct usb_gadget</emphasis>.
The response to a set_configuration usually involves
enabling one or more of the <emphasis>struct usb_ep</emphasis> objects
exposed by the gadget, and submitting one or more
<emphasis>struct usb_request</emphasis> buffers to transfer data.
Understand those four data types, and their operations, and
you will understand how this API works.
</para> 

<note><title>Incomplete Data Type Descriptions</title>

<para>This documentation was prepared using the standard Linux
kernel <filename>docproc</filename> tool, which turns text
and in-code comments into SGML DocBook and then into usable
formats such as HTML or PDF.
Other than the "Chapter 9" data types, most of the significant
data types and functions are described here.
</para>

<para>However, docproc does not understand all the C constructs
that are used, so some relevant information is likely omitted from
what you are reading.  
One example of such information is endpoint autoconfiguration.
You'll have to read the header file, and use example source
code (such as that for "Gadget Zero"), to fully understand the API.
</para>

<para>The part of the API implementing some basic
driver capabilities is specific to the version of the
Linux kernel that's in use.
The 2.6 kernel includes a <emphasis>driver model</emphasis>
framework that has no analogue on earlier kernels;
so those parts of the gadget API are not fully portable.
(They are implemented on 2.4 kernels, but in a different way.)
The driver model state is another part of this API that is
ignored by the kerneldoc tools.
</para>
</note>

<para>The core API does not expose
every possible hardware feature, only the most widely available ones.
There are significant hardware features, such as device-to-device DMA
(without temporary storage in a memory buffer)
that would be added using hardware-specific APIs.
</para>

<para>This API allows drivers to use conditional compilation to handle
endpoint capabilities of different hardware, but doesn't require that.
Hardware tends to have arbitrary restrictions, relating to
transfer types, addressing, packet sizes, buffering, and availability.
As a rule, such differences only matter for "endpoint zero" logic
that handles device configuration and management.
The API supports limited run-time
detection of capabilities, through naming conventions for endpoints.
Many drivers will be able to at least partially autoconfigure
themselves.
In particular, driver init sections will often have endpoint
autoconfiguration logic that scans the hardware's list of endpoints
to find ones matching the driver requirements
(relying on those conventions), to eliminate some of the most
common reasons for conditional compilation.
</para>

<para>Like the Linux-USB host side API, this API exposes
the "chunky" nature of USB messages:  I/O requests are in terms
of one or more "packets", and packet boundaries are visible to drivers.
Compared to RS-232 serial protocols, USB resembles
synchronous protocols like HDLC
(N bytes per frame, multipoint addressing, host as the primary
station and devices as secondary stations)
more than asynchronous ones
(tty style:  8 data bits per frame, no parity, one stop bit).
So for example the controller drivers won't buffer
two single byte writes into a single two-byte USB IN packet,
although gadget drivers may do so when they implement
protocols where packet boundaries (and "short packets")
are not significant.
</para>

<sect1 id="lifecycle"><title>Driver Life Cycle</title>

<para>Gadget drivers make endpoint I/O requests to hardware without
needing to know many details of the hardware, but driver
setup/configuration code needs to handle some differences.
Use the API like this:
</para>

<orderedlist numeration='arabic'>

<listitem><para>Register a driver for the particular device side
usb controller hardware,
such as the net2280 on PCI (USB 2.0),
sa11x0 or pxa25x as found in Linux PDAs,
and so on.
At this point the device is logically in the USB ch9 initial state
("attached"), drawing no power and not usable
(since it does not yet support enumeration).
Any host should not see the device, since it's not
activated the data line pullup used by the host to
detect a device, even if VBUS power is available.
</para></listitem>

<listitem><para>Register a gadget driver that implements some higher level
device function.  That will then bind() to a usb_gadget, which
activates the data line pullup sometime after detecting VBUS.
</para></listitem>

<listitem><para>The hardware driver can now start enumerating.
The steps it handles are to accept USB power and set_address requests.
Other steps are handled by the gadget driver.
If the gadget driver module is unloaded before the host starts to
enumerate, steps before step 7 are skipped.
</para></listitem>

<listitem><para>The gadget driver's setup() call returns usb descriptors,
based both on what the bus interface hardware provides and on the
functionality being implemented.
That can involve alternate settings or configurations,
unless the hardware prevents such operation.
For OTG devices, each configuration descriptor includes
an OTG descriptor.
</para></listitem>

<listitem><para>The gadget driver handles the last step of enumeration,
when the USB host issues a set_configuration call.
It enables all endpoints used in that configuration,
with all interfaces in their default settings.
That involves using a list of the hardware's endpoints, enabling each
endpoint according to its descriptor.
It may also involve using <function>usb_gadget_vbus_draw</function>
to let more power be drawn from VBUS, as allowed by that configuration.
For OTG devices, setting a configuration may also involve reporting
HNP capabilities through a user interface.
</para></listitem>

<listitem><para>Do real work and perform data transfers, possibly involving
changes to interface settings or switching to new configurations, until the
device is disconnect()ed from the host.
Queue any number of transfer requests to each endpoint.
It may be suspended and resumed several times before being disconnected.
On disconnect, the drivers go back to step 3 (above).
</para></listitem>

<listitem><para>When the gadget driver module is being unloaded,
the driver unbind() callback is issued.  That lets the controller
driver be unloaded.
</para></listitem>

</orderedlist>

<para>Drivers will normally be arranged so that just loading the
gadget driver module (or statically linking it into a Linux kernel)
allows the peripheral device to be enumerated, but some drivers
will defer enumeration until some higher level component (like
a user mode daemon) enables it.
Note that at this lowest level there are no policies about how
ep0 configuration logic is implemented,
except that it should obey USB specifications.
Such issues are in the domain of gadget drivers,
including knowing about implementation constraints
imposed by some USB controllers
or understanding that composite devices might happen to
be built by integrating reusable components.
</para>

<para>Note that the lifecycle above can be slightly different
for OTG devices.
Other than providing an additional OTG descriptor in each
configuration, only the HNP-related differences are particularly
visible to driver code.
They involve reporting requirements during the SET_CONFIGURATION
request, and the option to invoke HNP during some suspend callbacks.
Also, SRP changes the semantics of
<function>usb_gadget_wakeup</function>
slightly.
</para>

</sect1>

<sect1 id="ch9"><title>USB 2.0 Chapter 9 Types and Constants</title>

<para>Gadget drivers
rely on common USB structures and constants
defined in the
<filename>&lt;linux/usb/ch9.h&gt;</filename>
header file, which is standard in Linux 2.6 kernels.
These are the same types and constants used by host
side drivers (and usbcore).
</para>

<!-- include/linux/usb/ch9.h -->
<refentry id="API-usb-speed-string">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>usb_speed_string</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>usb_speed_string</refname>
 <refpurpose>
  Returns human readable-name of the speed.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>const char * <function>usb_speed_string </function></funcdef>
   <paramdef>enum usb_device_speed <parameter>speed</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>speed</parameter></term>
   <listitem>
    <para>
     The speed to return human-readable name for.  If it's not
     any of the speeds defined in usb_device_speed enum, string for
     USB_SPEED_UNKNOWN will be returned.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-usb-state-string">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>usb_state_string</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>usb_state_string</refname>
 <refpurpose>
     Returns human readable name for the state.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>const char * <function>usb_state_string </function></funcdef>
   <paramdef>enum usb_device_state <parameter>state</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>state</parameter></term>
   <listitem>
    <para>
     The state to return a human-readable name for. If it's not
     any of the states devices in usb_device_state_string enum,
     the string UNKNOWN will be returned.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

</sect1>

<sect1 id="core"><title>Core Objects and Methods</title>

<para>These are declared in
<filename>&lt;linux/usb/gadget.h&gt;</filename>,
and are used by gadget drivers to interact with
USB peripheral controller drivers.
</para>

	<!-- yeech, this is ugly in nsgmls PDF output.

	     the PDF bookmark and refentry output nesting is wrong,
	     and the member/argument documentation indents ugly.

	     plus something (docproc?) adds whitespace before the
	     descriptive paragraph text, so it can't line up right
	     unless the explanations are trivial.
	  -->

<!-- include/linux/usb/gadget.h -->
<refentry id="API-struct-usb-request">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct usb_request</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct usb_request</refname>
 <refpurpose>
  describes one i/o request
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct usb_request {
  void * buf;
  unsigned length;
  dma_addr_t dma;
  struct scatterlist * sg;
  unsigned num_sgs;
  unsigned num_mapped_sgs;
  unsigned stream_id:16;
  unsigned no_interrupt:1;
  unsigned zero:1;
  unsigned short_not_ok:1;
  void (* complete) (struct usb_ep *ep,struct usb_request *req);
  void * context;
  struct list_head list;
  int status;
  unsigned actual;
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>buf</term>
      <listitem><para>
Buffer used for data.  Always provide this; some controllers
only use PIO, or don't use DMA for some endpoints.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>length</term>
      <listitem><para>
Length of that data
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>dma</term>
      <listitem><para>
DMA address corresponding to 'buf'.  If you don't set this
field, and the usb controller needs one, it is responsible
for mapping and unmapping the buffer.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>sg</term>
      <listitem><para>
a scatterlist for SG-capable controllers.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>num_sgs</term>
      <listitem><para>
number of SG entries
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>num_mapped_sgs</term>
      <listitem><para>
number of SG entries mapped to DMA (internal)
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>stream_id</term>
      <listitem><para>
The stream id, when USB3.0 bulk streams are being used
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>no_interrupt</term>
      <listitem><para>
If true, hints that no completion irq is needed.
Helpful sometimes with deep request queues that are handled
directly by DMA controllers.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>zero</term>
      <listitem><para>
If true, when writing data, makes the last packet be <quote>short</quote>
by adding a zero length packet as needed;
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>short_not_ok</term>
      <listitem><para>
When reading data, makes short packets be
treated as errors (queue stops advancing till cleanup).
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>complete</term>
      <listitem><para>
Function called when request completes, so this request and
its buffer may be re-used.  The function will always be called with
interrupts disabled, and it must not sleep.
Reads terminate with a short packet, or when the buffer fills,
whichever comes first.  When writes terminate, some data bytes
will usually still be in flight (often in a hardware fifo).
Errors (for reads or writes) stop the queue from advancing
until the completion function returns, so that any transfers
invalidated by the error may first be dequeued.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>context</term>
      <listitem><para>
For use by the completion callback
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>list</term>
      <listitem><para>
For use by the gadget driver.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>status</term>
      <listitem><para>
Reports completion code, zero or a negative errno.
Normally, faults block the transfer queue from advancing until
the completion callback returns.
Code <quote>-ESHUTDOWN</quote> indicates completion caused by device disconnect,
or when the driver disabled the endpoint.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>actual</term>
      <listitem><para>
Reports bytes transferred to/from the buffer.  For reads (OUT
transfers) this may be less than the requested length.  If the
short_not_ok flag is set, short reads are treated as errors
even when status otherwise indicates successful completion.
Note that for writes (IN transfers) some data bytes may still
reside in a device-side FIFO when the request is reported as
complete.
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
<refsect1>
<title>Description</title>
<para>
   These are allocated/freed through the endpoint they're used with.  The
   hardware's driver can add extra per-request data to the memory it returns,
   which often avoids separate memory allocations (potential failures),
   later when the request is queued.
   </para><para>

   Request flags affect request handling, such as whether a zero length
   packet is written (the <quote>zero</quote> flag), whether a short read should be
   treated as an error (blocking request queue advance, the <quote>short_not_ok</quote>
   flag), or hinting that an interrupt is not required (the <quote>no_interrupt</quote>
   flag, for use with deep request queues).
   </para><para>

   Bulk endpoints can use any size buffers, and can also be used for interrupt
   transfers. interrupt-only endpoints can be much less functional.
</para>
</refsect1>
<refsect1>
<title>NOTE</title>
<para>
   this is analogous to 'struct urb' on the host side, except that
   it's thinner and promotes more pre-allocation.
</para>
</refsect1>
</refentry>

<refentry id="API-struct-usb-ep">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct usb_ep</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct usb_ep</refname>
 <refpurpose>
     device side representation of USB endpoint
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct usb_ep {
  void * driver_data;
  const char * name;
  const struct usb_ep_ops * ops;
  struct list_head ep_list;
  unsigned maxpacket:16;
  unsigned maxpacket_limit:16;
  unsigned max_streams:16;
  unsigned mult:2;
  unsigned maxburst:5;
  u8 address;
  const struct usb_endpoint_descriptor * desc;
  const struct usb_ss_ep_comp_descriptor * comp_desc;
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>driver_data</term>
      <listitem><para>
   for use by the gadget driver.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>name</term>
      <listitem><para>
   identifier for the endpoint, such as <quote>ep-a</quote> or <quote>ep9in-bulk</quote>
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>ops</term>
      <listitem><para>
   Function pointers used to access hardware-specific operations.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>ep_list</term>
      <listitem><para>
   the gadget's ep_list holds all of its endpoints
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>maxpacket</term>
      <listitem><para>
   The maximum packet size used on this endpoint.  The initial
   value can sometimes be reduced (hardware allowing), according to
   the endpoint descriptor used to configure the endpoint.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>maxpacket_limit</term>
      <listitem><para>
   The maximum packet size value which can be handled by this
   endpoint. It's set once by UDC driver when endpoint is initialized, and
   should not be changed. Should not be confused with maxpacket.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>max_streams</term>
      <listitem><para>
   The maximum number of streams supported
   by this EP (0 - 16, actual number is 2^n)
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>mult</term>
      <listitem><para>
   multiplier, 'mult' value for SS Isoc EPs
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>maxburst</term>
      <listitem><para>
   the maximum number of bursts supported by this EP (for usb3)
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>address</term>
      <listitem><para>
   used to identify the endpoint when finding descriptor that
   matches connection speed
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>desc</term>
      <listitem><para>
   endpoint descriptor.  This pointer is set before the endpoint is
   enabled and remains valid until the endpoint is disabled.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>comp_desc</term>
      <listitem><para>
   In case of SuperSpeed support, this is the endpoint companion
   descriptor that is used to configure the endpoint
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
<refsect1>
<title>Description</title>
<para>
   the bus controller driver lists all the general purpose endpoints in
   gadget-&gt;ep_list.  the control endpoint (gadget-&gt;ep0) is not in that list,
   and is accessed only in response to a driver <function>setup</function> callback.
</para>
</refsect1>
</refentry>

<refentry id="API-usb-ep-set-maxpacket-limit">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>usb_ep_set_maxpacket_limit</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>usb_ep_set_maxpacket_limit</refname>
 <refpurpose>
     set maximum packet size limit for endpoint
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>usb_ep_set_maxpacket_limit </function></funcdef>
   <paramdef>struct usb_ep * <parameter>ep</parameter></paramdef>
   <paramdef>unsigned <parameter>maxpacket_limit</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ep</parameter></term>
   <listitem>
    <para>
     the endpoint being configured
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>maxpacket_limit</parameter></term>
   <listitem>
    <para>
     value of maximum packet size limit
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This function shoud be used only in UDC drivers to initialize endpoint
   (usually in probe function).
</para>
</refsect1>
</refentry>

<refentry id="API-usb-ep-enable">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>usb_ep_enable</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>usb_ep_enable</refname>
 <refpurpose>
     configure endpoint, making it usable
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>usb_ep_enable </function></funcdef>
   <paramdef>struct usb_ep * <parameter>ep</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ep</parameter></term>
   <listitem>
    <para>
     the endpoint being configured.  may not be the endpoint named <quote>ep0</quote>.
     drivers discover endpoints through the ep_list of a usb_gadget.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   When configurations are set, or when interface settings change, the driver
   will enable or disable the relevant endpoints.  while it is enabled, an
   endpoint may be used for i/o until the driver receives a <function>disconnect</function> from
   the host or until the endpoint is disabled.
   </para><para>

   the ep0 implementation (which calls this routine) must ensure that the
   hardware capabilities of each endpoint match the descriptor provided
   for it.  for example, an endpoint named <quote>ep2in-bulk</quote> would be usable
   for interrupt transfers as well as bulk, but it likely couldn't be used
   for iso transfers or for endpoint 14.  some endpoints are fully
   configurable, with more generic names like <quote>ep-a</quote>.  (remember that for
   USB, <quote>in</quote> means <quote>towards the USB master</quote>.)
   </para><para>

   returns zero, or a negative error code.
</para>
</refsect1>
</refentry>

<refentry id="API-usb-ep-disable">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>usb_ep_disable</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>usb_ep_disable</refname>
 <refpurpose>
     endpoint is no longer usable
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>usb_ep_disable </function></funcdef>
   <paramdef>struct usb_ep * <parameter>ep</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ep</parameter></term>
   <listitem>
    <para>
     the endpoint being unconfigured.  may not be the endpoint named <quote>ep0</quote>.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   no other task may be using this endpoint when this is called.
   any pending and uncompleted requests will complete with status
   indicating disconnect (-ESHUTDOWN) before this call returns.
   gadget drivers must call <function>usb_ep_enable</function> again before queueing
   requests to the endpoint.
   </para><para>

   returns zero, or a negative error code.
</para>
</refsect1>
</refentry>

<refentry id="API-usb-ep-alloc-request">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>usb_ep_alloc_request</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>usb_ep_alloc_request</refname>
 <refpurpose>
     allocate a request object to use with this endpoint
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct usb_request * <function>usb_ep_alloc_request </function></funcdef>
   <paramdef>struct usb_ep * <parameter>ep</parameter></paramdef>
   <paramdef>gfp_t <parameter>gfp_flags</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ep</parameter></term>
   <listitem>
    <para>
     the endpoint to be used with with the request
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>gfp_flags</parameter></term>
   <listitem>
    <para>
     GFP_* flags to use
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Request objects must be allocated with this call, since they normally
   need controller-specific setup and may even need endpoint-specific
   resources such as allocation of DMA descriptors.
   Requests may be submitted with <function>usb_ep_queue</function>, and receive a single
   completion callback.  Free requests with <function>usb_ep_free_request</function>, when
   they are no longer needed.
   </para><para>

   Returns the request, or null if one could not be allocated.
</para>
</refsect1>
</refentry>

<refentry id="API-usb-ep-free-request">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>usb_ep_free_request</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>usb_ep_free_request</refname>
 <refpurpose>
     frees a request object
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>usb_ep_free_request </function></funcdef>
   <paramdef>struct usb_ep * <parameter>ep</parameter></paramdef>
   <paramdef>struct usb_request * <parameter>req</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ep</parameter></term>
   <listitem>
    <para>
     the endpoint associated with the request
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>req</parameter></term>
   <listitem>
    <para>
     the request being freed
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Reverses the effect of <function>usb_ep_alloc_request</function>.
   Caller guarantees the request is not queued, and that it will
   no longer be requeued (or otherwise used).
</para>
</refsect1>
</refentry>

<refentry id="API-usb-ep-queue">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>usb_ep_queue</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>usb_ep_queue</refname>
 <refpurpose>
     queues (submits) an I/O request to an endpoint.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>usb_ep_queue </function></funcdef>
   <paramdef>struct usb_ep * <parameter>ep</parameter></paramdef>
   <paramdef>struct usb_request * <parameter>req</parameter></paramdef>
   <paramdef>gfp_t <parameter>gfp_flags</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ep</parameter></term>
   <listitem>
    <para>
     the endpoint associated with the request
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>req</parameter></term>
   <listitem>
    <para>
     the request being submitted
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>gfp_flags</parameter></term>
   <listitem>
    <para>
     GFP_* flags to use in case the lower level driver couldn't
     pre-allocate all necessary memory with the request.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This tells the device controller to perform the specified request through
   that endpoint (reading or writing a buffer).  When the request completes,
   including being canceled by <function>usb_ep_dequeue</function>, the request's completion
   routine is called to return the request to the driver.  Any endpoint
   (except control endpoints like ep0) may have more than one transfer
   request queued; they complete in FIFO order.  Once a gadget driver
   submits a request, that request may not be examined or modified until it
   is given back to that driver through the completion callback.
   </para><para>

   Each request is turned into one or more packets.  The controller driver
   never merges adjacent requests into the same packet.  OUT transfers
   will sometimes use data that's already buffered in the hardware.
   Drivers can rely on the fact that the first byte of the request's buffer
   always corresponds to the first byte of some USB packet, for both
   IN and OUT transfers.
   </para><para>

   Bulk endpoints can queue any amount of data; the transfer is packetized
   automatically.  The last packet will be short if the request doesn't fill it
   out completely.  Zero length packets (ZLPs) should be avoided in portable
   protocols since not all usb hardware can successfully handle zero length
   packets.  (ZLPs may be explicitly written, and may be implicitly written if
   the request 'zero' flag is set.)  Bulk endpoints may also be used
   for interrupt transfers; but the reverse is not true, and some endpoints
   won't support every interrupt transfer.  (Such as 768 byte packets.)
   </para><para>

   Interrupt-only endpoints are less functional than bulk endpoints, for
   example by not supporting queueing or not handling buffers that are
   larger than the endpoint's maxpacket size.  They may also treat data
   toggle differently.
   </para><para>

   Control endpoints ... after getting a <function>setup</function> callback, the driver queues
   one response (even if it would be zero length).  That enables the
   status ack, after transferring data as specified in the response.  Setup
   functions may return negative error codes to generate protocol stalls.
   (Note that some USB device controllers disallow protocol stall responses
   in some cases.)  When control responses are deferred (the response is
   written after the setup callback returns), then <function>usb_ep_set_halt</function> may be
   used on ep0 to trigger protocol stalls.  Depending on the controller,
   it may not be possible to trigger a status-stage protocol stall when the
   data stage is over, that is, from within the response's completion
   routine.
   </para><para>

   For periodic endpoints, like interrupt or isochronous ones, the usb host
   arranges to poll once per interval, and the gadget driver usually will
   have queued some data to transfer at that time.
   </para><para>

   Returns zero, or a negative error code.  Endpoints that are not enabled
   report errors; errors will also be
   reported when the usb peripheral is disconnected.
</para>
</refsect1>
</refentry>

<refentry id="API-usb-ep-dequeue">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>usb_ep_dequeue</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>usb_ep_dequeue</refname>
 <refpurpose>
     dequeues (cancels, unlinks) an I/O request from an endpoint
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>usb_ep_dequeue </function></funcdef>
   <paramdef>struct usb_ep * <parameter>ep</parameter></paramdef>
   <paramdef>struct usb_request * <parameter>req</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ep</parameter></term>
   <listitem>
    <para>
     the endpoint associated with the request
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>req</parameter></term>
   <listitem>
    <para>
     the request being canceled
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   If the request is still active on the endpoint, it is dequeued and its
   completion routine is called (with status -ECONNRESET); else a negative
   error code is returned. This is guaranteed to happen before the call to
   <function>usb_ep_dequeue</function> returns.
   </para><para>

   Note that some hardware can't clear out write fifos (to unlink the request
   at the head of the queue) except as part of disconnecting from usb. Such
   restrictions prevent drivers from supporting configuration changes,
   even to configuration zero (a <quote>chapter 9</quote> requirement).
</para>
</refsect1>
</refentry>

<refentry id="API-usb-ep-set-halt">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>usb_ep_set_halt</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>usb_ep_set_halt</refname>
 <refpurpose>
     sets the endpoint halt feature.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>usb_ep_set_halt </function></funcdef>
   <paramdef>struct usb_ep * <parameter>ep</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ep</parameter></term>
   <listitem>
    <para>
     the non-isochronous endpoint being stalled
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Use this to stall an endpoint, perhaps as an error report.
   Except for control endpoints,
   the endpoint stays halted (will not stream any data) until the host
   clears this feature; drivers may need to empty the endpoint's request
   queue first, to make sure no inappropriate transfers happen.
   </para><para>

   Note that while an endpoint CLEAR_FEATURE will be invisible to the
   gadget driver, a SET_INTERFACE will not be.  To reset endpoints for the
   current altsetting, see <function>usb_ep_clear_halt</function>.  When switching altsettings,
   it's simplest to use <function>usb_ep_enable</function> or <function>usb_ep_disable</function> for the endpoints.
   </para><para>

   Returns zero, or a negative error code.  On success, this call sets
   underlying hardware state that blocks data transfers.
   Attempts to halt IN endpoints will fail (returning -EAGAIN) if any
   transfer requests are still queued, or if the controller hardware
   (usually a FIFO) still holds bytes that the host hasn't collected.
</para>
</refsect1>
</refentry>

<refentry id="API-usb-ep-clear-halt">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>usb_ep_clear_halt</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>usb_ep_clear_halt</refname>
 <refpurpose>
     clears endpoint halt, and resets toggle
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>usb_ep_clear_halt </function></funcdef>
   <paramdef>struct usb_ep * <parameter>ep</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ep</parameter></term>
   <listitem>
    <para>
     the bulk or interrupt endpoint being reset
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Use this when responding to the standard usb <quote>set interface</quote> request,
   for endpoints that aren't reconfigured, after clearing any other state
   in the endpoint's i/o queue.
   </para><para>

   Returns zero, or a negative error code.  On success, this call clears
   the underlying hardware state reflecting endpoint halt and data toggle.
   Note that some hardware can't support this request (like pxa2xx_udc),
   and accordingly can't correctly implement interface altsettings.
</para>
</refsect1>
</refentry>

<refentry id="API-usb-ep-set-wedge">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>usb_ep_set_wedge</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>usb_ep_set_wedge</refname>
 <refpurpose>
     sets the halt feature and ignores clear requests
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>usb_ep_set_wedge </function></funcdef>
   <paramdef>struct usb_ep * <parameter>ep</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ep</parameter></term>
   <listitem>
    <para>
     the endpoint being wedged
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Use this to stall an endpoint and ignore CLEAR_FEATURE(HALT_ENDPOINT)
   requests. If the gadget driver clears the halt status, it will
   automatically unwedge the endpoint.
   </para><para>

   Returns zero on success, else negative errno.
</para>
</refsect1>
</refentry>

<refentry id="API-usb-ep-fifo-status">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>usb_ep_fifo_status</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>usb_ep_fifo_status</refname>
 <refpurpose>
     returns number of bytes in fifo, or error
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>usb_ep_fifo_status </function></funcdef>
   <paramdef>struct usb_ep * <parameter>ep</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ep</parameter></term>
   <listitem>
    <para>
     the endpoint whose fifo status is being checked.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   FIFO endpoints may have <quote>unclaimed data</quote> in them in certain cases,
   such as after aborted transfers.  Hosts may not have collected all
   the IN data written by the gadget driver (and reported by a request
   completion).  The gadget driver may not have collected all the data
   written OUT to it by the host.  Drivers that need precise handling for
   fault reporting or recovery may need to use this call.
   </para><para>

   This returns the number of such bytes in the fifo, or a negative
   errno if the endpoint doesn't use a FIFO or doesn't support such
   precise handling.
</para>
</refsect1>
</refentry>

<refentry id="API-usb-ep-fifo-flush">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>usb_ep_fifo_flush</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>usb_ep_fifo_flush</refname>
 <refpurpose>
     flushes contents of a fifo
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>usb_ep_fifo_flush </function></funcdef>
   <paramdef>struct usb_ep * <parameter>ep</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ep</parameter></term>
   <listitem>
    <para>
     the endpoint whose fifo is being flushed.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This call may be used to flush the <quote>unclaimed data</quote> that may exist in
   an endpoint fifo after abnormal transaction terminations.  The call
   must never be used except when endpoint is not being used for any
   protocol translation.
</para>
</refsect1>
</refentry>

<refentry id="API-struct-usb-gadget">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct usb_gadget</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct usb_gadget</refname>
 <refpurpose>
     represents a usb slave device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct usb_gadget {
  struct work_struct work;
  const struct usb_gadget_ops * ops;
  struct usb_ep * ep0;
  struct list_head ep_list;
  enum usb_device_speed speed;
  enum usb_device_speed max_speed;
  enum usb_device_state state;
  const char * name;
  struct device dev;
  unsigned out_epnum;
  unsigned in_epnum;
  unsigned sg_supported:1;
  unsigned is_otg:1;
  unsigned is_a_peripheral:1;
  unsigned b_hnp_enable:1;
  unsigned a_hnp_support:1;
  unsigned a_alt_hnp_support:1;
  unsigned quirk_ep_out_aligned_size:1;
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>work</term>
      <listitem><para>
   (internal use) Workqueue to be used for <function>sysfs_notify</function>
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>ops</term>
      <listitem><para>
   Function pointers used to access hardware-specific operations.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>ep0</term>
      <listitem><para>
   Endpoint zero, used when reading or writing responses to
   driver <function>setup</function> requests
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>ep_list</term>
      <listitem><para>
   List of other endpoints supported by the device.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>speed</term>
      <listitem><para>
   Speed of current connection to USB host.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>max_speed</term>
      <listitem><para>
   Maximal speed the UDC can handle.  UDC must support this
   and all slower speeds.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>state</term>
      <listitem><para>
   the state we are now (attached, suspended, configured, etc)
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>name</term>
      <listitem><para>
   Identifies the controller hardware type.  Used in diagnostics
   and sometimes configuration.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>dev</term>
      <listitem><para>
   Driver model state for this abstract device.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>out_epnum</term>
      <listitem><para>
   last used out ep number
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>in_epnum</term>
      <listitem><para>
   last used in ep number
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>sg_supported</term>
      <listitem><para>
   true if we can handle scatter-gather
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>is_otg</term>
      <listitem><para>
   True if the USB device port uses a Mini-AB jack, so that the
   gadget driver must provide a USB OTG descriptor.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>is_a_peripheral</term>
      <listitem><para>
   False unless is_otg, the <quote>A</quote> end of a USB cable
   is in the Mini-AB jack, and HNP has been used to switch roles
   so that the <quote>A</quote> device currently acts as A-Peripheral, not A-Host.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>b_hnp_enable</term>
      <listitem><para>
   OTG device feature flag, indicating that the A-Host
   enabled HNP support.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>a_hnp_support</term>
      <listitem><para>
   OTG device feature flag, indicating that the A-Host
   supports HNP at this port.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>a_alt_hnp_support</term>
      <listitem><para>
   OTG device feature flag, indicating that the A-Host
   only supports HNP on a different root port.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>quirk_ep_out_aligned_size</term>
      <listitem><para>
   epout requires buffer size to be aligned to
   MaxPacketSize.
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
<refsect1>
<title>Description</title>
<para>
   Gadgets have a mostly-portable <quote>gadget driver</quote> implementing device
   functions, handling all usb configurations and interfaces.  Gadget
   drivers talk to hardware-specific code indirectly, through ops vectors.
   That insulates the gadget driver from hardware details, and packages
   the hardware endpoints through generic i/o queues.  The <quote>usb_gadget</quote>
   and <quote>usb_ep</quote> interfaces provide that insulation from the hardware.
   </para><para>

   Except for the driver data, all fields in this structure are
   read-only to the gadget driver.  That driver data is part of the
   <quote>driver model</quote> infrastructure in 2.6 (and later) kernels, and for
   earlier systems is grouped in a similar structure that's not known
   to the rest of the kernel.
   </para><para>

   Values of the three OTG device feature flags are updated before the
   <function>setup</function> call corresponding to USB_REQ_SET_CONFIGURATION, and before
   driver <function>suspend</function> calls.  They are valid only when is_otg, and when the
   device is acting as a B-Peripheral (so is_a_peripheral is false).
</para>
</refsect1>
</refentry>

<refentry id="API-usb-ep-align">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>usb_ep_align</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>usb_ep_align</refname>
 <refpurpose>
     returns <parameter>len</parameter> aligned to ep's maxpacketsize.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>size_t <function>usb_ep_align </function></funcdef>
   <paramdef>struct usb_ep * <parameter>ep</parameter></paramdef>
   <paramdef>size_t <parameter>len</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ep</parameter></term>
   <listitem>
    <para>
     the endpoint whose maxpacketsize is used to align <parameter>len</parameter>
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>len</parameter></term>
   <listitem>
    <para>
     buffer size's length to align to <parameter>ep</parameter>'s maxpacketsize
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This helper is used to align buffer's size to an ep's maxpacketsize.
</para>
</refsect1>
</refentry>

<refentry id="API-usb-ep-align-maybe">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>usb_ep_align_maybe</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>usb_ep_align_maybe</refname>
 <refpurpose>
     returns <parameter>len</parameter> aligned to ep's maxpacketsize if gadget requires quirk_ep_out_aligned_size, otherwise returns len.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>size_t <function>usb_ep_align_maybe </function></funcdef>
   <paramdef>struct usb_gadget * <parameter>g</parameter></paramdef>
   <paramdef>struct usb_ep * <parameter>ep</parameter></paramdef>
   <paramdef>size_t <parameter>len</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>g</parameter></term>
   <listitem>
    <para>
     controller to check for quirk
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>ep</parameter></term>
   <listitem>
    <para>
     the endpoint whose maxpacketsize is used to align <parameter>len</parameter>
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>len</parameter></term>
   <listitem>
    <para>
     buffer size's length to align to <parameter>ep</parameter>'s maxpacketsize
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This helper is used in case it's required for any reason to check and maybe
   align buffer's size to an ep's maxpacketsize.
</para>
</refsect1>
</refentry>

<refentry id="API-gadget-is-dualspeed">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>gadget_is_dualspeed</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>gadget_is_dualspeed</refname>
 <refpurpose>
     return true iff the hardware handles high speed
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>gadget_is_dualspeed </function></funcdef>
   <paramdef>struct usb_gadget * <parameter>g</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>g</parameter></term>
   <listitem>
    <para>
     controller that might support both high and full speeds
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-gadget-is-superspeed">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>gadget_is_superspeed</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>gadget_is_superspeed</refname>
 <refpurpose>
     return true if the hardware handles superspeed
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>gadget_is_superspeed </function></funcdef>
   <paramdef>struct usb_gadget * <parameter>g</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>g</parameter></term>
   <listitem>
    <para>
     controller that might support superspeed
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-gadget-is-otg">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>gadget_is_otg</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>gadget_is_otg</refname>
 <refpurpose>
     return true iff the hardware is OTG-ready
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>gadget_is_otg </function></funcdef>
   <paramdef>struct usb_gadget * <parameter>g</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>g</parameter></term>
   <listitem>
    <para>
     controller that might have a Mini-AB connector
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This is a runtime test, since kernels with a USB-OTG stack sometimes
   run on boards which only have a Mini-B (or Mini-A) connector.
</para>
</refsect1>
</refentry>

<refentry id="API-usb-gadget-frame-number">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>usb_gadget_frame_number</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>usb_gadget_frame_number</refname>
 <refpurpose>
     returns the current frame number
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>usb_gadget_frame_number </function></funcdef>
   <paramdef>struct usb_gadget * <parameter>gadget</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>gadget</parameter></term>
   <listitem>
    <para>
     controller that reports the frame number
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Returns the usb frame number, normally eleven bits from a SOF packet,
   or negative errno if this device doesn't support this capability.
</para>
</refsect1>
</refentry>

<refentry id="API-usb-gadget-wakeup">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>usb_gadget_wakeup</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>usb_gadget_wakeup</refname>
 <refpurpose>
     tries to wake up the host connected to this gadget
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>usb_gadget_wakeup </function></funcdef>
   <paramdef>struct usb_gadget * <parameter>gadget</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>gadget</parameter></term>
   <listitem>
    <para>
     controller used to wake up the host
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Returns zero on success, else negative error code if the hardware
   doesn't support such attempts, or its support has not been enabled
   by the usb host.  Drivers must return device descriptors that report
   their ability to support this, or hosts won't enable it.
   </para><para>

   This may also try to use SRP to wake the host and start enumeration,
   even if OTG isn't otherwise in use.  OTG devices may also start
   remote wakeup even when hosts don't explicitly enable it.
</para>
</refsect1>
</refentry>

<refentry id="API-usb-gadget-set-selfpowered">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>usb_gadget_set_selfpowered</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>usb_gadget_set_selfpowered</refname>
 <refpurpose>
     sets the device selfpowered feature.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>usb_gadget_set_selfpowered </function></funcdef>
   <paramdef>struct usb_gadget * <parameter>gadget</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>gadget</parameter></term>
   <listitem>
    <para>
     the device being declared as self-powered
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   this affects the device status reported by the hardware driver
   to reflect that it now has a local power supply.
   </para><para>

   returns zero on success, else negative errno.
</para>
</refsect1>
</refentry>

<refentry id="API-usb-gadget-clear-selfpowered">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>usb_gadget_clear_selfpowered</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>usb_gadget_clear_selfpowered</refname>
 <refpurpose>
     clear the device selfpowered feature.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>usb_gadget_clear_selfpowered </function></funcdef>
   <paramdef>struct usb_gadget * <parameter>gadget</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>gadget</parameter></term>
   <listitem>
    <para>
     the device being declared as bus-powered
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   this affects the device status reported by the hardware driver.
   some hardware may not support bus-powered operation, in which
   case this feature's value can never change.
   </para><para>

   returns zero on success, else negative errno.
</para>
</refsect1>
</refentry>

<refentry id="API-usb-gadget-vbus-connect">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>usb_gadget_vbus_connect</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>usb_gadget_vbus_connect</refname>
 <refpurpose>
     Notify controller that VBUS is powered
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>usb_gadget_vbus_connect </function></funcdef>
   <paramdef>struct usb_gadget * <parameter>gadget</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>gadget</parameter></term>
   <listitem>
    <para>
     The device which now has VBUS power.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Context</title>
<para>
   can sleep
</para>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This call is used by a driver for an external transceiver (or GPIO)
   that detects a VBUS power session starting.  Common responses include
   resuming the controller, activating the D+ (or D-) pullup to let the
   host detect that a USB device is attached, and starting to draw power
   (8mA or possibly more, especially after SET_CONFIGURATION).
   </para><para>

   Returns zero on success, else negative errno.
</para>
</refsect1>
</refentry>

<refentry id="API-usb-gadget-vbus-draw">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>usb_gadget_vbus_draw</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>usb_gadget_vbus_draw</refname>
 <refpurpose>
     constrain controller's VBUS power usage
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>usb_gadget_vbus_draw </function></funcdef>
   <paramdef>struct usb_gadget * <parameter>gadget</parameter></paramdef>
   <paramdef>unsigned <parameter>mA</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>gadget</parameter></term>
   <listitem>
    <para>
     The device whose VBUS usage is being described
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>mA</parameter></term>
   <listitem>
    <para>
     How much current to draw, in milliAmperes.  This should be twice
     the value listed in the configuration descriptor bMaxPower field.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This call is used by gadget drivers during SET_CONFIGURATION calls,
   reporting how much power the device may consume.  For example, this
   could affect how quickly batteries are recharged.
   </para><para>

   Returns zero on success, else negative errno.
</para>
</refsect1>
</refentry>

<refentry id="API-usb-gadget-vbus-disconnect">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>usb_gadget_vbus_disconnect</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>usb_gadget_vbus_disconnect</refname>
 <refpurpose>
     notify controller about VBUS session end
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>usb_gadget_vbus_disconnect </function></funcdef>
   <paramdef>struct usb_gadget * <parameter>gadget</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>gadget</parameter></term>
   <listitem>
    <para>
     the device whose VBUS supply is being described
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Context</title>
<para>
   can sleep
</para>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This call is used by a driver for an external transceiver (or GPIO)
   that detects a VBUS power session ending.  Common responses include
   reversing everything done in <function>usb_gadget_vbus_connect</function>.
   </para><para>

   Returns zero on success, else negative errno.
</para>
</refsect1>
</refentry>

<refentry id="API-usb-gadget-connect">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>usb_gadget_connect</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>usb_gadget_connect</refname>
 <refpurpose>
     software-controlled connect to USB host
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>usb_gadget_connect </function></funcdef>
   <paramdef>struct usb_gadget * <parameter>gadget</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>gadget</parameter></term>
   <listitem>
    <para>
     the peripheral being connected
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Enables the D+ (or potentially D-) pullup.  The host will start
   enumerating this gadget when the pullup is active and a VBUS session
   is active (the link is powered).  This pullup is always enabled unless
   <function>usb_gadget_disconnect</function> has been used to disable it.
   </para><para>

   Returns zero on success, else negative errno.
</para>
</refsect1>
</refentry>

<refentry id="API-usb-gadget-disconnect">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>usb_gadget_disconnect</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>usb_gadget_disconnect</refname>
 <refpurpose>
     software-controlled disconnect from USB host
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>usb_gadget_disconnect </function></funcdef>
   <paramdef>struct usb_gadget * <parameter>gadget</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>gadget</parameter></term>
   <listitem>
    <para>
     the peripheral being disconnected
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Disables the D+ (or potentially D-) pullup, which the host may see
   as a disconnect (when a VBUS session is active).  Not all systems
   support software pullup controls.
   </para><para>

   This routine may be used during the gadget driver <function>bind</function> call to prevent
   the peripheral from ever being visible to the USB host, unless later
   <function>usb_gadget_connect</function> is called.  For example, user mode components may
   need to be activated before the system can talk to hosts.
   </para><para>

   Returns zero on success, else negative errno.
</para>
</refsect1>
</refentry>

<refentry id="API-struct-usb-gadget-driver">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct usb_gadget_driver</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct usb_gadget_driver</refname>
 <refpurpose>
     driver for usb 'slave' devices
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct usb_gadget_driver {
  char * function;
  enum usb_device_speed max_speed;
  int (* bind) (struct usb_gadget *gadget,struct usb_gadget_driver *driver);
  void (* unbind) (struct usb_gadget *);
  int (* setup) (struct usb_gadget *,const struct usb_ctrlrequest *);
  void (* disconnect) (struct usb_gadget *);
  void (* suspend) (struct usb_gadget *);
  void (* resume) (struct usb_gadget *);
  void (* reset) (struct usb_gadget *);
  struct device_driver driver;
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>function</term>
      <listitem><para>
   String describing the gadget's function
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>max_speed</term>
      <listitem><para>
   Highest speed the driver handles.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>bind</term>
      <listitem><para>
   the driver's bind callback
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>unbind</term>
      <listitem><para>
   Invoked when the driver is unbound from a gadget,
   usually from rmmod (after a disconnect is reported).
   Called in a context that permits sleeping.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>setup</term>
      <listitem><para>
   Invoked for ep0 control requests that aren't handled by
   the hardware level driver. Most calls must be handled by
   the gadget driver, including descriptor and configuration
   management.  The 16 bit members of the setup data are in
   USB byte order. Called in_interrupt; this may not sleep.  Driver
   queues a response to ep0, or returns negative to stall.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>disconnect</term>
      <listitem><para>
   Invoked after all transfers have been stopped,
   when the host is disconnected.  May be called in_interrupt; this
   may not sleep.  Some devices can't detect disconnect, so this might
   not be called except as part of controller shutdown.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>suspend</term>
      <listitem><para>
   Invoked on USB suspend.  May be called in_interrupt.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>resume</term>
      <listitem><para>
   Invoked on USB resume.  May be called in_interrupt.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>reset</term>
      <listitem><para>
   Invoked on USB bus reset. It is mandatory for all gadget drivers
   and should be called in_interrupt.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>driver</term>
      <listitem><para>
   Driver model state for this driver.
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
<refsect1>
<title>Description</title>
<para>
   Devices are disabled till a gadget driver successfully <function>bind</function>s, which
   means the driver will handle <function>setup</function> requests needed to enumerate (and
   meet <quote>chapter 9</quote> requirements) then do some useful work.
   </para><para>

   If gadget-&gt;is_otg is true, the gadget driver must provide an OTG
   descriptor during enumeration, or else fail the <function>bind</function> call.  In such
   cases, no USB traffic may flow until both <function>bind</function> returns without
   having called <function>usb_gadget_disconnect</function>, and the USB host stack has
   initialized.
   </para><para>

   Drivers use hardware-specific knowledge to configure the usb hardware.
   endpoint addressing is only one of several hardware characteristics that
   are in descriptors the ep0 implementation returns from <function>setup</function> calls.
   </para><para>

   Except for ep0 implementation, most driver code shouldn't need change to
   run on top of different usb controllers.  It'll use endpoints set up by
   that ep0 implementation.
   </para><para>

   The usb controller driver handles a few standard usb requests.  Those
   include set_address, and feature flags for devices, interfaces, and
   endpoints (the get_status, set_feature, and clear_feature requests).
   </para><para>

   Accordingly, the driver's <function>setup</function> callback must always implement all
   get_descriptor requests, returning at least a device descriptor and
   a configuration descriptor.  Drivers must make sure the endpoint
   descriptors match any hardware constraints. Some hardware also constrains
   other descriptors. (The pxa250 allows only configurations 1, 2, or 3).
   </para><para>

   The driver's <function>setup</function> callback must also implement set_configuration,
   and should also implement set_interface, get_configuration, and
   get_interface.  Setting a configuration (or interface) is where
   endpoints should be activated or (config 0) shut down.
   </para><para>

   (Note that only the default control endpoint is supported.  Neither
   hosts nor devices generally support control traffic except to ep0.)
   </para><para>

   Most devices will ignore USB suspend/resume operations, and so will
   not provide those callbacks.  However, some may need to change modes
   when the host is not longer directing those activities.  For example,
   local controls (buttons, dials, etc) may need to be re-enabled since
   the (remote) host can't do that any longer; or an error state might
   be cleared, to make the device behave identically whether or not
   power is maintained.
</para>
</refsect1>
</refentry>

<refentry id="API-usb-gadget-probe-driver">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>usb_gadget_probe_driver</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>usb_gadget_probe_driver</refname>
 <refpurpose>
     probe a gadget driver
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>usb_gadget_probe_driver </function></funcdef>
   <paramdef>struct usb_gadget_driver * <parameter>driver</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>driver</parameter></term>
   <listitem>
    <para>
     the driver being registered
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Context</title>
<para>
   can sleep
</para>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Call this in your gadget driver's module initialization function,
   to tell the underlying usb controller driver about your driver.
   The @<function>bind</function> function will be called to bind it to a gadget before this
   registration call returns.  It's expected that the @<function>bind</function> function will
   be in init sections.
</para>
</refsect1>
</refentry>

<refentry id="API-usb-gadget-unregister-driver">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>usb_gadget_unregister_driver</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>usb_gadget_unregister_driver</refname>
 <refpurpose>
     unregister a gadget driver
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>usb_gadget_unregister_driver </function></funcdef>
   <paramdef>struct usb_gadget_driver * <parameter>driver</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>driver</parameter></term>
   <listitem>
    <para>
     the driver being unregistered
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Context</title>
<para>
   can sleep
</para>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Call this in your gadget driver's module cleanup function,
   to tell the underlying usb controller that your driver is
   going away.  If the controller is connected to a USB host,
   it will first <function>disconnect</function>.  The driver is also requested
   to <function>unbind</function> and clean up any device state, before this procedure
   finally returns.  It's expected that the <function>unbind</function> functions
   will in in exit sections, so may not be linked in some kernels.
</para>
</refsect1>
</refentry>

<refentry id="API-struct-usb-string">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct usb_string</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct usb_string</refname>
 <refpurpose>
     wraps a C string and its USB id
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct usb_string {
  u8 id;
  const char * s;
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>id</term>
      <listitem><para>
   the (nonzero) ID for this string
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>s</term>
      <listitem><para>
   the string, in UTF-8 encoding
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
<refsect1>
<title>Description</title>
<para>
   If you're using <function>usb_gadget_get_string</function>, use this to wrap a string
   together with its ID.
</para>
</refsect1>
</refentry>

<refentry id="API-struct-usb-gadget-strings">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct usb_gadget_strings</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct usb_gadget_strings</refname>
 <refpurpose>
     a set of USB strings in a given language
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct usb_gadget_strings {
  u16 language;
  struct usb_string * strings;
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>language</term>
      <listitem><para>
   identifies the strings' language (0x0409 for en-us)
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>strings</term>
      <listitem><para>
   array of strings with their ids
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
<refsect1>
<title>Description</title>
<para>
   If you're using <function>usb_gadget_get_string</function>, use this to wrap all the
   strings for a given language.
</para>
</refsect1>
</refentry>

<refentry id="API-usb-free-descriptors">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>usb_free_descriptors</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>usb_free_descriptors</refname>
 <refpurpose>
     free descriptors returned by <function>usb_copy_descriptors</function>
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>usb_free_descriptors </function></funcdef>
   <paramdef>struct usb_descriptor_header ** <parameter>v</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>v</parameter></term>
   <listitem>
    <para>
     vector of descriptors
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

</sect1>

<sect1 id="utils"><title>Optional Utilities</title>

<para>The core API is sufficient for writing a USB Gadget Driver,
but some optional utilities are provided to simplify common tasks.
These utilities include endpoint autoconfiguration.
</para>

<!-- drivers/usb/gadget/usbstring.c -->
<refentry id="API-usb-gadget-get-string">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>usb_gadget_get_string</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>usb_gadget_get_string</refname>
 <refpurpose>
  fill out a string descriptor
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>usb_gadget_get_string </function></funcdef>
   <paramdef>struct usb_gadget_strings * <parameter>table</parameter></paramdef>
   <paramdef>int <parameter>id</parameter></paramdef>
   <paramdef>u8 * <parameter>buf</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>table</parameter></term>
   <listitem>
    <para>
     of c strings encoded using UTF-8
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>id</parameter></term>
   <listitem>
    <para>
     string id, from low byte of wValue in get string descriptor
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>buf</parameter></term>
   <listitem>
    <para>
     at least 256 bytes, must be 16-bit aligned
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Finds the UTF-8 string matching the ID, and converts it into a
   string descriptor in utf16-le.
   Returns length of descriptor (always even) or negative errno
   </para><para>

   If your driver needs stings in multiple languages, you'll probably
   <quote>switch (wIndex) { ... }</quote>  in your ep0 string descriptor logic,
   using this routine after choosing which set of UTF-8 strings to use.
   Note that US-ASCII is a strict subset of UTF-8; any string bytes with
   the eighth bit set will be multibyte UTF-8 characters, not ISO-8859/1
   characters (which are also widely used in C strings).
</para>
</refsect1>
</refentry>

<!-- drivers/usb/gadget/config.c -->
<refentry id="API-usb-descriptor-fillbuf">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>usb_descriptor_fillbuf</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>usb_descriptor_fillbuf</refname>
 <refpurpose>
  fill buffer with descriptors
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>usb_descriptor_fillbuf </function></funcdef>
   <paramdef>void * <parameter>buf</parameter></paramdef>
   <paramdef>unsigned <parameter>buflen</parameter></paramdef>
   <paramdef>const struct usb_descriptor_header ** <parameter>src</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>buf</parameter></term>
   <listitem>
    <para>
     Buffer to be filled
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>buflen</parameter></term>
   <listitem>
    <para>
     Size of buf
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>src</parameter></term>
   <listitem>
    <para>
     Array of descriptor pointers, terminated by null pointer.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Copies descriptors into the buffer, returning the length or a
   negative error code if they can't all be copied.  Useful when
   assembling descriptors for an associated set of interfaces used
   as part of configuring a composite device; or in other cases where
   sets of descriptors need to be marshaled.
</para>
</refsect1>
</refentry>

<refentry id="API-usb-gadget-config-buf">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>usb_gadget_config_buf</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>usb_gadget_config_buf</refname>
 <refpurpose>
     builts a complete configuration descriptor
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>usb_gadget_config_buf </function></funcdef>
   <paramdef>const struct usb_config_descriptor * <parameter>config</parameter></paramdef>
   <paramdef>void * <parameter>buf</parameter></paramdef>
   <paramdef>unsigned <parameter>length</parameter></paramdef>
   <paramdef>const struct usb_descriptor_header ** <parameter>desc</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>config</parameter></term>
   <listitem>
    <para>
     Header for the descriptor, including characteristics such
     as power requirements and number of interfaces.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>buf</parameter></term>
   <listitem>
    <para>
     Buffer for the resulting configuration descriptor.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>length</parameter></term>
   <listitem>
    <para>
     Length of buffer.  If this is not big enough to hold the
     entire configuration descriptor, an error code will be returned.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>desc</parameter></term>
   <listitem>
    <para>
     Null-terminated vector of pointers to the descriptors (interface,
     endpoint, etc) defining all functions in this device configuration.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This copies descriptors into the response buffer, building a descriptor
   for that configuration.  It returns the buffer length or a negative
   status code.  The config.wTotalLength field is set to match the length
   of the result, but other descriptor fields (including power usage and
   interface count) must be set by the caller.
   </para><para>

   Gadget drivers could use this when constructing a config descriptor
   in response to USB_REQ_GET_DESCRIPTOR.  They will need to patch the
   resulting bDescriptorType value if USB_DT_OTHER_SPEED_CONFIG is needed.
</para>
</refsect1>
</refentry>

<refentry id="API-usb-copy-descriptors">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>usb_copy_descriptors</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>usb_copy_descriptors</refname>
 <refpurpose>
     copy a vector of USB descriptors
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct usb_descriptor_header ** <function>usb_copy_descriptors </function></funcdef>
   <paramdef>struct usb_descriptor_header ** <parameter>src</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>src</parameter></term>
   <listitem>
    <para>
     null-terminated vector to copy
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Context</title>
<para>
   initialization code, which may sleep
</para>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This makes a copy of a vector of USB descriptors.  Its primary use
   is to support usb_function objects which can have multiple copies,
   each needing different descriptors.  Functions may have static
   tables of descriptors, which are used as templates and customized
   with identifiers (for interfaces, strings, endpoints, and more)
   as needed by a given function instance.
</para>
</refsect1>
</refentry>

<!-- !Edrivers/usb/gadget/epautoconf.c -->
</sect1>

<sect1 id="composite"><title>Composite Device Framework</title>

<para>The core API is sufficient for writing drivers for composite
USB devices (with more than one function in a given configuration),
and also multi-configuration devices (also more than one function,
but not necessarily sharing a given configuration).
There is however an optional framework which makes it easier to
reuse and combine functions.
</para>

<para>Devices using this framework provide a <emphasis>struct
usb_composite_driver</emphasis>, which in turn provides one or
more <emphasis>struct usb_configuration</emphasis> instances.
Each such configuration includes at least one
<emphasis>struct usb_function</emphasis>, which packages a user
visible role such as "network link" or "mass storage device".
Management functions may also exist, such as "Device Firmware
Upgrade".
</para>

<!-- include/linux/usb/composite.h -->
<refentry id="API-struct-usb-os-desc-ext-prop">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct usb_os_desc_ext_prop</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct usb_os_desc_ext_prop</refname>
 <refpurpose>
  describes one <quote>Extended Property</quote>
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct usb_os_desc_ext_prop {
  struct list_head entry;
  u8 type;
  int name_len;
  char * name;
  int data_len;
  char * data;
  struct config_item item;
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>entry</term>
      <listitem><para>
used to keep a list of extended properties
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>type</term>
      <listitem><para>
Extended Property type
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>name_len</term>
      <listitem><para>
Extended Property unicode name length, including terminating '\0'
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>name</term>
      <listitem><para>
Extended Property name
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>data_len</term>
      <listitem><para>
Length of Extended Property blob (for unicode store double len)
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>data</term>
      <listitem><para>
Extended Property blob
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>item</term>
      <listitem><para>
Represents this Extended Property in configfs
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
</refentry>

<refentry id="API-struct-usb-os-desc">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct usb_os_desc</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct usb_os_desc</refname>
 <refpurpose>
     describes OS descriptors associated with one interface
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct usb_os_desc {
  char * ext_compat_id;
  struct list_head ext_prop;
  int ext_prop_len;
  int ext_prop_count;
  struct mutex * opts_mutex;
  struct config_group group;
  struct module * owner;
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>ext_compat_id</term>
      <listitem><para>
   16 bytes of <quote>Compatible ID</quote> and <quote>Subcompatible ID</quote>
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>ext_prop</term>
      <listitem><para>
   Extended Properties list
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>ext_prop_len</term>
      <listitem><para>
   Total length of Extended Properties blobs
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>ext_prop_count</term>
      <listitem><para>
   Number of Extended Properties
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>opts_mutex</term>
      <listitem><para>
   Optional mutex protecting config data of a usb_function_instance
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>group</term>
      <listitem><para>
   Represents OS descriptors associated with an interface in configfs
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>owner</term>
      <listitem><para>
   Module associated with this OS descriptor
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
</refentry>

<refentry id="API-struct-usb-os-desc-table">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct usb_os_desc_table</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct usb_os_desc_table</refname>
 <refpurpose>
     describes OS descriptors associated with one interface of a usb_function
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct usb_os_desc_table {
  int if_id;
  struct usb_os_desc * os_desc;
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>if_id</term>
      <listitem><para>
   Interface id
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>os_desc</term>
      <listitem><para>
   "Extended Compatibility ID<quote> and </quote>Extended Properties" of the
   interface
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
<refsect1>
<title>Description</title>
<para>
   Each interface can have at most one <quote>Extended Compatibility ID</quote> and a
   number of <quote>Extended Properties</quote>.
</para>
</refsect1>
</refentry>

<refentry id="API-struct-usb-function">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct usb_function</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct usb_function</refname>
 <refpurpose>
     describes one function of a configuration
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct usb_function {
  const char * name;
  struct usb_gadget_strings ** strings;
  struct usb_descriptor_header ** fs_descriptors;
  struct usb_descriptor_header ** hs_descriptors;
  struct usb_descriptor_header ** ss_descriptors;
  struct usb_configuration * config;
  struct usb_os_desc_table * os_desc_table;
  unsigned os_desc_n;
  int (* bind) (struct usb_configuration *,struct usb_function *);
  void (* unbind) (struct usb_configuration *,struct usb_function *);
  void (* free_func) (struct usb_function *f);
  struct module * mod;
  int (* set_alt) (struct usb_function *,unsigned interface, unsigned alt);
  int (* get_alt) (struct usb_function *,unsigned interface);
  void (* disable) (struct usb_function *);
  int (* setup) (struct usb_function *,const struct usb_ctrlrequest *);
  void (* suspend) (struct usb_function *);
  void (* resume) (struct usb_function *);
  int (* get_status) (struct usb_function *);
  int (* func_suspend) (struct usb_function *,u8 suspend_opt);
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>name</term>
      <listitem><para>
   For diagnostics, identifies the function.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>strings</term>
      <listitem><para>
   tables of strings, keyed by identifiers assigned during <function>bind</function>
   and by language IDs provided in control requests
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>fs_descriptors</term>
      <listitem><para>
   Table of full (or low) speed descriptors, using interface and
   string identifiers assigned during <parameter>bind</parameter>().  If this pointer is null,
   the function will not be available at full speed (or at low speed).
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>hs_descriptors</term>
      <listitem><para>
   Table of high speed descriptors, using interface and
   string identifiers assigned during <parameter>bind</parameter>().  If this pointer is null,
   the function will not be available at high speed.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>ss_descriptors</term>
      <listitem><para>
   Table of super speed descriptors, using interface and
   string identifiers assigned during <parameter>bind</parameter>(). If this
   pointer is null after initiation, the function will not
   be available at super speed.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>config</term>
      <listitem><para>
   assigned when <parameter>usb_add_function</parameter>() is called; this is the
   configuration with which this function is associated.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>os_desc_table</term>
      <listitem><para>
   Table of (interface id, os descriptors) pairs. The function
   can expose more than one interface. If an interface is a member of
   an IAD, only the first interface of IAD has its entry in the table.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>os_desc_n</term>
      <listitem><para>
   Number of entries in os_desc_table
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>bind</term>
      <listitem><para>
   Before the gadget can register, all of its functions <function>bind</function> to the
   available resources including string and interface identifiers used
   in interface or class descriptors; endpoints; I/O buffers; and so on.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>unbind</term>
      <listitem><para>
   Reverses <parameter>bind</parameter>; called as a side effect of unregistering the
   driver which added this function.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>free_func</term>
      <listitem><para>
   free the struct usb_function.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>mod</term>
      <listitem><para>
   (internal) points to the module that created this structure.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>set_alt</term>
      <listitem><para>
   (REQUIRED) Reconfigures altsettings; function drivers may
   initialize usb_ep.driver data at this time (when it is used).
   Note that setting an interface to its current altsetting resets
   interface state, and that all interfaces have a disabled state.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>get_alt</term>
      <listitem><para>
   Returns the active altsetting.  If this is not provided,
   then only altsetting zero is supported.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>disable</term>
      <listitem><para>
   (REQUIRED) Indicates the function should be disabled.  Reasons
   include host resetting or reconfiguring the gadget, and disconnection.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>setup</term>
      <listitem><para>
   Used for interface-specific control requests.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>suspend</term>
      <listitem><para>
   Notifies functions when the host stops sending USB traffic.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>resume</term>
      <listitem><para>
   Notifies functions when the host restarts USB traffic.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>get_status</term>
      <listitem><para>
   Returns function status as a reply to
   <function>GetStatus</function> request when the recipient is Interface.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>func_suspend</term>
      <listitem><para>
   callback to be called when
   SetFeature(FUNCTION_SUSPEND) is reseived
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
<refsect1>
<title>Description</title>
<para>
   A single USB function uses one or more interfaces, and should in most
   cases support operation at both full and high speeds.  Each function is
   associated by <parameter>usb_add_function</parameter>() with a one configuration; that function
   causes <parameter>bind</parameter>() to be called so resources can be allocated as part of
   setting up a gadget driver.  Those resources include endpoints, which
   should be allocated using <parameter>usb_ep_autoconfig</parameter>().
   </para><para>

   To support dual speed operation, a function driver provides descriptors
   for both high and full speed operation.  Except in rare cases that don't
   involve bulk endpoints, each speed needs different endpoint descriptors.
   </para><para>

   Function drivers choose their own strategies for managing instance data.
   The simplest strategy just declares it "static', which means the function
   can only be activated once.  If the function needs to be exposed in more
   than one configuration at a given speed, it needs to support multiple
   usb_function structures (one for each configuration).
   </para><para>

   A more complex strategy might encapsulate a <parameter>usb_function</parameter> structure inside
   a driver-specific instance structure to allows multiple activations.  An
   example of multiple activations might be a CDC ACM function that supports
   two or more distinct instances within the same configuration, providing
   several independent logical data links to a USB host.
</para>
</refsect1>
</refentry>

<refentry id="API-struct-usb-configuration">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct usb_configuration</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct usb_configuration</refname>
 <refpurpose>
     represents one gadget configuration
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct usb_configuration {
  const char * label;
  struct usb_gadget_strings ** strings;
  const struct usb_descriptor_header ** descriptors;
  void (* unbind) (struct usb_configuration *);
  int (* setup) (struct usb_configuration *,const struct usb_ctrlrequest *);
  u8 bConfigurationValue;
  u8 iConfiguration;
  u8 bmAttributes;
  u16 MaxPower;
  struct usb_composite_dev * cdev;
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>label</term>
      <listitem><para>
   For diagnostics, describes the configuration.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>strings</term>
      <listitem><para>
   Tables of strings, keyed by identifiers assigned during <parameter>bind</parameter>()
   and by language IDs provided in control requests.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>descriptors</term>
      <listitem><para>
   Table of descriptors preceding all function descriptors.
   Examples include OTG and vendor-specific descriptors.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>unbind</term>
      <listitem><para>
   Reverses <parameter>bind</parameter>; called as a side effect of unregistering the
   driver which added this configuration.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>setup</term>
      <listitem><para>
   Used to delegate control requests that aren't handled by standard
   device infrastructure or directed at a specific interface.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>bConfigurationValue</term>
      <listitem><para>
   Copied into configuration descriptor.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>iConfiguration</term>
      <listitem><para>
   Copied into configuration descriptor.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>bmAttributes</term>
      <listitem><para>
   Copied into configuration descriptor.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>MaxPower</term>
      <listitem><para>
   Power consumtion in mA. Used to compute bMaxPower in the
   configuration descriptor after considering the bus speed.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>cdev</term>
      <listitem><para>
   assigned by <parameter>usb_add_config</parameter>() before calling <parameter>bind</parameter>(); this is
   the device associated with this configuration.
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
<refsect1>
<title>Description</title>
<para>
   Configurations are building blocks for gadget drivers structured around
   function drivers.  Simple USB gadgets require only one function and one
   configuration, and handle dual-speed hardware by always providing the same
   functionality.  Slightly more complex gadgets may have more than one
   single-function configuration at a given speed; or have configurations
   that only work at one speed.
   </para><para>

   Composite devices are, by definition, ones with configurations which
   include more than one function.
   </para><para>

   The lifecycle of a usb_configuration includes allocation, initialization
   of the fields described above, and calling <parameter>usb_add_config</parameter>() to set up
   internal data and bind it to a specific device.  The configuration's
   <parameter>bind</parameter>() method is then used to initialize all the functions and then
   call <parameter>usb_add_function</parameter>() for them.
   </para><para>

   Those functions would normally be independent of each other, but that's
   not mandatory.  CDC WMC devices are an example where functions often
   depend on other functions, with some functions subsidiary to others.
   Such interdependency may be managed in any way, so long as all of the
   descriptors complete by the time the composite driver returns from
   its <function>bind</function> routine.
</para>
</refsect1>
</refentry>

<refentry id="API-struct-usb-composite-driver">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct usb_composite_driver</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct usb_composite_driver</refname>
 <refpurpose>
     groups configurations into a gadget
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct usb_composite_driver {
  const char * name;
  const struct usb_device_descriptor * dev;
  struct usb_gadget_strings ** strings;
  enum usb_device_speed max_speed;
  unsigned needs_serial:1;
  int (* bind) (struct usb_composite_dev *cdev);
  int (* unbind) (struct usb_composite_dev *);
  void (* disconnect) (struct usb_composite_dev *);
  void (* suspend) (struct usb_composite_dev *);
  void (* resume) (struct usb_composite_dev *);
  struct usb_gadget_driver gadget_driver;
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>name</term>
      <listitem><para>
   For diagnostics, identifies the driver.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>dev</term>
      <listitem><para>
   Template descriptor for the device, including default device
   identifiers.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>strings</term>
      <listitem><para>
   tables of strings, keyed by identifiers assigned during <parameter>bind</parameter>
   and language IDs provided in control requests. Note: The first entries
   are predefined. The first entry that may be used is
   USB_GADGET_FIRST_AVAIL_IDX
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>max_speed</term>
      <listitem><para>
   Highest speed the driver supports.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>needs_serial</term>
      <listitem><para>
   set to 1 if the gadget needs userspace to provide
   a serial number.  If one is not provided, warning will be printed.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>bind</term>
      <listitem><para>
   (REQUIRED) Used to allocate resources that are shared across the
   whole device, such as string IDs, and add its configurations using
   <parameter>usb_add_config</parameter>(). This may fail by returning a negative errno
   value; it should return zero on successful initialization.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>unbind</term>
      <listitem><para>
   Reverses <parameter>bind</parameter>; called as a side effect of unregistering
   this driver.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>disconnect</term>
      <listitem><para>
   optional driver disconnect method
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>suspend</term>
      <listitem><para>
   Notifies when the host stops sending USB traffic,
   after function notifications
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>resume</term>
      <listitem><para>
   Notifies configuration when the host restarts USB traffic,
   before function notifications
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>gadget_driver</term>
      <listitem><para>
   Gadget driver controlling this driver
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
<refsect1>
<title>Description</title>
<para>
   Devices default to reporting self powered operation.  Devices which rely
   on bus powered operation should report this in their <parameter>bind</parameter> method.
   </para><para>

   Before returning from <parameter>bind</parameter>, various fields in the template descriptor
   may be overridden.  These include the idVendor/idProduct/bcdDevice values
   normally to bind the appropriate host side driver, and the three strings
   (iManufacturer, iProduct, iSerialNumber) normally used to provide user
   meaningful device identifiers.  (The strings will not be defined unless
   they are defined in <parameter>dev</parameter> and <parameter>strings</parameter>.)  The correct ep0 maxpacket size
   is also reported, as defined by the underlying controller driver.
</para>
</refsect1>
</refentry>

<refentry id="API-module-usb-composite-driver">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>module_usb_composite_driver</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>module_usb_composite_driver</refname>
 <refpurpose>
     Helper macro for registering a USB gadget composite driver
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef> <function>module_usb_composite_driver </function></funcdef>
   <paramdef> <parameter>__usb_composite_driver</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>__usb_composite_driver</parameter></term>
   <listitem>
    <para>
     usb_composite_driver struct
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Helper macro for USB gadget composite drivers which do not do anything
   special in module init/exit. This eliminates a lot of boilerplate. Each
   module may only use this macro once, and calling it replaces <function>module_init</function>
   and <function>module_exit</function>
</para>
</refsect1>
</refentry>

<refentry id="API-struct-usb-composite-dev">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct usb_composite_dev</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct usb_composite_dev</refname>
 <refpurpose>
     represents one composite usb gadget
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct usb_composite_dev {
  struct usb_gadget * gadget;
  struct usb_request * req;
  struct usb_request * os_desc_req;
  struct usb_configuration * config;
  u8 qw_sign[OS_STRING_QW_SIGN_LEN];
  u8 b_vendor_code;
  struct usb_configuration * os_desc_config;
  unsigned int use_os_string:1;
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>gadget</term>
      <listitem><para>
   read-only, abstracts the gadget's usb peripheral controller
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>req</term>
      <listitem><para>
   used for control responses; buffer is pre-allocated
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>os_desc_req</term>
      <listitem><para>
   used for OS descriptors responses; buffer is pre-allocated
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>config</term>
      <listitem><para>
   the currently active configuration
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>qw_sign[OS_STRING_QW_SIGN_LEN]</term>
      <listitem><para>
   qwSignature part of the OS string
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>b_vendor_code</term>
      <listitem><para>
   bMS_VendorCode part of the OS string
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>os_desc_config</term>
      <listitem><para>
   the configuration to be used with OS descriptors
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>use_os_string</term>
      <listitem><para>
   false by default, interested gadgets set it
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
<refsect1>
<title>Description</title>
<para>
   One of these devices is allocated and initialized before the
   associated device driver's <function>bind</function> is called.
</para>
</refsect1>
<refsect1>
<title>OPEN ISSUE</title>
<para>
   it appears that some WUSB devices will need to be
   built by combining a normal (wired) gadget with a wireless one.
   This revision of the gadget framework should probably try to make
   sure doing that won't hurt too much.
</para>
</refsect1>
<refsect1>
<title>One notion for how to handle Wireless USB devices involves</title>
<para>
   (a) a second gadget here, discovery mechanism TBD, but likely
   needing separate <quote>register/unregister WUSB gadget</quote> calls;
   (b) updates to usb_gadget to include flags <quote>is it wireless</quote>,
   <quote>is it wired</quote>, plus (presumably in a wrapper structure)
   bandgroup and PHY info;
   (c) presumably a wireless_ep wrapping a usb_ep, and reporting
   wireless-specific parameters like maxburst and maxsequence;
   (d) configurations that are specific to wireless links;
   (e) function drivers that understand wireless configs and will
   support wireless for (additional) function instances;
   (f) a function to support association setup (like CBAF), not
   necessarily requiring a wireless adapter;
   (g) composite device setup that can create one or more wireless
   configs, including appropriate association setup support;
   (h) more, TBD.
</para>
</refsect1>
</refentry>

<!-- drivers/usb/gadget/composite.c -->
<refentry id="API-config-ep-by-speed">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>config_ep_by_speed</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>config_ep_by_speed</refname>
 <refpurpose>
  configures the given endpoint according to gadget speed.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>config_ep_by_speed </function></funcdef>
   <paramdef>struct usb_gadget * <parameter>g</parameter></paramdef>
   <paramdef>struct usb_function * <parameter>f</parameter></paramdef>
   <paramdef>struct usb_ep * <parameter>_ep</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>g</parameter></term>
   <listitem>
    <para>
     pointer to the gadget
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>f</parameter></term>
   <listitem>
    <para>
     usb function
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>_ep</parameter></term>
   <listitem>
    <para>
     the endpoint to configure
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Return</title>
<para>
   error code, 0 on success
   </para><para>

   This function chooses the right descriptors for a given
   endpoint according to gadget speed and saves it in the
   endpoint desc field. If the endpoint already has a descriptor
   assigned to it - overwrites it with currently corresponding
   descriptor. The endpoint maxpacket field is updated according
   to the chosen descriptor.
</para>
</refsect1>
<refsect1>
<title>Note</title>
<para>
   the supplied function should hold all the descriptors
   for supported speeds
</para>
</refsect1>
</refentry>

<refentry id="API-usb-add-function">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>usb_add_function</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>usb_add_function</refname>
 <refpurpose>
     add a function to a configuration
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>usb_add_function </function></funcdef>
   <paramdef>struct usb_configuration * <parameter>config</parameter></paramdef>
   <paramdef>struct usb_function * <parameter>function</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>config</parameter></term>
   <listitem>
    <para>
     the configuration
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>function</parameter></term>
   <listitem>
    <para>
     the function being added
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Context</title>
<para>
   single threaded during gadget setup
</para>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   After initialization, each configuration must have one or more
   functions added to it.  Adding a function involves calling its @<function>bind</function>
   method to allocate resources such as interface and string identifiers
   and endpoints.
   </para><para>

   This function returns the value of the function's <function>bind</function>, which is
   zero for success else a negative errno value.
</para>
</refsect1>
</refentry>

<refentry id="API-usb-function-deactivate">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>usb_function_deactivate</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>usb_function_deactivate</refname>
 <refpurpose>
     prevent function and gadget enumeration
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>usb_function_deactivate </function></funcdef>
   <paramdef>struct usb_function * <parameter>function</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>function</parameter></term>
   <listitem>
    <para>
     the function that isn't yet ready to respond
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Blocks response of the gadget driver to host enumeration by
   preventing the data line pullup from being activated.  This is
   normally called during @<function>bind</function> processing to change from the
   initial <quote>ready to respond</quote> state, or when a required resource
   becomes available.
   </para><para>

   For example, drivers that serve as a passthrough to a userspace
   daemon can block enumeration unless that daemon (such as an OBEX,
   MTP, or print server) is ready to handle host requests.
   </para><para>

   Not all systems support software control of their USB peripheral
   data pullups.
   </para><para>

   Returns zero on success, else negative errno.
</para>
</refsect1>
</refentry>

<refentry id="API-usb-function-activate">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>usb_function_activate</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>usb_function_activate</refname>
 <refpurpose>
     allow function and gadget enumeration
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>usb_function_activate </function></funcdef>
   <paramdef>struct usb_function * <parameter>function</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>function</parameter></term>
   <listitem>
    <para>
     function on which <function>usb_function_activate</function> was called
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Reverses effect of <function>usb_function_deactivate</function>.  If no more functions
   are delaying their activation, the gadget driver will respond to
   host enumeration procedures.
   </para><para>

   Returns zero on success, else negative errno.
</para>
</refsect1>
</refentry>

<refentry id="API-usb-interface-id">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>usb_interface_id</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>usb_interface_id</refname>
 <refpurpose>
     allocate an unused interface ID
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>usb_interface_id </function></funcdef>
   <paramdef>struct usb_configuration * <parameter>config</parameter></paramdef>
   <paramdef>struct usb_function * <parameter>function</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>config</parameter></term>
   <listitem>
    <para>
     configuration associated with the interface
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>function</parameter></term>
   <listitem>
    <para>
     function handling the interface
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Context</title>
<para>
   single threaded during gadget setup
</para>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   <function>usb_interface_id</function> is called from usb_function.<function>bind</function> callbacks to
   allocate new interface IDs.  The function driver will then store that
   ID in interface, association, CDC union, and other descriptors.  It
   will also handle any control requests targeted at that interface,
   particularly changing its altsetting via <function>set_alt</function>.  There may
   also be class-specific or vendor-specific requests to handle.
   </para><para>

   All interface identifier should be allocated using this routine, to
   ensure that for example different functions don't wrongly assign
   different meanings to the same identifier.  Note that since interface
   identifiers are configuration-specific, functions used in more than
   one configuration (or more than once in a given configuration) need
   multiple versions of the relevant descriptors.
   </para><para>

   Returns the interface ID which was allocated; or -ENODEV if no
   more interface IDs can be allocated.
</para>
</refsect1>
</refentry>

<refentry id="API-usb-add-config">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>usb_add_config</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>usb_add_config</refname>
 <refpurpose>
     add a configuration to a device.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>usb_add_config </function></funcdef>
   <paramdef>struct usb_composite_dev * <parameter>cdev</parameter></paramdef>
   <paramdef>struct usb_configuration * <parameter>config</parameter></paramdef>
   <paramdef>int (*<parameter>bind</parameter>)
     <funcparams>struct usb_configuration *</funcparams></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>cdev</parameter></term>
   <listitem>
    <para>
     wraps the USB gadget
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>config</parameter></term>
   <listitem>
    <para>
     the configuration, with bConfigurationValue assigned
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>bind</parameter></term>
   <listitem>
    <para>
     the configuration's bind function
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Context</title>
<para>
   single threaded during gadget setup
</para>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   One of the main tasks of a composite @<function>bind</function> routine is to
   add each of the configurations it supports, using this routine.
   </para><para>

   This function returns the value of the configuration's @<function>bind</function>, which
   is zero for success else a negative errno value.  Binding configurations
   assigns global resources including string IDs, and per-configuration
   resources such as interface IDs and endpoints.
</para>
</refsect1>
</refentry>

<refentry id="API-usb-string-id">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>usb_string_id</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>usb_string_id</refname>
 <refpurpose>
     allocate an unused string ID
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>usb_string_id </function></funcdef>
   <paramdef>struct usb_composite_dev * <parameter>cdev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>cdev</parameter></term>
   <listitem>
    <para>
     the device whose string descriptor IDs are being allocated
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Context</title>
<para>
   single threaded during gadget setup
</para>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   @<function>usb_string_id</function> is called from <function>bind</function> callbacks to allocate
   string IDs.  Drivers for functions, configurations, or gadgets will
   then store that ID in the appropriate descriptors and string table.
   </para><para>

   All string identifier should be allocated using this,
   @<function>usb_string_ids_tab</function> or @<function>usb_string_ids_n</function> routine, to ensure
   that for example different functions don't wrongly assign different
   meanings to the same identifier.
</para>
</refsect1>
</refentry>

<refentry id="API-usb-string-ids-tab">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>usb_string_ids_tab</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>usb_string_ids_tab</refname>
 <refpurpose>
     allocate unused string IDs in batch
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>usb_string_ids_tab </function></funcdef>
   <paramdef>struct usb_composite_dev * <parameter>cdev</parameter></paramdef>
   <paramdef>struct usb_string * <parameter>str</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>cdev</parameter></term>
   <listitem>
    <para>
     the device whose string descriptor IDs are being allocated
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>str</parameter></term>
   <listitem>
    <para>
     an array of usb_string objects to assign numbers to
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Context</title>
<para>
   single threaded during gadget setup
</para>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   @<function>usb_string_ids</function> is called from <function>bind</function> callbacks to allocate
   string IDs.  Drivers for functions, configurations, or gadgets will
   then copy IDs from the string table to the appropriate descriptors
   and string table for other languages.
   </para><para>

   All string identifier should be allocated using this,
   @<function>usb_string_id</function> or @<function>usb_string_ids_n</function> routine, to ensure that for
   example different functions don't wrongly assign different meanings
   to the same identifier.
</para>
</refsect1>
</refentry>

<refentry id="API-usb-gstrings-attach">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>usb_gstrings_attach</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>usb_gstrings_attach</refname>
 <refpurpose>
     attach gadget strings to a cdev and assign ids
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct usb_string * <function>usb_gstrings_attach </function></funcdef>
   <paramdef>struct usb_composite_dev * <parameter>cdev</parameter></paramdef>
   <paramdef>struct usb_gadget_strings ** <parameter>sp</parameter></paramdef>
   <paramdef>unsigned <parameter>n_strings</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>cdev</parameter></term>
   <listitem>
    <para>
     the device whose string descriptor IDs are being allocated
     and attached.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>sp</parameter></term>
   <listitem>
    <para>
     an array of usb_gadget_strings to attach.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>n_strings</parameter></term>
   <listitem>
    <para>
     number of entries in each usb_strings array (sp[]-&gt;strings)
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This function will create a deep copy of usb_gadget_strings and usb_string
   and attach it to the cdev. The actual string (usb_string.s) will not be
   copied but only a referenced will be made. The struct usb_gadget_strings
   array may contain multiple languges and should be NULL terminated.
   The -&gt;language pointer of each struct usb_gadget_strings has to contain the
   same amount of entries.
</para>
</refsect1>
<refsect1>
<title>For instance</title>
<para>
   sp[0] is en-US, sp[1] is es-ES. It is expected that the first
   usb_string entry of es-ES containts the translation of the first usb_string
   entry of en-US. Therefore both entries become the same id assign.
</para>
</refsect1>
</refentry>

<refentry id="API-usb-string-ids-n">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>usb_string_ids_n</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>usb_string_ids_n</refname>
 <refpurpose>
     allocate unused string IDs in batch
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>usb_string_ids_n </function></funcdef>
   <paramdef>struct usb_composite_dev * <parameter>c</parameter></paramdef>
   <paramdef>unsigned <parameter>n</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>c</parameter></term>
   <listitem>
    <para>
     the device whose string descriptor IDs are being allocated
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>n</parameter></term>
   <listitem>
    <para>
     number of string IDs to allocate
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Context</title>
<para>
   single threaded during gadget setup
</para>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Returns the first requested ID.  This ID and next <parameter>n</parameter>-1 IDs are now
   valid IDs.  At least provided that <parameter>n</parameter> is non-zero because if it
   is, returns last requested ID which is now very useful information.
   </para><para>

   @<function>usb_string_ids_n</function> is called from <function>bind</function> callbacks to allocate
   string IDs.  Drivers for functions, configurations, or gadgets will
   then store that ID in the appropriate descriptors and string table.
   </para><para>

   All string identifier should be allocated using this,
   @<function>usb_string_id</function> or @<function>usb_string_ids_n</function> routine, to ensure that for
   example different functions don't wrongly assign different meanings
   to the same identifier.
</para>
</refsect1>
</refentry>

<refentry id="API-usb-composite-probe">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>usb_composite_probe</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>usb_composite_probe</refname>
 <refpurpose>
     register a composite driver
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>usb_composite_probe </function></funcdef>
   <paramdef>struct usb_composite_driver * <parameter>driver</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>driver</parameter></term>
   <listitem>
    <para>
     the driver to register
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Context</title>
<para>
   single threaded during gadget setup
</para>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This function is used to register drivers using the composite driver
   framework.  The return value is zero, or a negative errno value.
   Those values normally come from the driver's <parameter>bind</parameter> method, which does
   all the work of setting up the driver to match the hardware.
   </para><para>

   On successful return, the gadget is ready to respond to requests from
   the host, unless one of its components invokes <function>usb_gadget_disconnect</function>
   while it was binding.  That would usually be done in order to wait for
   some userspace participation.
</para>
</refsect1>
</refentry>

<refentry id="API-usb-composite-unregister">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>usb_composite_unregister</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>usb_composite_unregister</refname>
 <refpurpose>
     unregister a composite driver
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>usb_composite_unregister </function></funcdef>
   <paramdef>struct usb_composite_driver * <parameter>driver</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>driver</parameter></term>
   <listitem>
    <para>
     the driver to unregister
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This function is used to unregister drivers using the composite
   driver framework.
</para>
</refsect1>
</refentry>

<refentry id="API-usb-composite-setup-continue">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>usb_composite_setup_continue</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>usb_composite_setup_continue</refname>
 <refpurpose>
     Continue with the control transfer
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>usb_composite_setup_continue </function></funcdef>
   <paramdef>struct usb_composite_dev * <parameter>cdev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>cdev</parameter></term>
   <listitem>
    <para>
     the composite device who's control transfer was kept waiting
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This function must be called by the USB function driver to continue
   with the control transfer's data/status stage in case it had requested to
   delay the data/status stages. A USB function's setup handler (e.g. <function>set_alt</function>)
   can request the composite framework to delay the setup request's data/status
   stages by returning USB_GADGET_DELAYED_STATUS.
</para>
</refsect1>
</refentry>


</sect1>

<sect1 id="functions"><title>Composite Device Functions</title>

<para>At this writing, a few of the current gadget drivers have
been converted to this framework.
Near-term plans include converting all of them, except for "gadgetfs".
</para>

<!-- drivers/usb/gadget/function/f_acm.c -->
<refentry>
 <refnamediv>
  <refname>
   ..//drivers/usb/gadget/function/f_acm.c
  </refname>
  <refpurpose>
   Document generation inconsistency
  </refpurpose>
 </refnamediv>
 <refsect1>
  <title>
   Oops
  </title>
  <warning>
   <para>
    The template for this document tried to insert
    the structured comment from the file
    <filename>..//drivers/usb/gadget/function/f_acm.c</filename> at this point,
    but none was found.
    This dummy section is inserted to allow
    generation to continue.
   </para>
  </warning>
 </refsect1>
</refentry>
<!-- drivers/usb/gadget/function/f_ecm.c -->
<refentry>
 <refnamediv>
  <refname>
   ..//drivers/usb/gadget/function/f_ecm.c
  </refname>
  <refpurpose>
   Document generation inconsistency
  </refpurpose>
 </refnamediv>
 <refsect1>
  <title>
   Oops
  </title>
  <warning>
   <para>
    The template for this document tried to insert
    the structured comment from the file
    <filename>..//drivers/usb/gadget/function/f_ecm.c</filename> at this point,
    but none was found.
    This dummy section is inserted to allow
    generation to continue.
   </para>
  </warning>
 </refsect1>
</refentry>
<!-- drivers/usb/gadget/function/f_subset.c -->
<refentry>
 <refnamediv>
  <refname>
   ..//drivers/usb/gadget/function/f_subset.c
  </refname>
  <refpurpose>
   Document generation inconsistency
  </refpurpose>
 </refnamediv>
 <refsect1>
  <title>
   Oops
  </title>
  <warning>
   <para>
    The template for this document tried to insert
    the structured comment from the file
    <filename>..//drivers/usb/gadget/function/f_subset.c</filename> at this point,
    but none was found.
    This dummy section is inserted to allow
    generation to continue.
   </para>
  </warning>
 </refsect1>
</refentry>
<!-- drivers/usb/gadget/function/f_obex.c -->
<refentry>
 <refnamediv>
  <refname>
   ..//drivers/usb/gadget/function/f_obex.c
  </refname>
  <refpurpose>
   Document generation inconsistency
  </refpurpose>
 </refnamediv>
 <refsect1>
  <title>
   Oops
  </title>
  <warning>
   <para>
    The template for this document tried to insert
    the structured comment from the file
    <filename>..//drivers/usb/gadget/function/f_obex.c</filename> at this point,
    but none was found.
    This dummy section is inserted to allow
    generation to continue.
   </para>
  </warning>
 </refsect1>
</refentry>
<!-- drivers/usb/gadget/function/f_serial.c -->
<refentry>
 <refnamediv>
  <refname>
   ..//drivers/usb/gadget/function/f_serial.c
  </refname>
  <refpurpose>
   Document generation inconsistency
  </refpurpose>
 </refnamediv>
 <refsect1>
  <title>
   Oops
  </title>
  <warning>
   <para>
    The template for this document tried to insert
    the structured comment from the file
    <filename>..//drivers/usb/gadget/function/f_serial.c</filename> at this point,
    but none was found.
    This dummy section is inserted to allow
    generation to continue.
   </para>
  </warning>
 </refsect1>
</refentry>

</sect1>


</chapter>

<chapter id="controllers"><title>Peripheral Controller Drivers</title>

<para>The first hardware supporting this API was the NetChip 2280
controller, which supports USB 2.0 high speed and is based on PCI.
This is the <filename>net2280</filename> driver module.
The driver supports Linux kernel versions 2.4 and 2.6;
contact NetChip Technologies for development boards and product
information.
</para> 

<para>Other hardware working in the "gadget" framework includes:
Intel's PXA 25x and IXP42x series processors
(<filename>pxa2xx_udc</filename>),
Toshiba TC86c001 "Goku-S" (<filename>goku_udc</filename>),
Renesas SH7705/7727 (<filename>sh_udc</filename>),
MediaQ 11xx (<filename>mq11xx_udc</filename>),
Hynix HMS30C7202 (<filename>h7202_udc</filename>),
National 9303/4 (<filename>n9604_udc</filename>),
Texas Instruments OMAP (<filename>omap_udc</filename>),
Sharp LH7A40x (<filename>lh7a40x_udc</filename>),
and more.
Most of those are full speed controllers.
</para>

<para>At this writing, there are people at work on drivers in
this framework for several other USB device controllers,
with plans to make many of them be widely available.
</para>

<!-- !Edrivers/usb/gadget/net2280.c -->

<para>A partial USB simulator,
the <filename>dummy_hcd</filename> driver, is available.
It can act like a net2280, a pxa25x, or an sa11x0 in terms
of available endpoints and device speeds; and it simulates
control, bulk, and to some extent interrupt transfers.
That lets you develop some parts of a gadget driver on a normal PC,
without any special hardware, and perhaps with the assistance
of tools such as GDB running with User Mode Linux.
At least one person has expressed interest in adapting that
approach, hooking it up to a simulator for a microcontroller.
Such simulators can help debug subsystems where the runtime hardware
is unfriendly to software development, or is not yet available.
</para>

<para>Support for other controllers is expected to be developed
and contributed
over time, as this driver framework evolves.
</para>

</chapter>

<chapter id="gadget"><title>Gadget Drivers</title>

<para>In addition to <emphasis>Gadget Zero</emphasis>
(used primarily for testing and development with drivers
for usb controller hardware), other gadget drivers exist.
</para>

<para>There's an <emphasis>ethernet</emphasis> gadget
driver, which implements one of the most useful
<emphasis>Communications Device Class</emphasis> (CDC) models.  
One of the standards for cable modem interoperability even
specifies the use of this ethernet model as one of two
mandatory options.
Gadgets using this code look to a USB host as if they're
an Ethernet adapter.
It provides access to a network where the gadget's CPU is one host,
which could easily be bridging, routing, or firewalling
access to other networks.
Since some hardware can't fully implement the CDC Ethernet
requirements, this driver also implements a "good parts only"
subset of CDC Ethernet.
(That subset doesn't advertise itself as CDC Ethernet,
to avoid creating problems.)
</para>

<para>Support for Microsoft's <emphasis>RNDIS</emphasis>
protocol has been contributed by Pengutronix and Auerswald GmbH.
This is like CDC Ethernet, but it runs on more slightly USB hardware
(but less than the CDC subset).
However, its main claim to fame is being able to connect directly to
recent versions of Windows, using drivers that Microsoft bundles
and supports, making it much simpler to network with Windows.
</para>

<para>There is also support for user mode gadget drivers,
using <emphasis>gadgetfs</emphasis>.
This provides a <emphasis>User Mode API</emphasis> that presents
each endpoint as a single file descriptor.  I/O is done using
normal <emphasis>read()</emphasis> and <emphasis>read()</emphasis> calls.
Familiar tools like GDB and pthreads can be used to
develop and debug user mode drivers, so that once a robust
controller driver is available many applications for it
won't require new kernel mode software.
Linux 2.6 <emphasis>Async I/O (AIO)</emphasis>
support is available, so that user mode software
can stream data with only slightly more overhead
than a kernel driver.
</para>

<para>There's a USB Mass Storage class driver, which provides
a different solution for interoperability with systems such
as MS-Windows and MacOS.
That <emphasis>Mass Storage</emphasis> driver uses a
file or block device as backing store for a drive,
like the <filename>loop</filename> driver.
The USB host uses the BBB, CB, or CBI versions of the mass
storage class specification, using transparent SCSI commands
to access the data from the backing store.
</para>

<para>There's a "serial line" driver, useful for TTY style
operation over USB.
The latest version of that driver supports CDC ACM style
operation, like a USB modem, and so on most hardware it can
interoperate easily with MS-Windows.
One interesting use of that driver is in boot firmware (like a BIOS),
which can sometimes use that model with very small systems without
real serial lines.
</para>

<para>Support for other kinds of gadget is expected to
be developed and contributed
over time, as this driver framework evolves.
</para>

</chapter>

<chapter id="otg"><title>USB On-The-GO (OTG)</title>

<para>USB OTG support on Linux 2.6 was initially developed
by Texas Instruments for
<ulink url="http://www.omap.com">OMAP</ulink> 16xx and 17xx
series processors.
Other OTG systems should work in similar ways, but the
hardware level details could be very different.
</para> 

<para>Systems need specialized hardware support to implement OTG,
notably including a special <emphasis>Mini-AB</emphasis> jack
and associated transceiver to support <emphasis>Dual-Role</emphasis>
operation:
they can act either as a host, using the standard
Linux-USB host side driver stack,
or as a peripheral, using this "gadget" framework.
To do that, the system software relies on small additions
to those programming interfaces,
and on a new internal component (here called an "OTG Controller")
affecting which driver stack connects to the OTG port.
In each role, the system can re-use the existing pool of
hardware-neutral drivers, layered on top of the controller
driver interfaces (<emphasis>usb_bus</emphasis> or
<emphasis>usb_gadget</emphasis>).
Such drivers need at most minor changes, and most of the calls
added to support OTG can also benefit non-OTG products.
</para>

<itemizedlist>
    <listitem><para>Gadget drivers test the <emphasis>is_otg</emphasis>
	flag, and use it to determine whether or not to include
	an OTG descriptor in each of their configurations.
	</para></listitem>
    <listitem><para>Gadget drivers may need changes to support the
	two new OTG protocols, exposed in new gadget attributes
	such as <emphasis>b_hnp_enable</emphasis> flag.
	HNP support should be reported through a user interface
	(two LEDs could suffice), and is triggered in some cases
	when the host suspends the peripheral.
	SRP support can be user-initiated just like remote wakeup,
	probably by pressing the same button.
	</para></listitem>
    <listitem><para>On the host side, USB device drivers need
	to be taught to trigger HNP at appropriate moments, using
	<function>usb_suspend_device()</function>.
	That also conserves battery power, which is useful even
	for non-OTG configurations.
	</para></listitem>
    <listitem><para>Also on the host side, a driver must support the
	OTG "Targeted Peripheral List".  That's just a whitelist,
	used to reject peripherals not supported with a given
	Linux OTG host.
	<emphasis>This whitelist is product-specific;
	each product must modify <filename>otg_whitelist.h</filename>
	to match its interoperability specification.
	</emphasis>
	</para>
	<para>Non-OTG Linux hosts, like PCs and workstations,
	normally have some solution for adding drivers, so that
	peripherals that aren't recognized can eventually be supported.
	That approach is unreasonable for consumer products that may
	never have their firmware upgraded, and where it's usually
	unrealistic to expect traditional PC/workstation/server kinds
	of support model to work.
	For example, it's often impractical to change device firmware
	once the product has been distributed, so driver bugs can't
	normally be fixed if they're found after shipment.
	</para></listitem>
</itemizedlist>

<para>
Additional changes are needed below those hardware-neutral
<emphasis>usb_bus</emphasis> and <emphasis>usb_gadget</emphasis>
driver interfaces; those aren't discussed here in any detail.
Those affect the hardware-specific code for each USB Host or Peripheral
controller, and how the HCD initializes (since OTG can be active only
on a single port).
They also involve what may be called an <emphasis>OTG Controller
Driver</emphasis>, managing the OTG transceiver and the OTG state
machine logic as well as much of the root hub behavior for the
OTG port.
The OTG controller driver needs to activate and deactivate USB
controllers depending on the relevant device role.
Some related changes were needed inside usbcore, so that it
can identify OTG-capable devices and respond appropriately
to HNP or SRP protocols.
</para> 

</chapter>

</book>
<!--
	vim:syntax=sgml:sw=4
-->
