<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>Chapter 3. Handling IRQs</title><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot"><link rel="home" href="index.html" title="Writing an MUSB Glue Layer"><link rel="up" href="index.html" title="Writing an MUSB Glue Layer"><link rel="prev" href="linux-musb-basics.html" title="Chapter 2. Linux MUSB Basics"><link rel="next" href="device-platform-data.html" title="Chapter 4. Device Platform Data"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Chapter 3. Handling IRQs</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="linux-musb-basics.html">Prev</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="device-platform-data.html">Next</a></td></tr></table><hr></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="handling-irqs"></a>Chapter 3. Handling IRQs</h1></div></div></div><p>
      Additionally to the MUSB controller hardware basic setup and
      registration, the glue layer is also responsible for handling the
      IRQs:
    </p><pre class="programlisting">
static irqreturn_t jz4740_musb_interrupt(int irq, void *__hci)
{
	unsigned long   flags;
	irqreturn_t     retval = IRQ_NONE;
	struct musb     *musb = __hci;

	spin_lock_irqsave(&amp;musb-&gt;lock, flags);

	musb-&gt;int_usb = musb_readb(musb-&gt;mregs, MUSB_INTRUSB);
	musb-&gt;int_tx = musb_readw(musb-&gt;mregs, MUSB_INTRTX);
	musb-&gt;int_rx = musb_readw(musb-&gt;mregs, MUSB_INTRRX);

	/*
	 * The controller is gadget only, the state of the host mode IRQ bits is
	 * undefined. Mask them to make sure that the musb driver core will
	 * never see them set
	 */
	musb-&gt;int_usb &amp;= MUSB_INTR_SUSPEND | MUSB_INTR_RESUME |
	    MUSB_INTR_RESET | MUSB_INTR_SOF;

	if (musb-&gt;int_usb || musb-&gt;int_tx || musb-&gt;int_rx)
		retval = musb_interrupt(musb);

	spin_unlock_irqrestore(&amp;musb-&gt;lock, flags);

	return retval;
}
    </pre><p>
      Here the glue layer mostly has to read the relevant hardware
      registers and pass their values on to the controller driver which
      will handle the actual event that triggered the IRQ.
    </p><p>
      The interrupt handler critical section is protected by the
      spin_lock_irqsave() and counterpart spin_unlock_irqrestore()
      functions (line 7 and 24 respectively), which prevent the
      interrupt handler code to be run by two different threads at the
      same time.
    </p><p>
      Then the relevant interrupt registers are read (line 9 to 11):
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          MUSB_INTRUSB: indicates which USB interrupts are currently
          active,
        </p></li><li class="listitem"><p>
          MUSB_INTRTX: indicates which of the interrupts for TX
          endpoints are currently active,
        </p></li><li class="listitem"><p>
          MUSB_INTRRX: indicates which of the interrupts for TX
          endpoints are currently active.
        </p></li></ul></div><p>
      Note that musb_readb() is used to read 8-bit registers at most,
      while musb_readw() allows us to read at most 16-bit registers.
      There are other functions that can be used depending on the size
      of your device registers. See musb_io.h for more information.
    </p><p>
      Instruction on line 18 is another quirk specific to the JZ4740
      USB device controller, which will be discussed later in <a class="link" href="device-quirks.html" title="Chapter 5. Device Quirks">Chapter 5</a>.
    </p><p>
      The glue layer still needs to register the IRQ handler though.
      Remember the instruction on line 14 of the init function:
    </p><pre class="programlisting">
static int jz4740_musb_init(struct musb *musb)
{
	musb-&gt;isr = jz4740_musb_interrupt;

	return 0;
}
    </pre><p>
      This instruction sets a pointer to the glue layer IRQ handler
      function, in order for the controller hardware to call the handler
      back when an IRQ comes from the controller hardware. The interrupt
      handler is now implemented and registered.
    </p></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="linux-musb-basics.html">Prev</a> </td><td width="20%" align="center"> </td><td width="40%" align="right"> <a accesskey="n" href="device-platform-data.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Chapter 2. Linux MUSB Basics </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> Chapter 4. Device Platform Data</td></tr></table></div></body></html>
