<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>Chapter 5. Device Quirks</title><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot"><link rel="home" href="index.html" title="Writing an MUSB Glue Layer"><link rel="up" href="index.html" title="Writing an MUSB Glue Layer"><link rel="prev" href="device-platform-data.html" title="Chapter 4. Device Platform Data"><link rel="next" href="conclusion.html" title="Chapter 6. Conclusion"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Chapter 5. Device Quirks</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="device-platform-data.html">Prev</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="conclusion.html">Next</a></td></tr></table><hr></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="device-quirks"></a>Chapter 5. Device Quirks</h1></div></div></div><p>
      Completing the platform data specific to your device, you may also
      need to write some code in the glue layer to work around some
      device specific limitations. These quirks may be due to some
      hardware bugs, or simply be the result of an incomplete
      implementation of the USB On-the-Go specification.
    </p><p>
      The JZ4740 UDC exhibits such quirks, some of which we will discuss
      here for the sake of insight even though these might not be found
      in the controller hardware you are working on.
    </p><p>
      Let's get back to the init function first:
    </p><pre class="programlisting">
static int jz4740_musb_init(struct musb *musb)
{
	musb-&gt;xceiv = usb_get_phy(USB_PHY_TYPE_USB2);
	if (!musb-&gt;xceiv) {
		pr_err("HS UDC: no transceiver configured\n");
		return -ENODEV;
	}

	/* Silicon does not implement ConfigData register.
	 * Set dyn_fifo to avoid reading EP config from hardware.
	 */
	musb-&gt;dyn_fifo = true;

	musb-&gt;isr = jz4740_musb_interrupt;

	return 0;
}
    </pre><p>
      Instruction on line 12 helps the MUSB controller driver to work
      around the fact that the controller hardware is missing registers
      that are used for USB endpoints configuration.
    </p><p>
      Without these registers, the controller driver is unable to read
      the endpoints configuration from the hardware, so we use line 12
      instruction to bypass reading the configuration from silicon, and
      rely on a hard-coded table that describes the endpoints
      configuration instead:
    </p><pre class="programlisting">
static struct musb_fifo_cfg jz4740_musb_fifo_cfg[] = {
{ .hw_ep_num = 1, .style = FIFO_TX, .maxpacket = 512, },
{ .hw_ep_num = 1, .style = FIFO_RX, .maxpacket = 512, },
{ .hw_ep_num = 2, .style = FIFO_TX, .maxpacket = 64, },
};
    </pre><p>
      Looking at the configuration table above, we see that each
      endpoints is described by three fields: hw_ep_num is the endpoint
      number, style is its direction (either FIFO_TX for the controller
      driver to send packets in the controller hardware, or FIFO_RX to
      receive packets from hardware), and maxpacket defines the maximum
      size of each data packet that can be transmitted over that
      endpoint. Reading from the table, the controller driver knows that
      endpoint 1 can be used to send and receive USB data packets of 512
      bytes at once (this is in fact a bulk in/out endpoint), and
      endpoint 2 can be used to send data packets of 64 bytes at once
      (this is in fact an interrupt endpoint).
    </p><p>
      Note that there is no information about endpoint 0 here: that one
      is implemented by default in every silicon design, with a
      predefined configuration according to the USB specification. For
      more examples of endpoint configuration tables, see musb_core.c.
    </p><p>
      Let's now get back to the interrupt handler function:
    </p><pre class="programlisting">
static irqreturn_t jz4740_musb_interrupt(int irq, void *__hci)
{
	unsigned long   flags;
	irqreturn_t     retval = IRQ_NONE;
	struct musb     *musb = __hci;

	spin_lock_irqsave(&amp;musb-&gt;lock, flags);

	musb-&gt;int_usb = musb_readb(musb-&gt;mregs, MUSB_INTRUSB);
	musb-&gt;int_tx = musb_readw(musb-&gt;mregs, MUSB_INTRTX);
	musb-&gt;int_rx = musb_readw(musb-&gt;mregs, MUSB_INTRRX);

	/*
	 * The controller is gadget only, the state of the host mode IRQ bits is
	 * undefined. Mask them to make sure that the musb driver core will
	 * never see them set
	 */
	musb-&gt;int_usb &amp;= MUSB_INTR_SUSPEND | MUSB_INTR_RESUME |
	    MUSB_INTR_RESET | MUSB_INTR_SOF;

	if (musb-&gt;int_usb || musb-&gt;int_tx || musb-&gt;int_rx)
		retval = musb_interrupt(musb);

	spin_unlock_irqrestore(&amp;musb-&gt;lock, flags);

	return retval;
}
    </pre><p>
      Instruction on line 18 above is a way for the controller driver to
      work around the fact that some interrupt bits used for USB host
      mode operation are missing in the MUSB_INTRUSB register, thus left
      in an undefined hardware state, since this MUSB controller
      hardware is used in peripheral mode only. As a consequence, the
      glue layer masks these missing bits out to avoid parasite
      interrupts by doing a logical AND operation between the value read
      from MUSB_INTRUSB and the bits that are actually implemented in
      the register.
    </p><p>
      These are only a couple of the quirks found in the JZ4740 USB
      device controller. Some others were directly addressed in the MUSB
      core since the fixes were generic enough to provide a better
      handling of the issues for others controller hardware eventually.
    </p></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="device-platform-data.html">Prev</a> </td><td width="20%" align="center"> </td><td width="40%" align="right"> <a accesskey="n" href="conclusion.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Chapter 4. Device Platform Data </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> Chapter 6. Conclusion</td></tr></table></div></body></html>
