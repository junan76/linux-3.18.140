<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN"
	"http://www.oasis-open.org/docbook/xml/4.1.2/docbookx.dtd" []>

<book id="Linux-USB-API">
 <bookinfo>
  <title>The Linux-USB Host Side API</title>
  
  <legalnotice>
   <para>
     This documentation is free software; you can redistribute
     it and/or modify it under the terms of the GNU General Public
     License as published by the Free Software Foundation; either
     version 2 of the License, or (at your option) any later
     version.
   </para>
      
   <para>
     This program is distributed in the hope that it will be
     useful, but WITHOUT ANY WARRANTY; without even the implied
     warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
     See the GNU General Public License for more details.
   </para>
      
   <para>
     You should have received a copy of the GNU General Public
     License along with this program; if not, write to the Free
     Software Foundation, Inc., 59 Temple Place, Suite 330, Boston,
     MA 02111-1307 USA
   </para>
      
   <para>
     For more details see the file COPYING in the source
     distribution of Linux.
   </para>
  </legalnotice>
 </bookinfo>

<toc></toc>

<chapter id="intro">
    <title>Introduction to USB on Linux</title>

    <para>A Universal Serial Bus (USB) is used to connect a host,
    such as a PC or workstation, to a number of peripheral
    devices.  USB uses a tree structure, with the host as the
    root (the system's master), hubs as interior nodes, and
    peripherals as leaves (and slaves).
    Modern PCs support several such trees of USB devices, usually
    one USB 2.0 tree (480 Mbit/sec each) with
    a few USB 1.1 trees (12 Mbit/sec each) that are used when you
    connect a USB 1.1 device directly to the machine's "root hub".
    </para>

    <para>That master/slave asymmetry was designed-in for a number of
    reasons, one being ease of use.  It is not physically possible to
    assemble (legal) USB cables incorrectly:  all upstream "to the host"
    connectors are the rectangular type (matching the sockets on
    root hubs), and all downstream connectors are the squarish type
    (or they are built into the peripheral).
    Also, the host software doesn't need to deal with distributed
    auto-configuration since the pre-designated master node manages all that.
    And finally, at the electrical level, bus protocol overhead is reduced by
    eliminating arbitration and moving scheduling into the host software.
    </para>

    <para>USB 1.0 was announced in January 1996 and was revised
    as USB 1.1 (with improvements in hub specification and
    support for interrupt-out transfers) in September 1998.
    USB 2.0 was released in April 2000, adding high-speed
    transfers and transaction-translating hubs (used for USB 1.1
    and 1.0 backward compatibility).
    </para>

    <para>Kernel developers added USB support to Linux early in the 2.2 kernel
    series, shortly before 2.3 development forked.  Updates from 2.3 were
    regularly folded back into 2.2 releases, which improved reliability and
    brought <filename>/sbin/hotplug</filename> support as well more drivers.
    Such improvements were continued in the 2.5 kernel series, where they added
    USB 2.0 support, improved performance, and made the host controller drivers
    (HCDs) more consistent.  They also simplified the API (to make bugs less
    likely) and added internal "kerneldoc" documentation.
    </para>

    <para>Linux can run inside USB devices as well as on
    the hosts that control the devices.
    But USB device drivers running inside those peripherals
    don't do the same things as the ones running inside hosts,
    so they've been given a different name:
    <emphasis>gadget drivers</emphasis>.
    This document does not cover gadget drivers.
    </para>

    </chapter>

<chapter id="host">
    <title>USB Host-Side API Model</title>

    <para>Host-side drivers for USB devices talk to the "usbcore" APIs.
    There are two.  One is intended for
    <emphasis>general-purpose</emphasis> drivers (exposed through
    driver frameworks), and the other is for drivers that are
    <emphasis>part of the core</emphasis>.
    Such core drivers include the <emphasis>hub</emphasis> driver
    (which manages trees of USB devices) and several different kinds
    of <emphasis>host controller drivers</emphasis>,
    which control individual busses.
    </para>

    <para>The device model seen by USB drivers is relatively complex.
    </para>
     
    <itemizedlist>

	<listitem><para>USB supports four kinds of data transfers
	(control, bulk, interrupt, and isochronous).  Two of them (control
	and bulk) use bandwidth as it's available,
	while the other two (interrupt and isochronous)
	are scheduled to provide guaranteed bandwidth.
	</para></listitem>

	<listitem><para>The device description model includes one or more
	"configurations" per device, only one of which is active at a time.
	Devices that are capable of high-speed operation must also support
	full-speed configurations, along with a way to ask about the
	"other speed" configurations which might be used.
	</para></listitem>

	<listitem><para>Configurations have one or more "interfaces", each
	of which may have "alternate settings".  Interfaces may be
	standardized by USB "Class" specifications, or may be specific to
	a vendor or device.</para>

	<para>USB device drivers actually bind to interfaces, not devices.
	Think of them as "interface drivers", though you
	may not see many devices where the distinction is important.
	<emphasis>Most USB devices are simple, with only one configuration,
	one interface, and one alternate setting.</emphasis>
	</para></listitem>

	<listitem><para>Interfaces have one or more "endpoints", each of
	which supports one type and direction of data transfer such as
	"bulk out" or "interrupt in".  The entire configuration may have
	up to sixteen endpoints in each direction, allocated as needed
	among all the interfaces.
	</para></listitem>

	<listitem><para>Data transfer on USB is packetized; each endpoint
	has a maximum packet size.
	Drivers must often be aware of conventions such as flagging the end
	of bulk transfers using "short" (including zero length) packets.
	</para></listitem>

	<listitem><para>The Linux USB API supports synchronous calls for
	control and bulk messages.
	It also supports asynchronous calls for all kinds of data transfer,
	using request structures called "URBs" (USB Request Blocks).
	</para></listitem>

    </itemizedlist>

    <para>Accordingly, the USB Core API exposed to device drivers
    covers quite a lot of territory.  You'll probably need to consult
    the USB 2.0 specification, available online from www.usb.org at
    no cost, as well as class or device specifications.
    </para>

    <para>The only host-side drivers that actually touch hardware
    (reading/writing registers, handling IRQs, and so on) are the HCDs.
    In theory, all HCDs provide the same functionality through the same
    API.  In practice, that's becoming more true on the 2.5 kernels,
    but there are still differences that crop up especially with
    fault handling.  Different controllers don't necessarily report
    the same aspects of failures, and recovery from faults (including
    software-induced ones like unlinking an URB) isn't yet fully
    consistent.
    Device driver authors should make a point of doing disconnect
    testing (while the device is active) with each different host
    controller driver, to make sure drivers don't have bugs of
    their own as well as to make sure they aren't relying on some
    HCD-specific behavior.
    (You will need external USB 1.1 and/or
    USB 2.0 hubs to perform all those tests.)
    </para>

    </chapter>

<chapter id="types"><title>USB-Standard Types</title>

    <para>In <filename>&lt;linux/usb/ch9.h&gt;</filename> you will find
    the USB data types defined in chapter 9 of the USB specification.
    These data types are used throughout USB, and in APIs including
    this host side API, gadget APIs, and usbfs.
    </para>

<!-- include/linux/usb/ch9.h -->
<refentry id="API-usb-speed-string">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>usb_speed_string</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>usb_speed_string</refname>
 <refpurpose>
  Returns human readable-name of the speed.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>const char * <function>usb_speed_string </function></funcdef>
   <paramdef>enum usb_device_speed <parameter>speed</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>speed</parameter></term>
   <listitem>
    <para>
     The speed to return human-readable name for.  If it's not
     any of the speeds defined in usb_device_speed enum, string for
     USB_SPEED_UNKNOWN will be returned.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-usb-state-string">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>usb_state_string</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>usb_state_string</refname>
 <refpurpose>
     Returns human readable name for the state.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>const char * <function>usb_state_string </function></funcdef>
   <paramdef>enum usb_device_state <parameter>state</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>state</parameter></term>
   <listitem>
    <para>
     The state to return a human-readable name for. If it's not
     any of the states devices in usb_device_state_string enum,
     the string UNKNOWN will be returned.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>


    </chapter>

<chapter id="hostside"><title>Host-Side Data Types and Macros</title>

    <para>The host side API exposes several layers to drivers, some of
    which are more necessary than others.
    These support lifecycle models for host side drivers
    and devices, and support passing buffers through usbcore to
    some HCD that performs the I/O for the device driver.
    </para>


<!-- include/linux/usb.h -->
<refentry id="API-struct-usb-host-endpoint">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct usb_host_endpoint</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct usb_host_endpoint</refname>
 <refpurpose>
  host-side endpoint descriptor and queue
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct usb_host_endpoint {
  struct usb_endpoint_descriptor desc;
  struct usb_ss_ep_comp_descriptor ss_ep_comp;
  struct list_head urb_list;
  void * hcpriv;
  struct ep_device * ep_dev;
  unsigned char * extra;
  int extralen;
  int enabled;
  int streams;
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>desc</term>
      <listitem><para>
descriptor for this endpoint, wMaxPacketSize in native byteorder
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>ss_ep_comp</term>
      <listitem><para>
SuperSpeed companion descriptor for this endpoint
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>urb_list</term>
      <listitem><para>
urbs queued to this endpoint; maintained by usbcore
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>hcpriv</term>
      <listitem><para>
for use by HCD; typically holds hardware dma queue head (QH)
with one or more transfer descriptors (TDs) per urb
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>ep_dev</term>
      <listitem><para>
ep_device for sysfs info
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>extra</term>
      <listitem><para>
descriptors following this endpoint in the configuration
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>extralen</term>
      <listitem><para>
how many bytes of <quote>extra</quote> are valid
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>enabled</term>
      <listitem><para>
URBs may be submitted to this endpoint
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>streams</term>
      <listitem><para>
number of USB-3 streams allocated on the endpoint
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
<refsect1>
<title>Description</title>
<para>
   USB requests are always queued to a given endpoint, identified by a
   descriptor within an active interface in a given USB configuration.
</para>
</refsect1>
</refentry>

<refentry id="API-struct-usb-interface">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct usb_interface</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct usb_interface</refname>
 <refpurpose>
     what usb device drivers talk to
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct usb_interface {
  struct usb_host_interface * altsetting;
  struct usb_host_interface * cur_altsetting;
  unsigned num_altsetting;
  struct usb_interface_assoc_descriptor * intf_assoc;
  int minor;
  enum usb_interface_condition condition;
  unsigned sysfs_files_created:1;
  unsigned ep_devs_created:1;
  unsigned unregistering:1;
  unsigned needs_remote_wakeup:1;
  unsigned needs_altsetting0:1;
  unsigned needs_binding:1;
  unsigned resetting_device:1;
  struct device dev;
  struct device * usb_dev;
  struct work_struct reset_ws;
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>altsetting</term>
      <listitem><para>
   array of interface structures, one for each alternate
   setting that may be selected.  Each one includes a set of
   endpoint configurations.  They will be in no particular order.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>cur_altsetting</term>
      <listitem><para>
   the current altsetting.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>num_altsetting</term>
      <listitem><para>
   number of altsettings defined.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>intf_assoc</term>
      <listitem><para>
   interface association descriptor
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>minor</term>
      <listitem><para>
   the minor number assigned to this interface, if this
   interface is bound to a driver that uses the USB major number.
   If this interface does not use the USB major, this field should
   be unused.  The driver should set this value in the <function>probe</function>
   function of the driver, after it has been assigned a minor
   number from the USB core by calling <function>usb_register_dev</function>.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>condition</term>
      <listitem><para>
   binding state of the interface: not bound, binding
   (in <function>probe</function>), bound to a driver, or unbinding (in <function>disconnect</function>)
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>sysfs_files_created</term>
      <listitem><para>
   sysfs attributes exist
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>ep_devs_created</term>
      <listitem><para>
   endpoint child pseudo-devices exist
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>unregistering</term>
      <listitem><para>
   flag set when the interface is being unregistered
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>needs_remote_wakeup</term>
      <listitem><para>
   flag set when the driver requires remote-wakeup
   capability during autosuspend.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>needs_altsetting0</term>
      <listitem><para>
   flag set when a set-interface request for altsetting 0
   has been deferred.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>needs_binding</term>
      <listitem><para>
   flag set when the driver should be re-probed or unbound
   following a reset or suspend operation it doesn't support.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>resetting_device</term>
      <listitem><para>
   USB core reset the device, so use alt setting 0 as
   current; needs bandwidth alloc after reset.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>dev</term>
      <listitem><para>
   driver model's view of this device
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>usb_dev</term>
      <listitem><para>
   if an interface is bound to the USB major, this will point
   to the sysfs representation for that device.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>reset_ws</term>
      <listitem><para>
   Used for scheduling resets from atomic context.
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
<refsect1>
<title>Description</title>
<para>
   USB device drivers attach to interfaces on a physical device.  Each
   interface encapsulates a single high level function, such as feeding
   an audio stream to a speaker or reporting a change in a volume control.
   Many USB devices only have one interface.  The protocol used to talk to
   an interface's endpoints can be defined in a usb <quote>class</quote> specification,
   or by a product's vendor.  The (default) control endpoint is part of
   every interface, but is never listed among the interface's descriptors.
   </para><para>

   The driver that is bound to the interface can use standard driver model
   calls such as <function>dev_get_drvdata</function> on the dev member of this structure.
   </para><para>

   Each interface may have alternate settings.  The initial configuration
   of a device sets altsetting 0, but the device driver can change
   that setting using <function>usb_set_interface</function>.  Alternate settings are often
   used to control the use of periodic endpoints, such as by having
   different endpoints use different amounts of reserved USB bandwidth.
   All standards-conformant USB devices that use isochronous endpoints
   will use them in non-default settings.
   </para><para>

   The USB specification says that alternate setting numbers must run from
   0 to one less than the total number of alternate settings.  But some
   devices manage to mess this up, and the structures aren't necessarily
   stored in numerical order anyhow.  Use <function>usb_altnum_to_altsetting</function> to
   look up an alternate setting in the altsetting array based on its number.
</para>
</refsect1>
</refentry>

<refentry id="API-struct-usb-interface-cache">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct usb_interface_cache</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct usb_interface_cache</refname>
 <refpurpose>
     long-term representation of a device interface
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct usb_interface_cache {
  unsigned num_altsetting;
  struct kref ref;
  struct usb_host_interface altsetting[0];
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>num_altsetting</term>
      <listitem><para>
   number of altsettings defined.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>ref</term>
      <listitem><para>
   reference counter.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>altsetting[0]</term>
      <listitem><para>
   variable-length array of interface structures, one for
   each alternate setting that may be selected.  Each one includes a
   set of endpoint configurations.  They will be in no particular order.
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
<refsect1>
<title>Description</title>
<para>
   These structures persist for the lifetime of a usb_device, unlike
   struct usb_interface (which persists only as long as its configuration
   is installed).  The altsetting arrays can be accessed through these
   structures at any time, permitting comparison of configurations and
   providing support for the /proc/bus/usb/devices pseudo-file.
</para>
</refsect1>
</refentry>

<refentry id="API-struct-usb-host-config">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct usb_host_config</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct usb_host_config</refname>
 <refpurpose>
     representation of a device's configuration
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct usb_host_config {
  struct usb_config_descriptor desc;
  char * string;
  struct usb_interface_assoc_descriptor * intf_assoc[USB_MAXIADS];
  struct usb_interface * interface[USB_MAXINTERFACES];
  struct usb_interface_cache * intf_cache[USB_MAXINTERFACES];
  unsigned char * extra;
  int extralen;
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>desc</term>
      <listitem><para>
   the device's configuration descriptor.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>string</term>
      <listitem><para>
   pointer to the cached version of the iConfiguration string, if
   present for this configuration.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>intf_assoc[USB_MAXIADS]</term>
      <listitem><para>
   list of any interface association descriptors in this config
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>interface[USB_MAXINTERFACES]</term>
      <listitem><para>
   array of pointers to usb_interface structures, one for each
   interface in the configuration.  The number of interfaces is stored
   in desc.bNumInterfaces.  These pointers are valid only while the
   the configuration is active.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>intf_cache[USB_MAXINTERFACES]</term>
      <listitem><para>
   array of pointers to usb_interface_cache structures, one
   for each interface in the configuration.  These structures exist
   for the entire life of the device.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>extra</term>
      <listitem><para>
   pointer to buffer containing all extra descriptors associated
   with this configuration (those preceding the first interface
   descriptor).
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>extralen</term>
      <listitem><para>
   length of the extra descriptors buffer.
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
<refsect1>
<title>Description</title>
<para>
   USB devices may have multiple configurations, but only one can be active
   at any time.  Each encapsulates a different operational environment;
   for example, a dual-speed device would have separate configurations for
   full-speed and high-speed operation.  The number of configurations
   available is stored in the device descriptor as bNumConfigurations.
   </para><para>

   A configuration can contain multiple interfaces.  Each corresponds to
   a different function of the USB device, and all are available whenever
   the configuration is active.  The USB standard says that interfaces
   are supposed to be numbered from 0 to desc.bNumInterfaces-1, but a lot
   of devices get this wrong.  In addition, the interface array is not
   guaranteed to be sorted in numerical order.  Use <function>usb_ifnum_to_if</function> to
   look up an interface entry based on its number.
   </para><para>

   Device drivers should not attempt to activate configurations.  The choice
   of which configuration to install is a policy decision based on such
   considerations as available power, functionality provided, and the user's
   desires (expressed through userspace tools).  However, drivers can call
   <function>usb_reset_configuration</function> to reinitialize the current configuration and
   all its interfaces.
</para>
</refsect1>
</refentry>

<refentry id="API-struct-usb-device">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct usb_device</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct usb_device</refname>
 <refpurpose>
     kernel's representation of a USB device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct usb_device {
  int devnum;
  char devpath[16];
  u32 route;
  enum usb_device_state state;
  enum usb_device_speed speed;
  struct usb_tt * tt;
  int ttport;
  unsigned int toggle[2];
  struct usb_device * parent;
  struct usb_bus * bus;
  struct usb_host_endpoint ep0;
  struct device dev;
  struct usb_device_descriptor descriptor;
  struct usb_host_bos * bos;
  struct usb_host_config * config;
  struct usb_host_config * actconfig;
  struct usb_host_endpoint * ep_in[16];
  struct usb_host_endpoint * ep_out[16];
  char ** rawdescriptors;
  unsigned short bus_mA;
  u8 portnum;
  u8 level;
  unsigned can_submit:1;
  unsigned persist_enabled:1;
  unsigned have_langid:1;
  unsigned authorized:1;
  unsigned authenticated:1;
  unsigned wusb:1;
  unsigned lpm_capable:1;
  unsigned usb2_hw_lpm_capable:1;
  unsigned usb2_hw_lpm_besl_capable:1;
  unsigned usb2_hw_lpm_enabled:1;
  unsigned usb2_hw_lpm_allowed:1;
  unsigned usb3_lpm_enabled:1;
  int string_langid;
  char * product;
  char * manufacturer;
  char * serial;
  struct list_head filelist;
  int maxchild;
  u32 quirks;
  atomic_t urbnum;
  unsigned long active_duration;
#ifdef CONFIG_PM
  unsigned long connect_time;
  unsigned do_remote_wakeup:1;
  unsigned reset_resume:1;
  unsigned port_is_suspended:1;
#endif
  struct wusb_dev * wusb_dev;
  int slot_id;
  enum usb_device_removable removable;
  struct usb2_lpm_parameters l1_params;
  struct usb3_lpm_parameters u1_params;
  struct usb3_lpm_parameters u2_params;
  unsigned lpm_disable_count;
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>devnum</term>
      <listitem><para>
   device number; address on a USB bus
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>devpath[16]</term>
      <listitem><para>
   device ID string for use in messages (e.g., /port/...)
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>route</term>
      <listitem><para>
   tree topology hex string for use with xHCI
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>state</term>
      <listitem><para>
   device state: configured, not attached, etc.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>speed</term>
      <listitem><para>
   device speed: high/full/low (or error)
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>tt</term>
      <listitem><para>
   Transaction Translator info; used with low/full speed dev, highspeed hub
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>ttport</term>
      <listitem><para>
   device port on that tt hub
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>toggle[2]</term>
      <listitem><para>
   one bit for each endpoint, with ([0] = IN, [1] = OUT) endpoints
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>parent</term>
      <listitem><para>
   our hub, unless we're the root
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>bus</term>
      <listitem><para>
   bus we're part of
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>ep0</term>
      <listitem><para>
   endpoint 0 data (default control pipe)
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>dev</term>
      <listitem><para>
   generic device interface
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>descriptor</term>
      <listitem><para>
   USB device descriptor
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>bos</term>
      <listitem><para>
   USB device BOS descriptor set
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>config</term>
      <listitem><para>
   all of the device's configs
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>actconfig</term>
      <listitem><para>
   the active configuration
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>ep_in[16]</term>
      <listitem><para>
   array of IN endpoints
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>ep_out[16]</term>
      <listitem><para>
   array of OUT endpoints
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>rawdescriptors</term>
      <listitem><para>
   raw descriptors for each config
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>bus_mA</term>
      <listitem><para>
   Current available from the bus
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>portnum</term>
      <listitem><para>
   parent port number (origin 1)
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>level</term>
      <listitem><para>
   number of USB hub ancestors
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>can_submit</term>
      <listitem><para>
   URBs may be submitted
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>persist_enabled</term>
      <listitem><para>
   USB_PERSIST enabled for this device
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>have_langid</term>
      <listitem><para>
   whether string_langid is valid
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>authorized</term>
      <listitem><para>
   policy has said we can use it;
   (user space) policy determines if we authorize this device to be
   used or not. By default, wired USB devices are authorized.
   WUSB devices are not, until we authorize them from user space.
   FIXME -- complete doc
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>authenticated</term>
      <listitem><para>
   Crypto authentication passed
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>wusb</term>
      <listitem><para>
   device is Wireless USB
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>lpm_capable</term>
      <listitem><para>
   device supports LPM
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>usb2_hw_lpm_capable</term>
      <listitem><para>
   device can perform USB2 hardware LPM
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>usb2_hw_lpm_besl_capable</term>
      <listitem><para>
   device can perform USB2 hardware BESL LPM
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>usb2_hw_lpm_enabled</term>
      <listitem><para>
   USB2 hardware LPM is enabled
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>usb2_hw_lpm_allowed</term>
      <listitem><para>
   Userspace allows USB 2.0 LPM to be enabled
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>usb3_lpm_enabled</term>
      <listitem><para>
   USB3 hardware LPM enabled
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>string_langid</term>
      <listitem><para>
   language ID for strings
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>product</term>
      <listitem><para>
   iProduct string, if present (static)
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>manufacturer</term>
      <listitem><para>
   iManufacturer string, if present (static)
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>serial</term>
      <listitem><para>
   iSerialNumber string, if present (static)
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>filelist</term>
      <listitem><para>
   usbfs files that are open to this device
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>maxchild</term>
      <listitem><para>
   number of ports if hub
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>quirks</term>
      <listitem><para>
   quirks of the whole device
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>urbnum</term>
      <listitem><para>
   number of URBs submitted for the whole device
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>active_duration</term>
      <listitem><para>
   total time device is not suspended
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>connect_time</term>
      <listitem><para>
   time device was first connected
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>do_remote_wakeup</term>
      <listitem><para>
   remote wakeup should be enabled
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>reset_resume</term>
      <listitem><para>
   needs reset instead of resume
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>port_is_suspended</term>
      <listitem><para>
   the upstream port is suspended (L2 or U3)
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>wusb_dev</term>
      <listitem><para>
   if this is a Wireless USB device, link to the WUSB
   specific data for the device.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>slot_id</term>
      <listitem><para>
   Slot ID assigned by xHCI
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>removable</term>
      <listitem><para>
   Device can be physically removed from this port
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>l1_params</term>
      <listitem><para>
   best effor service latency for USB2 L1 LPM state, and L1 timeout.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>u1_params</term>
      <listitem><para>
   exit latencies for USB3 U1 LPM state, and hub-initiated timeout.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>u2_params</term>
      <listitem><para>
   exit latencies for USB3 U2 LPM state, and hub-initiated timeout.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>lpm_disable_count</term>
      <listitem><para>
   Ref count used by <function>usb_disable_lpm</function> and <function>usb_enable_lpm</function>
   to keep track of the number of functions that require USB 3.0 Link Power
   Management to be disabled for this usb_device.  This count should only
   be manipulated by those functions, with the bandwidth_mutex is held.
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
<refsect1>
<title>Notes</title>
<para>
   Usbcore drivers should not set usbdev-&gt;state directly.  Instead use
   <function>usb_set_device_state</function>.
</para>
</refsect1>
</refentry>

<refentry id="API-usb-hub-for-each-child">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>usb_hub_for_each_child</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>usb_hub_for_each_child</refname>
 <refpurpose>
     iterate over all child devices on the hub
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef> <function>usb_hub_for_each_child </function></funcdef>
   <paramdef> <parameter>hdev</parameter></paramdef>
   <paramdef> <parameter>port1</parameter></paramdef>
   <paramdef> <parameter>child</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>hdev</parameter></term>
   <listitem>
    <para>
     USB device belonging to the usb hub
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>port1</parameter></term>
   <listitem>
    <para>
     portnum associated with child device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>child</parameter></term>
   <listitem>
    <para>
     child device pointer
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-usb-interface-claimed">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>usb_interface_claimed</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>usb_interface_claimed</refname>
 <refpurpose>
     returns true iff an interface is claimed
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>usb_interface_claimed </function></funcdef>
   <paramdef>struct usb_interface * <parameter>iface</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>iface</parameter></term>
   <listitem>
    <para>
     the interface being checked
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Return</title>
<para>
   <constant>true</constant> (nonzero) iff the interface is claimed, else <constant>false</constant>
   (zero).
</para>
</refsect1>
<refsect1>
<title>Note</title>
<para>
   Callers must own the driver model's usb bus readlock.  So driver
   <function>probe</function> entries don't need extra locking, but other call contexts
   may need to explicitly claim that lock.
</para>
</refsect1>
</refentry>

<refentry id="API-usb-make-path">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>usb_make_path</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>usb_make_path</refname>
 <refpurpose>
     returns stable device path in the usb tree
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>usb_make_path </function></funcdef>
   <paramdef>struct usb_device * <parameter>dev</parameter></paramdef>
   <paramdef>char * <parameter>buf</parameter></paramdef>
   <paramdef>size_t <parameter>size</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     the device whose path is being constructed
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>buf</parameter></term>
   <listitem>
    <para>
     where to put the string
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>size</parameter></term>
   <listitem>
    <para>
     how big is <quote>buf</quote>?
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Return</title>
<para>
   Length of the string (&gt; 0) or negative if size was too small.
</para>
</refsect1>
<refsect1>
<title>Note</title>
<para>
   This identifier is intended to be <quote>stable</quote>, reflecting physical paths in
   hardware such as physical bus addresses for host controllers or ports on
   USB hubs.  That makes it stay the same until systems are physically
   reconfigured, by re-cabling a tree of USB devices or by moving USB host
   controllers.  Adding and removing devices, including virtual root hubs
   in host controller driver modules, does not change these path identifiers;
   neither does rebooting or re-enumerating.  These are more useful identifiers
   than changeable (<quote>unstable</quote>) ones like bus numbers or device addresses.
   </para><para>

   With a partial exception for devices connected to USB 2.0 root hubs, these
   identifiers are also predictable.  So long as the device tree isn't changed,
   plugging any USB device into a given hub port always gives it the same path.
   Because of the use of <quote>companion</quote> controllers, devices connected to ports on
   USB 2.0 root hubs (EHCI host controllers) will get one path ID if they are
   high speed, and a different one if they are full or low speed.
</para>
</refsect1>
</refentry>

<refentry id="API-USB-DEVICE">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>USB_DEVICE</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>USB_DEVICE</refname>
 <refpurpose>
     macro used to describe a specific usb device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef> <function>USB_DEVICE </function></funcdef>
   <paramdef> <parameter>vend</parameter></paramdef>
   <paramdef> <parameter>prod</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>vend</parameter></term>
   <listitem>
    <para>
     the 16 bit USB Vendor ID
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>prod</parameter></term>
   <listitem>
    <para>
     the 16 bit USB Product ID
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This macro is used to create a struct usb_device_id that matches a
   specific device.
</para>
</refsect1>
</refentry>

<refentry id="API-USB-DEVICE-VER">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>USB_DEVICE_VER</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>USB_DEVICE_VER</refname>
 <refpurpose>
     describe a specific usb device with a version range
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef> <function>USB_DEVICE_VER </function></funcdef>
   <paramdef> <parameter>vend</parameter></paramdef>
   <paramdef> <parameter>prod</parameter></paramdef>
   <paramdef> <parameter>lo</parameter></paramdef>
   <paramdef> <parameter>hi</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>vend</parameter></term>
   <listitem>
    <para>
     the 16 bit USB Vendor ID
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>prod</parameter></term>
   <listitem>
    <para>
     the 16 bit USB Product ID
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>lo</parameter></term>
   <listitem>
    <para>
     the bcdDevice_lo value
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>hi</parameter></term>
   <listitem>
    <para>
     the bcdDevice_hi value
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This macro is used to create a struct usb_device_id that matches a
   specific device, with a version range.
</para>
</refsect1>
</refentry>

<refentry id="API-USB-DEVICE-INTERFACE-CLASS">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>USB_DEVICE_INTERFACE_CLASS</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>USB_DEVICE_INTERFACE_CLASS</refname>
 <refpurpose>
     describe a usb device with a specific interface class
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef> <function>USB_DEVICE_INTERFACE_CLASS </function></funcdef>
   <paramdef> <parameter>vend</parameter></paramdef>
   <paramdef> <parameter>prod</parameter></paramdef>
   <paramdef> <parameter>cl</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>vend</parameter></term>
   <listitem>
    <para>
     the 16 bit USB Vendor ID
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>prod</parameter></term>
   <listitem>
    <para>
     the 16 bit USB Product ID
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>cl</parameter></term>
   <listitem>
    <para>
     bInterfaceClass value
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This macro is used to create a struct usb_device_id that matches a
   specific interface class of devices.
</para>
</refsect1>
</refentry>

<refentry id="API-USB-DEVICE-INTERFACE-PROTOCOL">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>USB_DEVICE_INTERFACE_PROTOCOL</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>USB_DEVICE_INTERFACE_PROTOCOL</refname>
 <refpurpose>
     describe a usb device with a specific interface protocol
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef> <function>USB_DEVICE_INTERFACE_PROTOCOL </function></funcdef>
   <paramdef> <parameter>vend</parameter></paramdef>
   <paramdef> <parameter>prod</parameter></paramdef>
   <paramdef> <parameter>pr</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>vend</parameter></term>
   <listitem>
    <para>
     the 16 bit USB Vendor ID
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>prod</parameter></term>
   <listitem>
    <para>
     the 16 bit USB Product ID
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>pr</parameter></term>
   <listitem>
    <para>
     bInterfaceProtocol value
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This macro is used to create a struct usb_device_id that matches a
   specific interface protocol of devices.
</para>
</refsect1>
</refentry>

<refentry id="API-USB-DEVICE-INTERFACE-NUMBER">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>USB_DEVICE_INTERFACE_NUMBER</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>USB_DEVICE_INTERFACE_NUMBER</refname>
 <refpurpose>
     describe a usb device with a specific interface number
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef> <function>USB_DEVICE_INTERFACE_NUMBER </function></funcdef>
   <paramdef> <parameter>vend</parameter></paramdef>
   <paramdef> <parameter>prod</parameter></paramdef>
   <paramdef> <parameter>num</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>vend</parameter></term>
   <listitem>
    <para>
     the 16 bit USB Vendor ID
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>prod</parameter></term>
   <listitem>
    <para>
     the 16 bit USB Product ID
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>num</parameter></term>
   <listitem>
    <para>
     bInterfaceNumber value
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This macro is used to create a struct usb_device_id that matches a
   specific interface number of devices.
</para>
</refsect1>
</refentry>

<refentry id="API-USB-DEVICE-INFO">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>USB_DEVICE_INFO</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>USB_DEVICE_INFO</refname>
 <refpurpose>
     macro used to describe a class of usb devices
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef> <function>USB_DEVICE_INFO </function></funcdef>
   <paramdef> <parameter>cl</parameter></paramdef>
   <paramdef> <parameter>sc</parameter></paramdef>
   <paramdef> <parameter>pr</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>cl</parameter></term>
   <listitem>
    <para>
     bDeviceClass value
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>sc</parameter></term>
   <listitem>
    <para>
     bDeviceSubClass value
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>pr</parameter></term>
   <listitem>
    <para>
     bDeviceProtocol value
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This macro is used to create a struct usb_device_id that matches a
   specific class of devices.
</para>
</refsect1>
</refentry>

<refentry id="API-USB-INTERFACE-INFO">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>USB_INTERFACE_INFO</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>USB_INTERFACE_INFO</refname>
 <refpurpose>
     macro used to describe a class of usb interfaces
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef> <function>USB_INTERFACE_INFO </function></funcdef>
   <paramdef> <parameter>cl</parameter></paramdef>
   <paramdef> <parameter>sc</parameter></paramdef>
   <paramdef> <parameter>pr</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>cl</parameter></term>
   <listitem>
    <para>
     bInterfaceClass value
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>sc</parameter></term>
   <listitem>
    <para>
     bInterfaceSubClass value
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>pr</parameter></term>
   <listitem>
    <para>
     bInterfaceProtocol value
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This macro is used to create a struct usb_device_id that matches a
   specific class of interfaces.
</para>
</refsect1>
</refentry>

<refentry id="API-USB-DEVICE-AND-INTERFACE-INFO">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>USB_DEVICE_AND_INTERFACE_INFO</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>USB_DEVICE_AND_INTERFACE_INFO</refname>
 <refpurpose>
     describe a specific usb device with a class of usb interfaces
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef> <function>USB_DEVICE_AND_INTERFACE_INFO </function></funcdef>
   <paramdef> <parameter>vend</parameter></paramdef>
   <paramdef> <parameter>prod</parameter></paramdef>
   <paramdef> <parameter>cl</parameter></paramdef>
   <paramdef> <parameter>sc</parameter></paramdef>
   <paramdef> <parameter>pr</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>vend</parameter></term>
   <listitem>
    <para>
     the 16 bit USB Vendor ID
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>prod</parameter></term>
   <listitem>
    <para>
     the 16 bit USB Product ID
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>cl</parameter></term>
   <listitem>
    <para>
     bInterfaceClass value
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>sc</parameter></term>
   <listitem>
    <para>
     bInterfaceSubClass value
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>pr</parameter></term>
   <listitem>
    <para>
     bInterfaceProtocol value
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This macro is used to create a struct usb_device_id that matches a
   specific device with a specific class of interfaces.
   </para><para>

   This is especially useful when explicitly matching devices that have
   vendor specific bDeviceClass values, but standards-compliant interfaces.
</para>
</refsect1>
</refentry>

<refentry id="API-USB-VENDOR-AND-INTERFACE-INFO">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>USB_VENDOR_AND_INTERFACE_INFO</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>USB_VENDOR_AND_INTERFACE_INFO</refname>
 <refpurpose>
     describe a specific usb vendor with a class of usb interfaces
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef> <function>USB_VENDOR_AND_INTERFACE_INFO </function></funcdef>
   <paramdef> <parameter>vend</parameter></paramdef>
   <paramdef> <parameter>cl</parameter></paramdef>
   <paramdef> <parameter>sc</parameter></paramdef>
   <paramdef> <parameter>pr</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>vend</parameter></term>
   <listitem>
    <para>
     the 16 bit USB Vendor ID
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>cl</parameter></term>
   <listitem>
    <para>
     bInterfaceClass value
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>sc</parameter></term>
   <listitem>
    <para>
     bInterfaceSubClass value
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>pr</parameter></term>
   <listitem>
    <para>
     bInterfaceProtocol value
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This macro is used to create a struct usb_device_id that matches a
   specific vendor with a specific class of interfaces.
   </para><para>

   This is especially useful when explicitly matching devices that have
   vendor specific bDeviceClass values, but standards-compliant interfaces.
</para>
</refsect1>
</refentry>

<refentry id="API-struct-usbdrv-wrap">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct usbdrv_wrap</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct usbdrv_wrap</refname>
 <refpurpose>
     wrapper for driver-model structure
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct usbdrv_wrap {
  struct device_driver driver;
  int for_devices;
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>driver</term>
      <listitem><para>
   The driver-model core driver structure.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>for_devices</term>
      <listitem><para>
   Non-zero for device drivers, 0 for interface drivers.
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
</refentry>

<refentry id="API-struct-usb-driver">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct usb_driver</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct usb_driver</refname>
 <refpurpose>
     identifies USB interface driver to usbcore
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct usb_driver {
  const char * name;
  int (* probe) (struct usb_interface *intf,const struct usb_device_id *id);
  void (* disconnect) (struct usb_interface *intf);
  int (* unlocked_ioctl) (struct usb_interface *intf, unsigned int code,void *buf);
  int (* suspend) (struct usb_interface *intf, pm_message_t message);
  int (* resume) (struct usb_interface *intf);
  int (* reset_resume) (struct usb_interface *intf);
  int (* pre_reset) (struct usb_interface *intf);
  int (* post_reset) (struct usb_interface *intf);
  const struct usb_device_id * id_table;
  struct usb_dynids dynids;
  struct usbdrv_wrap drvwrap;
  unsigned int no_dynamic_id:1;
  unsigned int supports_autosuspend:1;
  unsigned int disable_hub_initiated_lpm:1;
  unsigned int soft_unbind:1;
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>name</term>
      <listitem><para>
   The driver name should be unique among USB drivers,
   and should normally be the same as the module name.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>probe</term>
      <listitem><para>
   Called to see if the driver is willing to manage a particular
   interface on a device.  If it is, probe returns zero and uses
   <function>usb_set_intfdata</function> to associate driver-specific data with the
   interface.  It may also use <function>usb_set_interface</function> to specify the
   appropriate altsetting.  If unwilling to manage the interface,
   return -ENODEV, if genuine IO errors occurred, an appropriate
   negative errno value.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>disconnect</term>
      <listitem><para>
   Called when the interface is no longer accessible, usually
   because its device has been (or is being) disconnected or the
   driver module is being unloaded.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>unlocked_ioctl</term>
      <listitem><para>
   Used for drivers that want to talk to userspace through
   the <quote>usbfs</quote> filesystem.  This lets devices provide ways to
   expose information to user space regardless of where they
   do (or don't) show up otherwise in the filesystem.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>suspend</term>
      <listitem><para>
   Called when the device is going to be suspended by the
   system either from system sleep or runtime suspend context. The
   return value will be ignored in system sleep context, so do NOT
   try to continue using the device if suspend fails in this case.
   Instead, let the resume or reset-resume routine recover from
   the failure.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>resume</term>
      <listitem><para>
   Called when the device is being resumed by the system.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>reset_resume</term>
      <listitem><para>
   Called when the suspended device has been reset instead
   of being resumed.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>pre_reset</term>
      <listitem><para>
   Called by <function>usb_reset_device</function> when the device is about to be
   reset.  This routine must not return until the driver has no active
   URBs for the device, and no more URBs may be submitted until the
   post_reset method is called.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>post_reset</term>
      <listitem><para>
   Called by <function>usb_reset_device</function> after the device
   has been reset
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>id_table</term>
      <listitem><para>
   USB drivers use ID table to support hotplugging.
   Export this with MODULE_DEVICE_TABLE(usb,...).  This must be set
   or your driver's probe function will never get called.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>dynids</term>
      <listitem><para>
   used internally to hold the list of dynamically added device
   ids for this driver.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>drvwrap</term>
      <listitem><para>
   Driver-model core structure wrapper.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>no_dynamic_id</term>
      <listitem><para>
   if set to 1, the USB core will not allow dynamic ids to be
   added to this driver by preventing the sysfs file from being created.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>supports_autosuspend</term>
      <listitem><para>
   if set to 0, the USB core will not allow autosuspend
   for interfaces bound to this driver.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>disable_hub_initiated_lpm</term>
      <listitem><para>
   if set to 1, the USB core will not allow hubs
   to initiate lower power link state transitions when an idle timeout
   occurs.  Device-initiated USB 3.0 link PM will still be allowed.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>soft_unbind</term>
      <listitem><para>
   if set to 1, the USB core will not kill URBs and disable
   endpoints before calling the driver's disconnect method.
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
<refsect1>
<title>Description</title>
<para>
   USB interface drivers must provide a name, <function>probe</function> and <function>disconnect</function>
   methods, and an id_table.  Other driver fields are optional.
   </para><para>

   The id_table is used in hotplugging.  It holds a set of descriptors,
   and specialized data may be associated with each entry.  That table
   is used by both user and kernel mode hotplugging support.
   </para><para>

   The <function>probe</function> and <function>disconnect</function> methods are called in a context where
   they can sleep, but they should avoid abusing the privilege.  Most
   work to connect to a device should be done when the device is opened,
   and undone at the last close.  The disconnect code needs to address
   concurrency issues with respect to <function>open</function> and <function>close</function> methods, as
   well as forcing all pending I/O requests to complete (by unlinking
   them as necessary, and blocking until the unlinks complete).
</para>
</refsect1>
</refentry>

<refentry id="API-struct-usb-device-driver">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct usb_device_driver</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct usb_device_driver</refname>
 <refpurpose>
     identifies USB device driver to usbcore
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct usb_device_driver {
  const char * name;
  int (* probe) (struct usb_device *udev);
  void (* disconnect) (struct usb_device *udev);
  int (* suspend) (struct usb_device *udev, pm_message_t message);
  int (* resume) (struct usb_device *udev, pm_message_t message);
  struct usbdrv_wrap drvwrap;
  unsigned int supports_autosuspend:1;
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>name</term>
      <listitem><para>
   The driver name should be unique among USB drivers,
   and should normally be the same as the module name.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>probe</term>
      <listitem><para>
   Called to see if the driver is willing to manage a particular
   device.  If it is, probe returns zero and uses <function>dev_set_drvdata</function>
   to associate driver-specific data with the device.  If unwilling
   to manage the device, return a negative errno value.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>disconnect</term>
      <listitem><para>
   Called when the device is no longer accessible, usually
   because it has been (or is being) disconnected or the driver's
   module is being unloaded.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>suspend</term>
      <listitem><para>
   Called when the device is going to be suspended by the system.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>resume</term>
      <listitem><para>
   Called when the device is being resumed by the system.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>drvwrap</term>
      <listitem><para>
   Driver-model core structure wrapper.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>supports_autosuspend</term>
      <listitem><para>
   if set to 0, the USB core will not allow autosuspend
   for devices bound to this driver.
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
<refsect1>
<title>Description</title>
<para>
   USB drivers must provide all the fields listed above except drvwrap.
</para>
</refsect1>
</refentry>

<refentry id="API-struct-usb-class-driver">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct usb_class_driver</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct usb_class_driver</refname>
 <refpurpose>
     identifies a USB driver that wants to use the USB major number
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct usb_class_driver {
  char * name;
  char *(* devnode) (struct device *dev, umode_t *mode);
  const struct file_operations * fops;
  int minor_base;
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>name</term>
      <listitem><para>
   the usb class device name for this driver.  Will show up in sysfs.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>devnode</term>
      <listitem><para>
   Callback to provide a naming hint for a possible
   device node to create.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>fops</term>
      <listitem><para>
   pointer to the struct file_operations of this driver.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>minor_base</term>
      <listitem><para>
   the start of the minor range for this driver.
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
<refsect1>
<title>Description</title>
<para>
   This structure is used for the <function>usb_register_dev</function> and
   <function>usb_unregister_dev</function> functions, to consolidate a number of the
   parameters used for them.
</para>
</refsect1>
</refentry>

<refentry id="API-module-usb-driver">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>module_usb_driver</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>module_usb_driver</refname>
 <refpurpose>
     Helper macro for registering a USB driver
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef> <function>module_usb_driver </function></funcdef>
   <paramdef> <parameter>__usb_driver</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>__usb_driver</parameter></term>
   <listitem>
    <para>
     usb_driver struct
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Helper macro for USB drivers which do not do anything special in module
   init/exit. This eliminates a lot of boilerplate. Each module may only
   use this macro once, and calling it replaces <function>module_init</function> and <function>module_exit</function>
</para>
</refsect1>
</refentry>

<refentry id="API-struct-urb">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct urb</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct urb</refname>
 <refpurpose>
     USB Request Block
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct urb {
  struct list_head urb_list;
  struct list_head anchor_list;
  struct usb_anchor * anchor;
  struct usb_device * dev;
  struct usb_host_endpoint * ep;
  unsigned int pipe;
  unsigned int stream_id;
  int status;
  unsigned int transfer_flags;
  void * transfer_buffer;
  dma_addr_t transfer_dma;
  struct scatterlist * sg;
  int num_mapped_sgs;
  int num_sgs;
  u32 transfer_buffer_length;
  u32 actual_length;
  unsigned char * setup_packet;
  dma_addr_t setup_dma;
  int start_frame;
  int number_of_packets;
  int interval;
  int error_count;
  void * context;
  usb_complete_t complete;
  struct usb_iso_packet_descriptor iso_frame_desc[0];
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>urb_list</term>
      <listitem><para>
   For use by current owner of the URB.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>anchor_list</term>
      <listitem><para>
   membership in the list of an anchor
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>anchor</term>
      <listitem><para>
   to anchor URBs to a common mooring
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>dev</term>
      <listitem><para>
   Identifies the USB device to perform the request.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>ep</term>
      <listitem><para>
   Points to the endpoint's data structure.  Will eventually
   replace <parameter>pipe</parameter>.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>pipe</term>
      <listitem><para>
   Holds endpoint number, direction, type, and more.
   Create these values with the eight macros available;
   usb_{snd,rcv}TYPEpipe(dev,endpoint), where the TYPE is <quote>ctrl</quote>
   (control), <quote>bulk</quote>, <quote>int</quote> (interrupt), or <quote>iso</quote> (isochronous).
   For example <function>usb_sndbulkpipe</function> or <function>usb_rcvintpipe</function>.  Endpoint
   numbers range from zero to fifteen.  Note that <quote>in</quote> endpoint two
   is a different endpoint (and pipe) from <quote>out</quote> endpoint two.
   The current configuration controls the existence, type, and
   maximum packet size of any given endpoint.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>stream_id</term>
      <listitem><para>
   the endpoint's stream ID for bulk streams
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>status</term>
      <listitem><para>
   This is read in non-iso completion functions to get the
   status of the particular request.  ISO requests only use it
   to tell whether the URB was unlinked; detailed status for
   each frame is in the fields of the iso_frame-desc.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>transfer_flags</term>
      <listitem><para>
   A variety of flags may be used to affect how URB
   submission, unlinking, or operation are handled.  Different
   kinds of URB can use different flags.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>transfer_buffer</term>
      <listitem><para>
   This identifies the buffer to (or from) which the I/O
   request will be performed unless URB_NO_TRANSFER_DMA_MAP is set
   (however, do not leave garbage in transfer_buffer even then).
   This buffer must be suitable for DMA; allocate it with
   <function>kmalloc</function> or equivalent.  For transfers to <quote>in</quote> endpoints, contents
   of this buffer will be modified.  This buffer is used for the data
   stage of control transfers.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>transfer_dma</term>
      <listitem><para>
   When transfer_flags includes URB_NO_TRANSFER_DMA_MAP,
   the device driver is saying that it provided this DMA address,
   which the host controller driver should use in preference to the
   transfer_buffer.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>sg</term>
      <listitem><para>
   scatter gather buffer list, the buffer size of each element in
   the list (except the last) must be divisible by the endpoint's
   max packet size if no_sg_constraint isn't set in 'struct usb_bus'
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>num_mapped_sgs</term>
      <listitem><para>
   (internal) number of mapped sg entries
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>num_sgs</term>
      <listitem><para>
   number of entries in the sg list
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>transfer_buffer_length</term>
      <listitem><para>
   How big is transfer_buffer.  The transfer may
   be broken up into chunks according to the current maximum packet
   size for the endpoint, which is a function of the configuration
   and is encoded in the pipe.  When the length is zero, neither
   transfer_buffer nor transfer_dma is used.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>actual_length</term>
      <listitem><para>
   This is read in non-iso completion functions, and
   it tells how many bytes (out of transfer_buffer_length) were
   transferred.  It will normally be the same as requested, unless
   either an error was reported or a short read was performed.
   The URB_SHORT_NOT_OK transfer flag may be used to make such
   short reads be reported as errors.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>setup_packet</term>
      <listitem><para>
   Only used for control transfers, this points to eight bytes
   of setup data.  Control transfers always start by sending this data
   to the device.  Then transfer_buffer is read or written, if needed.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>setup_dma</term>
      <listitem><para>
   DMA pointer for the setup packet.  The caller must not use
   this field; setup_packet must point to a valid buffer.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>start_frame</term>
      <listitem><para>
   Returns the initial frame for isochronous transfers.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>number_of_packets</term>
      <listitem><para>
   Lists the number of ISO transfer buffers.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>interval</term>
      <listitem><para>
   Specifies the polling interval for interrupt or isochronous
   transfers.  The units are frames (milliseconds) for full and low
   speed devices, and microframes (1/8 millisecond) for highspeed
   and SuperSpeed devices.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>error_count</term>
      <listitem><para>
   Returns the number of ISO transfers that reported errors.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>context</term>
      <listitem><para>
   For use in completion functions.  This normally points to
   request-specific driver context.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>complete</term>
      <listitem><para>
   Completion handler. This URB is passed as the parameter to the
   completion function.  The completion function may then do what
   it likes with the URB, including resubmitting or freeing it.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>iso_frame_desc[0]</term>
      <listitem><para>
   Used to provide arrays of ISO transfer buffers and to
   collect the transfer status for each buffer.
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
<refsect1>
<title>Description</title>
<para>
   This structure identifies USB transfer requests.  URBs must be allocated by
   calling <function>usb_alloc_urb</function> and freed with a call to <function>usb_free_urb</function>.
   Initialization may be done using various usb_fill_*<function>_urb</function> functions.  URBs
   are submitted using <function>usb_submit_urb</function>, and pending requests may be canceled
   using <function>usb_unlink_urb</function> or <function>usb_kill_urb</function>.
</para>
</refsect1>
<refsect1>
<title>Data Transfer Buffers</title>
<para>
   </para><para>

   Normally drivers provide I/O buffers allocated with <function>kmalloc</function> or otherwise
   taken from the general page pool.  That is provided by transfer_buffer
   (control requests also use setup_packet), and host controller drivers
   perform a dma mapping (and unmapping) for each buffer transferred.  Those
   mapping operations can be expensive on some platforms (perhaps using a dma
   bounce buffer or talking to an IOMMU),
   although they're cheap on commodity x86 and ppc hardware.
   </para><para>

   Alternatively, drivers may pass the URB_NO_TRANSFER_DMA_MAP transfer flag,
   which tells the host controller driver that no such mapping is needed for
   the transfer_buffer since
   the device driver is DMA-aware.  For example, a device driver might
   allocate a DMA buffer with <function>usb_alloc_coherent</function> or call <function>usb_buffer_map</function>.
   When this transfer flag is provided, host controller drivers will
   attempt to use the dma address found in the transfer_dma
   field rather than determining a dma address themselves.
   </para><para>

   Note that transfer_buffer must still be set if the controller
   does not support DMA (as indicated by bus.uses_dma) and when talking
   to root hub. If you have to trasfer between highmem zone and the device
   on such controller, create a bounce buffer or bail out with an error.
   If transfer_buffer cannot be set (is in highmem) and the controller is DMA
   capable, assign NULL to it, so that usbmon knows not to use the value.
   The setup_packet must always be set, so it cannot be located in highmem.
</para>
</refsect1>
<refsect1>
<title>Initialization</title>
<para>
   </para><para>

   All URBs submitted must initialize the dev, pipe, transfer_flags (may be
   zero), and complete fields.  All URBs must also initialize
   transfer_buffer and transfer_buffer_length.  They may provide the
   URB_SHORT_NOT_OK transfer flag, indicating that short reads are
   to be treated as errors; that flag is invalid for write requests.
   </para><para>

   Bulk URBs may
   use the URB_ZERO_PACKET transfer flag, indicating that bulk OUT transfers
   should always terminate with a short packet, even if it means adding an
   extra zero length packet.
   </para><para>

   Control URBs must provide a valid pointer in the setup_packet field.
   Unlike the transfer_buffer, the setup_packet may not be mapped for DMA
   beforehand.
   </para><para>

   Interrupt URBs must provide an interval, saying how often (in milliseconds
   or, for highspeed devices, 125 microsecond units)
   to poll for transfers.  After the URB has been submitted, the interval
   field reflects how the transfer was actually scheduled.
   The polling interval may be more frequent than requested.
   For example, some controllers have a maximum interval of 32 milliseconds,
   while others support intervals of up to 1024 milliseconds.
   Isochronous URBs also have transfer intervals.  (Note that for isochronous
   endpoints, as well as high speed interrupt endpoints, the encoding of
   the transfer interval in the endpoint descriptor is logarithmic.
   Device drivers must convert that value to linear units themselves.)
   </para><para>

   If an isochronous endpoint queue isn't already running, the host
   controller will schedule a new URB to start as soon as bandwidth
   utilization allows.  If the queue is running then a new URB will be
   scheduled to start in the first transfer slot following the end of the
   preceding URB, if that slot has not already expired.  If the slot has
   expired (which can happen when IRQ delivery is delayed for a long time),
   the scheduling behavior depends on the URB_ISO_ASAP flag.  If the flag
   is clear then the URB will be scheduled to start in the expired slot,
   implying that some of its packets will not be transferred; if the flag
   is set then the URB will be scheduled in the first unexpired slot,
   breaking the queue's synchronization.  Upon URB completion, the
   start_frame field will be set to the (micro)frame number in which the
   transfer was scheduled.  Ranges for frame counter values are HC-specific
   and can go from as low as 256 to as high as 65536 frames.
   </para><para>

   Isochronous URBs have a different data transfer model, in part because
   the quality of service is only <quote>best effort</quote>.  Callers provide specially
   allocated URBs, with number_of_packets worth of iso_frame_desc structures
   at the end.  Each such packet is an individual ISO transfer.  Isochronous
   URBs are normally queued, submitted by drivers to arrange that
   transfers are at least double buffered, and then explicitly resubmitted
   in completion handlers, so
   that data (such as audio or video) streams at as constant a rate as the
   host controller scheduler can support.
</para>
</refsect1>
<refsect1>
<title>Completion Callbacks</title>
<para>
   </para><para>

   The completion callback is made <function>in_interrupt</function>, and one of the first
   things that a completion handler should do is check the status field.
   The status field is provided for all URBs.  It is used to report
   unlinked URBs, and status for all non-ISO transfers.  It should not
   be examined before the URB is returned to the completion handler.
   </para><para>

   The context field is normally used to link URBs back to the relevant
   driver or request state.
   </para><para>

   When the completion callback is invoked for non-isochronous URBs, the
   actual_length field tells how many bytes were transferred.  This field
   is updated even when the URB terminated with an error or was unlinked.
   </para><para>

   ISO transfer status is reported in the status and actual_length fields
   of the iso_frame_desc array, and the number of errors is reported in
   error_count.  Completion callbacks for ISO transfers will normally
   (re)submit URBs to ensure a constant transfer rate.
   </para><para>

   Note that even fields marked <quote>public</quote> should not be touched by the driver
   when the urb is owned by the hcd, that is, since the call to
   <function>usb_submit_urb</function> till the entry into the completion routine.
</para>
</refsect1>
</refentry>

<refentry id="API-usb-fill-control-urb">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>usb_fill_control_urb</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>usb_fill_control_urb</refname>
 <refpurpose>
     initializes a control urb
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>usb_fill_control_urb </function></funcdef>
   <paramdef>struct urb * <parameter>urb</parameter></paramdef>
   <paramdef>struct usb_device * <parameter>dev</parameter></paramdef>
   <paramdef>unsigned int <parameter>pipe</parameter></paramdef>
   <paramdef>unsigned char * <parameter>setup_packet</parameter></paramdef>
   <paramdef>void * <parameter>transfer_buffer</parameter></paramdef>
   <paramdef>int <parameter>buffer_length</parameter></paramdef>
   <paramdef>usb_complete_t <parameter>complete_fn</parameter></paramdef>
   <paramdef>void * <parameter>context</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>urb</parameter></term>
   <listitem>
    <para>
     pointer to the urb to initialize.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     pointer to the struct usb_device for this urb.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>pipe</parameter></term>
   <listitem>
    <para>
     the endpoint pipe
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>setup_packet</parameter></term>
   <listitem>
    <para>
     pointer to the setup_packet buffer
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>transfer_buffer</parameter></term>
   <listitem>
    <para>
     pointer to the transfer buffer
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>buffer_length</parameter></term>
   <listitem>
    <para>
     length of the transfer buffer
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>complete_fn</parameter></term>
   <listitem>
    <para>
     pointer to the usb_complete_t function
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>context</parameter></term>
   <listitem>
    <para>
     what to set the urb context to.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Initializes a control urb with the proper information needed to submit
   it to a device.
</para>
</refsect1>
</refentry>

<refentry id="API-usb-fill-bulk-urb">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>usb_fill_bulk_urb</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>usb_fill_bulk_urb</refname>
 <refpurpose>
     macro to help initialize a bulk urb
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>usb_fill_bulk_urb </function></funcdef>
   <paramdef>struct urb * <parameter>urb</parameter></paramdef>
   <paramdef>struct usb_device * <parameter>dev</parameter></paramdef>
   <paramdef>unsigned int <parameter>pipe</parameter></paramdef>
   <paramdef>void * <parameter>transfer_buffer</parameter></paramdef>
   <paramdef>int <parameter>buffer_length</parameter></paramdef>
   <paramdef>usb_complete_t <parameter>complete_fn</parameter></paramdef>
   <paramdef>void * <parameter>context</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>urb</parameter></term>
   <listitem>
    <para>
     pointer to the urb to initialize.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     pointer to the struct usb_device for this urb.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>pipe</parameter></term>
   <listitem>
    <para>
     the endpoint pipe
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>transfer_buffer</parameter></term>
   <listitem>
    <para>
     pointer to the transfer buffer
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>buffer_length</parameter></term>
   <listitem>
    <para>
     length of the transfer buffer
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>complete_fn</parameter></term>
   <listitem>
    <para>
     pointer to the usb_complete_t function
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>context</parameter></term>
   <listitem>
    <para>
     what to set the urb context to.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Initializes a bulk urb with the proper information needed to submit it
   to a device.
</para>
</refsect1>
</refentry>

<refentry id="API-usb-fill-int-urb">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>usb_fill_int_urb</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>usb_fill_int_urb</refname>
 <refpurpose>
     macro to help initialize a interrupt urb
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>usb_fill_int_urb </function></funcdef>
   <paramdef>struct urb * <parameter>urb</parameter></paramdef>
   <paramdef>struct usb_device * <parameter>dev</parameter></paramdef>
   <paramdef>unsigned int <parameter>pipe</parameter></paramdef>
   <paramdef>void * <parameter>transfer_buffer</parameter></paramdef>
   <paramdef>int <parameter>buffer_length</parameter></paramdef>
   <paramdef>usb_complete_t <parameter>complete_fn</parameter></paramdef>
   <paramdef>void * <parameter>context</parameter></paramdef>
   <paramdef>int <parameter>interval</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>urb</parameter></term>
   <listitem>
    <para>
     pointer to the urb to initialize.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     pointer to the struct usb_device for this urb.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>pipe</parameter></term>
   <listitem>
    <para>
     the endpoint pipe
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>transfer_buffer</parameter></term>
   <listitem>
    <para>
     pointer to the transfer buffer
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>buffer_length</parameter></term>
   <listitem>
    <para>
     length of the transfer buffer
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>complete_fn</parameter></term>
   <listitem>
    <para>
     pointer to the usb_complete_t function
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>context</parameter></term>
   <listitem>
    <para>
     what to set the urb context to.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>interval</parameter></term>
   <listitem>
    <para>
     what to set the urb interval to, encoded like
     the endpoint descriptor's bInterval value.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Initializes a interrupt urb with the proper information needed to submit
   it to a device.
   </para><para>

   Note that High Speed and SuperSpeed interrupt endpoints use a logarithmic
   encoding of the endpoint interval, and express polling intervals in
   microframes (eight per millisecond) rather than in frames (one per
   millisecond).
   </para><para>

   Wireless USB also uses the logarithmic encoding, but specifies it in units of
   128us instead of 125us.  For Wireless USB devices, the interval is passed
   through to the host controller, rather than being translated into microframe
   units.
</para>
</refsect1>
</refentry>

<refentry id="API-usb-urb-dir-in">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>usb_urb_dir_in</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>usb_urb_dir_in</refname>
 <refpurpose>
     check if an URB describes an IN transfer
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>usb_urb_dir_in </function></funcdef>
   <paramdef>struct urb * <parameter>urb</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>urb</parameter></term>
   <listitem>
    <para>
     URB to be checked
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Return</title>
<para>
   1 if <parameter>urb</parameter> describes an IN transfer (device-to-host),
   otherwise 0.
</para>
</refsect1>
</refentry>

<refentry id="API-usb-urb-dir-out">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>usb_urb_dir_out</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>usb_urb_dir_out</refname>
 <refpurpose>
     check if an URB describes an OUT transfer
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>usb_urb_dir_out </function></funcdef>
   <paramdef>struct urb * <parameter>urb</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>urb</parameter></term>
   <listitem>
    <para>
     URB to be checked
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Return</title>
<para>
   1 if <parameter>urb</parameter> describes an OUT transfer (host-to-device),
   otherwise 0.
</para>
</refsect1>
</refentry>

<refentry id="API-struct-usb-sg-request">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct usb_sg_request</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct usb_sg_request</refname>
 <refpurpose>
     support for scatter/gather I/O
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct usb_sg_request {
  int status;
  size_t bytes;
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>status</term>
      <listitem><para>
   zero indicates success, else negative errno
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>bytes</term>
      <listitem><para>
   counts bytes transferred.
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
<refsect1>
<title>Description</title>
<para>
   These requests are initialized using <function>usb_sg_init</function>, and then are used
   as request handles passed to <function>usb_sg_wait</function> or <function>usb_sg_cancel</function>.  Most
   members of the request object aren't for driver access.
   </para><para>

   The status and bytecount values are valid only after <function>usb_sg_wait</function>
   returns.  If the status is zero, then the bytecount matches the total
   from the request.
   </para><para>

   After an error completion, drivers may need to clear a halt condition
   on the endpoint.
</para>
</refsect1>
</refentry>


    </chapter>

    <chapter id="usbcore"><title>USB Core APIs</title>

    <para>There are two basic I/O models in the USB API.
    The most elemental one is asynchronous:  drivers submit requests
    in the form of an URB, and the URB's completion callback
    handle the next step.
    All USB transfer types support that model, although there
    are special cases for control URBs (which always have setup
    and status stages, but may not have a data stage) and
    isochronous URBs (which allow large packets and include
    per-packet fault reports).
    Built on top of that is synchronous API support, where a
    driver calls a routine that allocates one or more URBs,
    submits them, and waits until they complete.
    There are synchronous wrappers for single-buffer control
    and bulk transfers (which are awkward to use in some
    driver disconnect scenarios), and for scatterlist based
    streaming i/o (bulk or interrupt).
    </para>

    <para>USB drivers need to provide buffers that can be
    used for DMA, although they don't necessarily need to
    provide the DMA mapping themselves.
    There are APIs to use used when allocating DMA buffers,
    which can prevent use of bounce buffers on some systems.
    In some cases, drivers may be able to rely on 64bit DMA
    to eliminate another kind of bounce buffer.
    </para>

<!-- drivers/usb/core/urb.c -->
<refentry id="API-usb-init-urb">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>usb_init_urb</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>usb_init_urb</refname>
 <refpurpose>
  initializes a urb so that it can be used by a USB driver
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>usb_init_urb </function></funcdef>
   <paramdef>struct urb * <parameter>urb</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>urb</parameter></term>
   <listitem>
    <para>
     pointer to the urb to initialize
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Initializes a urb so that the USB subsystem can use it properly.
   </para><para>

   If a urb is created with a call to <function>usb_alloc_urb</function> it is not
   necessary to call this function.  Only use this if you allocate the
   space for a struct urb on your own.  If you call this function, be
   careful when freeing the memory for your urb that it is no longer in
   use by the USB core.
   </para><para>

   Only use this function if you _really_ understand what you are doing.
</para>
</refsect1>
</refentry>

<refentry id="API-usb-alloc-urb">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>usb_alloc_urb</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>usb_alloc_urb</refname>
 <refpurpose>
     creates a new urb for a USB driver to use
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct urb * <function>usb_alloc_urb </function></funcdef>
   <paramdef>int <parameter>iso_packets</parameter></paramdef>
   <paramdef>gfp_t <parameter>mem_flags</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>iso_packets</parameter></term>
   <listitem>
    <para>
     number of iso packets for this urb
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>mem_flags</parameter></term>
   <listitem>
    <para>
     the type of memory to allocate, see <function>kmalloc</function> for a list of
     valid options for this.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Creates an urb for the USB driver to use, initializes a few internal
   structures, increments the usage counter, and returns a pointer to it.
   </para><para>

   If the driver want to use this urb for interrupt, control, or bulk
   endpoints, pass '0' as the number of iso packets.
   </para><para>

   The driver must call <function>usb_free_urb</function> when it is finished with the urb.
</para>
</refsect1>
<refsect1>
<title>Return</title>
<para>
   A pointer to the new urb, or <constant>NULL</constant> if no memory is available.
</para>
</refsect1>
</refentry>

<refentry id="API-usb-free-urb">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>usb_free_urb</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>usb_free_urb</refname>
 <refpurpose>
     frees the memory used by a urb when all users of it are finished
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>usb_free_urb </function></funcdef>
   <paramdef>struct urb * <parameter>urb</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>urb</parameter></term>
   <listitem>
    <para>
     pointer to the urb to free, may be NULL
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Must be called when a user of a urb is finished with it.  When the last user
   of the urb calls this function, the memory of the urb is freed.
</para>
</refsect1>
<refsect1>
<title>Note</title>
<para>
   The transfer buffer associated with the urb is not freed unless the
   URB_FREE_BUFFER transfer flag is set.
</para>
</refsect1>
</refentry>

<refentry id="API-usb-get-urb">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>usb_get_urb</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>usb_get_urb</refname>
 <refpurpose>
     increments the reference count of the urb
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct urb * <function>usb_get_urb </function></funcdef>
   <paramdef>struct urb * <parameter>urb</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>urb</parameter></term>
   <listitem>
    <para>
     pointer to the urb to modify, may be NULL
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This must be  called whenever a urb is transferred from a device driver to a
   host controller driver.  This allows proper reference counting to happen
   for urbs.
</para>
</refsect1>
<refsect1>
<title>Return</title>
<para>
   A pointer to the urb with the incremented reference counter.
</para>
</refsect1>
</refentry>

<refentry id="API-usb-anchor-urb">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>usb_anchor_urb</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>usb_anchor_urb</refname>
 <refpurpose>
     anchors an URB while it is processed
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>usb_anchor_urb </function></funcdef>
   <paramdef>struct urb * <parameter>urb</parameter></paramdef>
   <paramdef>struct usb_anchor * <parameter>anchor</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>urb</parameter></term>
   <listitem>
    <para>
     pointer to the urb to anchor
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>anchor</parameter></term>
   <listitem>
    <para>
     pointer to the anchor
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This can be called to have access to URBs which are to be executed
   without bothering to track them
</para>
</refsect1>
</refentry>

<refentry id="API-usb-unanchor-urb">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>usb_unanchor_urb</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>usb_unanchor_urb</refname>
 <refpurpose>
     unanchors an URB
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>usb_unanchor_urb </function></funcdef>
   <paramdef>struct urb * <parameter>urb</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>urb</parameter></term>
   <listitem>
    <para>
     pointer to the urb to anchor
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Call this to stop the system keeping track of this URB
</para>
</refsect1>
</refentry>

<refentry id="API-usb-submit-urb">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>usb_submit_urb</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>usb_submit_urb</refname>
 <refpurpose>
     issue an asynchronous transfer request for an endpoint
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>usb_submit_urb </function></funcdef>
   <paramdef>struct urb * <parameter>urb</parameter></paramdef>
   <paramdef>gfp_t <parameter>mem_flags</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>urb</parameter></term>
   <listitem>
    <para>
     pointer to the urb describing the request
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>mem_flags</parameter></term>
   <listitem>
    <para>
     the type of memory to allocate, see <function>kmalloc</function> for a list
     of valid options for this.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This submits a transfer request, and transfers control of the URB
   describing that request to the USB subsystem.  Request completion will
   be indicated later, asynchronously, by calling the completion handler.
   The three types of completion are success, error, and unlink
   (a software-induced fault, also called <quote>request cancellation</quote>).
   </para><para>

   URBs may be submitted in interrupt context.
   </para><para>

   The caller must have correctly initialized the URB before submitting
   it.  Functions such as <function>usb_fill_bulk_urb</function> and <function>usb_fill_control_urb</function> are
   available to ensure that most fields are correctly initialized, for
   the particular kind of transfer, although they will not initialize
   any transfer flags.
   </para><para>

   If the submission is successful, the <function>complete</function> callback from the URB
   will be called exactly once, when the USB core and Host Controller Driver
   (HCD) are finished with the URB.  When the completion function is called,
   control of the URB is returned to the device driver which issued the
   request.  The completion handler may then immediately free or reuse that
   URB.
   </para><para>

   With few exceptions, USB device drivers should never access URB fields
   provided by usbcore or the HCD until its <function>complete</function> is called.
   The exceptions relate to periodic transfer scheduling.  For both
   interrupt and isochronous urbs, as part of successful URB submission
   urb-&gt;interval is modified to reflect the actual transfer period used
   (normally some power of two units).  And for isochronous urbs,
   urb-&gt;start_frame is modified to reflect when the URB's transfers were
   scheduled to start.
   </para><para>

   Not all isochronous transfer scheduling policies will work, but most
   host controller drivers should easily handle ISO queues going from now
   until 10-200 msec into the future.  Drivers should try to keep at
   least one or two msec of data in the queue; many controllers require
   that new transfers start at least 1 msec in the future when they are
   added.  If the driver is unable to keep up and the queue empties out,
   the behavior for new submissions is governed by the URB_ISO_ASAP flag.
   If the flag is set, or if the queue is idle, then the URB is always
   assigned to the first available (and not yet expired) slot in the
   endpoint's schedule.  If the flag is not set and the queue is active
   then the URB is always assigned to the next slot in the schedule
   following the end of the endpoint's previous URB, even if that slot is
   in the past.  When a packet is assigned in this way to a slot that has
   already expired, the packet is not transmitted and the corresponding
   usb_iso_packet_descriptor's status field will return -EXDEV.  If this
   would happen to all the packets in the URB, submission fails with a
   -EXDEV error code.
   </para><para>

   For control endpoints, the synchronous <function>usb_control_msg</function> call is
   often used (in non-interrupt context) instead of this call.
   That is often used through convenience wrappers, for the requests
   that are standardized in the USB 2.0 specification.  For bulk
   endpoints, a synchronous <function>usb_bulk_msg</function> call is available.
</para>
</refsect1>
<refsect1>
<title>Return</title>
<para>
   0 on successful submissions. A negative error number otherwise.
</para>
</refsect1>
<refsect1>
<title>Request Queuing</title>
<para>
   </para><para>

   URBs may be submitted to endpoints before previous ones complete, to
   minimize the impact of interrupt latencies and system overhead on data
   throughput.  With that queuing policy, an endpoint's queue would never
   be empty.  This is required for continuous isochronous data streams,
   and may also be required for some kinds of interrupt transfers. Such
   queuing also maximizes bandwidth utilization by letting USB controllers
   start work on later requests before driver software has finished the
   completion processing for earlier (successful) requests.
   </para><para>

   As of Linux 2.6, all USB endpoint transfer queues support depths greater
   than one.  This was previously a HCD-specific behavior, except for ISO
   transfers.  Non-isochronous endpoint queues are inactive during cleanup
   after faults (transfer errors or cancellation).
</para>
</refsect1>
<refsect1>
<title>Reserved Bandwidth Transfers</title>
<para>
   </para><para>

   Periodic transfers (interrupt or isochronous) are performed repeatedly,
   using the interval specified in the urb.  Submitting the first urb to
   the endpoint reserves the bandwidth necessary to make those transfers.
   If the USB subsystem can't allocate sufficient bandwidth to perform
   the periodic request, submitting such a periodic request should fail.
   </para><para>

   For devices under xHCI, the bandwidth is reserved at configuration time, or
   when the alt setting is selected.  If there is not enough bus bandwidth, the
   configuration/alt setting request will fail.  Therefore, submissions to
   periodic endpoints on devices under xHCI should never fail due to bandwidth
   constraints.
   </para><para>

   Device drivers must explicitly request that repetition, by ensuring that
   some URB is always on the endpoint's queue (except possibly for short
   periods during completion callbacks).  When there is no longer an urb
   queued, the endpoint's bandwidth reservation is canceled.  This means
   drivers can use their completion handlers to ensure they keep bandwidth
   they need, by reinitializing and resubmitting the just-completed urb
   until the driver longer needs that periodic bandwidth.
</para>
</refsect1>
<refsect1>
<title>Memory Flags</title>
<para>
   </para><para>

   The general rules for how to decide which mem_flags to use
   are the same as for kmalloc.  There are four
   different possible values; GFP_KERNEL, GFP_NOFS, GFP_NOIO and
   GFP_ATOMIC.
   </para><para>

   GFP_NOFS is not ever used, as it has not been implemented yet.
   </para><para>

   GFP_ATOMIC is used when
   (a) you are inside a completion handler, an interrupt, bottom half,
   tasklet or timer, or
   (b) you are holding a spinlock or rwlock (does not apply to
   semaphores), or
   (c) current-&gt;state != TASK_RUNNING, this is the case only after
   you've changed it.
   </para><para>

   GFP_NOIO is used in the block io path and error handling of storage
   devices.
   </para><para>

   All other situations use GFP_KERNEL.
   </para><para>

   Some more specific rules for mem_flags can be inferred, such as
   (1) start_xmit, timeout, and receive methods of network drivers must
   use GFP_ATOMIC (they are called with a spinlock held);
   (2) queuecommand methods of scsi drivers must use GFP_ATOMIC (also
   called with a spinlock held);
   (3) If you use a kernel thread with a network driver you must use
   GFP_NOIO, unless (b) or (c) apply;
   (4) after you have done a <function>down</function> you can use GFP_KERNEL, unless (b) or (c)
   apply or your are in a storage driver's block io path;
   (5) USB probe and disconnect can use GFP_KERNEL unless (b) or (c) apply; and
   (6) changing firmware on a running storage or net device uses
   GFP_NOIO, unless b) or c) apply
</para>
</refsect1>
</refentry>

<refentry id="API-usb-unlink-urb">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>usb_unlink_urb</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>usb_unlink_urb</refname>
 <refpurpose>
     abort/cancel a transfer request for an endpoint
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>usb_unlink_urb </function></funcdef>
   <paramdef>struct urb * <parameter>urb</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>urb</parameter></term>
   <listitem>
    <para>
     pointer to urb describing a previously submitted request,
     may be NULL
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This routine cancels an in-progress request.  URBs complete only once
   per submission, and may be canceled only once per submission.
   Successful cancellation means termination of <parameter>urb</parameter> will be expedited
   and the completion handler will be called with a status code
   indicating that the request has been canceled (rather than any other
   code).
   </para><para>

   Drivers should not call this routine or related routines, such as
   <function>usb_kill_urb</function> or <function>usb_unlink_anchored_urbs</function>, after their disconnect
   method has returned.  The disconnect function should synchronize with
   a driver's I/O routines to insure that all URB-related activity has
   completed before it returns.
   </para><para>

   This request is asynchronous, however the HCD might call the -&gt;<function>complete</function>
   callback during unlink. Therefore when drivers call <function>usb_unlink_urb</function>, they
   must not hold any locks that may be taken by the completion function.
   Success is indicated by returning -EINPROGRESS, at which time the URB will
   probably not yet have been given back to the device driver. When it is
   eventually called, the completion function will see <parameter>urb</parameter>-&gt;status ==
   -ECONNRESET.
   Failure is indicated by <function>usb_unlink_urb</function> returning any other value.
   Unlinking will fail when <parameter>urb</parameter> is not currently <quote>linked</quote> (i.e., it was
   never submitted, or it was unlinked before, or the hardware is already
   finished with it), even if the completion handler has not yet run.
   </para><para>

   The URB must not be deallocated while this routine is running.  In
   particular, when a driver calls this routine, it must insure that the
   completion handler cannot deallocate the URB.
</para>
</refsect1>
<refsect1>
<title>Return</title>
<para>
   -EINPROGRESS on success. See description for other values on
   failure.
</para>
</refsect1>
<refsect1>
<title>Unlinking and Endpoint Queues</title>
<para>
   </para><para>

   [The behaviors and guarantees described below do not apply to virtual
   root hubs but only to endpoint queues for physical USB devices.]
   </para><para>

   Host Controller Drivers (HCDs) place all the URBs for a particular
   endpoint in a queue.  Normally the queue advances as the controller
   hardware processes each request.  But when an URB terminates with an
   error its queue generally stops (see below), at least until that URB's
   completion routine returns.  It is guaranteed that a stopped queue
   will not restart until all its unlinked URBs have been fully retired,
   with their completion routines run, even if that's not until some time
   after the original completion handler returns.  The same behavior and
   guarantee apply when an URB terminates because it was unlinked.
   </para><para>

   Bulk and interrupt endpoint queues are guaranteed to stop whenever an
   URB terminates with any sort of error, including -ECONNRESET, -ENOENT,
   and -EREMOTEIO.  Control endpoint queues behave the same way except
   that they are not guaranteed to stop for -EREMOTEIO errors.  Queues
   for isochronous endpoints are treated differently, because they must
   advance at fixed rates.  Such queues do not stop when an URB
   encounters an error or is unlinked.  An unlinked isochronous URB may
   leave a gap in the stream of packets; it is undefined whether such
   gaps can be filled in.
   </para><para>

   Note that early termination of an URB because a short packet was
   received will generate a -EREMOTEIO error if and only if the
   URB_SHORT_NOT_OK flag is set.  By setting this flag, USB device
   drivers can build deep queues for large or complex bulk transfers
   and clean them up reliably after any sort of aborted transfer by
   unlinking all pending URBs at the first fault.
   </para><para>

   When a control URB terminates with an error other than -EREMOTEIO, it
   is quite likely that the status stage of the transfer will not take
   place.
</para>
</refsect1>
</refentry>

<refentry id="API-usb-kill-urb">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>usb_kill_urb</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>usb_kill_urb</refname>
 <refpurpose>
     cancel a transfer request and wait for it to finish
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>usb_kill_urb </function></funcdef>
   <paramdef>struct urb * <parameter>urb</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>urb</parameter></term>
   <listitem>
    <para>
     pointer to URB describing a previously submitted request,
     may be NULL
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This routine cancels an in-progress request.  It is guaranteed that
   upon return all completion handlers will have finished and the URB
   will be totally idle and available for reuse.  These features make
   this an ideal way to stop I/O in a <function>disconnect</function> callback or <function>close</function>
   function.  If the request has not already finished or been unlinked
   the completion handler will see urb-&gt;status == -ENOENT.
   </para><para>

   While the routine is running, attempts to resubmit the URB will fail
   with error -EPERM.  Thus even if the URB's completion handler always
   tries to resubmit, it will not succeed and the URB will become idle.
   </para><para>

   The URB must not be deallocated while this routine is running.  In
   particular, when a driver calls this routine, it must insure that the
   completion handler cannot deallocate the URB.
   </para><para>

   This routine may not be used in an interrupt context (such as a bottom
   half or a completion handler), or when holding a spinlock, or in other
   situations where the caller can't <function>schedule</function>.
   </para><para>

   This routine should not be called by a driver after its disconnect
   method has returned.
</para>
</refsect1>
</refentry>

<refentry id="API-usb-poison-urb">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>usb_poison_urb</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>usb_poison_urb</refname>
 <refpurpose>
     reliably kill a transfer and prevent further use of an URB
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>usb_poison_urb </function></funcdef>
   <paramdef>struct urb * <parameter>urb</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>urb</parameter></term>
   <listitem>
    <para>
     pointer to URB describing a previously submitted request,
     may be NULL
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This routine cancels an in-progress request.  It is guaranteed that
   upon return all completion handlers will have finished and the URB
   will be totally idle and cannot be reused.  These features make
   this an ideal way to stop I/O in a <function>disconnect</function> callback.
   If the request has not already finished or been unlinked
   the completion handler will see urb-&gt;status == -ENOENT.
   </para><para>

   After and while the routine runs, attempts to resubmit the URB will fail
   with error -EPERM.  Thus even if the URB's completion handler always
   tries to resubmit, it will not succeed and the URB will become idle.
   </para><para>

   The URB must not be deallocated while this routine is running.  In
   particular, when a driver calls this routine, it must insure that the
   completion handler cannot deallocate the URB.
   </para><para>

   This routine may not be used in an interrupt context (such as a bottom
   half or a completion handler), or when holding a spinlock, or in other
   situations where the caller can't <function>schedule</function>.
   </para><para>

   This routine should not be called by a driver after its disconnect
   method has returned.
</para>
</refsect1>
</refentry>

<refentry id="API-usb-block-urb">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>usb_block_urb</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>usb_block_urb</refname>
 <refpurpose>
     reliably prevent further use of an URB
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>usb_block_urb </function></funcdef>
   <paramdef>struct urb * <parameter>urb</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>urb</parameter></term>
   <listitem>
    <para>
     pointer to URB to be blocked, may be NULL
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   After the routine has run, attempts to resubmit the URB will fail
   with error -EPERM.  Thus even if the URB's completion handler always
   tries to resubmit, it will not succeed and the URB will become idle.
   </para><para>

   The URB must not be deallocated while this routine is running.  In
   particular, when a driver calls this routine, it must insure that the
   completion handler cannot deallocate the URB.
</para>
</refsect1>
</refentry>

<refentry id="API-usb-kill-anchored-urbs">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>usb_kill_anchored_urbs</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>usb_kill_anchored_urbs</refname>
 <refpurpose>
     cancel transfer requests en masse
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>usb_kill_anchored_urbs </function></funcdef>
   <paramdef>struct usb_anchor * <parameter>anchor</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>anchor</parameter></term>
   <listitem>
    <para>
     anchor the requests are bound to
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   this allows all outstanding URBs to be killed starting
   from the back of the queue
   </para><para>

   This routine should not be called by a driver after its disconnect
   method has returned.
</para>
</refsect1>
</refentry>

<refentry id="API-usb-poison-anchored-urbs">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>usb_poison_anchored_urbs</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>usb_poison_anchored_urbs</refname>
 <refpurpose>
     cease all traffic from an anchor
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>usb_poison_anchored_urbs </function></funcdef>
   <paramdef>struct usb_anchor * <parameter>anchor</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>anchor</parameter></term>
   <listitem>
    <para>
     anchor the requests are bound to
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   this allows all outstanding URBs to be poisoned starting
   from the back of the queue. Newly added URBs will also be
   poisoned
   </para><para>

   This routine should not be called by a driver after its disconnect
   method has returned.
</para>
</refsect1>
</refentry>

<refentry id="API-usb-unpoison-anchored-urbs">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>usb_unpoison_anchored_urbs</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>usb_unpoison_anchored_urbs</refname>
 <refpurpose>
     let an anchor be used successfully again
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>usb_unpoison_anchored_urbs </function></funcdef>
   <paramdef>struct usb_anchor * <parameter>anchor</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>anchor</parameter></term>
   <listitem>
    <para>
     anchor the requests are bound to
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Reverses the effect of usb_poison_anchored_urbs
   the anchor can be used normally after it returns
</para>
</refsect1>
</refentry>

<refentry id="API-usb-unlink-anchored-urbs">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>usb_unlink_anchored_urbs</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>usb_unlink_anchored_urbs</refname>
 <refpurpose>
     asynchronously cancel transfer requests en masse
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>usb_unlink_anchored_urbs </function></funcdef>
   <paramdef>struct usb_anchor * <parameter>anchor</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>anchor</parameter></term>
   <listitem>
    <para>
     anchor the requests are bound to
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   this allows all outstanding URBs to be unlinked starting
   from the back of the queue. This function is asynchronous.
   The unlinking is just triggered. It may happen after this
   function has returned.
   </para><para>

   This routine should not be called by a driver after its disconnect
   method has returned.
</para>
</refsect1>
</refentry>

<refentry id="API-usb-anchor-suspend-wakeups">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>usb_anchor_suspend_wakeups</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>usb_anchor_suspend_wakeups</refname>
 <refpurpose>
   </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>usb_anchor_suspend_wakeups </function></funcdef>
   <paramdef>struct usb_anchor * <parameter>anchor</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>anchor</parameter></term>
   <listitem>
    <para>
     the anchor you want to suspend wakeups on
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Call this to stop the last urb being unanchored from waking up any
   usb_wait_anchor_empty_timeout waiters. This is used in the hcd urb give-
   back path to delay waking up until after the completion handler has run.
</para>
</refsect1>
</refentry>

<refentry id="API-usb-anchor-resume-wakeups">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>usb_anchor_resume_wakeups</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>usb_anchor_resume_wakeups</refname>
 <refpurpose>
   </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>usb_anchor_resume_wakeups </function></funcdef>
   <paramdef>struct usb_anchor * <parameter>anchor</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>anchor</parameter></term>
   <listitem>
    <para>
     the anchor you want to resume wakeups on
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Allow usb_wait_anchor_empty_timeout waiters to be woken up again, and
   wake up any current waiters if the anchor is empty.
</para>
</refsect1>
</refentry>

<refentry id="API-usb-wait-anchor-empty-timeout">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>usb_wait_anchor_empty_timeout</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>usb_wait_anchor_empty_timeout</refname>
 <refpurpose>
     wait for an anchor to be unused
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>usb_wait_anchor_empty_timeout </function></funcdef>
   <paramdef>struct usb_anchor * <parameter>anchor</parameter></paramdef>
   <paramdef>unsigned int <parameter>timeout</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>anchor</parameter></term>
   <listitem>
    <para>
     the anchor you want to become unused
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>timeout</parameter></term>
   <listitem>
    <para>
     how long you are willing to wait in milliseconds
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Call this is you want to be sure all an anchor's
   URBs have finished
</para>
</refsect1>
<refsect1>
<title>Return</title>
<para>
   Non-zero if the anchor became unused. Zero on timeout.
</para>
</refsect1>
</refentry>

<refentry id="API-usb-get-from-anchor">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>usb_get_from_anchor</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>usb_get_from_anchor</refname>
 <refpurpose>
     get an anchor's oldest urb
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct urb * <function>usb_get_from_anchor </function></funcdef>
   <paramdef>struct usb_anchor * <parameter>anchor</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>anchor</parameter></term>
   <listitem>
    <para>
     the anchor whose urb you want
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This will take the oldest urb from an anchor,
   unanchor and return it
</para>
</refsect1>
<refsect1>
<title>Return</title>
<para>
   The oldest urb from <parameter>anchor</parameter>, or <constant>NULL</constant> if <parameter>anchor</parameter> has no
   urbs associated with it.
</para>
</refsect1>
</refentry>

<refentry id="API-usb-scuttle-anchored-urbs">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>usb_scuttle_anchored_urbs</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>usb_scuttle_anchored_urbs</refname>
 <refpurpose>
     unanchor all an anchor's urbs
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>usb_scuttle_anchored_urbs </function></funcdef>
   <paramdef>struct usb_anchor * <parameter>anchor</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>anchor</parameter></term>
   <listitem>
    <para>
     the anchor whose urbs you want to unanchor
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   use this to get rid of all an anchor's urbs
</para>
</refsect1>
</refentry>

<refentry id="API-usb-anchor-empty">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>usb_anchor_empty</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>usb_anchor_empty</refname>
 <refpurpose>
     is an anchor empty
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>usb_anchor_empty </function></funcdef>
   <paramdef>struct usb_anchor * <parameter>anchor</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>anchor</parameter></term>
   <listitem>
    <para>
     the anchor you want to query
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Return</title>
<para>
   1 if the anchor has no urbs associated with it.
</para>
</refsect1>
</refentry>

<!-- drivers/usb/core/message.c -->
<refentry id="API-usb-control-msg">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>usb_control_msg</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>usb_control_msg</refname>
 <refpurpose>
  Builds a control urb, sends it off and waits for completion
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>usb_control_msg </function></funcdef>
   <paramdef>struct usb_device * <parameter>dev</parameter></paramdef>
   <paramdef>unsigned int <parameter>pipe</parameter></paramdef>
   <paramdef>__u8 <parameter>request</parameter></paramdef>
   <paramdef>__u8 <parameter>requesttype</parameter></paramdef>
   <paramdef>__u16 <parameter>value</parameter></paramdef>
   <paramdef>__u16 <parameter>index</parameter></paramdef>
   <paramdef>void * <parameter>data</parameter></paramdef>
   <paramdef>__u16 <parameter>size</parameter></paramdef>
   <paramdef>int <parameter>timeout</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     pointer to the usb device to send the message to
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>pipe</parameter></term>
   <listitem>
    <para>
     endpoint <quote>pipe</quote> to send the message to
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>request</parameter></term>
   <listitem>
    <para>
     USB message request value
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>requesttype</parameter></term>
   <listitem>
    <para>
     USB message request type value
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>value</parameter></term>
   <listitem>
    <para>
     USB message value
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>index</parameter></term>
   <listitem>
    <para>
     USB message index value
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>data</parameter></term>
   <listitem>
    <para>
     pointer to the data to send
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>size</parameter></term>
   <listitem>
    <para>
     length in bytes of the data to send
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>timeout</parameter></term>
   <listitem>
    <para>
     time in msecs to wait for the message to complete before timing
     out (if 0 the wait is forever)
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Context</title>
<para>
   !in_interrupt ()
</para>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This function sends a simple control message to a specified endpoint and
   waits for the message to complete, or timeout.
   </para><para>

   Don't use this function from within an interrupt context, like a bottom half
   handler.  If you need an asynchronous message, or need to send a message
   from within interrupt context, use <function>usb_submit_urb</function>.
   If a thread in your driver uses this call, make sure your <function>disconnect</function>
   method can wait for it to complete.  Since you don't have a handle on the
   URB used, you can't cancel the request.
</para>
</refsect1>
<refsect1>
<title>Return</title>
<para>
   If successful, the number of bytes transferred. Otherwise, a negative
   error number.
</para>
</refsect1>
</refentry>

<refentry id="API-usb-interrupt-msg">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>usb_interrupt_msg</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>usb_interrupt_msg</refname>
 <refpurpose>
     Builds an interrupt urb, sends it off and waits for completion
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>usb_interrupt_msg </function></funcdef>
   <paramdef>struct usb_device * <parameter>usb_dev</parameter></paramdef>
   <paramdef>unsigned int <parameter>pipe</parameter></paramdef>
   <paramdef>void * <parameter>data</parameter></paramdef>
   <paramdef>int <parameter>len</parameter></paramdef>
   <paramdef>int * <parameter>actual_length</parameter></paramdef>
   <paramdef>int <parameter>timeout</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>usb_dev</parameter></term>
   <listitem>
    <para>
     pointer to the usb device to send the message to
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>pipe</parameter></term>
   <listitem>
    <para>
     endpoint <quote>pipe</quote> to send the message to
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>data</parameter></term>
   <listitem>
    <para>
     pointer to the data to send
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>len</parameter></term>
   <listitem>
    <para>
     length in bytes of the data to send
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>actual_length</parameter></term>
   <listitem>
    <para>
     pointer to a location to put the actual length transferred
     in bytes
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>timeout</parameter></term>
   <listitem>
    <para>
     time in msecs to wait for the message to complete before
     timing out (if 0 the wait is forever)
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Context</title>
<para>
   !in_interrupt ()
</para>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This function sends a simple interrupt message to a specified endpoint and
   waits for the message to complete, or timeout.
   </para><para>

   Don't use this function from within an interrupt context, like a bottom half
   handler.  If you need an asynchronous message, or need to send a message
   from within interrupt context, use <function>usb_submit_urb</function> If a thread in your
   driver uses this call, make sure your <function>disconnect</function> method can wait for it to
   complete.  Since you don't have a handle on the URB used, you can't cancel
   the request.
</para>
</refsect1>
<refsect1>
<title>Return</title>
<para>
   If successful, 0. Otherwise a negative error number. The number of actual
   bytes transferred will be stored in the <parameter>actual_length</parameter> parameter.
</para>
</refsect1>
</refentry>

<refentry id="API-usb-bulk-msg">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>usb_bulk_msg</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>usb_bulk_msg</refname>
 <refpurpose>
     Builds a bulk urb, sends it off and waits for completion
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>usb_bulk_msg </function></funcdef>
   <paramdef>struct usb_device * <parameter>usb_dev</parameter></paramdef>
   <paramdef>unsigned int <parameter>pipe</parameter></paramdef>
   <paramdef>void * <parameter>data</parameter></paramdef>
   <paramdef>int <parameter>len</parameter></paramdef>
   <paramdef>int * <parameter>actual_length</parameter></paramdef>
   <paramdef>int <parameter>timeout</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>usb_dev</parameter></term>
   <listitem>
    <para>
     pointer to the usb device to send the message to
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>pipe</parameter></term>
   <listitem>
    <para>
     endpoint <quote>pipe</quote> to send the message to
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>data</parameter></term>
   <listitem>
    <para>
     pointer to the data to send
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>len</parameter></term>
   <listitem>
    <para>
     length in bytes of the data to send
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>actual_length</parameter></term>
   <listitem>
    <para>
     pointer to a location to put the actual length transferred
     in bytes
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>timeout</parameter></term>
   <listitem>
    <para>
     time in msecs to wait for the message to complete before
     timing out (if 0 the wait is forever)
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Context</title>
<para>
   !in_interrupt ()
</para>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This function sends a simple bulk message to a specified endpoint
   and waits for the message to complete, or timeout.
   </para><para>

   Don't use this function from within an interrupt context, like a bottom half
   handler.  If you need an asynchronous message, or need to send a message
   from within interrupt context, use <function>usb_submit_urb</function> If a thread in your
   driver uses this call, make sure your <function>disconnect</function> method can wait for it to
   complete.  Since you don't have a handle on the URB used, you can't cancel
   the request.
   </para><para>

   Because there is no <function>usb_interrupt_msg</function> and no USBDEVFS_INTERRUPT ioctl,
   users are forced to abuse this routine by using it to submit URBs for
   interrupt endpoints.  We will take the liberty of creating an interrupt URB
   (with the default interval) if the target is an interrupt endpoint.
</para>
</refsect1>
<refsect1>
<title>Return</title>
<para>
   If successful, 0. Otherwise a negative error number. The number of actual
   bytes transferred will be stored in the <parameter>actual_length</parameter> parameter.
</para>
</refsect1>
</refentry>

<refentry id="API-usb-sg-init">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>usb_sg_init</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>usb_sg_init</refname>
 <refpurpose>
     initializes scatterlist-based bulk/interrupt I/O request
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>usb_sg_init </function></funcdef>
   <paramdef>struct usb_sg_request * <parameter>io</parameter></paramdef>
   <paramdef>struct usb_device * <parameter>dev</parameter></paramdef>
   <paramdef>unsigned <parameter>pipe</parameter></paramdef>
   <paramdef>unsigned <parameter>period</parameter></paramdef>
   <paramdef>struct scatterlist * <parameter>sg</parameter></paramdef>
   <paramdef>int <parameter>nents</parameter></paramdef>
   <paramdef>size_t <parameter>length</parameter></paramdef>
   <paramdef>gfp_t <parameter>mem_flags</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>io</parameter></term>
   <listitem>
    <para>
     request block being initialized.  until <function>usb_sg_wait</function> returns,
     treat this as a pointer to an opaque block of memory,
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     the usb device that will send or receive the data
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>pipe</parameter></term>
   <listitem>
    <para>
     endpoint <quote>pipe</quote> used to transfer the data
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>period</parameter></term>
   <listitem>
    <para>
     polling rate for interrupt endpoints, in frames or
     (for high speed endpoints) microframes; ignored for bulk
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>sg</parameter></term>
   <listitem>
    <para>
     scatterlist entries
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>nents</parameter></term>
   <listitem>
    <para>
     how many entries in the scatterlist
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>length</parameter></term>
   <listitem>
    <para>
     how many bytes to send from the scatterlist, or zero to
     send every byte identified in the list.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>mem_flags</parameter></term>
   <listitem>
    <para>
     SLAB_* flags affecting memory allocations in this call
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This initializes a scatter/gather request, allocating resources such as
   I/O mappings and urb memory (except maybe memory used by USB controller
   drivers).
   </para><para>

   The request must be issued using <function>usb_sg_wait</function>, which waits for the I/O to
   complete (or to be canceled) and then cleans up all resources allocated by
   <function>usb_sg_init</function>.
   </para><para>

   The request may be canceled with <function>usb_sg_cancel</function>, either before or after
   <function>usb_sg_wait</function> is called.
</para>
</refsect1>
<refsect1>
<title>Return</title>
<para>
   Zero for success, else a negative errno value.
</para>
</refsect1>
</refentry>

<refentry id="API-usb-sg-wait">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>usb_sg_wait</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>usb_sg_wait</refname>
 <refpurpose>
     synchronously execute scatter/gather request
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>usb_sg_wait </function></funcdef>
   <paramdef>struct usb_sg_request * <parameter>io</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>io</parameter></term>
   <listitem>
    <para>
     request block handle, as initialized with <function>usb_sg_init</function>.
     some fields become accessible when this call returns.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Context</title>
<para>
   !in_interrupt ()
</para>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This function blocks until the specified I/O operation completes.  It
   leverages the grouping of the related I/O requests to get good transfer
   rates, by queueing the requests.  At higher speeds, such queuing can
   significantly improve USB throughput.
   </para><para>

   There are three kinds of completion for this function.
   (1) success, where io-&gt;status is zero.  The number of io-&gt;bytes
   transferred is as requested.
   (2) error, where io-&gt;status is a negative errno value.  The number
   of io-&gt;bytes transferred before the error is usually less
   than requested, and can be nonzero.
   (3) cancellation, a type of error with status -ECONNRESET that
   is initiated by <function>usb_sg_cancel</function>.
   </para><para>

   When this function returns, all memory allocated through <function>usb_sg_init</function> or
   this call will have been freed.  The request block parameter may still be
   passed to <function>usb_sg_cancel</function>, or it may be freed.  It could also be
   reinitialized and then reused.
</para>
</refsect1>
<refsect1>
<title>Data Transfer Rates</title>
<para>
   </para><para>

   Bulk transfers are valid for full or high speed endpoints.
   The best full speed data rate is 19 packets of 64 bytes each
   per frame, or 1216 bytes per millisecond.
   The best high speed data rate is 13 packets of 512 bytes each
   per microframe, or 52 KBytes per millisecond.
   </para><para>

   The reason to use interrupt transfers through this API would most likely
   be to reserve high speed bandwidth, where up to 24 KBytes per millisecond
   could be transferred.  That capability is less useful for low or full
   speed interrupt endpoints, which allow at most one packet per millisecond,
   of at most 8 or 64 bytes (respectively).
   </para><para>

   It is not necessary to call this function to reserve bandwidth for devices
   under an xHCI host controller, as the bandwidth is reserved when the
   configuration or interface alt setting is selected.
</para>
</refsect1>
</refentry>

<refentry id="API-usb-sg-cancel">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>usb_sg_cancel</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>usb_sg_cancel</refname>
 <refpurpose>
     stop scatter/gather i/o issued by <function>usb_sg_wait</function>
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>usb_sg_cancel </function></funcdef>
   <paramdef>struct usb_sg_request * <parameter>io</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>io</parameter></term>
   <listitem>
    <para>
     request block, initialized with <function>usb_sg_init</function>
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This stops a request after it has been started by <function>usb_sg_wait</function>.
   It can also prevents one initialized by <function>usb_sg_init</function> from starting,
   so that call just frees resources allocated to the request.
</para>
</refsect1>
</refentry>

<refentry id="API-usb-get-descriptor">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>usb_get_descriptor</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>usb_get_descriptor</refname>
 <refpurpose>
     issues a generic GET_DESCRIPTOR request
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>usb_get_descriptor </function></funcdef>
   <paramdef>struct usb_device * <parameter>dev</parameter></paramdef>
   <paramdef>unsigned char <parameter>type</parameter></paramdef>
   <paramdef>unsigned char <parameter>index</parameter></paramdef>
   <paramdef>void * <parameter>buf</parameter></paramdef>
   <paramdef>int <parameter>size</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     the device whose descriptor is being retrieved
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>type</parameter></term>
   <listitem>
    <para>
     the descriptor type (USB_DT_*)
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>index</parameter></term>
   <listitem>
    <para>
     the number of the descriptor
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>buf</parameter></term>
   <listitem>
    <para>
     where to put the descriptor
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>size</parameter></term>
   <listitem>
    <para>
     how big is <quote>buf</quote>?
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Context</title>
<para>
   !in_interrupt ()
</para>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Gets a USB descriptor.  Convenience functions exist to simplify
   getting some types of descriptors.  Use
   <function>usb_get_string</function> or <function>usb_string</function> for USB_DT_STRING.
   Device (USB_DT_DEVICE) and configuration descriptors (USB_DT_CONFIG)
   are part of the device structure.
   In addition to a number of USB-standard descriptors, some
   devices also use class-specific or vendor-specific descriptors.
   </para><para>

   This call is synchronous, and may not be used in an interrupt context.
</para>
</refsect1>
<refsect1>
<title>Return</title>
<para>
   The number of bytes received on success, or else the status code
   returned by the underlying <function>usb_control_msg</function> call.
</para>
</refsect1>
</refentry>

<refentry id="API-usb-string">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>usb_string</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>usb_string</refname>
 <refpurpose>
     returns UTF-8 version of a string descriptor
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>usb_string </function></funcdef>
   <paramdef>struct usb_device * <parameter>dev</parameter></paramdef>
   <paramdef>int <parameter>index</parameter></paramdef>
   <paramdef>char * <parameter>buf</parameter></paramdef>
   <paramdef>size_t <parameter>size</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     the device whose string descriptor is being retrieved
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>index</parameter></term>
   <listitem>
    <para>
     the number of the descriptor
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>buf</parameter></term>
   <listitem>
    <para>
     where to put the string
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>size</parameter></term>
   <listitem>
    <para>
     how big is <quote>buf</quote>?
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Context</title>
<para>
   !in_interrupt ()
</para>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This converts the UTF-16LE encoded strings returned by devices, from
   <function>usb_get_string_descriptor</function>, to null-terminated UTF-8 encoded ones
   that are more usable in most kernel contexts.  Note that this function
   chooses strings in the first language supported by the device.
   </para><para>

   This call is synchronous, and may not be used in an interrupt context.
</para>
</refsect1>
<refsect1>
<title>Return</title>
<para>
   length of the string (&gt;= 0) or usb_control_msg status (&lt; 0).
</para>
</refsect1>
</refentry>

<refentry id="API-usb-get-status">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>usb_get_status</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>usb_get_status</refname>
 <refpurpose>
     issues a GET_STATUS call
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>usb_get_status </function></funcdef>
   <paramdef>struct usb_device * <parameter>dev</parameter></paramdef>
   <paramdef>int <parameter>type</parameter></paramdef>
   <paramdef>int <parameter>target</parameter></paramdef>
   <paramdef>void * <parameter>data</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     the device whose status is being checked
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>type</parameter></term>
   <listitem>
    <para>
     USB_RECIP_*; for device, interface, or endpoint
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>target</parameter></term>
   <listitem>
    <para>
     zero (for device), else interface or endpoint number
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>data</parameter></term>
   <listitem>
    <para>
     pointer to two bytes of bitmap data
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Context</title>
<para>
   !in_interrupt ()
</para>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Returns device, interface, or endpoint status.  Normally only of
   interest to see if the device is self powered, or has enabled the
   remote wakeup facility; or whether a bulk or interrupt endpoint
   is halted (<quote>stalled</quote>).
   </para><para>

   Bits in these status bitmaps are set using the SET_FEATURE request,
   and cleared using the CLEAR_FEATURE request.  The <function>usb_clear_halt</function>
   function should be used to clear halt (<quote>stall</quote>) status.
   </para><para>

   This call is synchronous, and may not be used in an interrupt context.
   </para><para>

   Returns 0 and the status value in *<parameter>data</parameter> (in host byte order) on success,
   or else the status code from the underlying <function>usb_control_msg</function> call.
</para>
</refsect1>
</refentry>

<refentry id="API-usb-clear-halt">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>usb_clear_halt</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>usb_clear_halt</refname>
 <refpurpose>
     tells device to clear endpoint halt/stall condition
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>usb_clear_halt </function></funcdef>
   <paramdef>struct usb_device * <parameter>dev</parameter></paramdef>
   <paramdef>int <parameter>pipe</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     device whose endpoint is halted
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>pipe</parameter></term>
   <listitem>
    <para>
     endpoint <quote>pipe</quote> being cleared
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Context</title>
<para>
   !in_interrupt ()
</para>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This is used to clear halt conditions for bulk and interrupt endpoints,
   as reported by URB completion status.  Endpoints that are halted are
   sometimes referred to as being <quote>stalled</quote>.  Such endpoints are unable
   to transmit or receive data until the halt status is cleared.  Any URBs
   queued for such an endpoint should normally be unlinked by the driver
   before clearing the halt condition, as described in sections 5.7.5
   and 5.8.5 of the USB 2.0 spec.
   </para><para>

   Note that control and isochronous endpoints don't halt, although control
   endpoints report <quote>protocol stall</quote> (for unsupported requests) using the
   same status code used to report a true stall.
   </para><para>

   This call is synchronous, and may not be used in an interrupt context.
</para>
</refsect1>
<refsect1>
<title>Return</title>
<para>
   Zero on success, or else the status code returned by the
   underlying <function>usb_control_msg</function> call.
</para>
</refsect1>
</refentry>

<refentry id="API-usb-reset-endpoint">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>usb_reset_endpoint</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>usb_reset_endpoint</refname>
 <refpurpose>
     Reset an endpoint's state.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>usb_reset_endpoint </function></funcdef>
   <paramdef>struct usb_device * <parameter>dev</parameter></paramdef>
   <paramdef>unsigned int <parameter>epaddr</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     the device whose endpoint is to be reset
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>epaddr</parameter></term>
   <listitem>
    <para>
     the endpoint's address.  Endpoint number for output,
     endpoint number + USB_DIR_IN for input
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Resets any host-side endpoint state such as the toggle bit,
   sequence number or current window.
</para>
</refsect1>
</refentry>

<refentry id="API-usb-set-interface">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>usb_set_interface</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>usb_set_interface</refname>
 <refpurpose>
     Makes a particular alternate setting be current
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>usb_set_interface </function></funcdef>
   <paramdef>struct usb_device * <parameter>dev</parameter></paramdef>
   <paramdef>int <parameter>interface</parameter></paramdef>
   <paramdef>int <parameter>alternate</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     the device whose interface is being updated
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>interface</parameter></term>
   <listitem>
    <para>
     the interface being updated
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>alternate</parameter></term>
   <listitem>
    <para>
     the setting being chosen.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Context</title>
<para>
   !in_interrupt ()
</para>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This is used to enable data transfers on interfaces that may not
   be enabled by default.  Not all devices support such configurability.
   Only the driver bound to an interface may change its setting.
   </para><para>

   Within any given configuration, each interface may have several
   alternative settings.  These are often used to control levels of
   bandwidth consumption.  For example, the default setting for a high
   speed interrupt endpoint may not send more than 64 bytes per microframe,
   while interrupt transfers of up to 3KBytes per microframe are legal.
   Also, isochronous endpoints may never be part of an
   interface's default setting.  To access such bandwidth, alternate
   interface settings must be made current.
   </para><para>

   Note that in the Linux USB subsystem, bandwidth associated with
   an endpoint in a given alternate setting is not reserved until an URB
   is submitted that needs that bandwidth.  Some other operating systems
   allocate bandwidth early, when a configuration is chosen.
   </para><para>

   xHCI reserves bandwidth and configures the alternate setting in
   <function>usb_hcd_alloc_bandwidth</function>. If it fails the original interface altsetting
   may be disabled. Drivers cannot rely on any particular alternate
   setting being in effect after a failure.
   </para><para>

   This call is synchronous, and may not be used in an interrupt context.
   Also, drivers must not change altsettings while urbs are scheduled for
   endpoints in that interface; all such urbs must first be completed
   (perhaps forced by unlinking).
</para>
</refsect1>
<refsect1>
<title>Return</title>
<para>
   Zero on success, or else the status code returned by the
   underlying <function>usb_control_msg</function> call.
</para>
</refsect1>
</refentry>

<refentry id="API-usb-reset-configuration">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>usb_reset_configuration</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>usb_reset_configuration</refname>
 <refpurpose>
     lightweight device reset
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>usb_reset_configuration </function></funcdef>
   <paramdef>struct usb_device * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     the device whose configuration is being reset
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This issues a standard SET_CONFIGURATION request to the device using
   the current configuration.  The effect is to reset most USB-related
   state in the device, including interface altsettings (reset to zero),
   endpoint halts (cleared), and endpoint state (only for bulk and interrupt
   endpoints).  Other usbcore state is unchanged, including bindings of
   usb device drivers to interfaces.
   </para><para>

   Because this affects multiple interfaces, avoid using this with composite
   (multi-interface) devices.  Instead, the driver for each interface may
   use <function>usb_set_interface</function> on the interfaces it claims.  Be careful though;
   some devices don't support the SET_INTERFACE request, and others won't
   reset all the interface state (notably endpoint state).  Resetting the whole
   configuration would affect other drivers' interfaces.
   </para><para>

   The caller must own the device lock.
</para>
</refsect1>
<refsect1>
<title>Return</title>
<para>
   Zero on success, else a negative error code.
</para>
</refsect1>
</refentry>

<refentry id="API-usb-driver-set-configuration">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>usb_driver_set_configuration</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>usb_driver_set_configuration</refname>
 <refpurpose>
     Provide a way for drivers to change device configurations
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>usb_driver_set_configuration </function></funcdef>
   <paramdef>struct usb_device * <parameter>udev</parameter></paramdef>
   <paramdef>int <parameter>config</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>udev</parameter></term>
   <listitem>
    <para>
     the device whose configuration is being updated
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>config</parameter></term>
   <listitem>
    <para>
     the configuration being chosen.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Context</title>
<para>
   In process context, must be able to sleep
</para>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Device interface drivers are not allowed to change device configurations.
   This is because changing configurations will destroy the interface the
   driver is bound to and create new ones; it would be like a floppy-disk
   driver telling the computer to replace the floppy-disk drive with a
   tape drive!
   </para><para>

   Still, in certain specialized circumstances the need may arise.  This
   routine gets around the normal restrictions by using a work thread to
   submit the change-config request.
</para>
</refsect1>
<refsect1>
<title>Return</title>
<para>
   0 if the request was successfully queued, error code otherwise.
   The caller has no way to know whether the queued request will eventually
   succeed.
</para>
</refsect1>
</refentry>

<!-- drivers/usb/core/file.c -->
<refentry id="API-usb-register-dev">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>usb_register_dev</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>usb_register_dev</refname>
 <refpurpose>
  register a USB device, and ask for a minor number
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>usb_register_dev </function></funcdef>
   <paramdef>struct usb_interface * <parameter>intf</parameter></paramdef>
   <paramdef>struct usb_class_driver * <parameter>class_driver</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>intf</parameter></term>
   <listitem>
    <para>
     pointer to the usb_interface that is being registered
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>class_driver</parameter></term>
   <listitem>
    <para>
     pointer to the usb_class_driver for this device
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This should be called by all USB drivers that use the USB major number.
   If CONFIG_USB_DYNAMIC_MINORS is enabled, the minor number will be
   dynamically allocated out of the list of available ones.  If it is not
   enabled, the minor number will be based on the next available free minor,
   starting at the class_driver-&gt;minor_base.
   </para><para>

   This function also creates a usb class device in the sysfs tree.
   </para><para>

   <function>usb_deregister_dev</function> must be called when the driver is done with
   the minor numbers given out by this function.
</para>
</refsect1>
<refsect1>
<title>Return</title>
<para>
   -EINVAL if something bad happens with trying to register a
   device, and 0 on success.
</para>
</refsect1>
</refentry>

<refentry id="API-usb-deregister-dev">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>usb_deregister_dev</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>usb_deregister_dev</refname>
 <refpurpose>
     deregister a USB device's dynamic minor.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>usb_deregister_dev </function></funcdef>
   <paramdef>struct usb_interface * <parameter>intf</parameter></paramdef>
   <paramdef>struct usb_class_driver * <parameter>class_driver</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>intf</parameter></term>
   <listitem>
    <para>
     pointer to the usb_interface that is being deregistered
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>class_driver</parameter></term>
   <listitem>
    <para>
     pointer to the usb_class_driver for this device
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Used in conjunction with <function>usb_register_dev</function>.  This function is called
   when the USB driver is finished with the minor numbers gotten from a
   call to <function>usb_register_dev</function> (usually when the device is disconnected
   from the system.)
   </para><para>

   This function also removes the usb class device from the sysfs tree.
   </para><para>

   This should be called by all drivers that use the USB major number.
</para>
</refsect1>
</refentry>

<!-- drivers/usb/core/driver.c -->
<refentry id="API-usb-driver-claim-interface">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>usb_driver_claim_interface</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>usb_driver_claim_interface</refname>
 <refpurpose>
  bind a driver to an interface
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>usb_driver_claim_interface </function></funcdef>
   <paramdef>struct usb_driver * <parameter>driver</parameter></paramdef>
   <paramdef>struct usb_interface * <parameter>iface</parameter></paramdef>
   <paramdef>void * <parameter>priv</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>driver</parameter></term>
   <listitem>
    <para>
     the driver to be bound
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>iface</parameter></term>
   <listitem>
    <para>
     the interface to which it will be bound; must be in the
     usb device's active configuration
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>priv</parameter></term>
   <listitem>
    <para>
     driver data associated with that interface
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This is used by usb device drivers that need to claim more than one
   interface on a device when probing (audio and acm are current examples).
   No device driver should directly modify internal usb_interface or
   usb_device structure members.
   </para><para>

   Few drivers should need to use this routine, since the most natural
   way to bind to an interface is to return the private data from
   the driver's <function>probe</function> method.
   </para><para>

   Callers must own the device lock, so driver <function>probe</function> entries don't need
   extra locking, but other call contexts may need to explicitly claim that
   lock.
</para>
</refsect1>
<refsect1>
<title>Return</title>
<para>
   0 on success.
</para>
</refsect1>
</refentry>

<refentry id="API-usb-driver-release-interface">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>usb_driver_release_interface</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>usb_driver_release_interface</refname>
 <refpurpose>
     unbind a driver from an interface
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>usb_driver_release_interface </function></funcdef>
   <paramdef>struct usb_driver * <parameter>driver</parameter></paramdef>
   <paramdef>struct usb_interface * <parameter>iface</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>driver</parameter></term>
   <listitem>
    <para>
     the driver to be unbound
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>iface</parameter></term>
   <listitem>
    <para>
     the interface from which it will be unbound
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This can be used by drivers to release an interface without waiting
   for their <function>disconnect</function> methods to be called.  In typical cases this
   also causes the driver <function>disconnect</function> method to be called.
   </para><para>

   This call is synchronous, and may not be used in an interrupt context.
   Callers must own the device lock, so driver <function>disconnect</function> entries don't
   need extra locking, but other call contexts may need to explicitly claim
   that lock.
</para>
</refsect1>
</refentry>

<refentry id="API-usb-match-id">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>usb_match_id</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>usb_match_id</refname>
 <refpurpose>
     find first usb_device_id matching device or interface
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>const struct usb_device_id * <function>usb_match_id </function></funcdef>
   <paramdef>struct usb_interface * <parameter>interface</parameter></paramdef>
   <paramdef>const struct usb_device_id * <parameter>id</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>interface</parameter></term>
   <listitem>
    <para>
     the interface of interest
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>id</parameter></term>
   <listitem>
    <para>
     array of usb_device_id structures, terminated by zero entry
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   usb_match_id searches an array of usb_device_id's and returns
   the first one matching the device or interface, or null.
   This is used when binding (or rebinding) a driver to an interface.
   Most USB device drivers will use this indirectly, through the usb core,
   but some layered driver frameworks use it directly.
   These device tables are exported with MODULE_DEVICE_TABLE, through
   modutils, to support the driver loading functionality of USB hotplugging.
</para>
</refsect1>
<refsect1>
<title>Return</title>
<para>
   The first matching usb_device_id, or <constant>NULL</constant>.
</para>
</refsect1>
<refsect1>
<title>What Matches</title>
<para>
   </para><para>

   The <quote>match_flags</quote> element in a usb_device_id controls which
   members are used.  If the corresponding bit is set, the
   value in the device_id must match its corresponding member
   in the device or interface descriptor, or else the device_id
   does not match.
   </para><para>

   <quote>driver_info</quote> is normally used only by device drivers,
   but you can create a wildcard <quote>matches anything</quote> usb_device_id
   as a driver's <quote>modules.usbmap</quote> entry if you provide an id with
   only a nonzero <quote>driver_info</quote> field.  If you do this, the USB device
   driver's <function>probe</function> routine should use additional intelligence to
   decide whether to bind to the specified interface.
</para>
</refsect1>
<refsect1>
<title>What Makes Good usb_device_id Tables</title>
<para>
   </para><para>

   The match algorithm is very simple, so that intelligence in
   driver selection must come from smart driver id records.
   Unless you have good reasons to use another selection policy,
   provide match elements only in related groups, and order match
   specifiers from specific to general.  Use the macros provided
   for that purpose if you can.
   </para><para>

   The most specific match specifiers use device descriptor
   data.  These are commonly used with product-specific matches;
   the USB_DEVICE macro lets you provide vendor and product IDs,
   and you can also match against ranges of product revisions.
   These are widely used for devices with application or vendor
   specific bDeviceClass values.
   </para><para>

   Matches based on device class/subclass/protocol specifications
   are slightly more general; use the USB_DEVICE_INFO macro, or
   its siblings.  These are used with single-function devices
   where bDeviceClass doesn't specify that each interface has
   its own class.
   </para><para>

   Matches based on interface class/subclass/protocol are the
   most general; they let drivers bind to any interface on a
   multiple-function device.  Use the USB_INTERFACE_INFO
   macro, or its siblings, to match class-per-interface style
   devices (as recorded in bInterfaceClass).
   </para><para>

   Note that an entry created by USB_INTERFACE_INFO won't match
   any interface if the device class is set to Vendor-Specific.
   This is deliberate; according to the USB spec the meanings of
   the interface class/subclass/protocol for these devices are also
   vendor-specific, and hence matching against a standard product
   class wouldn't work anyway.  If you really want to use an
   interface-based match for such a device, create a match record
   that also specifies the vendor ID.  (Unforunately there isn't a
   standard macro for creating records like this.)
   </para><para>

   Within those groups, remember that not all combinations are
   meaningful.  For example, don't give a product version range
   without vendor and product IDs; or specify a protocol without
   its associated class and subclass.
</para>
</refsect1>
</refentry>

<refentry id="API-usb-register-device-driver">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>usb_register_device_driver</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>usb_register_device_driver</refname>
 <refpurpose>
     register a USB device (not interface) driver
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>usb_register_device_driver </function></funcdef>
   <paramdef>struct usb_device_driver * <parameter>new_udriver</parameter></paramdef>
   <paramdef>struct module * <parameter>owner</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>new_udriver</parameter></term>
   <listitem>
    <para>
     USB operations for the device driver
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>owner</parameter></term>
   <listitem>
    <para>
     module owner of this driver.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Registers a USB device driver with the USB core.  The list of
   unattached devices will be rescanned whenever a new driver is
   added, allowing the new driver to attach to any recognized devices.
</para>
</refsect1>
<refsect1>
<title>Return</title>
<para>
   A negative error code on failure and 0 on success.
</para>
</refsect1>
</refentry>

<refentry id="API-usb-deregister-device-driver">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>usb_deregister_device_driver</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>usb_deregister_device_driver</refname>
 <refpurpose>
     unregister a USB device (not interface) driver
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>usb_deregister_device_driver </function></funcdef>
   <paramdef>struct usb_device_driver * <parameter>udriver</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>udriver</parameter></term>
   <listitem>
    <para>
     USB operations of the device driver to unregister
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Context</title>
<para>
   must be able to sleep
</para>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Unlinks the specified driver from the internal USB driver list.
</para>
</refsect1>
</refentry>

<refentry id="API-usb-register-driver">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>usb_register_driver</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>usb_register_driver</refname>
 <refpurpose>
     register a USB interface driver
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>usb_register_driver </function></funcdef>
   <paramdef>struct usb_driver * <parameter>new_driver</parameter></paramdef>
   <paramdef>struct module * <parameter>owner</parameter></paramdef>
   <paramdef>const char * <parameter>mod_name</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>new_driver</parameter></term>
   <listitem>
    <para>
     USB operations for the interface driver
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>owner</parameter></term>
   <listitem>
    <para>
     module owner of this driver.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>mod_name</parameter></term>
   <listitem>
    <para>
     module name string
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Registers a USB interface driver with the USB core.  The list of
   unattached interfaces will be rescanned whenever a new driver is
   added, allowing the new driver to attach to any recognized interfaces.
</para>
</refsect1>
<refsect1>
<title>Return</title>
<para>
   A negative error code on failure and 0 on success.
</para>
</refsect1>
<refsect1>
<title>NOTE</title>
<para>
   if you want your driver to use the USB major number, you must call
   <function>usb_register_dev</function> to enable that functionality.  This function no longer
   takes care of that.
</para>
</refsect1>
</refentry>

<refentry id="API-usb-deregister">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>usb_deregister</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>usb_deregister</refname>
 <refpurpose>
     unregister a USB interface driver
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>usb_deregister </function></funcdef>
   <paramdef>struct usb_driver * <parameter>driver</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>driver</parameter></term>
   <listitem>
    <para>
     USB operations of the interface driver to unregister
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Context</title>
<para>
   must be able to sleep
</para>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Unlinks the specified driver from the internal USB driver list.
</para>
</refsect1>
<refsect1>
<title>NOTE</title>
<para>
   If you called <function>usb_register_dev</function>, you still need to call
   <function>usb_deregister_dev</function> to clean up your driver's allocated minor numbers,
   this * call will no longer do it for you.
</para>
</refsect1>
</refentry>

<refentry id="API-usb-enable-autosuspend">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>usb_enable_autosuspend</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>usb_enable_autosuspend</refname>
 <refpurpose>
     allow a USB device to be autosuspended
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>usb_enable_autosuspend </function></funcdef>
   <paramdef>struct usb_device * <parameter>udev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>udev</parameter></term>
   <listitem>
    <para>
     the USB device which may be autosuspended
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This routine allows <parameter>udev</parameter> to be autosuspended.  An autosuspend won't
   take place until the autosuspend_delay has elapsed and all the other
   necessary conditions are satisfied.
   </para><para>

   The caller must hold <parameter>udev</parameter>'s device lock.
</para>
</refsect1>
</refentry>

<refentry id="API-usb-disable-autosuspend">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>usb_disable_autosuspend</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>usb_disable_autosuspend</refname>
 <refpurpose>
     prevent a USB device from being autosuspended
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>usb_disable_autosuspend </function></funcdef>
   <paramdef>struct usb_device * <parameter>udev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>udev</parameter></term>
   <listitem>
    <para>
     the USB device which may not be autosuspended
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This routine prevents <parameter>udev</parameter> from being autosuspended and wakes it up
   if it is already autosuspended.
   </para><para>

   The caller must hold <parameter>udev</parameter>'s device lock.
</para>
</refsect1>
</refentry>

<refentry id="API-usb-autopm-put-interface">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>usb_autopm_put_interface</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>usb_autopm_put_interface</refname>
 <refpurpose>
     decrement a USB interface's PM-usage counter
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>usb_autopm_put_interface </function></funcdef>
   <paramdef>struct usb_interface * <parameter>intf</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>intf</parameter></term>
   <listitem>
    <para>
     the usb_interface whose counter should be decremented
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This routine should be called by an interface driver when it is
   finished using <parameter>intf</parameter> and wants to allow it to autosuspend.  A typical
   example would be a character-device driver when its device file is
   closed.
   </para><para>

   The routine decrements <parameter>intf</parameter>'s usage counter.  When the counter reaches
   0, a delayed autosuspend request for <parameter>intf</parameter>'s device is attempted.  The
   attempt may fail (see <function>autosuspend_check</function>).
   </para><para>

   This routine can run only in process context.
</para>
</refsect1>
</refentry>

<refentry id="API-usb-autopm-put-interface-async">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>usb_autopm_put_interface_async</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>usb_autopm_put_interface_async</refname>
 <refpurpose>
     decrement a USB interface's PM-usage counter
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>usb_autopm_put_interface_async </function></funcdef>
   <paramdef>struct usb_interface * <parameter>intf</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>intf</parameter></term>
   <listitem>
    <para>
     the usb_interface whose counter should be decremented
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This routine does much the same thing as <function>usb_autopm_put_interface</function>:
   It decrements <parameter>intf</parameter>'s usage counter and schedules a delayed
   autosuspend request if the counter is &lt;= 0.  The difference is that it
   does not perform any synchronization; callers should hold a private
   lock and handle all synchronization issues themselves.
   </para><para>

   Typically a driver would call this routine during an URB's completion
   handler, if no more URBs were pending.
   </para><para>

   This routine can run in atomic context.
</para>
</refsect1>
</refentry>

<refentry id="API-usb-autopm-put-interface-no-suspend">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>usb_autopm_put_interface_no_suspend</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>usb_autopm_put_interface_no_suspend</refname>
 <refpurpose>
     decrement a USB interface's PM-usage counter
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>usb_autopm_put_interface_no_suspend </function></funcdef>
   <paramdef>struct usb_interface * <parameter>intf</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>intf</parameter></term>
   <listitem>
    <para>
     the usb_interface whose counter should be decremented
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This routine decrements <parameter>intf</parameter>'s usage counter but does not carry out an
   autosuspend.
   </para><para>

   This routine can run in atomic context.
</para>
</refsect1>
</refentry>

<refentry id="API-usb-autopm-get-interface">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>usb_autopm_get_interface</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>usb_autopm_get_interface</refname>
 <refpurpose>
     increment a USB interface's PM-usage counter
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>usb_autopm_get_interface </function></funcdef>
   <paramdef>struct usb_interface * <parameter>intf</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>intf</parameter></term>
   <listitem>
    <para>
     the usb_interface whose counter should be incremented
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This routine should be called by an interface driver when it wants to
   use <parameter>intf</parameter> and needs to guarantee that it is not suspended.  In addition,
   the routine prevents <parameter>intf</parameter> from being autosuspended subsequently.  (Note
   that this will not prevent suspend events originating in the PM core.)
   This prevention will persist until <function>usb_autopm_put_interface</function> is called
   or <parameter>intf</parameter> is unbound.  A typical example would be a character-device
   driver when its device file is opened.
   </para><para>

   <parameter>intf</parameter>'s usage counter is incremented to prevent subsequent autosuspends.
   However if the autoresume fails then the counter is re-decremented.
   </para><para>

   This routine can run only in process context.
</para>
</refsect1>
<refsect1>
<title>Return</title>
<para>
   0 on success.
</para>
</refsect1>
</refentry>

<refentry id="API-usb-autopm-get-interface-async">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>usb_autopm_get_interface_async</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>usb_autopm_get_interface_async</refname>
 <refpurpose>
     increment a USB interface's PM-usage counter
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>usb_autopm_get_interface_async </function></funcdef>
   <paramdef>struct usb_interface * <parameter>intf</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>intf</parameter></term>
   <listitem>
    <para>
     the usb_interface whose counter should be incremented
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This routine does much the same thing as
   <function>usb_autopm_get_interface</function>: It increments <parameter>intf</parameter>'s usage counter and
   queues an autoresume request if the device is suspended.  The
   differences are that it does not perform any synchronization (callers
   should hold a private lock and handle all synchronization issues
   themselves), and it does not autoresume the device directly (it only
   queues a request).  After a successful call, the device may not yet be
   resumed.
   </para><para>

   This routine can run in atomic context.
</para>
</refsect1>
<refsect1>
<title>Return</title>
<para>
   0 on success. A negative error code otherwise.
</para>
</refsect1>
</refentry>

<refentry id="API-usb-autopm-get-interface-no-resume">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>usb_autopm_get_interface_no_resume</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>usb_autopm_get_interface_no_resume</refname>
 <refpurpose>
     increment a USB interface's PM-usage counter
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>usb_autopm_get_interface_no_resume </function></funcdef>
   <paramdef>struct usb_interface * <parameter>intf</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>intf</parameter></term>
   <listitem>
    <para>
     the usb_interface whose counter should be incremented
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This routine increments <parameter>intf</parameter>'s usage counter but does not carry out an
   autoresume.
   </para><para>

   This routine can run in atomic context.
</para>
</refsect1>
</refentry>

<!-- drivers/usb/core/usb.c -->
<refentry id="API-usb-find-alt-setting">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>usb_find_alt_setting</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>usb_find_alt_setting</refname>
 <refpurpose>
  Given a configuration, find the alternate setting for the given interface.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct usb_host_interface * <function>usb_find_alt_setting </function></funcdef>
   <paramdef>struct usb_host_config * <parameter>config</parameter></paramdef>
   <paramdef>unsigned int <parameter>iface_num</parameter></paramdef>
   <paramdef>unsigned int <parameter>alt_num</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>config</parameter></term>
   <listitem>
    <para>
     the configuration to search (not necessarily the current config).
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>iface_num</parameter></term>
   <listitem>
    <para>
     interface number to search in
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>alt_num</parameter></term>
   <listitem>
    <para>
     alternate interface setting number to search for.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Search the configuration's interface cache for the given alt setting.
</para>
</refsect1>
<refsect1>
<title>Return</title>
<para>
   The alternate setting, if found. <constant>NULL</constant> otherwise.
</para>
</refsect1>
</refentry>

<refentry id="API-usb-ifnum-to-if">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>usb_ifnum_to_if</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>usb_ifnum_to_if</refname>
 <refpurpose>
     get the interface object with a given interface number
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct usb_interface * <function>usb_ifnum_to_if </function></funcdef>
   <paramdef>const struct usb_device * <parameter>dev</parameter></paramdef>
   <paramdef>unsigned <parameter>ifnum</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     the device whose current configuration is considered
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>ifnum</parameter></term>
   <listitem>
    <para>
     the desired interface
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This walks the device descriptor for the currently active configuration
   to find the interface object with the particular interface number.
   </para><para>

   Note that configuration descriptors are not required to assign interface
   numbers sequentially, so that it would be incorrect to assume that
   the first interface in that descriptor corresponds to interface zero.
   This routine helps device drivers avoid such mistakes.
   However, you should make sure that you do the right thing with any
   alternate settings available for this interfaces.
   </para><para>

   Don't call this function unless you are bound to one of the interfaces
   on this device or you have locked the device!
</para>
</refsect1>
<refsect1>
<title>Return</title>
<para>
   A pointer to the interface that has <parameter>ifnum</parameter> as interface number,
   if found. <constant>NULL</constant> otherwise.
</para>
</refsect1>
</refentry>

<refentry id="API-usb-altnum-to-altsetting">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>usb_altnum_to_altsetting</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>usb_altnum_to_altsetting</refname>
 <refpurpose>
     get the altsetting structure with a given alternate setting number.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct usb_host_interface * <function>usb_altnum_to_altsetting </function></funcdef>
   <paramdef>const struct usb_interface * <parameter>intf</parameter></paramdef>
   <paramdef>unsigned int <parameter>altnum</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>intf</parameter></term>
   <listitem>
    <para>
     the interface containing the altsetting in question
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>altnum</parameter></term>
   <listitem>
    <para>
     the desired alternate setting number
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This searches the altsetting array of the specified interface for
   an entry with the correct bAlternateSetting value.
   </para><para>

   Note that altsettings need not be stored sequentially by number, so
   it would be incorrect to assume that the first altsetting entry in
   the array corresponds to altsetting zero.  This routine helps device
   drivers avoid such mistakes.
   </para><para>

   Don't call this function unless you are bound to the intf interface
   or you have locked the device!
</para>
</refsect1>
<refsect1>
<title>Return</title>
<para>
   A pointer to the entry of the altsetting array of <parameter>intf</parameter> that
   has <parameter>altnum</parameter> as the alternate setting number. <constant>NULL</constant> if not found.
</para>
</refsect1>
</refentry>

<refentry id="API-usb-find-interface">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>usb_find_interface</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>usb_find_interface</refname>
 <refpurpose>
     find usb_interface pointer for driver and device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct usb_interface * <function>usb_find_interface </function></funcdef>
   <paramdef>struct usb_driver * <parameter>drv</parameter></paramdef>
   <paramdef>int <parameter>minor</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>drv</parameter></term>
   <listitem>
    <para>
     the driver whose current configuration is considered
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>minor</parameter></term>
   <listitem>
    <para>
     the minor number of the desired device
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This walks the bus device list and returns a pointer to the interface
   with the matching minor and driver.  Note, this only works for devices
   that share the USB major number.
</para>
</refsect1>
<refsect1>
<title>Return</title>
<para>
   A pointer to the interface with the matching major and <parameter>minor</parameter>.
</para>
</refsect1>
</refentry>

<refentry id="API-usb-for-each-dev">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>usb_for_each_dev</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>usb_for_each_dev</refname>
 <refpurpose>
     iterate over all USB devices in the system
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>usb_for_each_dev </function></funcdef>
   <paramdef>void * <parameter>data</parameter></paramdef>
   <paramdef>int (*<parameter>fn</parameter>)
     <funcparams>struct usb_device *, void *</funcparams></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>data</parameter></term>
   <listitem>
    <para>
     data pointer that will be handed to the callback function
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>fn</parameter></term>
   <listitem>
    <para>
     callback function to be called for each USB device
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Iterate over all USB devices and call <parameter>fn</parameter> for each, passing it <parameter>data</parameter>. If it
   returns anything other than 0, we break the iteration prematurely and return
   that value.
</para>
</refsect1>
</refentry>

<refentry id="API-usb-alloc-dev">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>usb_alloc_dev</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>usb_alloc_dev</refname>
 <refpurpose>
     usb device constructor (usbcore-internal)
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct usb_device * <function>usb_alloc_dev </function></funcdef>
   <paramdef>struct usb_device * <parameter>parent</parameter></paramdef>
   <paramdef>struct usb_bus * <parameter>bus</parameter></paramdef>
   <paramdef>unsigned <parameter>port1</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>parent</parameter></term>
   <listitem>
    <para>
     hub to which device is connected; null to allocate a root hub
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>bus</parameter></term>
   <listitem>
    <para>
     bus used to access the device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>port1</parameter></term>
   <listitem>
    <para>
     one-based index of port; ignored for root hubs
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Context</title>
<para>
   !<function>in_interrupt</function>
</para>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Only hub drivers (including virtual root hub drivers for host
   controllers) should ever call this.
   </para><para>

   This call may not be used in a non-sleeping context.
</para>
</refsect1>
<refsect1>
<title>Return</title>
<para>
   On success, a pointer to the allocated usb device. <constant>NULL</constant> on
   failure.
</para>
</refsect1>
</refentry>

<refentry id="API-usb-get-dev">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>usb_get_dev</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>usb_get_dev</refname>
 <refpurpose>
     increments the reference count of the usb device structure
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct usb_device * <function>usb_get_dev </function></funcdef>
   <paramdef>struct usb_device * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     the device being referenced
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Each live reference to a device should be refcounted.
   </para><para>

   Drivers for USB interfaces should normally record such references in
   their <function>probe</function> methods, when they bind to an interface, and release
   them by calling <function>usb_put_dev</function>, in their <function>disconnect</function> methods.
</para>
</refsect1>
<refsect1>
<title>Return</title>
<para>
   A pointer to the device with the incremented reference counter.
</para>
</refsect1>
</refentry>

<refentry id="API-usb-put-dev">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>usb_put_dev</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>usb_put_dev</refname>
 <refpurpose>
     release a use of the usb device structure
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>usb_put_dev </function></funcdef>
   <paramdef>struct usb_device * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     device that's been disconnected
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Must be called when a user of a device is finished with it.  When the last
   user of the device calls this function, the memory of the device is freed.
</para>
</refsect1>
</refentry>

<refentry id="API-usb-get-intf">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>usb_get_intf</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>usb_get_intf</refname>
 <refpurpose>
     increments the reference count of the usb interface structure
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct usb_interface * <function>usb_get_intf </function></funcdef>
   <paramdef>struct usb_interface * <parameter>intf</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>intf</parameter></term>
   <listitem>
    <para>
     the interface being referenced
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Each live reference to a interface must be refcounted.
   </para><para>

   Drivers for USB interfaces should normally record such references in
   their <function>probe</function> methods, when they bind to an interface, and release
   them by calling <function>usb_put_intf</function>, in their <function>disconnect</function> methods.
</para>
</refsect1>
<refsect1>
<title>Return</title>
<para>
   A pointer to the interface with the incremented reference counter.
</para>
</refsect1>
</refentry>

<refentry id="API-usb-put-intf">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>usb_put_intf</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>usb_put_intf</refname>
 <refpurpose>
     release a use of the usb interface structure
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>usb_put_intf </function></funcdef>
   <paramdef>struct usb_interface * <parameter>intf</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>intf</parameter></term>
   <listitem>
    <para>
     interface that's been decremented
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Must be called when a user of an interface is finished with it.  When the
   last user of the interface calls this function, the memory of the interface
   is freed.
</para>
</refsect1>
</refentry>

<refentry id="API-usb-lock-device-for-reset">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>usb_lock_device_for_reset</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>usb_lock_device_for_reset</refname>
 <refpurpose>
     cautiously acquire the lock for a usb device structure
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>usb_lock_device_for_reset </function></funcdef>
   <paramdef>struct usb_device * <parameter>udev</parameter></paramdef>
   <paramdef>const struct usb_interface * <parameter>iface</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>udev</parameter></term>
   <listitem>
    <para>
     device that's being locked
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>iface</parameter></term>
   <listitem>
    <para>
     interface bound to the driver making the request (optional)
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Attempts to acquire the device lock, but fails if the device is
   NOTATTACHED or SUSPENDED, or if iface is specified and the interface
   is neither BINDING nor BOUND.  Rather than sleeping to wait for the
   lock, the routine polls repeatedly.  This is to prevent deadlock with
   disconnect; in some drivers (such as usb-storage) the <function>disconnect</function>
   or <function>suspend</function> method will block waiting for a device reset to complete.
</para>
</refsect1>
<refsect1>
<title>Return</title>
<para>
   A negative error code for failure, otherwise 0.
</para>
</refsect1>
</refentry>

<refentry id="API-usb-get-current-frame-number">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>usb_get_current_frame_number</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>usb_get_current_frame_number</refname>
 <refpurpose>
     return current bus frame number
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>usb_get_current_frame_number </function></funcdef>
   <paramdef>struct usb_device * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     the device whose bus is being queried
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Return</title>
<para>
   The current frame number for the USB host controller used
   with the given USB device. This can be used when scheduling
   isochronous requests.
</para>
</refsect1>
<refsect1>
<title>Note</title>
<para>
   Different kinds of host controller have different <quote>scheduling
   horizons</quote>. While one type might support scheduling only 32 frames
   into the future, others could support scheduling up to 1024 frames
   into the future.
</para>
</refsect1>
</refentry>

<refentry id="API-usb-alloc-coherent">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>usb_alloc_coherent</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>usb_alloc_coherent</refname>
 <refpurpose>
     allocate dma-consistent buffer for URB_NO_xxx_DMA_MAP
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void * <function>usb_alloc_coherent </function></funcdef>
   <paramdef>struct usb_device * <parameter>dev</parameter></paramdef>
   <paramdef>size_t <parameter>size</parameter></paramdef>
   <paramdef>gfp_t <parameter>mem_flags</parameter></paramdef>
   <paramdef>dma_addr_t * <parameter>dma</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     device the buffer will be used with
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>size</parameter></term>
   <listitem>
    <para>
     requested buffer size
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>mem_flags</parameter></term>
   <listitem>
    <para>
     affect whether allocation may block
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>dma</parameter></term>
   <listitem>
    <para>
     used to return DMA address of buffer
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Return</title>
<para>
   Either null (indicating no buffer could be allocated), or the
   cpu-space pointer to a buffer that may be used to perform DMA to the
   specified device.  Such cpu-space buffers are returned along with the DMA
   address (through the pointer provided).
</para>
</refsect1>
<refsect1>
<title>Note</title>
<para>
   These buffers are used with URB_NO_xxx_DMA_MAP set in urb-&gt;transfer_flags
   to avoid behaviors like using <quote>DMA bounce buffers</quote>, or thrashing IOMMU
   hardware during URB completion/resubmit.  The implementation varies between
   platforms, depending on details of how DMA will work to this device.
   Using these buffers also eliminates cacheline sharing problems on
   architectures where CPU caches are not DMA-coherent.  On systems without
   bus-snooping caches, these buffers are uncached.
   </para><para>

   When the buffer is no longer used, free it with <function>usb_free_coherent</function>.
</para>
</refsect1>
</refentry>

<refentry id="API-usb-free-coherent">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>usb_free_coherent</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>usb_free_coherent</refname>
 <refpurpose>
     free memory allocated with <function>usb_alloc_coherent</function>
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>usb_free_coherent </function></funcdef>
   <paramdef>struct usb_device * <parameter>dev</parameter></paramdef>
   <paramdef>size_t <parameter>size</parameter></paramdef>
   <paramdef>void * <parameter>addr</parameter></paramdef>
   <paramdef>dma_addr_t <parameter>dma</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     device the buffer was used with
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>size</parameter></term>
   <listitem>
    <para>
     requested buffer size
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>addr</parameter></term>
   <listitem>
    <para>
     CPU address of buffer
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>dma</parameter></term>
   <listitem>
    <para>
     DMA address of buffer
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This reclaims an I/O buffer, letting it be reused.  The memory must have
   been allocated using <function>usb_alloc_coherent</function>, and the parameters must match
   those provided in that allocation request.
</para>
</refsect1>
</refentry>

<refentry id="API-usb-buffer-map">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>usb_buffer_map</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>usb_buffer_map</refname>
 <refpurpose>
     create DMA mapping(s) for an urb
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct urb * <function>usb_buffer_map </function></funcdef>
   <paramdef>struct urb * <parameter>urb</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>urb</parameter></term>
   <listitem>
    <para>
     urb whose transfer_buffer/setup_packet will be mapped
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   URB_NO_TRANSFER_DMA_MAP is added to urb-&gt;transfer_flags if the operation
   succeeds. If the device is connected to this system through a non-DMA
   controller, this operation always succeeds.
   </para><para>

   This call would normally be used for an urb which is reused, perhaps
   as the target of a large periodic transfer, with <function>usb_buffer_dmasync</function>
   calls to synchronize memory and dma state.
   </para><para>

   Reverse the effect of this call with <function>usb_buffer_unmap</function>.
</para>
</refsect1>
<refsect1>
<title>Return</title>
<para>
   Either <constant>NULL</constant> (indicating no buffer could be mapped), or <parameter>urb</parameter>.
</para>
</refsect1>
</refentry>

<refentry id="API-usb-buffer-dmasync">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>usb_buffer_dmasync</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>usb_buffer_dmasync</refname>
 <refpurpose>
     synchronize DMA and CPU view of buffer(s)
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>usb_buffer_dmasync </function></funcdef>
   <paramdef>struct urb * <parameter>urb</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>urb</parameter></term>
   <listitem>
    <para>
     urb whose transfer_buffer/setup_packet will be synchronized
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-usb-buffer-unmap">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>usb_buffer_unmap</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>usb_buffer_unmap</refname>
 <refpurpose>
     free DMA mapping(s) for an urb
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>usb_buffer_unmap </function></funcdef>
   <paramdef>struct urb * <parameter>urb</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>urb</parameter></term>
   <listitem>
    <para>
     urb whose transfer_buffer will be unmapped
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Reverses the effect of <function>usb_buffer_map</function>.
</para>
</refsect1>
</refentry>

<refentry id="API-usb-buffer-map-sg">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>usb_buffer_map_sg</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>usb_buffer_map_sg</refname>
 <refpurpose>
     create scatterlist DMA mapping(s) for an endpoint
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>usb_buffer_map_sg </function></funcdef>
   <paramdef>const struct usb_device * <parameter>dev</parameter></paramdef>
   <paramdef>int <parameter>is_in</parameter></paramdef>
   <paramdef>struct scatterlist * <parameter>sg</parameter></paramdef>
   <paramdef>int <parameter>nents</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     device to which the scatterlist will be mapped
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>is_in</parameter></term>
   <listitem>
    <para>
     mapping transfer direction
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>sg</parameter></term>
   <listitem>
    <para>
     the scatterlist to map
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>nents</parameter></term>
   <listitem>
    <para>
     the number of entries in the scatterlist
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Return</title>
<para>
   Either &lt; 0 (indicating no buffers could be mapped), or the
   number of DMA mapping array entries in the scatterlist.
</para>
</refsect1>
<refsect1>
<title>Note</title>
<para>
   The caller is responsible for placing the resulting DMA addresses from
   the scatterlist into URB transfer buffer pointers, and for setting the
   URB_NO_TRANSFER_DMA_MAP transfer flag in each of those URBs.
   </para><para>

   Top I/O rates come from queuing URBs, instead of waiting for each one
   to complete before starting the next I/O.   This is particularly easy
   to do with scatterlists.  Just allocate and submit one URB for each DMA
   mapping entry returned, stopping on the first error or when all succeed.
   Better yet, use the usb_sg_*() calls, which do that (and more) for you.
   </para><para>

   This call would normally be used when translating scatterlist requests,
   rather than <function>usb_buffer_map</function>, since on some hardware (with IOMMUs) it
   may be able to coalesce mappings for improved I/O efficiency.
   </para><para>

   Reverse the effect of this call with <function>usb_buffer_unmap_sg</function>.
</para>
</refsect1>
</refentry>

<refentry id="API-usb-buffer-dmasync-sg">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>usb_buffer_dmasync_sg</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>usb_buffer_dmasync_sg</refname>
 <refpurpose>
     synchronize DMA and CPU view of scatterlist buffer(s)
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>usb_buffer_dmasync_sg </function></funcdef>
   <paramdef>const struct usb_device * <parameter>dev</parameter></paramdef>
   <paramdef>int <parameter>is_in</parameter></paramdef>
   <paramdef>struct scatterlist * <parameter>sg</parameter></paramdef>
   <paramdef>int <parameter>n_hw_ents</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     device to which the scatterlist will be mapped
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>is_in</parameter></term>
   <listitem>
    <para>
     mapping transfer direction
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>sg</parameter></term>
   <listitem>
    <para>
     the scatterlist to synchronize
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>n_hw_ents</parameter></term>
   <listitem>
    <para>
     the positive return value from usb_buffer_map_sg
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Use this when you are re-using a scatterlist's data buffers for
   another USB request.
</para>
</refsect1>
</refentry>

<refentry id="API-usb-buffer-unmap-sg">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>usb_buffer_unmap_sg</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>usb_buffer_unmap_sg</refname>
 <refpurpose>
     free DMA mapping(s) for a scatterlist
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>usb_buffer_unmap_sg </function></funcdef>
   <paramdef>const struct usb_device * <parameter>dev</parameter></paramdef>
   <paramdef>int <parameter>is_in</parameter></paramdef>
   <paramdef>struct scatterlist * <parameter>sg</parameter></paramdef>
   <paramdef>int <parameter>n_hw_ents</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     device to which the scatterlist will be mapped
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>is_in</parameter></term>
   <listitem>
    <para>
     mapping transfer direction
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>sg</parameter></term>
   <listitem>
    <para>
     the scatterlist to unmap
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>n_hw_ents</parameter></term>
   <listitem>
    <para>
     the positive return value from usb_buffer_map_sg
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Reverses the effect of <function>usb_buffer_map_sg</function>.
</para>
</refsect1>
</refentry>

<!-- drivers/usb/core/hub.c -->
<refentry id="API-usb-hub-clear-tt-buffer">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>usb_hub_clear_tt_buffer</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>usb_hub_clear_tt_buffer</refname>
 <refpurpose>
  clear control/bulk TT state in high speed hub
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>usb_hub_clear_tt_buffer </function></funcdef>
   <paramdef>struct urb * <parameter>urb</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>urb</parameter></term>
   <listitem>
    <para>
     an URB associated with the failed or incomplete split transaction
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   High speed HCDs use this to tell the hub driver that some split control or
   bulk transaction failed in a way that requires clearing internal state of
   a transaction translator.  This is normally detected (and reported) from
   interrupt context.
   </para><para>

   It may not be possible for that hub to handle additional full (or low)
   speed transactions until that state is fully cleared out.
</para>
</refsect1>
<refsect1>
<title>Return</title>
<para>
   0 if successful. A negative error code otherwise.
</para>
</refsect1>
</refentry>

<refentry id="API-usb-set-device-state">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>usb_set_device_state</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>usb_set_device_state</refname>
 <refpurpose>
     change a device's current state (usbcore, hcds)
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>usb_set_device_state </function></funcdef>
   <paramdef>struct usb_device * <parameter>udev</parameter></paramdef>
   <paramdef>enum usb_device_state <parameter>new_state</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>udev</parameter></term>
   <listitem>
    <para>
     pointer to device whose state should be changed
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>new_state</parameter></term>
   <listitem>
    <para>
     new state value to be stored
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   udev-&gt;state is _not_ fully protected by the device lock.  Although
   most transitions are made only while holding the lock, the state can
   can change to USB_STATE_NOTATTACHED at almost any time.  This
   is so that devices can be marked as disconnected as soon as possible,
   without having to wait for any semaphores to be released.  As a result,
   all changes to any device's state must be protected by the
   device_state_lock spinlock.
   </para><para>

   Once a device has been added to the device tree, all changes to its state
   should be made using this routine.  The state should _not_ be set directly.
   </para><para>

   If udev-&gt;state is already USB_STATE_NOTATTACHED then no change is made.
   Otherwise udev-&gt;state is set to new_state, and if new_state is
   USB_STATE_NOTATTACHED then all of udev's descendants' states are also set
   to USB_STATE_NOTATTACHED.
</para>
</refsect1>
</refentry>

<refentry id="API-usb-root-hub-lost-power">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>usb_root_hub_lost_power</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>usb_root_hub_lost_power</refname>
 <refpurpose>
     called by HCD if the root hub lost Vbus power
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>usb_root_hub_lost_power </function></funcdef>
   <paramdef>struct usb_device * <parameter>rhdev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>rhdev</parameter></term>
   <listitem>
    <para>
     struct usb_device for the root hub
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   The USB host controller driver calls this function when its root hub
   is resumed and Vbus power has been interrupted or the controller
   has been reset.  The routine marks <parameter>rhdev</parameter> as having lost power.
   When the hub driver is resumed it will take notice and carry out
   power-session recovery for all the <quote>USB-PERSIST</quote>-enabled child devices;
   the others will be disconnected.
</para>
</refsect1>
</refentry>

<refentry id="API-usb-reset-device">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>usb_reset_device</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>usb_reset_device</refname>
 <refpurpose>
     warn interface drivers and perform a USB port reset
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>usb_reset_device </function></funcdef>
   <paramdef>struct usb_device * <parameter>udev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>udev</parameter></term>
   <listitem>
    <para>
     device to reset (not in SUSPENDED or NOTATTACHED state)
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Warns all drivers bound to registered interfaces (using their pre_reset
   method), performs the port reset, and then lets the drivers know that
   the reset is over (using their post_reset method).
</para>
</refsect1>
<refsect1>
<title>Return</title>
<para>
   The same as for <function>usb_reset_and_verify_device</function>.
</para>
</refsect1>
<refsect1>
<title>Note</title>
<para>
   The caller must own the device lock.  For example, it's safe to use
   this from a driver <function>probe</function> routine after downloading new firmware.
   For calls that might not occur during <function>probe</function>, drivers should lock
   the device using <function>usb_lock_device_for_reset</function>.
   </para><para>

   If an interface is currently being probed or disconnected, we assume
   its driver knows how to handle resets.  For all other interfaces,
   if the driver doesn't have pre_reset and post_reset methods then
   we attempt to unbind it and rebind afterward.
</para>
</refsect1>
</refentry>

<refentry id="API-usb-queue-reset-device">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>usb_queue_reset_device</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>usb_queue_reset_device</refname>
 <refpurpose>
     Reset a USB device from an atomic context
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>usb_queue_reset_device </function></funcdef>
   <paramdef>struct usb_interface * <parameter>iface</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>iface</parameter></term>
   <listitem>
    <para>
     USB interface belonging to the device to reset
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This function can be used to reset a USB device from an atomic
   context, where <function>usb_reset_device</function> won't work (as it blocks).
   </para><para>

   Doing a reset via this method is functionally equivalent to calling
   <function>usb_reset_device</function>, except for the fact that it is delayed to a
   workqueue. This means that any drivers bound to other interfaces
   might be unbound, as well as users from usbfs in user space.
</para>
</refsect1>
<refsect1>
<title>Corner cases</title>
<para>
   </para><para>

   - Scheduling two resets at the same time from two different drivers
   attached to two different interfaces of the same device is
   possible; depending on how the driver attached to each interface
   handles -&gt;<function>pre_reset</function>, the second reset might happen or not.
   </para><para>

   - If the reset is delayed so long that the interface is unbound from
   its driver, the reset will be skipped.
   </para><para>

   - This function can be called during .<function>probe</function>.  It can also be called
   during .<function>disconnect</function>, but doing so is pointless because the reset
   will not occur.  If you really want to reset the device during
   .<function>disconnect</function>, call <function>usb_reset_device</function> directly -- but watch out
   for nested unbinding issues!
</para>
</refsect1>
</refentry>

<refentry id="API-usb-hub-find-child">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>usb_hub_find_child</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>usb_hub_find_child</refname>
 <refpurpose>
     Get the pointer of child device attached to the port which is specified by <parameter>port1</parameter>.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct usb_device * <function>usb_hub_find_child </function></funcdef>
   <paramdef>struct usb_device * <parameter>hdev</parameter></paramdef>
   <paramdef>int <parameter>port1</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>hdev</parameter></term>
   <listitem>
    <para>
     USB device belonging to the usb hub
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>port1</parameter></term>
   <listitem>
    <para>
     port num to indicate which port the child device
     is attached to.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   USB drivers call this function to get hub's child device
   pointer.
</para>
</refsect1>
<refsect1>
<title>Return</title>
<para>
   <constant>NULL</constant> if input param is invalid and
   child's usb_device pointer if non-NULL.
</para>
</refsect1>
</refentry>

    </chapter>

    <chapter id="hcd"><title>Host Controller APIs</title>

    <para>These APIs are only for use by host controller drivers,
    most of which implement standard register interfaces such as
    EHCI, OHCI, or UHCI.
    UHCI was one of the first interfaces, designed by Intel and
    also used by VIA; it doesn't do much in hardware.
    OHCI was designed later, to have the hardware do more work
    (bigger transfers, tracking protocol state, and so on).
    EHCI was designed with USB 2.0; its design has features that
    resemble OHCI (hardware does much more work) as well as
    UHCI (some parts of ISO support, TD list processing).
    </para>

    <para>There are host controllers other than the "big three",
    although most PCI based controllers (and a few non-PCI based
    ones) use one of those interfaces.
    Not all host controllers use DMA; some use PIO, and there
    is also a simulator.
    </para>

    <para>The same basic APIs are available to drivers for all
    those controllers.  
    For historical reasons they are in two layers:
    <structname>struct usb_bus</structname> is a rather thin
    layer that became available in the 2.2 kernels, while
    <structname>struct usb_hcd</structname> is a more featureful
    layer (available in later 2.4 kernels and in 2.5) that
    lets HCDs share common code, to shrink driver size
    and significantly reduce hcd-specific behaviors.
    </para>

<!-- drivers/usb/core/hcd.c -->
<refentry id="API-usb-calc-bus-time">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>usb_calc_bus_time</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>usb_calc_bus_time</refname>
 <refpurpose>
  approximate periodic transaction time in nanoseconds
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>long <function>usb_calc_bus_time </function></funcdef>
   <paramdef>int <parameter>speed</parameter></paramdef>
   <paramdef>int <parameter>is_input</parameter></paramdef>
   <paramdef>int <parameter>isoc</parameter></paramdef>
   <paramdef>int <parameter>bytecount</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>speed</parameter></term>
   <listitem>
    <para>
     from dev-&gt;speed; USB_SPEED_{LOW,FULL,HIGH}
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>is_input</parameter></term>
   <listitem>
    <para>
     true iff the transaction sends data to the host
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>isoc</parameter></term>
   <listitem>
    <para>
     true for isochronous transactions, false for interrupt ones
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>bytecount</parameter></term>
   <listitem>
    <para>
     how many bytes in the transaction.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Return</title>
<para>
   Approximate bus time in nanoseconds for a periodic transaction.
</para>
</refsect1>
<refsect1>
<title>Note</title>
<para>
   See USB 2.0 spec section 5.11.3; only periodic transfers need to be
   scheduled in software, this function is only used for such scheduling.
</para>
</refsect1>
</refentry>

<refentry id="API-usb-hcd-link-urb-to-ep">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>usb_hcd_link_urb_to_ep</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>usb_hcd_link_urb_to_ep</refname>
 <refpurpose>
     add an URB to its endpoint queue
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>usb_hcd_link_urb_to_ep </function></funcdef>
   <paramdef>struct usb_hcd * <parameter>hcd</parameter></paramdef>
   <paramdef>struct urb * <parameter>urb</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>hcd</parameter></term>
   <listitem>
    <para>
     host controller to which <parameter>urb</parameter> was submitted
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>urb</parameter></term>
   <listitem>
    <para>
     URB being submitted
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Host controller drivers should call this routine in their <function>enqueue</function>
   method.  The HCD's private spinlock must be held and interrupts must
   be disabled.  The actions carried out here are required for URB
   submission, as well as for endpoint shutdown and for usb_kill_urb.
</para>
</refsect1>
<refsect1>
<title>Return</title>
<para>
   0 for no error, otherwise a negative error code (in which case
   the <function>enqueue</function> method must fail).  If no error occurs but <function>enqueue</function> fails
   anyway, it must call <function>usb_hcd_unlink_urb_from_ep</function> before releasing
   the private spinlock and returning.
</para>
</refsect1>
</refentry>

<refentry id="API-usb-hcd-check-unlink-urb">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>usb_hcd_check_unlink_urb</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>usb_hcd_check_unlink_urb</refname>
 <refpurpose>
     check whether an URB may be unlinked
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>usb_hcd_check_unlink_urb </function></funcdef>
   <paramdef>struct usb_hcd * <parameter>hcd</parameter></paramdef>
   <paramdef>struct urb * <parameter>urb</parameter></paramdef>
   <paramdef>int <parameter>status</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>hcd</parameter></term>
   <listitem>
    <para>
     host controller to which <parameter>urb</parameter> was submitted
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>urb</parameter></term>
   <listitem>
    <para>
     URB being checked for unlinkability
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>status</parameter></term>
   <listitem>
    <para>
     error code to store in <parameter>urb</parameter> if the unlink succeeds
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Host controller drivers should call this routine in their <function>dequeue</function>
   method.  The HCD's private spinlock must be held and interrupts must
   be disabled.  The actions carried out here are required for making
   sure than an unlink is valid.
</para>
</refsect1>
<refsect1>
<title>Return</title>
<para>
   0 for no error, otherwise a negative error code (in which case
   the <function>dequeue</function> method must fail).  The possible error codes are:
   </para><para>

   -EIDRM: <parameter>urb</parameter> was not submitted or has already completed.
   The completion function may not have been called yet.
   </para><para>

   -EBUSY: <parameter>urb</parameter> has already been unlinked.
</para>
</refsect1>
</refentry>

<refentry id="API-usb-hcd-unlink-urb-from-ep">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>usb_hcd_unlink_urb_from_ep</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>usb_hcd_unlink_urb_from_ep</refname>
 <refpurpose>
     remove an URB from its endpoint queue
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>usb_hcd_unlink_urb_from_ep </function></funcdef>
   <paramdef>struct usb_hcd * <parameter>hcd</parameter></paramdef>
   <paramdef>struct urb * <parameter>urb</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>hcd</parameter></term>
   <listitem>
    <para>
     host controller to which <parameter>urb</parameter> was submitted
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>urb</parameter></term>
   <listitem>
    <para>
     URB being unlinked
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Host controller drivers should call this routine before calling
   <function>usb_hcd_giveback_urb</function>.  The HCD's private spinlock must be held and
   interrupts must be disabled.  The actions carried out here are required
   for URB completion.
</para>
</refsect1>
</refentry>

<refentry id="API-usb-hcd-giveback-urb">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>usb_hcd_giveback_urb</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>usb_hcd_giveback_urb</refname>
 <refpurpose>
     return URB from HCD to device driver
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>usb_hcd_giveback_urb </function></funcdef>
   <paramdef>struct usb_hcd * <parameter>hcd</parameter></paramdef>
   <paramdef>struct urb * <parameter>urb</parameter></paramdef>
   <paramdef>int <parameter>status</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>hcd</parameter></term>
   <listitem>
    <para>
     host controller returning the URB
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>urb</parameter></term>
   <listitem>
    <para>
     urb being returned to the USB device driver.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>status</parameter></term>
   <listitem>
    <para>
     completion status code for the URB.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Context</title>
<para>
   <function>in_interrupt</function>
</para>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This hands the URB from HCD to its USB device driver, using its
   completion function.  The HCD has freed all per-urb resources
   (and is done using urb-&gt;hcpriv).  It also released all HCD locks;
   the device driver won't cause problems if it frees, modifies,
   or resubmits this URB.
   </para><para>

   If <parameter>urb</parameter> was unlinked, the value of <parameter>status</parameter> will be overridden by
   <parameter>urb</parameter>-&gt;unlinked.  Erroneous short transfers are detected in case
   the HCD hasn't checked for them.
</para>
</refsect1>
</refentry>

<refentry id="API-usb-alloc-streams">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>usb_alloc_streams</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>usb_alloc_streams</refname>
 <refpurpose>
     allocate bulk endpoint stream IDs.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>usb_alloc_streams </function></funcdef>
   <paramdef>struct usb_interface * <parameter>interface</parameter></paramdef>
   <paramdef>struct usb_host_endpoint ** <parameter>eps</parameter></paramdef>
   <paramdef>unsigned int <parameter>num_eps</parameter></paramdef>
   <paramdef>unsigned int <parameter>num_streams</parameter></paramdef>
   <paramdef>gfp_t <parameter>mem_flags</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>interface</parameter></term>
   <listitem>
    <para>
     alternate setting that includes all endpoints.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>eps</parameter></term>
   <listitem>
    <para>
     array of endpoints that need streams.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>num_eps</parameter></term>
   <listitem>
    <para>
     number of endpoints in the array.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>num_streams</parameter></term>
   <listitem>
    <para>
     number of streams to allocate.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>mem_flags</parameter></term>
   <listitem>
    <para>
     flags hcd should use to allocate memory.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Sets up a group of bulk endpoints to have <parameter>num_streams</parameter> stream IDs available.
   Drivers may queue multiple transfers to different stream IDs, which may
   complete in a different order than they were queued.
</para>
</refsect1>
<refsect1>
<title>Return</title>
<para>
   On success, the number of allocated streams. On failure, a negative
   error code.
</para>
</refsect1>
</refentry>

<refentry id="API-usb-free-streams">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>usb_free_streams</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>usb_free_streams</refname>
 <refpurpose>
     free bulk endpoint stream IDs.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>usb_free_streams </function></funcdef>
   <paramdef>struct usb_interface * <parameter>interface</parameter></paramdef>
   <paramdef>struct usb_host_endpoint ** <parameter>eps</parameter></paramdef>
   <paramdef>unsigned int <parameter>num_eps</parameter></paramdef>
   <paramdef>gfp_t <parameter>mem_flags</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>interface</parameter></term>
   <listitem>
    <para>
     alternate setting that includes all endpoints.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>eps</parameter></term>
   <listitem>
    <para>
     array of endpoints to remove streams from.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>num_eps</parameter></term>
   <listitem>
    <para>
     number of endpoints in the array.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>mem_flags</parameter></term>
   <listitem>
    <para>
     flags hcd should use to allocate memory.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Reverts a group of bulk endpoints back to not using stream IDs.
   Can fail if we are given bad arguments, or HCD is broken.
</para>
</refsect1>
<refsect1>
<title>Return</title>
<para>
   0 on success. On failure, a negative error code.
</para>
</refsect1>
</refentry>

<refentry id="API-usb-hcd-resume-root-hub">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>usb_hcd_resume_root_hub</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>usb_hcd_resume_root_hub</refname>
 <refpurpose>
     called by HCD to resume its root hub
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>usb_hcd_resume_root_hub </function></funcdef>
   <paramdef>struct usb_hcd * <parameter>hcd</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>hcd</parameter></term>
   <listitem>
    <para>
     host controller for this root hub
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   The USB host controller calls this function when its root hub is
   suspended (with the remote wakeup feature enabled) and a remote
   wakeup request is received.  The routine submits a workqueue request
   to resume the root hub (that is, manage its downstream ports again).
</para>
</refsect1>
</refentry>

<refentry id="API-usb-bus-start-enum">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>usb_bus_start_enum</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>usb_bus_start_enum</refname>
 <refpurpose>
     start immediate enumeration (for OTG)
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>usb_bus_start_enum </function></funcdef>
   <paramdef>struct usb_bus * <parameter>bus</parameter></paramdef>
   <paramdef>unsigned <parameter>port_num</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>bus</parameter></term>
   <listitem>
    <para>
     the bus (must use hcd framework)
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>port_num</parameter></term>
   <listitem>
    <para>
     1-based number of port; usually bus-&gt;otg_port
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Context</title>
<para>
   <function>in_interrupt</function>
</para>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Starts enumeration, with an immediate reset followed later by
   hub_wq identifying and possibly configuring the device.
   This is needed by OTG controller drivers, where it helps meet
   HNP protocol timing requirements for starting a port reset.
</para>
</refsect1>
<refsect1>
<title>Return</title>
<para>
   0 if successful.
</para>
</refsect1>
</refentry>

<refentry id="API-usb-hcd-irq">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>usb_hcd_irq</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>usb_hcd_irq</refname>
 <refpurpose>
     hook IRQs to HCD framework (bus glue)
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>irqreturn_t <function>usb_hcd_irq </function></funcdef>
   <paramdef>int <parameter>irq</parameter></paramdef>
   <paramdef>void * <parameter>__hcd</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>irq</parameter></term>
   <listitem>
    <para>
     the IRQ being raised
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>__hcd</parameter></term>
   <listitem>
    <para>
     pointer to the HCD whose IRQ is being signaled
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   If the controller isn't HALTed, calls the driver's irq handler.
   Checks whether the controller is now dead.
</para>
</refsect1>
<refsect1>
<title>Return</title>
<para>
   <constant>IRQ_HANDLED</constant> if the IRQ was handled. <constant>IRQ_NONE</constant> otherwise.
</para>
</refsect1>
</refentry>

<refentry id="API-usb-hc-died">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>usb_hc_died</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>usb_hc_died</refname>
 <refpurpose>
     report abnormal shutdown of a host controller (bus glue)
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>usb_hc_died </function></funcdef>
   <paramdef>struct usb_hcd * <parameter>hcd</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>hcd</parameter></term>
   <listitem>
    <para>
     pointer to the HCD representing the controller
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This is called by bus glue to report a USB host controller that died
   while operations may still have been pending.  It's called automatically
   by the PCI glue, so only glue for non-PCI busses should need to call it.
   </para><para>

   Only call this function with the primary HCD.
</para>
</refsect1>
</refentry>

<refentry id="API-usb-create-shared-hcd">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>usb_create_shared_hcd</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>usb_create_shared_hcd</refname>
 <refpurpose>
     create and initialize an HCD structure
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct usb_hcd * <function>usb_create_shared_hcd </function></funcdef>
   <paramdef>const struct hc_driver * <parameter>driver</parameter></paramdef>
   <paramdef>struct device * <parameter>dev</parameter></paramdef>
   <paramdef>const char * <parameter>bus_name</parameter></paramdef>
   <paramdef>struct usb_hcd * <parameter>primary_hcd</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>driver</parameter></term>
   <listitem>
    <para>
     HC driver that will use this hcd
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     device for this HC, stored in hcd-&gt;self.controller
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>bus_name</parameter></term>
   <listitem>
    <para>
     value to store in hcd-&gt;self.bus_name
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>primary_hcd</parameter></term>
   <listitem>
    <para>
     a pointer to the usb_hcd structure that is sharing the
     PCI device.  Only allocate certain resources for the primary HCD
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Context</title>
<para>
   !<function>in_interrupt</function>
</para>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Allocate a struct usb_hcd, with extra space at the end for the
   HC driver's private data.  Initialize the generic members of the
   hcd structure.
</para>
</refsect1>
<refsect1>
<title>Return</title>
<para>
   On success, a pointer to the created and initialized HCD structure.
   On failure (e.g. if memory is unavailable), <constant>NULL</constant>.
</para>
</refsect1>
</refentry>

<refentry id="API-usb-create-hcd">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>usb_create_hcd</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>usb_create_hcd</refname>
 <refpurpose>
     create and initialize an HCD structure
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct usb_hcd * <function>usb_create_hcd </function></funcdef>
   <paramdef>const struct hc_driver * <parameter>driver</parameter></paramdef>
   <paramdef>struct device * <parameter>dev</parameter></paramdef>
   <paramdef>const char * <parameter>bus_name</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>driver</parameter></term>
   <listitem>
    <para>
     HC driver that will use this hcd
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     device for this HC, stored in hcd-&gt;self.controller
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>bus_name</parameter></term>
   <listitem>
    <para>
     value to store in hcd-&gt;self.bus_name
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Context</title>
<para>
   !<function>in_interrupt</function>
</para>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Allocate a struct usb_hcd, with extra space at the end for the
   HC driver's private data.  Initialize the generic members of the
   hcd structure.
</para>
</refsect1>
<refsect1>
<title>Return</title>
<para>
   On success, a pointer to the created and initialized HCD
   structure. On failure (e.g. if memory is unavailable), <constant>NULL</constant>.
</para>
</refsect1>
</refentry>

<refentry id="API-usb-add-hcd">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>usb_add_hcd</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>usb_add_hcd</refname>
 <refpurpose>
     finish generic HCD structure initialization and register
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>usb_add_hcd </function></funcdef>
   <paramdef>struct usb_hcd * <parameter>hcd</parameter></paramdef>
   <paramdef>unsigned int <parameter>irqnum</parameter></paramdef>
   <paramdef>unsigned long <parameter>irqflags</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>hcd</parameter></term>
   <listitem>
    <para>
     the usb_hcd structure to initialize
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>irqnum</parameter></term>
   <listitem>
    <para>
     Interrupt line to allocate
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>irqflags</parameter></term>
   <listitem>
    <para>
     Interrupt type flags
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Finish the remaining parts of generic HCD initialization</title>
<para>
   allocate the
   buffers of consistent memory, register the bus, request the IRQ line,
   and call the driver's <function>reset</function> and <function>start</function> routines.
</para>
</refsect1>
</refentry>

<refentry id="API-usb-remove-hcd">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>usb_remove_hcd</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>usb_remove_hcd</refname>
 <refpurpose>
     shutdown processing for generic HCDs
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>usb_remove_hcd </function></funcdef>
   <paramdef>struct usb_hcd * <parameter>hcd</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>hcd</parameter></term>
   <listitem>
    <para>
     the usb_hcd structure to remove
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Context</title>
<para>
   !<function>in_interrupt</function>
</para>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Disconnects the root hub, then reverses the effects of <function>usb_add_hcd</function>,
   invoking the HCD's <function>stop</function> method.
</para>
</refsect1>
</refentry>

<!-- drivers/usb/core/hcd-pci.c -->
<refentry id="API-usb-hcd-pci-probe">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>usb_hcd_pci_probe</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>usb_hcd_pci_probe</refname>
 <refpurpose>
  initialize PCI-based HCDs
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>usb_hcd_pci_probe </function></funcdef>
   <paramdef>struct pci_dev * <parameter>dev</parameter></paramdef>
   <paramdef>const struct pci_device_id * <parameter>id</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     USB Host Controller being probed
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>id</parameter></term>
   <listitem>
    <para>
     pci hotplug id connecting controller to HCD framework
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Context</title>
<para>
   !<function>in_interrupt</function>
</para>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Allocates basic PCI resources for this USB host controller, and
   then invokes the <function>start</function> method for the HCD associated with it
   through the hotplug entry's driver_data.
   </para><para>

   Store this function in the HCD's struct pci_driver as <function>probe</function>.
</para>
</refsect1>
<refsect1>
<title>Return</title>
<para>
   0 if successful.
</para>
</refsect1>
</refentry>

<refentry id="API-usb-hcd-pci-remove">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>usb_hcd_pci_remove</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>usb_hcd_pci_remove</refname>
 <refpurpose>
     shutdown processing for PCI-based HCDs
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>usb_hcd_pci_remove </function></funcdef>
   <paramdef>struct pci_dev * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     USB Host Controller being removed
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Context</title>
<para>
   !<function>in_interrupt</function>
</para>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Reverses the effect of <function>usb_hcd_pci_probe</function>, first invoking
   the HCD's <function>stop</function> method.  It is always called from a thread
   context, normally <quote>rmmod</quote>, <quote>apmd</quote>, or something similar.
   </para><para>

   Store this function in the HCD's struct pci_driver as <function>remove</function>.
</para>
</refsect1>
</refentry>

<refentry id="API-usb-hcd-pci-shutdown">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>usb_hcd_pci_shutdown</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>usb_hcd_pci_shutdown</refname>
 <refpurpose>
     shutdown host controller
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>usb_hcd_pci_shutdown </function></funcdef>
   <paramdef>struct pci_dev * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     USB Host Controller being shutdown
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<!-- drivers/usb/core/buffer.c -->
<refentry id="API-hcd-buffer-create">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>hcd_buffer_create</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>hcd_buffer_create</refname>
 <refpurpose>
  initialize buffer pools
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>hcd_buffer_create </function></funcdef>
   <paramdef>struct usb_hcd * <parameter>hcd</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>hcd</parameter></term>
   <listitem>
    <para>
     the bus whose buffer pools are to be initialized
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Context</title>
<para>
   !<function>in_interrupt</function>
</para>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Call this as part of initializing a host controller that uses the dma
   memory allocators.  It initializes some pools of dma-coherent memory that
   will be shared by all drivers using that controller.
   </para><para>

   Call <function>hcd_buffer_destroy</function> to clean up after using those pools.
</para>
</refsect1>
<refsect1>
<title>Return</title>
<para>
   0 if successful. A negative errno value otherwise.
</para>
</refsect1>
</refentry>

<refentry id="API-hcd-buffer-destroy">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>hcd_buffer_destroy</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>hcd_buffer_destroy</refname>
 <refpurpose>
     deallocate buffer pools
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>hcd_buffer_destroy </function></funcdef>
   <paramdef>struct usb_hcd * <parameter>hcd</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>hcd</parameter></term>
   <listitem>
    <para>
     the bus whose buffer pools are to be destroyed
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Context</title>
<para>
   !<function>in_interrupt</function>
</para>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This frees the buffer pools created by <function>hcd_buffer_create</function>.
</para>
</refsect1>
</refentry>

    </chapter>

    <chapter id="usbfs">
	<title>The USB Filesystem (usbfs)</title>

	<para>This chapter presents the Linux <emphasis>usbfs</emphasis>.
	You may prefer to avoid writing new kernel code for your
	USB driver; that's the problem that usbfs set out to solve.
	User mode device drivers are usually packaged as applications
	or libraries, and may use usbfs through some programming library
	that wraps it.  Such libraries include
	<ulink url="http://libusb.sourceforge.net">libusb</ulink>
	for C/C++, and
	<ulink url="http://jUSB.sourceforge.net">jUSB</ulink> for Java.
	</para>

	<note><title>Unfinished</title>
	    <para>This particular documentation is incomplete,
	    especially with respect to the asynchronous mode.
	    As of kernel 2.5.66 the code and this (new) documentation
	    need to be cross-reviewed.
	    </para>
	    </note>

	<para>Configure usbfs into Linux kernels by enabling the
	<emphasis>USB filesystem</emphasis> option (CONFIG_USB_DEVICEFS),
	and you get basic support for user mode USB device drivers.
	Until relatively recently it was often (confusingly) called
	<emphasis>usbdevfs</emphasis> although it wasn't solving what
	<emphasis>devfs</emphasis> was.
	Every USB device will appear in usbfs, regardless of whether or
	not it has a kernel driver.
	</para>

	<sect1 id="usbfs-files">
	    <title>What files are in "usbfs"?</title>

	    <para>Conventionally mounted at
	    <filename>/proc/bus/usb</filename>, usbfs 
	    features include:
	    <itemizedlist>
		<listitem><para><filename>/proc/bus/usb/devices</filename>
		    ... a text file
		    showing each of the USB devices on known to the kernel,
		    and their configuration descriptors.
		    You can also poll() this to learn about new devices.
		    </para></listitem>
		<listitem><para><filename>/proc/bus/usb/BBB/DDD</filename>
		    ... magic files
		    exposing the each device's configuration descriptors, and
		    supporting a series of ioctls for making device requests,
		    including I/O to devices.  (Purely for access by programs.)
		    </para></listitem>
	    </itemizedlist>
	    </para>

	    <para> Each bus is given a number (BBB) based on when it was
	    enumerated; within each bus, each device is given a similar
	    number (DDD).
	    Those BBB/DDD paths are not "stable" identifiers;
	    expect them to change even if you always leave the devices
	    plugged in to the same hub port.
	    <emphasis>Don't even think of saving these in application
	    configuration files.</emphasis>
	    Stable identifiers are available, for user mode applications
	    that want to use them.  HID and networking devices expose
	    these stable IDs, so that for example you can be sure that
	    you told the right UPS to power down its second server.
	    "usbfs" doesn't (yet) expose those IDs.
	    </para>

	</sect1>

	<sect1 id="usbfs-fstab">
	    <title>Mounting and Access Control</title>

	    <para>There are a number of mount options for usbfs, which will
	    be of most interest to you if you need to override the default
	    access control policy.
	    That policy is that only root may read or write device files
	    (<filename>/proc/bus/BBB/DDD</filename>) although anyone may read
	    the <filename>devices</filename>
	    or <filename>drivers</filename> files.
	    I/O requests to the device also need the CAP_SYS_RAWIO capability,
	    </para>

	    <para>The significance of that is that by default, all user mode
	    device drivers need super-user privileges.
	    You can change modes or ownership in a driver setup
	    when the device hotplugs, or maye just start the
	    driver right then, as a privileged server (or some activity
	    within one).
	    That's the most secure approach for multi-user systems,
	    but for single user systems ("trusted" by that user)
	    it's more convenient just to grant everyone all access
	    (using the <emphasis>devmode=0666</emphasis> option)
	    so the driver can start whenever it's needed.
	    </para>

	    <para>The mount options for usbfs, usable in /etc/fstab or
	    in command line invocations of <emphasis>mount</emphasis>, are:

	    <variablelist>
		<varlistentry>
		    <term><emphasis>busgid</emphasis>=NNNNN</term>
		    <listitem><para>Controls the GID used for the
		    /proc/bus/usb/BBB
		    directories.  (Default: 0)</para></listitem></varlistentry>
		<varlistentry><term><emphasis>busmode</emphasis>=MMM</term>
		    <listitem><para>Controls the file mode used for the
		    /proc/bus/usb/BBB
		    directories.  (Default: 0555)
		    </para></listitem></varlistentry>
		<varlistentry><term><emphasis>busuid</emphasis>=NNNNN</term>
		    <listitem><para>Controls the UID used for the
		    /proc/bus/usb/BBB
		    directories.  (Default: 0)</para></listitem></varlistentry>

		<varlistentry><term><emphasis>devgid</emphasis>=NNNNN</term>
		    <listitem><para>Controls the GID used for the
		    /proc/bus/usb/BBB/DDD
		    files.  (Default: 0)</para></listitem></varlistentry>
		<varlistentry><term><emphasis>devmode</emphasis>=MMM</term>
		    <listitem><para>Controls the file mode used for the
		    /proc/bus/usb/BBB/DDD
		    files.  (Default: 0644)</para></listitem></varlistentry>
		<varlistentry><term><emphasis>devuid</emphasis>=NNNNN</term>
		    <listitem><para>Controls the UID used for the
		    /proc/bus/usb/BBB/DDD
		    files.  (Default: 0)</para></listitem></varlistentry>

		<varlistentry><term><emphasis>listgid</emphasis>=NNNNN</term>
		    <listitem><para>Controls the GID used for the
		    /proc/bus/usb/devices and drivers files.
		    (Default: 0)</para></listitem></varlistentry>
		<varlistentry><term><emphasis>listmode</emphasis>=MMM</term>
		    <listitem><para>Controls the file mode used for the
		    /proc/bus/usb/devices and drivers files.
		    (Default: 0444)</para></listitem></varlistentry>
		<varlistentry><term><emphasis>listuid</emphasis>=NNNNN</term>
		    <listitem><para>Controls the UID used for the
		    /proc/bus/usb/devices and drivers files.
		    (Default: 0)</para></listitem></varlistentry>
	    </variablelist>

	    </para>

	    <para>Note that many Linux distributions hard-wire the mount options
	    for usbfs in their init scripts, such as
	    <filename>/etc/rc.d/rc.sysinit</filename>,
	    rather than making it easy to set this per-system
	    policy in <filename>/etc/fstab</filename>.
	    </para>

	</sect1>

	<sect1 id="usbfs-devices">
	    <title>/proc/bus/usb/devices</title>

	    <para>This file is handy for status viewing tools in user
	    mode, which can scan the text format and ignore most of it.
	    More detailed device status (including class and vendor
	    status) is available from device-specific files.
	    For information about the current format of this file,
	    see the
	    <filename>Documentation/usb/proc_usb_info.txt</filename>
	    file in your Linux kernel sources.
	    </para>

	    <para>This file, in combination with the poll() system call, can
	    also be used to detect when devices are added or removed:
<programlisting>int fd;
struct pollfd pfd;

fd = open("/proc/bus/usb/devices", O_RDONLY);
pfd = { fd, POLLIN, 0 };
for (;;) {
	/* The first time through, this call will return immediately. */
	poll(&amp;pfd, 1, -1);

	/* To see what's changed, compare the file's previous and current
	   contents or scan the filesystem.  (Scanning is more precise.) */
}</programlisting>
	    Note that this behavior is intended to be used for informational
	    and debug purposes.  It would be more appropriate to use programs
	    such as udev or HAL to initialize a device or start a user-mode
	    helper program, for instance.
	    </para>
	</sect1>

	<sect1 id="usbfs-bbbddd">
	    <title>/proc/bus/usb/BBB/DDD</title>

	    <para>Use these files in one of these basic ways:
	    </para>

	    <para><emphasis>They can be read,</emphasis>
	    producing first the device descriptor
	    (18 bytes) and then the descriptors for the current configuration.
	    See the USB 2.0 spec for details about those binary data formats.
	    You'll need to convert most multibyte values from little endian
	    format to your native host byte order, although a few of the
	    fields in the device descriptor (both of the BCD-encoded fields,
	    and the vendor and product IDs) will be byteswapped for you.
	    Note that configuration descriptors include descriptors for
	    interfaces, altsettings, endpoints, and maybe additional
	    class descriptors.
	    </para>

	    <para><emphasis>Perform USB operations</emphasis> using 
	    <emphasis>ioctl()</emphasis> requests to make endpoint I/O
	    requests (synchronously or asynchronously) or manage
	    the device.
	    These requests need the CAP_SYS_RAWIO capability,
	    as well as filesystem access permissions.
	    Only one ioctl request can be made on one of these
	    device files at a time.
	    This means that if you are synchronously reading an endpoint
	    from one thread, you won't be able to write to a different
	    endpoint from another thread until the read completes.
	    This works for <emphasis>half duplex</emphasis> protocols,
	    but otherwise you'd use asynchronous i/o requests. 
	    </para>

	    </sect1>


	<sect1 id="usbfs-lifecycle">
	    <title>Life Cycle of User Mode Drivers</title>

	    <para>Such a driver first needs to find a device file
	    for a device it knows how to handle.
	    Maybe it was told about it because a
	    <filename>/sbin/hotplug</filename> event handling agent
	    chose that driver to handle the new device.
	    Or maybe it's an application that scans all the
	    /proc/bus/usb device files, and ignores most devices.
	    In either case, it should <function>read()</function> all
	    the descriptors from the device file,
	    and check them against what it knows how to handle.
	    It might just reject everything except a particular
	    vendor and product ID, or need a more complex policy.
	    </para>

	    <para>Never assume there will only be one such device
	    on the system at a time!
	    If your code can't handle more than one device at
	    a time, at least detect when there's more than one, and
	    have your users choose which device to use.
	    </para>

	    <para>Once your user mode driver knows what device to use,
	    it interacts with it in either of two styles.
	    The simple style is to make only control requests; some
	    devices don't need more complex interactions than those.
	    (An example might be software using vendor-specific control
	    requests for some initialization or configuration tasks,
	    with a kernel driver for the rest.)
	    </para>

	    <para>More likely, you need a more complex style driver:
	    one using non-control endpoints, reading or writing data
	    and claiming exclusive use of an interface.
	    <emphasis>Bulk</emphasis> transfers are easiest to use,
	    but only their sibling <emphasis>interrupt</emphasis> transfers 
	    work with low speed devices.
	    Both interrupt and <emphasis>isochronous</emphasis> transfers
	    offer service guarantees because their bandwidth is reserved.
	    Such "periodic" transfers are awkward to use through usbfs,
	    unless you're using the asynchronous calls.  However, interrupt
	    transfers can also be used in a synchronous "one shot" style.
	    </para>

	    <para>Your user-mode driver should never need to worry
	    about cleaning up request state when the device is
	    disconnected, although it should close its open file
	    descriptors as soon as it starts seeing the ENODEV
	    errors.
	    </para>

	    </sect1>

	<sect1 id="usbfs-ioctl"><title>The ioctl() Requests</title>

	    <para>To use these ioctls, you need to include the following
	    headers in your userspace program:
<programlisting>#include &lt;linux/usb.h&gt;
#include &lt;linux/usbdevice_fs.h&gt;
#include &lt;asm/byteorder.h&gt;</programlisting>
	    The standard USB device model requests, from "Chapter 9" of
	    the USB 2.0 specification, are automatically included from
	    the <filename>&lt;linux/usb/ch9.h&gt;</filename> header.
	    </para>

	    <para>Unless noted otherwise, the ioctl requests
	    described here will
	    update the modification time on the usbfs file to which
	    they are applied (unless they fail).
	    A return of zero indicates success; otherwise, a
	    standard USB error code is returned.  (These are
	    documented in
	    <filename>Documentation/usb/error-codes.txt</filename>
	    in your kernel sources.)
	    </para>

	    <para>Each of these files multiplexes access to several
	    I/O streams, one per endpoint.
	    Each device has one control endpoint (endpoint zero)
	    which supports a limited RPC style RPC access.
	    Devices are configured
	    by hub_wq (in the kernel) setting a device-wide
	    <emphasis>configuration</emphasis> that affects things
	    like power consumption and basic functionality.
	    The endpoints are part of USB <emphasis>interfaces</emphasis>,
	    which may have <emphasis>altsettings</emphasis>
	    affecting things like which endpoints are available.
	    Many devices only have a single configuration and interface,
	    so drivers for them will ignore configurations and altsettings.
	    </para>


	    <sect2 id="usbfs-mgmt">
		<title>Management/Status Requests</title>

		<para>A number of usbfs requests don't deal very directly
		with device I/O.
		They mostly relate to device management and status.
		These are all synchronous requests.
		</para>

		<variablelist>

		<varlistentry><term>USBDEVFS_CLAIMINTERFACE</term>
		    <listitem><para>This is used to force usbfs to
		    claim a specific interface,
		    which has not previously been claimed by usbfs or any other
		    kernel driver.
		    The ioctl parameter is an integer holding the number of
		    the interface (bInterfaceNumber from descriptor).
		    </para><para>
		    Note that if your driver doesn't claim an interface
		    before trying to use one of its endpoints, and no
		    other driver has bound to it, then the interface is
		    automatically claimed by usbfs.
		    </para><para>
		    This claim will be released by a RELEASEINTERFACE ioctl,
		    or by closing the file descriptor.
		    File modification time is not updated by this request.
		    </para></listitem></varlistentry>

		<varlistentry><term>USBDEVFS_CONNECTINFO</term>
		    <listitem><para>Says whether the device is lowspeed.
		    The ioctl parameter points to a structure like this:
<programlisting>struct usbdevfs_connectinfo {
        unsigned int   devnum;
        unsigned char  slow;
}; </programlisting>
		    File modification time is not updated by this request.
		    </para><para>
		    <emphasis>You can't tell whether a "not slow"
		    device is connected at high speed (480 MBit/sec)
		    or just full speed (12 MBit/sec).</emphasis>
		    You should know the devnum value already,
		    it's the DDD value of the device file name.
		    </para></listitem></varlistentry>

		<varlistentry><term>USBDEVFS_GETDRIVER</term>
		    <listitem><para>Returns the name of the kernel driver
		    bound to a given interface (a string).  Parameter
		    is a pointer to this structure, which is modified:
<programlisting>struct usbdevfs_getdriver {
        unsigned int  interface;
        char          driver[USBDEVFS_MAXDRIVERNAME + 1];
};</programlisting>
		    File modification time is not updated by this request.
		    </para></listitem></varlistentry>

		<varlistentry><term>USBDEVFS_IOCTL</term>
		    <listitem><para>Passes a request from userspace through
		    to a kernel driver that has an ioctl entry in the
		    <emphasis>struct usb_driver</emphasis> it registered.
<programlisting>struct usbdevfs_ioctl {
        int     ifno;
        int     ioctl_code;
        void    *data;
};

/* user mode call looks like this.
 * 'request' becomes the driver->ioctl() 'code' parameter.
 * the size of 'param' is encoded in 'request', and that data
 * is copied to or from the driver->ioctl() 'buf' parameter.
 */
static int
usbdev_ioctl (int fd, int ifno, unsigned request, void *param)
{
        struct usbdevfs_ioctl	wrapper;

        wrapper.ifno = ifno;
        wrapper.ioctl_code = request;
        wrapper.data = param;

        return ioctl (fd, USBDEVFS_IOCTL, &amp;wrapper);
} </programlisting>
		    File modification time is not updated by this request.
		    </para><para>
		    This request lets kernel drivers talk to user mode code
		    through filesystem operations even when they don't create
		    a character or block special device.
		    It's also been used to do things like ask devices what
		    device special file should be used.
		    Two pre-defined ioctls are used
		    to disconnect and reconnect kernel drivers, so
		    that user mode code can completely manage binding
		    and configuration of devices.
		    </para></listitem></varlistentry>

		<varlistentry><term>USBDEVFS_RELEASEINTERFACE</term>
		    <listitem><para>This is used to release the claim usbfs
		    made on interface, either implicitly or because of a
		    USBDEVFS_CLAIMINTERFACE call, before the file
		    descriptor is closed.
		    The ioctl parameter is an integer holding the number of
		    the interface (bInterfaceNumber from descriptor);
		    File modification time is not updated by this request.
		    </para><warning><para>
		    <emphasis>No security check is made to ensure
		    that the task which made the claim is the one
		    which is releasing it.
		    This means that user mode driver may interfere
		    other ones.  </emphasis>
		    </para></warning></listitem></varlistentry>

		<varlistentry><term>USBDEVFS_RESETEP</term>
		    <listitem><para>Resets the data toggle value for an endpoint
		    (bulk or interrupt) to DATA0.
		    The ioctl parameter is an integer endpoint number
		    (1 to 15, as identified in the endpoint descriptor),
		    with USB_DIR_IN added if the device's endpoint sends
		    data to the host.
		    </para><warning><para>
		    <emphasis>Avoid using this request.
		    It should probably be removed.</emphasis>
		    Using it typically means the device and driver will lose
		    toggle synchronization.  If you really lost synchronization,
		    you likely need to completely handshake with the device,
		    using a request like CLEAR_HALT
		    or SET_INTERFACE.
		    </para></warning></listitem></varlistentry>

		</variablelist>

		</sect2>

	    <sect2 id="usbfs-sync">
		<title>Synchronous I/O Support</title>

		<para>Synchronous requests involve the kernel blocking
		until the user mode request completes, either by
		finishing successfully or by reporting an error.
		In most cases this is the simplest way to use usbfs,
		although as noted above it does prevent performing I/O
		to more than one endpoint at a time.
		</para>

		<variablelist>

		<varlistentry><term>USBDEVFS_BULK</term>
		    <listitem><para>Issues a bulk read or write request to the
		    device.
		    The ioctl parameter is a pointer to this structure:
<programlisting>struct usbdevfs_bulktransfer {
        unsigned int  ep;
        unsigned int  len;
        unsigned int  timeout; /* in milliseconds */
        void          *data;
};</programlisting>
		    </para><para>The "ep" value identifies a
		    bulk endpoint number (1 to 15, as identified in an endpoint
		    descriptor),
		    masked with USB_DIR_IN when referring to an endpoint which
		    sends data to the host from the device.
		    The length of the data buffer is identified by "len";
		    Recent kernels support requests up to about 128KBytes.
		    <emphasis>FIXME say how read length is returned,
		    and how short reads are handled.</emphasis>.
		    </para></listitem></varlistentry>

		<varlistentry><term>USBDEVFS_CLEAR_HALT</term>
		    <listitem><para>Clears endpoint halt (stall) and
		    resets the endpoint toggle.  This is only
		    meaningful for bulk or interrupt endpoints.
		    The ioctl parameter is an integer endpoint number
		    (1 to 15, as identified in an endpoint descriptor),
		    masked with USB_DIR_IN when referring to an endpoint which
		    sends data to the host from the device.
		    </para><para>
		    Use this on bulk or interrupt endpoints which have
		    stalled, returning <emphasis>-EPIPE</emphasis> status
		    to a data transfer request.
		    Do not issue the control request directly, since
		    that could invalidate the host's record of the
		    data toggle.
		    </para></listitem></varlistentry>

		<varlistentry><term>USBDEVFS_CONTROL</term>
		    <listitem><para>Issues a control request to the device.
		    The ioctl parameter points to a structure like this:
<programlisting>struct usbdevfs_ctrltransfer {
        __u8   bRequestType;
        __u8   bRequest;
        __u16  wValue;
        __u16  wIndex;
        __u16  wLength;
        __u32  timeout;  /* in milliseconds */
        void   *data;
};</programlisting>
		    </para><para>
		    The first eight bytes of this structure are the contents
		    of the SETUP packet to be sent to the device; see the
		    USB 2.0 specification for details.
		    The bRequestType value is composed by combining a
		    USB_TYPE_* value, a USB_DIR_* value, and a
		    USB_RECIP_* value (from
		    <emphasis>&lt;linux/usb.h&gt;</emphasis>).
		    If wLength is nonzero, it describes the length of the data
		    buffer, which is either written to the device
		    (USB_DIR_OUT) or read from the device (USB_DIR_IN).
		    </para><para>
		    At this writing, you can't transfer more than 4 KBytes
		    of data to or from a device; usbfs has a limit, and
		    some host controller drivers have a limit.
		    (That's not usually a problem.)
		    <emphasis>Also</emphasis> there's no way to say it's
		    not OK to get a short read back from the device.
		    </para></listitem></varlistentry>

		<varlistentry><term>USBDEVFS_RESET</term>
		    <listitem><para>Does a USB level device reset.
		    The ioctl parameter is ignored.
		    After the reset, this rebinds all device interfaces.
		    File modification time is not updated by this request.
		    </para><warning><para>
		    <emphasis>Avoid using this call</emphasis>
		    until some usbcore bugs get fixed,
		    since it does not fully synchronize device, interface,
		    and driver (not just usbfs) state.
		    </para></warning></listitem></varlistentry>
	    
		<varlistentry><term>USBDEVFS_SETINTERFACE</term>
		    <listitem><para>Sets the alternate setting for an
		    interface.  The ioctl parameter is a pointer to a
		    structure like this:
<programlisting>struct usbdevfs_setinterface {
        unsigned int  interface;
        unsigned int  altsetting;
}; </programlisting>
		    File modification time is not updated by this request.
		    </para><para>
		    Those struct members are from some interface descriptor
		    applying to the current configuration.
		    The interface number is the bInterfaceNumber value, and
		    the altsetting number is the bAlternateSetting value.
		    (This resets each endpoint in the interface.)
		    </para></listitem></varlistentry>

		<varlistentry><term>USBDEVFS_SETCONFIGURATION</term>
		    <listitem><para>Issues the
		    <function>usb_set_configuration</function> call
		    for the device.
		    The parameter is an integer holding the number of
		    a configuration (bConfigurationValue from descriptor).
		    File modification time is not updated by this request.
		    </para><warning><para>
		    <emphasis>Avoid using this call</emphasis>
		    until some usbcore bugs get fixed,
		    since it does not fully synchronize device, interface,
		    and driver (not just usbfs) state.
		    </para></warning></listitem></varlistentry>

		</variablelist>
	    </sect2>

	    <sect2 id="usbfs-async">
		<title>Asynchronous I/O Support</title>

		<para>As mentioned above, there are situations where it may be
		important to initiate concurrent operations from user mode code.
		This is particularly important for periodic transfers
		(interrupt and isochronous), but it can be used for other
		kinds of USB requests too.
		In such cases, the asynchronous requests described here
		are essential.  Rather than submitting one request and having
		the kernel block until it completes, the blocking is separate.
		</para>

		<para>These requests are packaged into a structure that
		resembles the URB used by kernel device drivers.
		(No POSIX Async I/O support here, sorry.)
		It identifies the endpoint type (USBDEVFS_URB_TYPE_*),
		endpoint (number, masked with USB_DIR_IN as appropriate),
		buffer and length, and a user "context" value serving to
		uniquely identify each request.
		(It's usually a pointer to per-request data.)
		Flags can modify requests (not as many as supported for
		kernel drivers).
		</para>

		<para>Each request can specify a realtime signal number
		(between SIGRTMIN and SIGRTMAX, inclusive) to request a
		signal be sent when the request completes.
		</para>

		<para>When usbfs returns these urbs, the status value
		is updated, and the buffer may have been modified.
		Except for isochronous transfers, the actual_length is
		updated to say how many bytes were transferred; if the
		USBDEVFS_URB_DISABLE_SPD flag is set
		("short packets are not OK"), if fewer bytes were read
		than were requested then you get an error report.
		</para>

<programlisting>struct usbdevfs_iso_packet_desc {
        unsigned int                     length;
        unsigned int                     actual_length;
        unsigned int                     status;
};

struct usbdevfs_urb {
        unsigned char                    type;
        unsigned char                    endpoint;
        int                              status;
        unsigned int                     flags;
        void                             *buffer;
        int                              buffer_length;
        int                              actual_length;
        int                              start_frame;
        int                              number_of_packets;
        int                              error_count;
        unsigned int                     signr;
        void                             *usercontext;
        struct usbdevfs_iso_packet_desc  iso_frame_desc[];
};</programlisting>

		<para> For these asynchronous requests, the file modification
		time reflects when the request was initiated.
		This contrasts with their use with the synchronous requests,
		where it reflects when requests complete.
		</para>

		<variablelist>

		<varlistentry><term>USBDEVFS_DISCARDURB</term>
		    <listitem><para>
		    <emphasis>TBS</emphasis>
		    File modification time is not updated by this request.
		    </para><para>
		    </para></listitem></varlistentry>

		<varlistentry><term>USBDEVFS_DISCSIGNAL</term>
		    <listitem><para>
		    <emphasis>TBS</emphasis>
		    File modification time is not updated by this request.
		    </para><para>
		    </para></listitem></varlistentry>

		<varlistentry><term>USBDEVFS_REAPURB</term>
		    <listitem><para>
		    <emphasis>TBS</emphasis>
		    File modification time is not updated by this request.
		    </para><para>
		    </para></listitem></varlistentry>

		<varlistentry><term>USBDEVFS_REAPURBNDELAY</term>
		    <listitem><para>
		    <emphasis>TBS</emphasis>
		    File modification time is not updated by this request.
		    </para><para>
		    </para></listitem></varlistentry>

		<varlistentry><term>USBDEVFS_SUBMITURB</term>
		    <listitem><para>
		    <emphasis>TBS</emphasis>
		    </para><para>
		    </para></listitem></varlistentry>

		</variablelist>
	    </sect2>

	</sect1>

    </chapter>

</book>
<!-- vim:syntax=sgml:sw=4
-->
