<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN"
	"http://www.oasis-open.org/docbook/xml/4.1.2/docbookx.dtd" []>

<book id="MTD-NAND-Guide">
 <bookinfo>
  <title>MTD NAND Driver Programming Interface</title>
  
  <authorgroup>
   <author>
    <firstname>Thomas</firstname>
    <surname>Gleixner</surname>
    <affiliation>
     <address>
      <email>tglx@linutronix.de</email>
     </address>
    </affiliation>
   </author>
  </authorgroup>

  <copyright>
   <year>2004</year>
   <holder>Thomas Gleixner</holder>
  </copyright>

  <legalnotice>
   <para>
     This documentation is free software; you can redistribute
     it and/or modify it under the terms of the GNU General Public
     License version 2 as published by the Free Software Foundation.
   </para>
      
   <para>
     This program is distributed in the hope that it will be
     useful, but WITHOUT ANY WARRANTY; without even the implied
     warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
     See the GNU General Public License for more details.
   </para>
      
   <para>
     You should have received a copy of the GNU General Public
     License along with this program; if not, write to the Free
     Software Foundation, Inc., 59 Temple Place, Suite 330, Boston,
     MA 02111-1307 USA
   </para>
      
   <para>
     For more details see the file COPYING in the source
     distribution of Linux.
   </para>
  </legalnotice>
 </bookinfo>

<toc></toc>

  <chapter id="intro">
      <title>Introduction</title>
  <para>
  	The generic NAND driver supports almost all NAND and AG-AND based
	chips and connects them to the Memory Technology Devices (MTD)
	subsystem of the Linux Kernel.
  </para>
  <para>
  	This documentation is provided for developers who want to implement
	board drivers or filesystem drivers suitable for NAND devices.
  </para>
  </chapter>
  
  <chapter id="bugs">
     <title>Known Bugs And Assumptions</title>
  <para>
	None.	
  </para>
  </chapter>

  <chapter id="dochints">
     <title>Documentation hints</title>
     <para>
     The function and structure docs are autogenerated. Each function and 
     struct member has a short description which is marked with an [XXX] identifier.
     The following chapters explain the meaning of those identifiers.
     </para>
     <sect1 id="Function_identifiers_XXX">
	<title>Function identifiers [XXX]</title>
     	<para>
	The functions are marked with [XXX] identifiers in the short
	comment. The identifiers explain the usage and scope of the
	functions. Following identifiers are used:
     	</para>
	<itemizedlist>
		<listitem><para>
	  	[MTD Interface]</para><para>
		These functions provide the interface to the MTD kernel API. 
		They are not replaceable and provide functionality
		which is complete hardware independent.
		</para></listitem>
		<listitem><para>
	  	[NAND Interface]</para><para>
		These functions are exported and provide the interface to the NAND kernel API. 
		</para></listitem>
		<listitem><para>
	  	[GENERIC]</para><para>
		Generic functions are not replaceable and provide functionality
		which is complete hardware independent.
		</para></listitem>
		<listitem><para>
	  	[DEFAULT]</para><para>
		Default functions provide hardware related functionality which is suitable
		for most of the implementations. These functions can be replaced by the
		board driver if necessary. Those functions are called via pointers in the
		NAND chip description structure. The board driver can set the functions which
		should be replaced by board dependent functions before calling nand_scan().
		If the function pointer is NULL on entry to nand_scan() then the pointer
		is set to the default function which is suitable for the detected chip type.
		</para></listitem>
	</itemizedlist>
     </sect1>
     <sect1 id="Struct_member_identifiers_XXX">
	<title>Struct member identifiers [XXX]</title>
     	<para>
	The struct members are marked with [XXX] identifiers in the 
	comment. The identifiers explain the usage and scope of the
	members. Following identifiers are used:
     	</para>
	<itemizedlist>
		<listitem><para>
	  	[INTERN]</para><para>
		These members are for NAND driver internal use only and must not be
		modified. Most of these values are calculated from the chip geometry
		information which is evaluated during nand_scan().
		</para></listitem>
		<listitem><para>
	  	[REPLACEABLE]</para><para>
		Replaceable members hold hardware related functions which can be 
		provided by the board driver. The board driver can set the functions which
		should be replaced by board dependent functions before calling nand_scan().
		If the function pointer is NULL on entry to nand_scan() then the pointer
		is set to the default function which is suitable for the detected chip type.
		</para></listitem>
		<listitem><para>
	  	[BOARDSPECIFIC]</para><para>
		Board specific members hold hardware related information which must
		be provided by the board driver. The board driver must set the function
		pointers and datafields before calling nand_scan().
		</para></listitem>
		<listitem><para>
	  	[OPTIONAL]</para><para>
		Optional members can hold information relevant for the board driver. The
		generic NAND driver code does not use this information.
		</para></listitem>
	</itemizedlist>
     </sect1>
  </chapter>   

  <chapter id="basicboarddriver">
     	<title>Basic board driver</title>
	<para>
		For most boards it will be sufficient to provide just the
		basic functions and fill out some really board dependent
		members in the nand chip description structure.
	</para>
	<sect1 id="Basic_defines">
		<title>Basic defines</title>
		<para>
			At least you have to provide a mtd structure and
			a storage for the ioremap'ed chip address.
			You can allocate the mtd structure using kmalloc
			or you can allocate it statically.
			In case of static allocation you have to allocate
			a nand_chip structure too.
		</para>
		<para>
			Kmalloc based example
		</para>
		<programlisting>
static struct mtd_info *board_mtd;
static void __iomem *baseaddr;
		</programlisting>
		<para>
			Static example
		</para>
		<programlisting>
static struct mtd_info board_mtd;
static struct nand_chip board_chip;
static void __iomem *baseaddr;
		</programlisting>
	</sect1>
	<sect1 id="Partition_defines">
		<title>Partition defines</title>
		<para>
			If you want to divide your device into partitions, then
			define a partitioning scheme suitable to your board.
		</para>
		<programlisting>
#define NUM_PARTITIONS 2
static struct mtd_partition partition_info[] = {
	{ .name = "Flash partition 1",
	  .offset =  0,
	  .size =    8 * 1024 * 1024 },
	{ .name = "Flash partition 2",
	  .offset =  MTDPART_OFS_NEXT,
	  .size =    MTDPART_SIZ_FULL },
};
		</programlisting>
	</sect1>
	<sect1 id="Hardware_control_functions">
		<title>Hardware control function</title>
		<para>
			The hardware control function provides access to the 
			control pins of the NAND chip(s). 
			The access can be done by GPIO pins or by address lines.
			If you use address lines, make sure that the timing
			requirements are met.
		</para>
		<para>
			<emphasis>GPIO based example</emphasis>
		</para>
		<programlisting>
static void board_hwcontrol(struct mtd_info *mtd, int cmd)
{
	switch(cmd){
		case NAND_CTL_SETCLE: /* Set CLE pin high */ break;
		case NAND_CTL_CLRCLE: /* Set CLE pin low */ break;
		case NAND_CTL_SETALE: /* Set ALE pin high */ break;
		case NAND_CTL_CLRALE: /* Set ALE pin low */ break;
		case NAND_CTL_SETNCE: /* Set nCE pin low */ break;
		case NAND_CTL_CLRNCE: /* Set nCE pin high */ break;
	}
}
		</programlisting>
		<para>
			<emphasis>Address lines based example.</emphasis> It's assumed that the
			nCE pin is driven by a chip select decoder.
		</para>
		<programlisting>
static void board_hwcontrol(struct mtd_info *mtd, int cmd)
{
	struct nand_chip *this = (struct nand_chip *) mtd->priv;
	switch(cmd){
		case NAND_CTL_SETCLE: this->IO_ADDR_W |= CLE_ADRR_BIT;  break;
		case NAND_CTL_CLRCLE: this->IO_ADDR_W &amp;= ~CLE_ADRR_BIT; break;
		case NAND_CTL_SETALE: this->IO_ADDR_W |= ALE_ADRR_BIT;  break;
		case NAND_CTL_CLRALE: this->IO_ADDR_W &amp;= ~ALE_ADRR_BIT; break;
	}
}
		</programlisting>
	</sect1>
	<sect1 id="Device_ready_function">
		<title>Device ready function</title>
		<para>
			If the hardware interface has the ready busy pin of the NAND chip connected to a
			GPIO or other accessible I/O pin, this function is used to read back the state of the
			pin. The function has no arguments and should return 0, if the device is busy (R/B pin 
			is low) and 1, if the device is ready (R/B pin is high).
			If the hardware interface does not give access to the ready busy pin, then
			the function must not be defined and the function pointer this->dev_ready is set to NULL.		
		</para>
	</sect1>
	<sect1 id="Init_function">
		<title>Init function</title>
		<para>
			The init function allocates memory and sets up all the board
			specific parameters and function pointers. When everything
			is set up nand_scan() is called. This function tries to
			detect and identify then chip. If a chip is found all the
			internal data fields are initialized accordingly.
			The structure(s) have to be zeroed out first and then filled with the necessary
			information about the device.
		</para>
		<programlisting>
static int __init board_init (void)
{
	struct nand_chip *this;
	int err = 0;

	/* Allocate memory for MTD device structure and private data */
	board_mtd = kzalloc(sizeof(struct mtd_info) + sizeof(struct nand_chip), GFP_KERNEL);
	if (!board_mtd) {
		printk ("Unable to allocate NAND MTD device structure.\n");
		err = -ENOMEM;
		goto out;
	}

	/* map physical address */
	baseaddr = ioremap(CHIP_PHYSICAL_ADDRESS, 1024);
	if (!baseaddr) {
		printk("Ioremap to access NAND chip failed\n");
		err = -EIO;
		goto out_mtd;
	}

	/* Get pointer to private data */
	this = (struct nand_chip *) ();
	/* Link the private data with the MTD structure */
	board_mtd->priv = this;

	/* Set address of NAND IO lines */
	this->IO_ADDR_R = baseaddr;
	this->IO_ADDR_W = baseaddr;
	/* Reference hardware control function */
	this->hwcontrol = board_hwcontrol;
	/* Set command delay time, see datasheet for correct value */
	this->chip_delay = CHIP_DEPENDEND_COMMAND_DELAY;
	/* Assign the device ready function, if available */
	this->dev_ready = board_dev_ready;
	this->eccmode = NAND_ECC_SOFT;

	/* Scan to find existence of the device */
	if (nand_scan (board_mtd, 1)) {
		err = -ENXIO;
		goto out_ior;
	}
	
	add_mtd_partitions(board_mtd, partition_info, NUM_PARTITIONS);
	goto out;

out_ior:
	iounmap(baseaddr);
out_mtd:
	kfree (board_mtd);
out:
	return err;
}
module_init(board_init);
		</programlisting>
	</sect1>
	<sect1 id="Exit_function">
		<title>Exit function</title>
		<para>
			The exit function is only necessary if the driver is
			compiled as a module. It releases all resources which
			are held by the chip driver and unregisters the partitions
			in the MTD layer.
		</para>
		<programlisting>
#ifdef MODULE
static void __exit board_cleanup (void)
{
	/* Release resources, unregister device */
	nand_release (board_mtd);

	/* unmap physical address */
	iounmap(baseaddr);
	
	/* Free the MTD device structure */
	kfree (board_mtd);
}
module_exit(board_cleanup);
#endif
		</programlisting>
	</sect1>
  </chapter>

  <chapter id="boarddriversadvanced">
     	<title>Advanced board driver functions</title>
	<para>
		This chapter describes the advanced functionality of the NAND
		driver. For a list of functions which can be overridden by the board
		driver see the documentation of the nand_chip structure.
	</para>
	<sect1 id="Multiple_chip_control">
		<title>Multiple chip control</title>
		<para>
			The nand driver can control chip arrays. Therefore the
			board driver must provide an own select_chip function. This
			function must (de)select the requested chip.
			The function pointer in the nand_chip structure must
			be set before calling nand_scan(). The maxchip parameter
			of nand_scan() defines the maximum number of chips to
			scan for. Make sure that the select_chip function can
			handle the requested number of chips.
		</para>
		<para>
			The nand driver concatenates the chips to one virtual
			chip and provides this virtual chip to the MTD layer.
		</para>
		<para>
			<emphasis>Note: The driver can only handle linear chip arrays
			of equally sized chips. There is no support for
			parallel arrays which extend the buswidth.</emphasis>
		</para>
		<para>
			<emphasis>GPIO based example</emphasis>
		</para>
		<programlisting>
static void board_select_chip (struct mtd_info *mtd, int chip)
{
	/* Deselect all chips, set all nCE pins high */
	GPIO(BOARD_NAND_NCE) |= 0xff;	
	if (chip >= 0)
		GPIO(BOARD_NAND_NCE) &amp;= ~ (1 &lt;&lt; chip);
}
		</programlisting>
		<para>
			<emphasis>Address lines based example.</emphasis>
			Its assumed that the nCE pins are connected to an
			address decoder.
		</para>
		<programlisting>
static void board_select_chip (struct mtd_info *mtd, int chip)
{
	struct nand_chip *this = (struct nand_chip *) mtd->priv;
	
	/* Deselect all chips */
	this->IO_ADDR_R &amp;= ~BOARD_NAND_ADDR_MASK;
	this->IO_ADDR_W &amp;= ~BOARD_NAND_ADDR_MASK;
	switch (chip) {
	case 0:
		this->IO_ADDR_R |= BOARD_NAND_ADDR_CHIP0;
		this->IO_ADDR_W |= BOARD_NAND_ADDR_CHIP0;
		break;
	....	
	case n:
		this->IO_ADDR_R |= BOARD_NAND_ADDR_CHIPn;
		this->IO_ADDR_W |= BOARD_NAND_ADDR_CHIPn;
		break;
	}	
}
		</programlisting>
	</sect1>
	<sect1 id="Hardware_ECC_support">
		<title>Hardware ECC support</title>
		<sect2 id="Functions_and_constants">
			<title>Functions and constants</title>
			<para>
				The nand driver supports three different types of
				hardware ECC.
				<itemizedlist>
				<listitem><para>NAND_ECC_HW3_256</para><para>
				Hardware ECC generator providing 3 bytes ECC per
				256 byte.
				</para>	</listitem>
				<listitem><para>NAND_ECC_HW3_512</para><para>
				Hardware ECC generator providing 3 bytes ECC per
				512 byte.
				</para>	</listitem>
				<listitem><para>NAND_ECC_HW6_512</para><para>
				Hardware ECC generator providing 6 bytes ECC per
				512 byte.
				</para>	</listitem>
				<listitem><para>NAND_ECC_HW8_512</para><para>
				Hardware ECC generator providing 6 bytes ECC per
				512 byte.
				</para>	</listitem>
				</itemizedlist>
				If your hardware generator has a different functionality
				add it at the appropriate place in nand_base.c
			</para>
			<para>
				The board driver must provide following functions:
				<itemizedlist>
				<listitem><para>enable_hwecc</para><para>
				This function is called before reading / writing to
				the chip. Reset or initialize the hardware generator
				in this function. The function is called with an
				argument which let you distinguish between read 
				and write operations.
				</para>	</listitem>
				<listitem><para>calculate_ecc</para><para>
				This function is called after read / write from / to
				the chip. Transfer the ECC from the hardware to
				the buffer. If the option NAND_HWECC_SYNDROME is set
				then the function is only called on write. See below.
				</para>	</listitem>
				<listitem><para>correct_data</para><para>
				In case of an ECC error this function is called for
				error detection and correction. Return 1 respectively 2
				in case the error can be corrected. If the error is
				not correctable return -1. If your hardware generator
				matches the default algorithm of the nand_ecc software
				generator then use the correction function provided
				by nand_ecc instead of implementing duplicated code.
				</para>	</listitem>
				</itemizedlist>
			</para>
		</sect2>
		<sect2 id="Hardware_ECC_with_syndrome_calculation">
		<title>Hardware ECC with syndrome calculation</title>
			<para>
				Many hardware ECC implementations provide Reed-Solomon
				codes and calculate an error syndrome on read. The syndrome
				must be converted to a standard Reed-Solomon syndrome
				before calling the error correction code in the generic
				Reed-Solomon library.
			</para>
			<para>
				The ECC bytes must be placed immediately after the data
				bytes in order to make the syndrome generator work. This
				is contrary to the usual layout used by software ECC. The
				separation of data and out of band area is not longer
				possible. The nand driver code handles this layout and
				the remaining free bytes in the oob area are managed by 
				the autoplacement code. Provide a matching oob-layout
				in this case. See rts_from4.c and diskonchip.c for 
				implementation reference. In those cases we must also
				use bad block tables on FLASH, because the ECC layout is
				interfering with the bad block marker positions.
				See bad block table support for details.
			</para>
		</sect2>
	</sect1>
	<sect1 id="Bad_Block_table_support">
		<title>Bad block table support</title>
		<para>
			Most NAND chips mark the bad blocks at a defined
			position in the spare area. Those blocks must 
			not be erased under any circumstances as the bad 
			block information would be lost.
			It is possible to check the bad block mark each
			time when the blocks are accessed by reading the
			spare area of the first page in the block. This
			is time consuming so a bad block table is used.
		</para>
		<para>
			The nand driver supports various types of bad block
			tables.
			<itemizedlist>
			<listitem><para>Per device</para><para>
			The bad block table contains all bad block information
			of the device which can consist of multiple chips.
			</para>	</listitem>
			<listitem><para>Per chip</para><para>
			A bad block table is used per chip and contains the
			bad block information for this particular chip.
			</para>	</listitem>
			<listitem><para>Fixed offset</para><para>
			The bad block table is located at a fixed offset
			in the chip (device). This applies to various
			DiskOnChip devices.
			</para>	</listitem>
			<listitem><para>Automatic placed</para><para>
			The bad block table is automatically placed and
			detected either at the end or at the beginning
			of a chip (device)
			</para>	</listitem>
			<listitem><para>Mirrored tables</para><para>
			The bad block table is mirrored on the chip (device) to
			allow updates of the bad block table without data loss.
			</para>	</listitem>
			</itemizedlist>
		</para>
		<para>	
			nand_scan() calls the function nand_default_bbt(). 
			nand_default_bbt() selects appropriate default
			bad block table descriptors depending on the chip information
			which was retrieved by nand_scan().
		</para>
		<para>
			The standard policy is scanning the device for bad 
			blocks and build a ram based bad block table which
			allows faster access than always checking the
			bad block information on the flash chip itself.
		</para>
		<sect2 id="Flash_based_tables">
			<title>Flash based tables</title>
			<para>
				It may be desired or necessary to keep a bad block table in FLASH.
				For AG-AND chips this is mandatory, as they have no factory marked
				bad blocks. They have factory marked good blocks. The marker pattern
				is erased when the block is erased to be reused. So in case of
				powerloss before writing the pattern back to the chip this block 
				would be lost and added to the bad blocks. Therefore we scan the 
				chip(s) when we detect them the first time for good blocks and 
				store this information in a bad block table before erasing any 
				of the blocks.
			</para>
			<para>
				The blocks in which the tables are stored are protected against
				accidental access by marking them bad in the memory bad block
				table. The bad block table management functions are allowed
				to circumvent this protection.
			</para>
			<para>
				The simplest way to activate the FLASH based bad block table support 
				is to set the option NAND_BBT_USE_FLASH in the bbt_option field of
				the nand chip structure before calling nand_scan(). For AG-AND
				chips is this done by default.
				This activates the default FLASH based bad block table functionality 
				of the NAND driver. The default bad block table options are
				<itemizedlist>
				<listitem><para>Store bad block table per chip</para></listitem>
				<listitem><para>Use 2 bits per block</para></listitem>
				<listitem><para>Automatic placement at the end of the chip</para></listitem>
				<listitem><para>Use mirrored tables with version numbers</para></listitem>
				<listitem><para>Reserve 4 blocks at the end of the chip</para></listitem>
				</itemizedlist>
			</para>
		</sect2>
		<sect2 id="User_defined_tables">
			<title>User defined tables</title>
			<para>
				User defined tables are created by filling out a 
				nand_bbt_descr structure and storing the pointer in the
				nand_chip structure member bbt_td before calling nand_scan(). 
				If a mirror table is necessary a second structure must be
				created and a pointer to this structure must be stored
				in bbt_md inside the nand_chip structure. If the bbt_md 
				member is set to NULL then only the main table is used
				and no scan for the mirrored table is performed.
			</para>
			<para>
				The most important field in the nand_bbt_descr structure
				is the options field. The options define most of the 
				table properties. Use the predefined constants from
				nand.h to define the options.
				<itemizedlist>
				<listitem><para>Number of bits per block</para>
				<para>The supported number of bits is 1, 2, 4, 8.</para></listitem>
				<listitem><para>Table per chip</para>
				<para>Setting the constant NAND_BBT_PERCHIP selects that
				a bad block table is managed for each chip in a chip array.
				If this option is not set then a per device bad block table
				is used.</para></listitem>
				<listitem><para>Table location is absolute</para>
				<para>Use the option constant NAND_BBT_ABSPAGE and
				define the absolute page number where the bad block
				table starts in the field pages. If you have selected bad block
				tables per chip and you have a multi chip array then the start page
				must be given for each chip in the chip array. Note: there is no scan
				for a table ident pattern performed, so the fields 
				pattern, veroffs, offs, len can be left uninitialized</para></listitem>
				<listitem><para>Table location is automatically detected</para>
				<para>The table can either be located in the first or the last good
				blocks of the chip (device). Set NAND_BBT_LASTBLOCK to place
				the bad block table at the end of the chip (device). The
				bad block tables are marked and identified by a pattern which
				is stored in the spare area of the first page in the block which
				holds the bad block table. Store a pointer to the pattern  
				in the pattern field. Further the length of the pattern has to be 
				stored in len and the offset in the spare area must be given
				in the offs member of the nand_bbt_descr structure. For mirrored
				bad block tables different patterns are mandatory.</para></listitem>
				<listitem><para>Table creation</para>
				<para>Set the option NAND_BBT_CREATE to enable the table creation
				if no table can be found during the scan. Usually this is done only 
				once if a new chip is found. </para></listitem>
				<listitem><para>Table write support</para>
				<para>Set the option NAND_BBT_WRITE to enable the table write support.
				This allows the update of the bad block table(s) in case a block has
				to be marked bad due to wear. The MTD interface function block_markbad
				is calling the update function of the bad block table. If the write
				support is enabled then the table is updated on FLASH.</para>
				<para>
				Note: Write support should only be enabled for mirrored tables with
				version control.
				</para></listitem>
				<listitem><para>Table version control</para>
				<para>Set the option NAND_BBT_VERSION to enable the table version control.
				It's highly recommended to enable this for mirrored tables with write
				support. It makes sure that the risk of losing the bad block
				table information is reduced to the loss of the information about the
				one worn out block which should be marked bad. The version is stored in
				4 consecutive bytes in the spare area of the device. The position of
				the version number is defined by the member veroffs in the bad block table
				descriptor.</para></listitem>
				<listitem><para>Save block contents on write</para>
				<para>
				In case that the block which holds the bad block table does contain
				other useful information, set the option NAND_BBT_SAVECONTENT. When
				the bad block table is written then the whole block is read the bad
				block table is updated and the block is erased and everything is 
				written back. If this option is not set only the bad block table
				is written and everything else in the block is ignored and erased.
				</para></listitem>
				<listitem><para>Number of reserved blocks</para>
				<para>
				For automatic placement some blocks must be reserved for
				bad block table storage. The number of reserved blocks is defined 
				in the maxblocks member of the bad block table description structure.
				Reserving 4 blocks for mirrored tables should be a reasonable number. 
				This also limits the number of blocks which are scanned for the bad
				block table ident pattern.
				</para></listitem>
				</itemizedlist>
			</para>
		</sect2>
	</sect1>
	<sect1 id="Spare_area_placement">
		<title>Spare area (auto)placement</title>
		<para>
			The nand driver implements different possibilities for
			placement of filesystem data in the spare area, 
			<itemizedlist>
			<listitem><para>Placement defined by fs driver</para></listitem>
			<listitem><para>Automatic placement</para></listitem>
			</itemizedlist>
			The default placement function is automatic placement. The
			nand driver has built in default placement schemes for the
			various chiptypes. If due to hardware ECC functionality the
			default placement does not fit then the board driver can
			provide a own placement scheme.
		</para>
		<para>
			File system drivers can provide a own placement scheme which
			is used instead of the default placement scheme.
		</para>
		<para>
			Placement schemes are defined by a nand_oobinfo structure
	     		<programlisting>
struct nand_oobinfo {
	int	useecc;
	int	eccbytes;
	int	eccpos[24];
	int	oobfree[8][2];
};
	     		</programlisting>
			<itemizedlist>
			<listitem><para>useecc</para><para>
				The useecc member controls the ecc and placement function. The header
				file include/mtd/mtd-abi.h contains constants to select ecc and
				placement. MTD_NANDECC_OFF switches off the ecc complete. This is
				not recommended and available for testing and diagnosis only.
				MTD_NANDECC_PLACE selects caller defined placement, MTD_NANDECC_AUTOPLACE
				selects automatic placement.
			</para></listitem>
			<listitem><para>eccbytes</para><para>
				The eccbytes member defines the number of ecc bytes per page.
			</para></listitem>
			<listitem><para>eccpos</para><para>
				The eccpos array holds the byte offsets in the spare area where
				the ecc codes are placed.
			</para></listitem>
			<listitem><para>oobfree</para><para>
				The oobfree array defines the areas in the spare area which can be
				used for automatic placement. The information is given in the format
				{offset, size}. offset defines the start of the usable area, size the
				length in bytes. More than one area can be defined. The list is terminated
				by an {0, 0} entry.
			</para></listitem>
			</itemizedlist>
		</para>
		<sect2 id="Placement_defined_by_fs_driver">
			<title>Placement defined by fs driver</title>
			<para>
				The calling function provides a pointer to a nand_oobinfo
				structure which defines the ecc placement. For writes the
				caller must provide a spare area buffer along with the
				data buffer. The spare area buffer size is (number of pages) *
				(size of spare area). For reads the buffer size is
				(number of pages) * ((size of spare area) + (number of ecc
				steps per page) * sizeof (int)). The driver stores the
				result of the ecc check for each tuple in the spare buffer.
				The storage sequence is 
			</para>
			<para>
				&lt;spare data page 0&gt;&lt;ecc result 0&gt;...&lt;ecc result n&gt;
			</para>
			<para>
				...
			</para>
			<para>
				&lt;spare data page n&gt;&lt;ecc result 0&gt;...&lt;ecc result n&gt;
			</para>
			<para>
				This is a legacy mode used by YAFFS1.
			</para>
			<para>
				If the spare area buffer is NULL then only the ECC placement is
				done according to the given scheme in the nand_oobinfo structure.
			</para>
		</sect2>
		<sect2 id="Automatic_placement">
			<title>Automatic placement</title>
			<para>
				Automatic placement uses the built in defaults to place the
				ecc bytes in the spare area. If filesystem data have to be stored /
				read into the spare area then the calling function must provide a
				buffer. The buffer size per page is determined by the oobfree array in
				the nand_oobinfo structure.
			</para>
			<para>
				If the spare area buffer is NULL then only the ECC placement is
				done according to the default builtin scheme.
			</para>
		</sect2>
	</sect1>	
	<sect1 id="Spare_area_autoplacement_default">
		<title>Spare area autoplacement default schemes</title>
		<sect2 id="pagesize_256">
			<title>256 byte pagesize</title>
<informaltable><tgroup cols="3"><tbody>
<row>
<entry>Offset</entry>
<entry>Content</entry>
<entry>Comment</entry>
</row>
<row>
<entry>0x00</entry>
<entry>ECC byte 0</entry>
<entry>Error correction code byte 0</entry>
</row>
<row>
<entry>0x01</entry>
<entry>ECC byte 1</entry>
<entry>Error correction code byte 1</entry>
</row>
<row>
<entry>0x02</entry>
<entry>ECC byte 2</entry>
<entry>Error correction code byte 2</entry>
</row>
<row>
<entry>0x03</entry>
<entry>Autoplace 0</entry>
<entry></entry>
</row>
<row>
<entry>0x04</entry>
<entry>Autoplace 1</entry>
<entry></entry>
</row>
<row>
<entry>0x05</entry>
<entry>Bad block marker</entry>
<entry>If any bit in this byte is zero, then this block is bad.
This applies only to the first page in a block. In the remaining
pages this byte is reserved</entry>
</row>
<row>
<entry>0x06</entry>
<entry>Autoplace 2</entry>
<entry></entry>
</row>
<row>
<entry>0x07</entry>
<entry>Autoplace 3</entry>
<entry></entry>
</row>
</tbody></tgroup></informaltable>
		</sect2>
		<sect2 id="pagesize_512">
			<title>512 byte pagesize</title>
<informaltable><tgroup cols="3"><tbody>
<row>
<entry>Offset</entry>
<entry>Content</entry>
<entry>Comment</entry>
</row>
<row>
<entry>0x00</entry>
<entry>ECC byte 0</entry>
<entry>Error correction code byte 0 of the lower 256 Byte data in
this page</entry>
</row>
<row>
<entry>0x01</entry>
<entry>ECC byte 1</entry>
<entry>Error correction code byte 1 of the lower 256 Bytes of data
in this page</entry>
</row>
<row>
<entry>0x02</entry>
<entry>ECC byte 2</entry>
<entry>Error correction code byte 2 of the lower 256 Bytes of data
in this page</entry>
</row>
<row>
<entry>0x03</entry>
<entry>ECC byte 3</entry>
<entry>Error correction code byte 0 of the upper 256 Bytes of data
in this page</entry>
</row>
<row>
<entry>0x04</entry>
<entry>reserved</entry>
<entry>reserved</entry>
</row>
<row>
<entry>0x05</entry>
<entry>Bad block marker</entry>
<entry>If any bit in this byte is zero, then this block is bad.
This applies only to the first page in a block. In the remaining
pages this byte is reserved</entry>
</row>
<row>
<entry>0x06</entry>
<entry>ECC byte 4</entry>
<entry>Error correction code byte 1 of the upper 256 Bytes of data
in this page</entry>
</row>
<row>
<entry>0x07</entry>
<entry>ECC byte 5</entry>
<entry>Error correction code byte 2 of the upper 256 Bytes of data
in this page</entry>
</row>
<row>
<entry>0x08 - 0x0F</entry>
<entry>Autoplace 0 - 7</entry>
<entry></entry>
</row>
</tbody></tgroup></informaltable>
		</sect2>
		<sect2 id="pagesize_2048">
			<title>2048 byte pagesize</title>
<informaltable><tgroup cols="3"><tbody>
<row>
<entry>Offset</entry>
<entry>Content</entry>
<entry>Comment</entry>
</row>
<row>
<entry>0x00</entry>
<entry>Bad block marker</entry>
<entry>If any bit in this byte is zero, then this block is bad.
This applies only to the first page in a block. In the remaining
pages this byte is reserved</entry>
</row>
<row>
<entry>0x01</entry>
<entry>Reserved</entry>
<entry>Reserved</entry>
</row>
<row>
<entry>0x02-0x27</entry>
<entry>Autoplace 0 - 37</entry>
<entry></entry>
</row>
<row>
<entry>0x28</entry>
<entry>ECC byte 0</entry>
<entry>Error correction code byte 0 of the first 256 Byte data in
this page</entry>
</row>
<row>
<entry>0x29</entry>
<entry>ECC byte 1</entry>
<entry>Error correction code byte 1 of the first 256 Bytes of data
in this page</entry>
</row>
<row>
<entry>0x2A</entry>
<entry>ECC byte 2</entry>
<entry>Error correction code byte 2 of the first 256 Bytes data in
this page</entry>
</row>
<row>
<entry>0x2B</entry>
<entry>ECC byte 3</entry>
<entry>Error correction code byte 0 of the second 256 Bytes of data
in this page</entry>
</row>
<row>
<entry>0x2C</entry>
<entry>ECC byte 4</entry>
<entry>Error correction code byte 1 of the second 256 Bytes of data
in this page</entry>
</row>
<row>
<entry>0x2D</entry>
<entry>ECC byte 5</entry>
<entry>Error correction code byte 2 of the second 256 Bytes of data
in this page</entry>
</row>
<row>
<entry>0x2E</entry>
<entry>ECC byte 6</entry>
<entry>Error correction code byte 0 of the third 256 Bytes of data
in this page</entry>
</row>
<row>
<entry>0x2F</entry>
<entry>ECC byte 7</entry>
<entry>Error correction code byte 1 of the third 256 Bytes of data
in this page</entry>
</row>
<row>
<entry>0x30</entry>
<entry>ECC byte 8</entry>
<entry>Error correction code byte 2 of the third 256 Bytes of data
in this page</entry>
</row>
<row>
<entry>0x31</entry>
<entry>ECC byte 9</entry>
<entry>Error correction code byte 0 of the fourth 256 Bytes of data
in this page</entry>
</row>
<row>
<entry>0x32</entry>
<entry>ECC byte 10</entry>
<entry>Error correction code byte 1 of the fourth 256 Bytes of data
in this page</entry>
</row>
<row>
<entry>0x33</entry>
<entry>ECC byte 11</entry>
<entry>Error correction code byte 2 of the fourth 256 Bytes of data
in this page</entry>
</row>
<row>
<entry>0x34</entry>
<entry>ECC byte 12</entry>
<entry>Error correction code byte 0 of the fifth 256 Bytes of data
in this page</entry>
</row>
<row>
<entry>0x35</entry>
<entry>ECC byte 13</entry>
<entry>Error correction code byte 1 of the fifth 256 Bytes of data
in this page</entry>
</row>
<row>
<entry>0x36</entry>
<entry>ECC byte 14</entry>
<entry>Error correction code byte 2 of the fifth 256 Bytes of data
in this page</entry>
</row>
<row>
<entry>0x37</entry>
<entry>ECC byte 15</entry>
<entry>Error correction code byte 0 of the sixt 256 Bytes of data
in this page</entry>
</row>
<row>
<entry>0x38</entry>
<entry>ECC byte 16</entry>
<entry>Error correction code byte 1 of the sixt 256 Bytes of data
in this page</entry>
</row>
<row>
<entry>0x39</entry>
<entry>ECC byte 17</entry>
<entry>Error correction code byte 2 of the sixt 256 Bytes of data
in this page</entry>
</row>
<row>
<entry>0x3A</entry>
<entry>ECC byte 18</entry>
<entry>Error correction code byte 0 of the seventh 256 Bytes of
data in this page</entry>
</row>
<row>
<entry>0x3B</entry>
<entry>ECC byte 19</entry>
<entry>Error correction code byte 1 of the seventh 256 Bytes of
data in this page</entry>
</row>
<row>
<entry>0x3C</entry>
<entry>ECC byte 20</entry>
<entry>Error correction code byte 2 of the seventh 256 Bytes of
data in this page</entry>
</row>
<row>
<entry>0x3D</entry>
<entry>ECC byte 21</entry>
<entry>Error correction code byte 0 of the eighth 256 Bytes of data
in this page</entry>
</row>
<row>
<entry>0x3E</entry>
<entry>ECC byte 22</entry>
<entry>Error correction code byte 1 of the eighth 256 Bytes of data
in this page</entry>
</row>
<row>
<entry>0x3F</entry>
<entry>ECC byte 23</entry>
<entry>Error correction code byte 2 of the eighth 256 Bytes of data
in this page</entry>
</row>
</tbody></tgroup></informaltable>
		</sect2>
     	</sect1>
  </chapter>

  <chapter id="filesystems">
     	<title>Filesystem support</title>
	<para>
		The NAND driver provides all necessary functions for a
		filesystem via the MTD interface.
	</para>
	<para>
		Filesystems must be aware of the NAND peculiarities and
		restrictions. One major restrictions of NAND Flash is, that you cannot 
		write as often as you want to a page. The consecutive writes to a page, 
		before erasing it again, are restricted to 1-3 writes, depending on the 
		manufacturers specifications. This applies similar to the spare area. 
	</para>
	<para>
		Therefore NAND aware filesystems must either write in page size chunks
		or hold a writebuffer to collect smaller writes until they sum up to 
		pagesize. Available NAND aware filesystems: JFFS2, YAFFS. 		
	</para>
	<para>
		The spare area usage to store filesystem data is controlled by
		the spare area placement functionality which is described in one
		of the earlier chapters.
	</para>
  </chapter>	
  <chapter id="tools">
     	<title>Tools</title>
	<para>
		The MTD project provides a couple of helpful tools to handle NAND Flash.
		<itemizedlist>
		<listitem><para>flasherase, flasheraseall: Erase and format FLASH partitions</para></listitem>
		<listitem><para>nandwrite: write filesystem images to NAND FLASH</para></listitem>
		<listitem><para>nanddump: dump the contents of a NAND FLASH partitions</para></listitem>
		</itemizedlist>
	</para>
	<para>
		These tools are aware of the NAND restrictions. Please use those tools
		instead of complaining about errors which are caused by non NAND aware
		access methods.
	</para>
  </chapter>	

  <chapter id="defines">
     <title>Constants</title>
     <para>
     This chapter describes the constants which might be relevant for a driver developer.
     </para>
     <sect1 id="Chip_option_constants">
	<title>Chip option constants</title>
     	<sect2 id="Constants_for_chip_id_table">
		<title>Constants for chip id table</title>
     		<para>
		These constants are defined in nand.h. They are ored together to describe
		the chip functionality.
     		<programlisting>
/* Buswitdh is 16 bit */
#define NAND_BUSWIDTH_16	0x00000002
/* Device supports partial programming without padding */
#define NAND_NO_PADDING		0x00000004
/* Chip has cache program function */
#define NAND_CACHEPRG		0x00000008
/* Chip has copy back function */
#define NAND_COPYBACK		0x00000010
/* AND Chip which has 4 banks and a confusing page / block 
 * assignment. See Renesas datasheet for further information */
#define NAND_IS_AND		0x00000020
/* Chip has a array of 4 pages which can be read without
 * additional ready /busy waits */
#define NAND_4PAGE_ARRAY	0x00000040 
		</programlisting>
     		</para>
     	</sect2>
     	<sect2 id="Constants_for_runtime_options">
		<title>Constants for runtime options</title>
     		<para>
		These constants are defined in nand.h. They are ored together to describe
		the functionality.
     		<programlisting>
/* The hw ecc generator provides a syndrome instead a ecc value on read 
 * This can only work if we have the ecc bytes directly behind the 
 * data bytes. Applies for DOC and AG-AND Renesas HW Reed Solomon generators */
#define NAND_HWECC_SYNDROME	0x00020000
		</programlisting>
     		</para>
     	</sect2>
     </sect1>	

     <sect1 id="EEC_selection_constants">
	<title>ECC selection constants</title>
	<para>
	Use these constants to select the ECC algorithm.
  	<programlisting>
/* No ECC. Usage is not recommended ! */
#define NAND_ECC_NONE		0
/* Software ECC 3 byte ECC per 256 Byte data */
#define NAND_ECC_SOFT		1
/* Hardware ECC 3 byte ECC per 256 Byte data */
#define NAND_ECC_HW3_256	2
/* Hardware ECC 3 byte ECC per 512 Byte data */
#define NAND_ECC_HW3_512	3
/* Hardware ECC 6 byte ECC per 512 Byte data */
#define NAND_ECC_HW6_512	4
/* Hardware ECC 6 byte ECC per 512 Byte data */
#define NAND_ECC_HW8_512	6
	</programlisting>
	</para>
     </sect1>	

     <sect1 id="Hardware_control_related_constants">
	<title>Hardware control related constants</title>
	<para>
	These constants describe the requested hardware access function when
	the boardspecific hardware control function is called
  	<programlisting>
/* Select the chip by setting nCE to low */
#define NAND_CTL_SETNCE 	1
/* Deselect the chip by setting nCE to high */
#define NAND_CTL_CLRNCE		2
/* Select the command latch by setting CLE to high */
#define NAND_CTL_SETCLE		3
/* Deselect the command latch by setting CLE to low */
#define NAND_CTL_CLRCLE		4
/* Select the address latch by setting ALE to high */
#define NAND_CTL_SETALE		5
/* Deselect the address latch by setting ALE to low */
#define NAND_CTL_CLRALE		6
/* Set write protection by setting WP to high. Not used! */
#define NAND_CTL_SETWP		7
/* Clear write protection by setting WP to low. Not used! */
#define NAND_CTL_CLRWP		8
	</programlisting>
	</para>
     </sect1>	

     <sect1 id="Bad_block_table_constants">
	<title>Bad block table related constants</title>
	<para>
	These constants describe the options used for bad block
	table descriptors.
  	<programlisting>
/* Options for the bad block table descriptors */

/* The number of bits used per block in the bbt on the device */
#define NAND_BBT_NRBITS_MSK	0x0000000F
#define NAND_BBT_1BIT		0x00000001
#define NAND_BBT_2BIT		0x00000002
#define NAND_BBT_4BIT		0x00000004
#define NAND_BBT_8BIT		0x00000008
/* The bad block table is in the last good block of the device */
#define	NAND_BBT_LASTBLOCK	0x00000010
/* The bbt is at the given page, else we must scan for the bbt */
#define NAND_BBT_ABSPAGE	0x00000020
/* bbt is stored per chip on multichip devices */
#define NAND_BBT_PERCHIP	0x00000080
/* bbt has a version counter at offset veroffs */
#define NAND_BBT_VERSION	0x00000100
/* Create a bbt if none axists */
#define NAND_BBT_CREATE		0x00000200
/* Write bbt if necessary */
#define NAND_BBT_WRITE		0x00001000
/* Read and write back block contents when writing bbt */
#define NAND_BBT_SAVECONTENT	0x00002000
	</programlisting>
	</para>
     </sect1>	

  </chapter>
  	
  <chapter id="structs">
     <title>Structures</title>
     <para>
     This chapter contains the autogenerated documentation of the structures which are
     used in the NAND driver and might be relevant for a driver developer. Each  
     struct member has a short description which is marked with an [XXX] identifier.
     See the chapter "Documentation hints" for an explanation.
     </para>
<!-- include/linux/mtd/nand.h -->
<refentry id="API-struct-nand-hw-control">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct nand_hw_control</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct nand_hw_control</refname>
 <refpurpose>
  Control structure for hardware controller (e.g ECC generator) shared among independent devices
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct nand_hw_control {
  spinlock_t lock;
  struct nand_chip * active;
  wait_queue_head_t wq;
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>lock</term>
      <listitem><para>
protection lock
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>active</term>
      <listitem><para>
the mtd device which holds the controller currently
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>wq</term>
      <listitem><para>
wait queue to sleep on if a NAND operation is in
progress used instead of the per chip wait queue
when a hw controller is available.
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
</refentry>

<refentry id="API-struct-nand-ecc-ctrl">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct nand_ecc_ctrl</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct nand_ecc_ctrl</refname>
 <refpurpose>
     Control structure for ECC
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct nand_ecc_ctrl {
  nand_ecc_modes_t mode;
  int steps;
  int size;
  int bytes;
  int total;
  int strength;
  int prepad;
  int postpad;
  struct nand_ecclayout * layout;
  void * priv;
  void (* hwctl) (struct mtd_info *mtd, int mode);
  int (* calculate) (struct mtd_info *mtd, const uint8_t *dat,uint8_t *ecc_code);
  int (* correct) (struct mtd_info *mtd, uint8_t *dat, uint8_t *read_ecc,uint8_t *calc_ecc);
  int (* read_page_raw) (struct mtd_info *mtd, struct nand_chip *chip,uint8_t *buf, int oob_required, int page);
  int (* write_page_raw) (struct mtd_info *mtd, struct nand_chip *chip,const uint8_t *buf, int oob_required);
  int (* read_page) (struct mtd_info *mtd, struct nand_chip *chip,uint8_t *buf, int oob_required, int page);
  int (* read_subpage) (struct mtd_info *mtd, struct nand_chip *chip,uint32_t offs, uint32_t len, uint8_t *buf, int page);
  int (* write_subpage) (struct mtd_info *mtd, struct nand_chip *chip,uint32_t offset, uint32_t data_len,const uint8_t *data_buf, int oob_required);
  int (* write_page) (struct mtd_info *mtd, struct nand_chip *chip,const uint8_t *buf, int oob_required);
  int (* write_oob_raw) (struct mtd_info *mtd, struct nand_chip *chip,int page);
  int (* read_oob_raw) (struct mtd_info *mtd, struct nand_chip *chip,int page);
  int (* read_oob) (struct mtd_info *mtd, struct nand_chip *chip, int page);
  int (* write_oob) (struct mtd_info *mtd, struct nand_chip *chip,int page);
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>mode</term>
      <listitem><para>
   ECC mode
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>steps</term>
      <listitem><para>
   number of ECC steps per page
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>size</term>
      <listitem><para>
   data bytes per ECC step
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>bytes</term>
      <listitem><para>
   ECC bytes per step
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>total</term>
      <listitem><para>
   total number of ECC bytes per page
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>strength</term>
      <listitem><para>
   max number of correctible bits per ECC step
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>prepad</term>
      <listitem><para>
   padding information for syndrome based ECC generators
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>postpad</term>
      <listitem><para>
   padding information for syndrome based ECC generators
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>layout</term>
      <listitem><para>
   ECC layout control struct pointer
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>priv</term>
      <listitem><para>
   pointer to private ECC control data
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>hwctl</term>
      <listitem><para>
   function to control hardware ECC generator. Must only
   be provided if an hardware ECC is available
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>calculate</term>
      <listitem><para>
   function for ECC calculation or readback from ECC hardware
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>correct</term>
      <listitem><para>
   function for ECC correction, matching to ECC generator (sw/hw)
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>read_page_raw</term>
      <listitem><para>
   function to read a raw page without ECC
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>write_page_raw</term>
      <listitem><para>
   function to write a raw page without ECC
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>read_page</term>
      <listitem><para>
   function to read a page according to the ECC generator
   requirements; returns maximum number of bitflips corrected in
   any single ECC step, 0 if bitflips uncorrectable, -EIO hw error
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>read_subpage</term>
      <listitem><para>
   function to read parts of the page covered by ECC;
   returns same as <function>read_page</function>
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>write_subpage</term>
      <listitem><para>
   function to write parts of the page covered by ECC.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>write_page</term>
      <listitem><para>
   function to write a page according to the ECC generator
   requirements.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>write_oob_raw</term>
      <listitem><para>
   function to write chip OOB data without ECC
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>read_oob_raw</term>
      <listitem><para>
   function to read chip OOB data without ECC
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>read_oob</term>
      <listitem><para>
   function to read chip OOB data
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>write_oob</term>
      <listitem><para>
   function to write chip OOB data
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
</refentry>

<refentry id="API-struct-nand-buffers">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct nand_buffers</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct nand_buffers</refname>
 <refpurpose>
     buffer structure for read/write
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct nand_buffers {
  uint8_t * ecccalc;
  uint8_t * ecccode;
  uint8_t * databuf;
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>ecccalc</term>
      <listitem><para>
   buffer pointer for calculated ECC, size is oobsize.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>ecccode</term>
      <listitem><para>
   buffer pointer for ECC read from flash, size is oobsize.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>databuf</term>
      <listitem><para>
   buffer pointer for data, size is (page size + oobsize).
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
<refsect1>
<title>Description</title>
<para>
   Do not change the order of buffers. databuf and oobrbuf must be in
   consecutive order.
</para>
</refsect1>
</refentry>

<refentry id="API-struct-nand-chip">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct nand_chip</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct nand_chip</refname>
 <refpurpose>
     NAND Private Flash Chip Data
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct nand_chip {
  void __iomem * IO_ADDR_R;
  void __iomem * IO_ADDR_W;
  uint8_t (* read_byte) (struct mtd_info *mtd);
  u16 (* read_word) (struct mtd_info *mtd);
  void (* write_byte) (struct mtd_info *mtd, uint8_t byte);
  void (* write_buf) (struct mtd_info *mtd, const uint8_t *buf, int len);
  void (* read_buf) (struct mtd_info *mtd, uint8_t *buf, int len);
  void (* select_chip) (struct mtd_info *mtd, int chip);
  int (* block_bad) (struct mtd_info *mtd, loff_t ofs, int getchip);
  int (* block_markbad) (struct mtd_info *mtd, loff_t ofs);
  void (* cmd_ctrl) (struct mtd_info *mtd, int dat, unsigned int ctrl);
  int (* init_size) (struct mtd_info *mtd, struct nand_chip *this,u8 *id_data);
  int (* dev_ready) (struct mtd_info *mtd);
  void (* cmdfunc) (struct mtd_info *mtd, unsigned command, int column,int page_addr);
  int(* waitfunc) (struct mtd_info *mtd, struct nand_chip *this);
  int (* erase) (struct mtd_info *mtd, int page);
  int (* scan_bbt) (struct mtd_info *mtd);
  int (* errstat) (struct mtd_info *mtd, struct nand_chip *this, int state,int status, int page);
  int (* write_page) (struct mtd_info *mtd, struct nand_chip *chip,uint32_t offset, int data_len, const uint8_t *buf,int oob_required, int page, int cached, int raw);
  int (* onfi_set_features) (struct mtd_info *mtd, struct nand_chip *chip,int feature_addr, uint8_t *subfeature_para);
  int (* onfi_get_features) (struct mtd_info *mtd, struct nand_chip *chip,int feature_addr, uint8_t *subfeature_para);
  int (* setup_read_retry) (struct mtd_info *mtd, int retry_mode);
  int chip_delay;
  unsigned int options;
  unsigned int bbt_options;
  int page_shift;
  int phys_erase_shift;
  int bbt_erase_shift;
  int chip_shift;
  int numchips;
  uint64_t chipsize;
  int pagemask;
  int pagebuf;
  unsigned int pagebuf_bitflips;
  int subpagesize;
  uint8_t bits_per_cell;
  uint16_t ecc_strength_ds;
  uint16_t ecc_step_ds;
  int onfi_timing_mode_default;
  int badblockpos;
  int badblockbits;
  int onfi_version;
  int jedec_version;
  union {unnamed_union};
  int read_retries;
  flstate_t state;
  uint8_t * oob_poi;
  struct nand_hw_control * controller;
  struct nand_ecc_ctrl ecc;
  struct nand_buffers * buffers;
  struct nand_hw_control hwcontrol;
  uint8_t * bbt;
  struct nand_bbt_descr * bbt_td;
  struct nand_bbt_descr * bbt_md;
  struct nand_bbt_descr * badblock_pattern;
  void * priv;
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>IO_ADDR_R</term>
      <listitem><para>
   [BOARDSPECIFIC] address to read the 8 I/O lines of the
   flash device
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>IO_ADDR_W</term>
      <listitem><para>
   [BOARDSPECIFIC] address to write the 8 I/O lines of the
   flash device.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>read_byte</term>
      <listitem><para>
   [REPLACEABLE] read one byte from the chip
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>read_word</term>
      <listitem><para>
   [REPLACEABLE] read one word from the chip
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>write_byte</term>
      <listitem><para>
   [REPLACEABLE] write a single byte to the chip on the
   low 8 I/O lines
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>write_buf</term>
      <listitem><para>
   [REPLACEABLE] write data from the buffer to the chip
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>read_buf</term>
      <listitem><para>
   [REPLACEABLE] read data from the chip into the buffer
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>select_chip</term>
      <listitem><para>
   [REPLACEABLE] select chip nr
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>block_bad</term>
      <listitem><para>
   [REPLACEABLE] check if a block is bad, using OOB markers
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>block_markbad</term>
      <listitem><para>
   [REPLACEABLE] mark a block bad
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>cmd_ctrl</term>
      <listitem><para>
   [BOARDSPECIFIC] hardwarespecific function for controlling
   ALE/CLE/nCE. Also used to write command and address
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>init_size</term>
      <listitem><para>
   [BOARDSPECIFIC] hardwarespecific function for setting
   mtd-&gt;oobsize, mtd-&gt;writesize and so on.
   <parameter>id_data</parameter> contains the 8 bytes values of NAND_CMD_READID.
   Return with the bus width.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>dev_ready</term>
      <listitem><para>
   [BOARDSPECIFIC] hardwarespecific function for accessing
   device ready/busy line. If set to NULL no access to
   ready/busy is available and the ready/busy information
   is read from the chip status register.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>cmdfunc</term>
      <listitem><para>
   [REPLACEABLE] hardwarespecific function for writing
   commands to the chip.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>waitfunc</term>
      <listitem><para>
   [REPLACEABLE] hardwarespecific function for wait on
   ready.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>erase</term>
      <listitem><para>
   [REPLACEABLE] erase function
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>scan_bbt</term>
      <listitem><para>
   [REPLACEABLE] function to scan bad block table
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>errstat</term>
      <listitem><para>
   [OPTIONAL] hardware specific function to perform
   additional error status checks (determine if errors are
   correctable).
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>write_page</term>
      <listitem><para>
   [REPLACEABLE] High-level page write function
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>onfi_set_features</term>
      <listitem><para>
   [REPLACEABLE] set the features for ONFI nand
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>onfi_get_features</term>
      <listitem><para>
   [REPLACEABLE] get the features for ONFI nand
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>setup_read_retry</term>
      <listitem><para>
   [FLASHSPECIFIC] flash (vendor) specific function for
   setting the read-retry mode. Mostly needed for MLC NAND.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>chip_delay</term>
      <listitem><para>
   [BOARDSPECIFIC] chip dependent delay for transferring
   data from array to read regs (tR).
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>options</term>
      <listitem><para>
   [BOARDSPECIFIC] various chip options. They can partly
   be set to inform nand_scan about special functionality.
   See the defines for further explanation.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>bbt_options</term>
      <listitem><para>
   [INTERN] bad block specific options. All options used
   here must come from bbm.h. By default, these options
   will be copied to the appropriate nand_bbt_descr's.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>page_shift</term>
      <listitem><para>
   [INTERN] number of address bits in a page (column
   address bits).
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>phys_erase_shift</term>
      <listitem><para>
   [INTERN] number of address bits in a physical eraseblock
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>bbt_erase_shift</term>
      <listitem><para>
   [INTERN] number of address bits in a bbt entry
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>chip_shift</term>
      <listitem><para>
   [INTERN] number of address bits in one chip
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>numchips</term>
      <listitem><para>
   [INTERN] number of physical chips
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>chipsize</term>
      <listitem><para>
   [INTERN] the size of one chip for multichip arrays
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>pagemask</term>
      <listitem><para>
   [INTERN] page number mask = number of (pages / chip) - 1
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>pagebuf</term>
      <listitem><para>
   [INTERN] holds the pagenumber which is currently in
   data_buf.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>pagebuf_bitflips</term>
      <listitem><para>
   [INTERN] holds the bitflip count for the page which is
   currently in data_buf.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>subpagesize</term>
      <listitem><para>
   [INTERN] holds the subpagesize
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>bits_per_cell</term>
      <listitem><para>
   [INTERN] number of bits per cell. i.e., 1 means SLC.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>ecc_strength_ds</term>
      <listitem><para>
   [INTERN] ECC correctability from the datasheet.
   Minimum amount of bit errors per <parameter>ecc_step_ds</parameter> guaranteed
   to be correctable. If unknown, set to zero.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>ecc_step_ds</term>
      <listitem><para>
   [INTERN] ECC step required by the <parameter>ecc_strength_ds</parameter>,
   also from the datasheet. It is the recommended ECC step
   size, if known; if unknown, set to zero.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>onfi_timing_mode_default</term>
      <listitem><para>
   [INTERN] default ONFI timing mode. This field is
   either deduced from the datasheet if the NAND
   chip is not ONFI compliant or set to 0 if it is
   (an ONFI chip is always configured in mode 0
   after a NAND reset)
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>badblockpos</term>
      <listitem><para>
   [INTERN] position of the bad block marker in the oob
   area.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>badblockbits</term>
      <listitem><para>
   [INTERN] minimum number of set bits in a good block's
   bad block marker position; i.e., BBM == 11110111b is
   not bad when badblockbits == 7
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>onfi_version</term>
      <listitem><para>
   [INTERN] holds the chip ONFI version (BCD encoded),
   non 0 if ONFI supported.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>jedec_version</term>
      <listitem><para>
   [INTERN] holds the chip JEDEC version (BCD encoded),
   non 0 if JEDEC supported.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>{unnamed_union}</term>
      <listitem><para>
   anonymous
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>read_retries</term>
      <listitem><para>
   [INTERN] the number of read retry modes supported
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>state</term>
      <listitem><para>
   [INTERN] the current state of the NAND device
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>oob_poi</term>
      <listitem><para>
   "poison value buffer," used for laying out OOB data
   before writing
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>controller</term>
      <listitem><para>
   [REPLACEABLE] a pointer to a hardware controller
   structure which is shared among multiple independent
   devices.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>ecc</term>
      <listitem><para>
   [BOARDSPECIFIC] ECC control structure
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>buffers</term>
      <listitem><para>
   buffer structure for read/write
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>hwcontrol</term>
      <listitem><para>
   platform-specific hardware control structure
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>bbt</term>
      <listitem><para>
   [INTERN] bad block table pointer
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>bbt_td</term>
      <listitem><para>
   [REPLACEABLE] bad block table descriptor for flash
   lookup.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>bbt_md</term>
      <listitem><para>
   [REPLACEABLE] bad block table mirror descriptor
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>badblock_pattern</term>
      <listitem><para>
   [REPLACEABLE] bad block scan pattern used for initial
   bad block scan.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>priv</term>
      <listitem><para>
   [OPTIONAL] pointer to private chip data
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
</refentry>

<refentry id="API-struct-nand-flash-dev">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct nand_flash_dev</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct nand_flash_dev</refname>
 <refpurpose>
     NAND Flash Device ID Structure
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct nand_flash_dev {
  char * name;
  union ecc;
  int onfi_timing_mode_default;
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>name</term>
      <listitem><para>
   a human-readable name of the NAND chip
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>ecc</term>
      <listitem><para>
   ECC correctability and step information from the datasheet.
   <parameter>ecc</parameter>.strength_ds: The ECC correctability from the datasheet, same as the
   <parameter>ecc_strength_ds</parameter> in nand_chip{}.
   <parameter>ecc</parameter>.step_ds: The ECC step required by the <parameter>ecc</parameter>.strength_ds, same as the
   <parameter>ecc_step_ds</parameter> in nand_chip{}, also from the datasheet.
   For example, the <quote>4bit ECC for each 512Byte</quote> can be set with
   NAND_ECC_INFO(4, 512).
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>onfi_timing_mode_default</term>
      <listitem><para>
   the default ONFI timing mode entered after a NAND
   reset. Should be deduced from timings described
   in the datasheet.
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
</refentry>

<refentry id="API-struct-nand-manufacturers">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct nand_manufacturers</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct nand_manufacturers</refname>
 <refpurpose>
     NAND Flash Manufacturer ID Structure
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct nand_manufacturers {
  int id;
  char * name;
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>id</term>
      <listitem><para>
   manufacturer ID code of device.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>name</term>
      <listitem><para>
   Manufacturer name
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
</refentry>

<refentry id="API-struct-platform-nand-chip">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct platform_nand_chip</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct platform_nand_chip</refname>
 <refpurpose>
     chip level device structure
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct platform_nand_chip {
  int nr_chips;
  int chip_offset;
  int nr_partitions;
  struct mtd_partition * partitions;
  struct nand_ecclayout * ecclayout;
  int chip_delay;
  unsigned int options;
  unsigned int bbt_options;
  const char ** part_probe_types;
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>nr_chips</term>
      <listitem><para>
   max. number of chips to scan for
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>chip_offset</term>
      <listitem><para>
   chip number offset
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>nr_partitions</term>
      <listitem><para>
   number of partitions pointed to by partitions (or zero)
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>partitions</term>
      <listitem><para>
   mtd partition list
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>ecclayout</term>
      <listitem><para>
   ECC layout info structure
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>chip_delay</term>
      <listitem><para>
   R/B delay value in us
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>options</term>
      <listitem><para>
   Option flags, e.g. 16bit buswidth
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>bbt_options</term>
      <listitem><para>
   BBT option flags, e.g. NAND_BBT_USE_FLASH
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>part_probe_types</term>
      <listitem><para>
   NULL-terminated array of probe types
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
</refentry>

<refentry id="API-struct-platform-nand-ctrl">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct platform_nand_ctrl</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct platform_nand_ctrl</refname>
 <refpurpose>
     controller level device structure
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct platform_nand_ctrl {
  int (* probe) (struct platform_device *pdev);
  void (* remove) (struct platform_device *pdev);
  void (* hwcontrol) (struct mtd_info *mtd, int cmd);
  int (* dev_ready) (struct mtd_info *mtd);
  void (* select_chip) (struct mtd_info *mtd, int chip);
  void (* cmd_ctrl) (struct mtd_info *mtd, int dat, unsigned int ctrl);
  void (* write_buf) (struct mtd_info *mtd, const uint8_t *buf, int len);
  void (* read_buf) (struct mtd_info *mtd, uint8_t *buf, int len);
  unsigned char (* read_byte) (struct mtd_info *mtd);
  void * priv;
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>probe</term>
      <listitem><para>
   platform specific function to probe/setup hardware
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>remove</term>
      <listitem><para>
   platform specific function to remove/teardown hardware
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>hwcontrol</term>
      <listitem><para>
   platform specific hardware control structure
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>dev_ready</term>
      <listitem><para>
   platform specific function to read ready/busy pin
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>select_chip</term>
      <listitem><para>
   platform specific chip select function
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>cmd_ctrl</term>
      <listitem><para>
   platform specific function for controlling
   ALE/CLE/nCE. Also used to write command and address
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>write_buf</term>
      <listitem><para>
   platform specific function for write buffer
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>read_buf</term>
      <listitem><para>
   platform specific function for read buffer
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>read_byte</term>
      <listitem><para>
   platform specific function to read one byte from chip
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>priv</term>
      <listitem><para>
   private data to transport driver specific settings
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
<refsect1>
<title>Description</title>
<para>
   All fields are optional and depend on the hardware driver requirements
</para>
</refsect1>
</refentry>

<refentry id="API-struct-platform-nand-data">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct platform_nand_data</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct platform_nand_data</refname>
 <refpurpose>
     container structure for platform-specific data
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct platform_nand_data {
  struct platform_nand_chip chip;
  struct platform_nand_ctrl ctrl;
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>chip</term>
      <listitem><para>
   chip level chip structure
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>ctrl</term>
      <listitem><para>
   controller level device structure
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
</refentry>

<refentry id="API-nand-opcode-8bits">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>nand_opcode_8bits</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>nand_opcode_8bits</refname>
 <refpurpose>
   </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>nand_opcode_8bits </function></funcdef>
   <paramdef>unsigned int <parameter>command</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>command</parameter></term>
   <listitem>
    <para>
     opcode to check
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

  </chapter>

  <chapter id="pubfunctions">
     <title>Public Functions Provided</title>
     <para>
     This chapter contains the autogenerated documentation of the NAND kernel API functions
      which are exported. Each function has a short description which is marked with an [XXX] identifier.
     See the chapter "Documentation hints" for an explanation.
     </para>
<!-- drivers/mtd/nand/nand_base.c -->
<refentry id="API-nand-unlock">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>nand_unlock</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>nand_unlock</refname>
 <refpurpose>
  [REPLACEABLE] unlocks specified locked blocks
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>nand_unlock </function></funcdef>
   <paramdef>struct mtd_info * <parameter>mtd</parameter></paramdef>
   <paramdef>loff_t <parameter>ofs</parameter></paramdef>
   <paramdef>uint64_t <parameter>len</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>mtd</parameter></term>
   <listitem>
    <para>
     mtd info
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>ofs</parameter></term>
   <listitem>
    <para>
     offset to start unlock from
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>len</parameter></term>
   <listitem>
    <para>
     length to unlock
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Returns unlock status.
</para>
</refsect1>
</refentry>

<refentry id="API-nand-lock">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>nand_lock</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>nand_lock</refname>
 <refpurpose>
     [REPLACEABLE] locks all blocks present in the device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>nand_lock </function></funcdef>
   <paramdef>struct mtd_info * <parameter>mtd</parameter></paramdef>
   <paramdef>loff_t <parameter>ofs</parameter></paramdef>
   <paramdef>uint64_t <parameter>len</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>mtd</parameter></term>
   <listitem>
    <para>
     mtd info
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>ofs</parameter></term>
   <listitem>
    <para>
     offset to start unlock from
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>len</parameter></term>
   <listitem>
    <para>
     length to unlock
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This feature is not supported in many NAND parts. 'Micron' NAND parts do
   have this feature, but it allows only to lock all blocks, not for specified
   range for block. Implementing 'lock' feature by making use of 'unlock', for
   now.
   </para><para>

   Returns lock status.
</para>
</refsect1>
</refentry>

<refentry id="API-nand-scan-ident">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>nand_scan_ident</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>nand_scan_ident</refname>
 <refpurpose>
     [NAND Interface] Scan for the NAND device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>nand_scan_ident </function></funcdef>
   <paramdef>struct mtd_info * <parameter>mtd</parameter></paramdef>
   <paramdef>int <parameter>maxchips</parameter></paramdef>
   <paramdef>struct nand_flash_dev * <parameter>table</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>mtd</parameter></term>
   <listitem>
    <para>
     MTD device structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>maxchips</parameter></term>
   <listitem>
    <para>
     number of chips to scan for
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>table</parameter></term>
   <listitem>
    <para>
     alternative NAND ID table
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This is the first phase of the normal <function>nand_scan</function> function. It reads the
   flash ID and sets up MTD fields accordingly.
   </para><para>

   The mtd-&gt;owner field must be set to the module of the caller.
</para>
</refsect1>
</refentry>

<refentry id="API-nand-scan-tail">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>nand_scan_tail</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>nand_scan_tail</refname>
 <refpurpose>
     [NAND Interface] Scan for the NAND device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>nand_scan_tail </function></funcdef>
   <paramdef>struct mtd_info * <parameter>mtd</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>mtd</parameter></term>
   <listitem>
    <para>
     MTD device structure
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This is the second phase of the normal <function>nand_scan</function> function. It fills out
   all the uninitialized function pointers with the defaults and scans for a
   bad block table if appropriate.
</para>
</refsect1>
</refentry>

<refentry id="API-nand-scan">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>nand_scan</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>nand_scan</refname>
 <refpurpose>
     [NAND Interface] Scan for the NAND device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>nand_scan </function></funcdef>
   <paramdef>struct mtd_info * <parameter>mtd</parameter></paramdef>
   <paramdef>int <parameter>maxchips</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>mtd</parameter></term>
   <listitem>
    <para>
     MTD device structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>maxchips</parameter></term>
   <listitem>
    <para>
     number of chips to scan for
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This fills out all the uninitialized function pointers with the defaults.
   The flash ID is read and the mtd/chip structures are filled with the
   appropriate values. The mtd-&gt;owner field must be set to the module of the
   caller.
</para>
</refsect1>
</refentry>

<refentry id="API-nand-release">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>nand_release</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>nand_release</refname>
 <refpurpose>
     [NAND Interface] Free resources held by the NAND device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>nand_release </function></funcdef>
   <paramdef>struct mtd_info * <parameter>mtd</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>mtd</parameter></term>
   <listitem>
    <para>
     MTD device structure
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<!-- drivers/mtd/nand/nand_bbt.c -->
<refentry id="API-nand-scan-bbt">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>nand_scan_bbt</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>nand_scan_bbt</refname>
 <refpurpose>
  [NAND Interface] scan, find, read and maybe create bad block table(s)
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>nand_scan_bbt </function></funcdef>
   <paramdef>struct mtd_info * <parameter>mtd</parameter></paramdef>
   <paramdef>struct nand_bbt_descr * <parameter>bd</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>mtd</parameter></term>
   <listitem>
    <para>
     MTD device structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>bd</parameter></term>
   <listitem>
    <para>
     descriptor for the good/bad block search pattern
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   The function checks, if a bad block table(s) is/are already available. If
   not it scans the device for manufacturer marked good / bad blocks and writes
   the bad block table(s) to the selected place.
   </para><para>

   The bad block table memory is allocated here. It must be freed by calling
   the nand_free_bbt function.
</para>
</refsect1>
</refentry>

<!-- drivers/mtd/nand/nand_ecc.c -->
<refentry id="API---nand-calculate-ecc">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>__nand_calculate_ecc</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>__nand_calculate_ecc</refname>
 <refpurpose>
  [NAND Interface] Calculate 3-byte ECC for 256/512-byte block
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>__nand_calculate_ecc </function></funcdef>
   <paramdef>const unsigned char * <parameter>buf</parameter></paramdef>
   <paramdef>unsigned int <parameter>eccsize</parameter></paramdef>
   <paramdef>unsigned char * <parameter>code</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>buf</parameter></term>
   <listitem>
    <para>
     input buffer with raw data
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>eccsize</parameter></term>
   <listitem>
    <para>
     data bytes per ECC step (256 or 512)
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>code</parameter></term>
   <listitem>
    <para>
     output buffer with ECC
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-nand-calculate-ecc">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>nand_calculate_ecc</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>nand_calculate_ecc</refname>
 <refpurpose>
     [NAND Interface] Calculate 3-byte ECC for 256/512-byte block
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>nand_calculate_ecc </function></funcdef>
   <paramdef>struct mtd_info * <parameter>mtd</parameter></paramdef>
   <paramdef>const unsigned char * <parameter>buf</parameter></paramdef>
   <paramdef>unsigned char * <parameter>code</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>mtd</parameter></term>
   <listitem>
    <para>
     MTD block structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>buf</parameter></term>
   <listitem>
    <para>
     input buffer with raw data
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>code</parameter></term>
   <listitem>
    <para>
     output buffer with ECC
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API---nand-correct-data">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>__nand_correct_data</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>__nand_correct_data</refname>
 <refpurpose>
     [NAND Interface] Detect and correct bit error(s)
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>__nand_correct_data </function></funcdef>
   <paramdef>unsigned char * <parameter>buf</parameter></paramdef>
   <paramdef>unsigned char * <parameter>read_ecc</parameter></paramdef>
   <paramdef>unsigned char * <parameter>calc_ecc</parameter></paramdef>
   <paramdef>unsigned int <parameter>eccsize</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>buf</parameter></term>
   <listitem>
    <para>
     raw data read from the chip
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>read_ecc</parameter></term>
   <listitem>
    <para>
     ECC from the chip
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>calc_ecc</parameter></term>
   <listitem>
    <para>
     the ECC calculated from raw data
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>eccsize</parameter></term>
   <listitem>
    <para>
     data bytes per ECC step (256 or 512)
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Detect and correct a 1 bit error for eccsize byte block
</para>
</refsect1>
</refentry>

<refentry id="API-nand-correct-data">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>nand_correct_data</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>nand_correct_data</refname>
 <refpurpose>
     [NAND Interface] Detect and correct bit error(s)
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>nand_correct_data </function></funcdef>
   <paramdef>struct mtd_info * <parameter>mtd</parameter></paramdef>
   <paramdef>unsigned char * <parameter>buf</parameter></paramdef>
   <paramdef>unsigned char * <parameter>read_ecc</parameter></paramdef>
   <paramdef>unsigned char * <parameter>calc_ecc</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>mtd</parameter></term>
   <listitem>
    <para>
     MTD block structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>buf</parameter></term>
   <listitem>
    <para>
     raw data read from the chip
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>read_ecc</parameter></term>
   <listitem>
    <para>
     ECC from the chip
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>calc_ecc</parameter></term>
   <listitem>
    <para>
     the ECC calculated from raw data
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Detect and correct a 1 bit error for 256/512 byte block
</para>
</refsect1>
</refentry>

  </chapter>
  
  <chapter id="intfunctions">
     <title>Internal Functions Provided</title>
     <para>
     This chapter contains the autogenerated documentation of the NAND driver internal functions.
     Each function has a short description which is marked with an [XXX] identifier.
     See the chapter "Documentation hints" for an explanation.
     The functions marked with [DEFAULT] might be relevant for a board driver developer.
     </para>
<!-- drivers/mtd/nand/nand_base.c -->
<refentry id="API-nand-release-device">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>nand_release_device</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>nand_release_device</refname>
 <refpurpose>
  [GENERIC] release chip
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>nand_release_device </function></funcdef>
   <paramdef>struct mtd_info * <parameter>mtd</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>mtd</parameter></term>
   <listitem>
    <para>
     MTD device structure
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Release chip lock and wake up anyone waiting on the device.
</para>
</refsect1>
</refentry>

<refentry id="API-nand-read-byte">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>nand_read_byte</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>nand_read_byte</refname>
 <refpurpose>
     [DEFAULT] read one byte from the chip
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>uint8_t <function>nand_read_byte </function></funcdef>
   <paramdef>struct mtd_info * <parameter>mtd</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>mtd</parameter></term>
   <listitem>
    <para>
     MTD device structure
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Default read function for 8bit buswidth
</para>
</refsect1>
</refentry>

<refentry id="API-nand-read-byte16">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>nand_read_byte16</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>nand_read_byte16</refname>
 <refpurpose>
     [DEFAULT] read one byte endianness aware from the chip nand_read_byte16 - [DEFAULT] read one byte endianness aware from the chip
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>uint8_t <function>nand_read_byte16 </function></funcdef>
   <paramdef>struct mtd_info * <parameter>mtd</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>mtd</parameter></term>
   <listitem>
    <para>
     MTD device structure
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Default read function for 16bit buswidth with endianness conversion.
</para>
</refsect1>
</refentry>

<refentry id="API-nand-read-word">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>nand_read_word</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>nand_read_word</refname>
 <refpurpose>
     [DEFAULT] read one word from the chip
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>u16 <function>nand_read_word </function></funcdef>
   <paramdef>struct mtd_info * <parameter>mtd</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>mtd</parameter></term>
   <listitem>
    <para>
     MTD device structure
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Default read function for 16bit buswidth without endianness conversion.
</para>
</refsect1>
</refentry>

<refentry id="API-nand-select-chip">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>nand_select_chip</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>nand_select_chip</refname>
 <refpurpose>
     [DEFAULT] control CE line
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>nand_select_chip </function></funcdef>
   <paramdef>struct mtd_info * <parameter>mtd</parameter></paramdef>
   <paramdef>int <parameter>chipnr</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>mtd</parameter></term>
   <listitem>
    <para>
     MTD device structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>chipnr</parameter></term>
   <listitem>
    <para>
     chipnumber to select, -1 for deselect
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Default select function for 1 chip devices.
</para>
</refsect1>
</refentry>

<refentry id="API-nand-write-byte">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>nand_write_byte</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>nand_write_byte</refname>
 <refpurpose>
     [DEFAULT] write single byte to chip
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>nand_write_byte </function></funcdef>
   <paramdef>struct mtd_info * <parameter>mtd</parameter></paramdef>
   <paramdef>uint8_t <parameter>byte</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>mtd</parameter></term>
   <listitem>
    <para>
     MTD device structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>byte</parameter></term>
   <listitem>
    <para>
     value to write
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Default function to write a byte to I/O[7:0]
</para>
</refsect1>
</refentry>

<refentry id="API-nand-write-byte16">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>nand_write_byte16</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>nand_write_byte16</refname>
 <refpurpose>
     [DEFAULT] write single byte to a chip with width 16
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>nand_write_byte16 </function></funcdef>
   <paramdef>struct mtd_info * <parameter>mtd</parameter></paramdef>
   <paramdef>uint8_t <parameter>byte</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>mtd</parameter></term>
   <listitem>
    <para>
     MTD device structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>byte</parameter></term>
   <listitem>
    <para>
     value to write
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Default function to write a byte to I/O[7:0] on a 16-bit wide chip.
</para>
</refsect1>
</refentry>

<refentry id="API-nand-write-buf">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>nand_write_buf</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>nand_write_buf</refname>
 <refpurpose>
     [DEFAULT] write buffer to chip
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>nand_write_buf </function></funcdef>
   <paramdef>struct mtd_info * <parameter>mtd</parameter></paramdef>
   <paramdef>const uint8_t * <parameter>buf</parameter></paramdef>
   <paramdef>int <parameter>len</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>mtd</parameter></term>
   <listitem>
    <para>
     MTD device structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>buf</parameter></term>
   <listitem>
    <para>
     data buffer
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>len</parameter></term>
   <listitem>
    <para>
     number of bytes to write
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Default write function for 8bit buswidth.
</para>
</refsect1>
</refentry>

<refentry id="API-nand-read-buf">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>nand_read_buf</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>nand_read_buf</refname>
 <refpurpose>
     [DEFAULT] read chip data into buffer
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>nand_read_buf </function></funcdef>
   <paramdef>struct mtd_info * <parameter>mtd</parameter></paramdef>
   <paramdef>uint8_t * <parameter>buf</parameter></paramdef>
   <paramdef>int <parameter>len</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>mtd</parameter></term>
   <listitem>
    <para>
     MTD device structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>buf</parameter></term>
   <listitem>
    <para>
     buffer to store date
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>len</parameter></term>
   <listitem>
    <para>
     number of bytes to read
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Default read function for 8bit buswidth.
</para>
</refsect1>
</refentry>

<refentry id="API-nand-write-buf16">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>nand_write_buf16</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>nand_write_buf16</refname>
 <refpurpose>
     [DEFAULT] write buffer to chip
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>nand_write_buf16 </function></funcdef>
   <paramdef>struct mtd_info * <parameter>mtd</parameter></paramdef>
   <paramdef>const uint8_t * <parameter>buf</parameter></paramdef>
   <paramdef>int <parameter>len</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>mtd</parameter></term>
   <listitem>
    <para>
     MTD device structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>buf</parameter></term>
   <listitem>
    <para>
     data buffer
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>len</parameter></term>
   <listitem>
    <para>
     number of bytes to write
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Default write function for 16bit buswidth.
</para>
</refsect1>
</refentry>

<refentry id="API-nand-read-buf16">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>nand_read_buf16</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>nand_read_buf16</refname>
 <refpurpose>
     [DEFAULT] read chip data into buffer
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>nand_read_buf16 </function></funcdef>
   <paramdef>struct mtd_info * <parameter>mtd</parameter></paramdef>
   <paramdef>uint8_t * <parameter>buf</parameter></paramdef>
   <paramdef>int <parameter>len</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>mtd</parameter></term>
   <listitem>
    <para>
     MTD device structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>buf</parameter></term>
   <listitem>
    <para>
     buffer to store date
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>len</parameter></term>
   <listitem>
    <para>
     number of bytes to read
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Default read function for 16bit buswidth.
</para>
</refsect1>
</refentry>

<refentry id="API-nand-block-bad">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>nand_block_bad</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>nand_block_bad</refname>
 <refpurpose>
     [DEFAULT] Read bad block marker from the chip
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>nand_block_bad </function></funcdef>
   <paramdef>struct mtd_info * <parameter>mtd</parameter></paramdef>
   <paramdef>loff_t <parameter>ofs</parameter></paramdef>
   <paramdef>int <parameter>getchip</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>mtd</parameter></term>
   <listitem>
    <para>
     MTD device structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>ofs</parameter></term>
   <listitem>
    <para>
     offset from device start
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>getchip</parameter></term>
   <listitem>
    <para>
     0, if the chip is already selected
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Check, if the block is bad.
</para>
</refsect1>
</refentry>

<refentry id="API-nand-default-block-markbad">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>nand_default_block_markbad</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>nand_default_block_markbad</refname>
 <refpurpose>
     [DEFAULT] mark a block bad via bad block marker
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>nand_default_block_markbad </function></funcdef>
   <paramdef>struct mtd_info * <parameter>mtd</parameter></paramdef>
   <paramdef>loff_t <parameter>ofs</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>mtd</parameter></term>
   <listitem>
    <para>
     MTD device structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>ofs</parameter></term>
   <listitem>
    <para>
     offset from device start
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This is the default implementation, which can be overridden by a hardware
   specific driver. It provides the details for writing a bad block marker to a
   block.
</para>
</refsect1>
</refentry>

<refentry id="API-nand-block-markbad-lowlevel">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>nand_block_markbad_lowlevel</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>nand_block_markbad_lowlevel</refname>
 <refpurpose>
     mark a block bad
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>nand_block_markbad_lowlevel </function></funcdef>
   <paramdef>struct mtd_info * <parameter>mtd</parameter></paramdef>
   <paramdef>loff_t <parameter>ofs</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>mtd</parameter></term>
   <listitem>
    <para>
     MTD device structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>ofs</parameter></term>
   <listitem>
    <para>
     offset from device start
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This function performs the generic NAND bad block marking steps (i.e., bad
   block table(s) and/or marker(s)). We only allow the hardware driver to
   specify how to write bad block markers to OOB (chip-&gt;block_markbad).
</para>
</refsect1>
<refsect1>
<title>We try operations in the following order</title>
<para>
   (1) erase the affected block, to allow OOB marker to be written cleanly
   (2) write bad block marker to OOB area of affected block (unless flag
   NAND_BBT_NO_OOB_BBM is present)
   (3) update the BBT
   Note that we retain the first error encountered in (2) or (3), finish the
   procedures, and dump the error in the end.
</para>
</refsect1>
</refentry>

<refentry id="API-nand-check-wp">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>nand_check_wp</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>nand_check_wp</refname>
 <refpurpose>
     [GENERIC] check if the chip is write protected
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>nand_check_wp </function></funcdef>
   <paramdef>struct mtd_info * <parameter>mtd</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>mtd</parameter></term>
   <listitem>
    <para>
     MTD device structure
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Check, if the device is write protected. The function expects, that the
   device is already selected.
</para>
</refsect1>
</refentry>

<refentry id="API-nand-block-isreserved">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>nand_block_isreserved</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>nand_block_isreserved</refname>
 <refpurpose>
     [GENERIC] Check if a block is marked bad
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>nand_block_isreserved </function></funcdef>
   <paramdef>struct mtd_info * <parameter>mtd</parameter></paramdef>
   <paramdef>loff_t <parameter>ofs</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>mtd</parameter></term>
   <listitem>
    <para>
     MTD device structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>ofs</parameter></term>
   <listitem>
    <para>
     offset from device start
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Check if the block is mark as reserved.
</para>
</refsect1>
</refentry>

<refentry id="API-nand-block-checkbad">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>nand_block_checkbad</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>nand_block_checkbad</refname>
 <refpurpose>
     [GENERIC] Check if a block is marked bad
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>nand_block_checkbad </function></funcdef>
   <paramdef>struct mtd_info * <parameter>mtd</parameter></paramdef>
   <paramdef>loff_t <parameter>ofs</parameter></paramdef>
   <paramdef>int <parameter>getchip</parameter></paramdef>
   <paramdef>int <parameter>allowbbt</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>mtd</parameter></term>
   <listitem>
    <para>
     MTD device structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>ofs</parameter></term>
   <listitem>
    <para>
     offset from device start
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>getchip</parameter></term>
   <listitem>
    <para>
     0, if the chip is already selected
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>allowbbt</parameter></term>
   <listitem>
    <para>
     1, if its allowed to access the bbt area
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Check, if the block is bad. Either by reading the bad block table or
   calling of the scan function.
</para>
</refsect1>
</refentry>

<refentry id="API-panic-nand-wait-ready">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>panic_nand_wait_ready</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>panic_nand_wait_ready</refname>
 <refpurpose>
     [GENERIC] Wait for the ready pin after commands.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>panic_nand_wait_ready </function></funcdef>
   <paramdef>struct mtd_info * <parameter>mtd</parameter></paramdef>
   <paramdef>unsigned long <parameter>timeo</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>mtd</parameter></term>
   <listitem>
    <para>
     MTD device structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>timeo</parameter></term>
   <listitem>
    <para>
     Timeout
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Helper function for nand_wait_ready used when needing to wait in interrupt
   context.
</para>
</refsect1>
</refentry>

<refentry id="API-nand-command">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>nand_command</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>nand_command</refname>
 <refpurpose>
     [DEFAULT] Send command to NAND device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>nand_command </function></funcdef>
   <paramdef>struct mtd_info * <parameter>mtd</parameter></paramdef>
   <paramdef>unsigned int <parameter>command</parameter></paramdef>
   <paramdef>int <parameter>column</parameter></paramdef>
   <paramdef>int <parameter>page_addr</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>mtd</parameter></term>
   <listitem>
    <para>
     MTD device structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>command</parameter></term>
   <listitem>
    <para>
     the command to be sent
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>column</parameter></term>
   <listitem>
    <para>
     the column address for this command, -1 if none
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>page_addr</parameter></term>
   <listitem>
    <para>
     the page address for this command, -1 if none
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Send command to NAND device. This function is used for small page devices
   (512 Bytes per page).
</para>
</refsect1>
</refentry>

<refentry id="API-nand-command-lp">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>nand_command_lp</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>nand_command_lp</refname>
 <refpurpose>
     [DEFAULT] Send command to NAND large page device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>nand_command_lp </function></funcdef>
   <paramdef>struct mtd_info * <parameter>mtd</parameter></paramdef>
   <paramdef>unsigned int <parameter>command</parameter></paramdef>
   <paramdef>int <parameter>column</parameter></paramdef>
   <paramdef>int <parameter>page_addr</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>mtd</parameter></term>
   <listitem>
    <para>
     MTD device structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>command</parameter></term>
   <listitem>
    <para>
     the command to be sent
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>column</parameter></term>
   <listitem>
    <para>
     the column address for this command, -1 if none
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>page_addr</parameter></term>
   <listitem>
    <para>
     the page address for this command, -1 if none
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Send command to NAND device. This is the version for the new large page
   devices. We don't have the separate regions as we have in the small page
   devices. We must emulate NAND_CMD_READOOB to keep the code compatible.
</para>
</refsect1>
</refentry>

<refentry id="API-panic-nand-get-device">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>panic_nand_get_device</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>panic_nand_get_device</refname>
 <refpurpose>
     [GENERIC] Get chip for selected access
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>panic_nand_get_device </function></funcdef>
   <paramdef>struct nand_chip * <parameter>chip</parameter></paramdef>
   <paramdef>struct mtd_info * <parameter>mtd</parameter></paramdef>
   <paramdef>int <parameter>new_state</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>chip</parameter></term>
   <listitem>
    <para>
     the nand chip descriptor
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>mtd</parameter></term>
   <listitem>
    <para>
     MTD device structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>new_state</parameter></term>
   <listitem>
    <para>
     the state which is requested
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Used when in panic, no locks are taken.
</para>
</refsect1>
</refentry>

<refentry id="API-nand-get-device">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>nand_get_device</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>nand_get_device</refname>
 <refpurpose>
     [GENERIC] Get chip for selected access
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>nand_get_device </function></funcdef>
   <paramdef>struct mtd_info * <parameter>mtd</parameter></paramdef>
   <paramdef>int <parameter>new_state</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>mtd</parameter></term>
   <listitem>
    <para>
     MTD device structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>new_state</parameter></term>
   <listitem>
    <para>
     the state which is requested
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Get the device and lock it for exclusive access
</para>
</refsect1>
</refentry>

<refentry id="API-panic-nand-wait">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>panic_nand_wait</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>panic_nand_wait</refname>
 <refpurpose>
     [GENERIC] wait until the command is done
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>panic_nand_wait </function></funcdef>
   <paramdef>struct mtd_info * <parameter>mtd</parameter></paramdef>
   <paramdef>struct nand_chip * <parameter>chip</parameter></paramdef>
   <paramdef>unsigned long <parameter>timeo</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>mtd</parameter></term>
   <listitem>
    <para>
     MTD device structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>chip</parameter></term>
   <listitem>
    <para>
     NAND chip structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>timeo</parameter></term>
   <listitem>
    <para>
     timeout
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Wait for command done. This is a helper function for nand_wait used when
   we are in interrupt context. May happen when in panic and trying to write
   an oops through mtdoops.
</para>
</refsect1>
</refentry>

<refentry id="API-nand-wait">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>nand_wait</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>nand_wait</refname>
 <refpurpose>
     [DEFAULT] wait until the command is done
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>nand_wait </function></funcdef>
   <paramdef>struct mtd_info * <parameter>mtd</parameter></paramdef>
   <paramdef>struct nand_chip * <parameter>chip</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>mtd</parameter></term>
   <listitem>
    <para>
     MTD device structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>chip</parameter></term>
   <listitem>
    <para>
     NAND chip structure
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Wait for command done. This applies to erase and program only. Erase can
   take up to 400ms and program up to 20ms according to general NAND and
   SmartMedia specs.
</para>
</refsect1>
</refentry>

<refentry id="API---nand-unlock">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>__nand_unlock</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>__nand_unlock</refname>
 <refpurpose>
     [REPLACEABLE] unlocks specified locked blocks
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>__nand_unlock </function></funcdef>
   <paramdef>struct mtd_info * <parameter>mtd</parameter></paramdef>
   <paramdef>loff_t <parameter>ofs</parameter></paramdef>
   <paramdef>uint64_t <parameter>len</parameter></paramdef>
   <paramdef>int <parameter>invert</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>mtd</parameter></term>
   <listitem>
    <para>
     mtd info
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>ofs</parameter></term>
   <listitem>
    <para>
     offset to start unlock from
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>len</parameter></term>
   <listitem>
    <para>
     length to unlock
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>invert</parameter></term>
   <listitem>
    <para>
     when = 0, unlock the range of blocks within the lower and
     upper boundary address
     when = 1, unlock the range of blocks outside the boundaries
     of the lower and upper boundary address
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Returs unlock status.
</para>
</refsect1>
</refentry>

<refentry id="API-nand-read-page-raw">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>nand_read_page_raw</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>nand_read_page_raw</refname>
 <refpurpose>
     [INTERN] read raw page data without ecc
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>nand_read_page_raw </function></funcdef>
   <paramdef>struct mtd_info * <parameter>mtd</parameter></paramdef>
   <paramdef>struct nand_chip * <parameter>chip</parameter></paramdef>
   <paramdef>uint8_t * <parameter>buf</parameter></paramdef>
   <paramdef>int <parameter>oob_required</parameter></paramdef>
   <paramdef>int <parameter>page</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>mtd</parameter></term>
   <listitem>
    <para>
     mtd info structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>chip</parameter></term>
   <listitem>
    <para>
     nand chip info structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>buf</parameter></term>
   <listitem>
    <para>
     buffer to store read data
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>oob_required</parameter></term>
   <listitem>
    <para>
     caller requires OOB data read to chip-&gt;oob_poi
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>page</parameter></term>
   <listitem>
    <para>
     page number to read
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Not for syndrome calculating ECC controllers, which use a special oob layout.
</para>
</refsect1>
</refentry>

<refentry id="API-nand-read-page-raw-syndrome">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>nand_read_page_raw_syndrome</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>nand_read_page_raw_syndrome</refname>
 <refpurpose>
     [INTERN] read raw page data without ecc
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>nand_read_page_raw_syndrome </function></funcdef>
   <paramdef>struct mtd_info * <parameter>mtd</parameter></paramdef>
   <paramdef>struct nand_chip * <parameter>chip</parameter></paramdef>
   <paramdef>uint8_t * <parameter>buf</parameter></paramdef>
   <paramdef>int <parameter>oob_required</parameter></paramdef>
   <paramdef>int <parameter>page</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>mtd</parameter></term>
   <listitem>
    <para>
     mtd info structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>chip</parameter></term>
   <listitem>
    <para>
     nand chip info structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>buf</parameter></term>
   <listitem>
    <para>
     buffer to store read data
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>oob_required</parameter></term>
   <listitem>
    <para>
     caller requires OOB data read to chip-&gt;oob_poi
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>page</parameter></term>
   <listitem>
    <para>
     page number to read
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   We need a special oob layout and handling even when OOB isn't used.
</para>
</refsect1>
</refentry>

<refentry id="API-nand-read-page-swecc">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>nand_read_page_swecc</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>nand_read_page_swecc</refname>
 <refpurpose>
     [REPLACEABLE] software ECC based page read function
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>nand_read_page_swecc </function></funcdef>
   <paramdef>struct mtd_info * <parameter>mtd</parameter></paramdef>
   <paramdef>struct nand_chip * <parameter>chip</parameter></paramdef>
   <paramdef>uint8_t * <parameter>buf</parameter></paramdef>
   <paramdef>int <parameter>oob_required</parameter></paramdef>
   <paramdef>int <parameter>page</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>mtd</parameter></term>
   <listitem>
    <para>
     mtd info structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>chip</parameter></term>
   <listitem>
    <para>
     nand chip info structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>buf</parameter></term>
   <listitem>
    <para>
     buffer to store read data
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>oob_required</parameter></term>
   <listitem>
    <para>
     caller requires OOB data read to chip-&gt;oob_poi
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>page</parameter></term>
   <listitem>
    <para>
     page number to read
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-nand-read-subpage">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>nand_read_subpage</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>nand_read_subpage</refname>
 <refpurpose>
     [REPLACEABLE] ECC based sub-page read function
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>nand_read_subpage </function></funcdef>
   <paramdef>struct mtd_info * <parameter>mtd</parameter></paramdef>
   <paramdef>struct nand_chip * <parameter>chip</parameter></paramdef>
   <paramdef>uint32_t <parameter>data_offs</parameter></paramdef>
   <paramdef>uint32_t <parameter>readlen</parameter></paramdef>
   <paramdef>uint8_t * <parameter>bufpoi</parameter></paramdef>
   <paramdef>int <parameter>page</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>mtd</parameter></term>
   <listitem>
    <para>
     mtd info structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>chip</parameter></term>
   <listitem>
    <para>
     nand chip info structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>data_offs</parameter></term>
   <listitem>
    <para>
     offset of requested data within the page
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>readlen</parameter></term>
   <listitem>
    <para>
     data length
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>bufpoi</parameter></term>
   <listitem>
    <para>
     buffer to store read data
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>page</parameter></term>
   <listitem>
    <para>
     page number to read
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-nand-read-page-hwecc">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>nand_read_page_hwecc</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>nand_read_page_hwecc</refname>
 <refpurpose>
     [REPLACEABLE] hardware ECC based page read function
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>nand_read_page_hwecc </function></funcdef>
   <paramdef>struct mtd_info * <parameter>mtd</parameter></paramdef>
   <paramdef>struct nand_chip * <parameter>chip</parameter></paramdef>
   <paramdef>uint8_t * <parameter>buf</parameter></paramdef>
   <paramdef>int <parameter>oob_required</parameter></paramdef>
   <paramdef>int <parameter>page</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>mtd</parameter></term>
   <listitem>
    <para>
     mtd info structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>chip</parameter></term>
   <listitem>
    <para>
     nand chip info structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>buf</parameter></term>
   <listitem>
    <para>
     buffer to store read data
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>oob_required</parameter></term>
   <listitem>
    <para>
     caller requires OOB data read to chip-&gt;oob_poi
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>page</parameter></term>
   <listitem>
    <para>
     page number to read
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Not for syndrome calculating ECC controllers which need a special oob layout.
</para>
</refsect1>
</refentry>

<refentry id="API-nand-read-page-hwecc-oob-first">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>nand_read_page_hwecc_oob_first</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>nand_read_page_hwecc_oob_first</refname>
 <refpurpose>
     [REPLACEABLE] hw ecc, read oob first
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>nand_read_page_hwecc_oob_first </function></funcdef>
   <paramdef>struct mtd_info * <parameter>mtd</parameter></paramdef>
   <paramdef>struct nand_chip * <parameter>chip</parameter></paramdef>
   <paramdef>uint8_t * <parameter>buf</parameter></paramdef>
   <paramdef>int <parameter>oob_required</parameter></paramdef>
   <paramdef>int <parameter>page</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>mtd</parameter></term>
   <listitem>
    <para>
     mtd info structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>chip</parameter></term>
   <listitem>
    <para>
     nand chip info structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>buf</parameter></term>
   <listitem>
    <para>
     buffer to store read data
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>oob_required</parameter></term>
   <listitem>
    <para>
     caller requires OOB data read to chip-&gt;oob_poi
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>page</parameter></term>
   <listitem>
    <para>
     page number to read
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Hardware ECC for large page chips, require OOB to be read first. For this
   ECC mode, the write_page method is re-used from ECC_HW. These methods
   read/write ECC from the OOB area, unlike the ECC_HW_SYNDROME support with
   multiple ECC steps, follows the <quote>infix ECC</quote> scheme and reads/writes ECC from
   the data area, by overwriting the NAND manufacturer bad block markings.
</para>
</refsect1>
</refentry>

<refentry id="API-nand-read-page-syndrome">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>nand_read_page_syndrome</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>nand_read_page_syndrome</refname>
 <refpurpose>
     [REPLACEABLE] hardware ECC syndrome based page read
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>nand_read_page_syndrome </function></funcdef>
   <paramdef>struct mtd_info * <parameter>mtd</parameter></paramdef>
   <paramdef>struct nand_chip * <parameter>chip</parameter></paramdef>
   <paramdef>uint8_t * <parameter>buf</parameter></paramdef>
   <paramdef>int <parameter>oob_required</parameter></paramdef>
   <paramdef>int <parameter>page</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>mtd</parameter></term>
   <listitem>
    <para>
     mtd info structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>chip</parameter></term>
   <listitem>
    <para>
     nand chip info structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>buf</parameter></term>
   <listitem>
    <para>
     buffer to store read data
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>oob_required</parameter></term>
   <listitem>
    <para>
     caller requires OOB data read to chip-&gt;oob_poi
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>page</parameter></term>
   <listitem>
    <para>
     page number to read
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   The hw generator calculates the error syndrome automatically. Therefore we
   need a special oob layout and handling.
</para>
</refsect1>
</refentry>

<refentry id="API-nand-transfer-oob">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>nand_transfer_oob</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>nand_transfer_oob</refname>
 <refpurpose>
     [INTERN] Transfer oob to client buffer
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>uint8_t * <function>nand_transfer_oob </function></funcdef>
   <paramdef>struct nand_chip * <parameter>chip</parameter></paramdef>
   <paramdef>uint8_t * <parameter>oob</parameter></paramdef>
   <paramdef>struct mtd_oob_ops * <parameter>ops</parameter></paramdef>
   <paramdef>size_t <parameter>len</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>chip</parameter></term>
   <listitem>
    <para>
     nand chip structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>oob</parameter></term>
   <listitem>
    <para>
     oob destination address
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>ops</parameter></term>
   <listitem>
    <para>
     oob ops structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>len</parameter></term>
   <listitem>
    <para>
     size of oob to transfer
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-nand-setup-read-retry">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>nand_setup_read_retry</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>nand_setup_read_retry</refname>
 <refpurpose>
     [INTERN] Set the READ RETRY mode
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>nand_setup_read_retry </function></funcdef>
   <paramdef>struct mtd_info * <parameter>mtd</parameter></paramdef>
   <paramdef>int <parameter>retry_mode</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>mtd</parameter></term>
   <listitem>
    <para>
     MTD device structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>retry_mode</parameter></term>
   <listitem>
    <para>
     the retry mode to use
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Some vendors supply a special command to shift the Vt threshold, to be used
   when there are too many bitflips in a page (i.e., ECC error). After setting
   a new threshold, the host should retry reading the page.
</para>
</refsect1>
</refentry>

<refentry id="API-nand-do-read-ops">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>nand_do_read_ops</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>nand_do_read_ops</refname>
 <refpurpose>
     [INTERN] Read data with ECC
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>nand_do_read_ops </function></funcdef>
   <paramdef>struct mtd_info * <parameter>mtd</parameter></paramdef>
   <paramdef>loff_t <parameter>from</parameter></paramdef>
   <paramdef>struct mtd_oob_ops * <parameter>ops</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>mtd</parameter></term>
   <listitem>
    <para>
     MTD device structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>from</parameter></term>
   <listitem>
    <para>
     offset to read from
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>ops</parameter></term>
   <listitem>
    <para>
     oob ops structure
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Internal function. Called with chip held.
</para>
</refsect1>
</refentry>

<refentry id="API-nand-read">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>nand_read</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>nand_read</refname>
 <refpurpose>
     [MTD Interface] MTD compatibility function for nand_do_read_ecc
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>nand_read </function></funcdef>
   <paramdef>struct mtd_info * <parameter>mtd</parameter></paramdef>
   <paramdef>loff_t <parameter>from</parameter></paramdef>
   <paramdef>size_t <parameter>len</parameter></paramdef>
   <paramdef>size_t * <parameter>retlen</parameter></paramdef>
   <paramdef>uint8_t * <parameter>buf</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>mtd</parameter></term>
   <listitem>
    <para>
     MTD device structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>from</parameter></term>
   <listitem>
    <para>
     offset to read from
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>len</parameter></term>
   <listitem>
    <para>
     number of bytes to read
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>retlen</parameter></term>
   <listitem>
    <para>
     pointer to variable to store the number of read bytes
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>buf</parameter></term>
   <listitem>
    <para>
     the databuffer to put data
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Get hold of the chip and call nand_do_read.
</para>
</refsect1>
</refentry>

<refentry id="API-nand-read-oob-std">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>nand_read_oob_std</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>nand_read_oob_std</refname>
 <refpurpose>
     [REPLACEABLE] the most common OOB data read function
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>nand_read_oob_std </function></funcdef>
   <paramdef>struct mtd_info * <parameter>mtd</parameter></paramdef>
   <paramdef>struct nand_chip * <parameter>chip</parameter></paramdef>
   <paramdef>int <parameter>page</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>mtd</parameter></term>
   <listitem>
    <para>
     mtd info structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>chip</parameter></term>
   <listitem>
    <para>
     nand chip info structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>page</parameter></term>
   <listitem>
    <para>
     page number to read
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-nand-read-oob-syndrome">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>nand_read_oob_syndrome</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>nand_read_oob_syndrome</refname>
 <refpurpose>
     [REPLACEABLE] OOB data read function for HW ECC with syndromes
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>nand_read_oob_syndrome </function></funcdef>
   <paramdef>struct mtd_info * <parameter>mtd</parameter></paramdef>
   <paramdef>struct nand_chip * <parameter>chip</parameter></paramdef>
   <paramdef>int <parameter>page</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>mtd</parameter></term>
   <listitem>
    <para>
     mtd info structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>chip</parameter></term>
   <listitem>
    <para>
     nand chip info structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>page</parameter></term>
   <listitem>
    <para>
     page number to read
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-nand-write-oob-std">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>nand_write_oob_std</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>nand_write_oob_std</refname>
 <refpurpose>
     [REPLACEABLE] the most common OOB data write function
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>nand_write_oob_std </function></funcdef>
   <paramdef>struct mtd_info * <parameter>mtd</parameter></paramdef>
   <paramdef>struct nand_chip * <parameter>chip</parameter></paramdef>
   <paramdef>int <parameter>page</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>mtd</parameter></term>
   <listitem>
    <para>
     mtd info structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>chip</parameter></term>
   <listitem>
    <para>
     nand chip info structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>page</parameter></term>
   <listitem>
    <para>
     page number to write
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-nand-write-oob-syndrome">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>nand_write_oob_syndrome</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>nand_write_oob_syndrome</refname>
 <refpurpose>
     [REPLACEABLE] OOB data write function for HW ECC with syndrome - only for large page flash
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>nand_write_oob_syndrome </function></funcdef>
   <paramdef>struct mtd_info * <parameter>mtd</parameter></paramdef>
   <paramdef>struct nand_chip * <parameter>chip</parameter></paramdef>
   <paramdef>int <parameter>page</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>mtd</parameter></term>
   <listitem>
    <para>
     mtd info structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>chip</parameter></term>
   <listitem>
    <para>
     nand chip info structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>page</parameter></term>
   <listitem>
    <para>
     page number to write
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-nand-do-read-oob">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>nand_do_read_oob</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>nand_do_read_oob</refname>
 <refpurpose>
     [INTERN] NAND read out-of-band
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>nand_do_read_oob </function></funcdef>
   <paramdef>struct mtd_info * <parameter>mtd</parameter></paramdef>
   <paramdef>loff_t <parameter>from</parameter></paramdef>
   <paramdef>struct mtd_oob_ops * <parameter>ops</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>mtd</parameter></term>
   <listitem>
    <para>
     MTD device structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>from</parameter></term>
   <listitem>
    <para>
     offset to read from
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>ops</parameter></term>
   <listitem>
    <para>
     oob operations description structure
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   NAND read out-of-band data from the spare area.
</para>
</refsect1>
</refentry>

<refentry id="API-nand-read-oob">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>nand_read_oob</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>nand_read_oob</refname>
 <refpurpose>
     [MTD Interface] NAND read data and/or out-of-band
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>nand_read_oob </function></funcdef>
   <paramdef>struct mtd_info * <parameter>mtd</parameter></paramdef>
   <paramdef>loff_t <parameter>from</parameter></paramdef>
   <paramdef>struct mtd_oob_ops * <parameter>ops</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>mtd</parameter></term>
   <listitem>
    <para>
     MTD device structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>from</parameter></term>
   <listitem>
    <para>
     offset to read from
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>ops</parameter></term>
   <listitem>
    <para>
     oob operation description structure
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   NAND read data and/or out-of-band data.
</para>
</refsect1>
</refentry>

<refentry id="API-nand-write-page-raw">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>nand_write_page_raw</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>nand_write_page_raw</refname>
 <refpurpose>
     [INTERN] raw page write function
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>nand_write_page_raw </function></funcdef>
   <paramdef>struct mtd_info * <parameter>mtd</parameter></paramdef>
   <paramdef>struct nand_chip * <parameter>chip</parameter></paramdef>
   <paramdef>const uint8_t * <parameter>buf</parameter></paramdef>
   <paramdef>int <parameter>oob_required</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>mtd</parameter></term>
   <listitem>
    <para>
     mtd info structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>chip</parameter></term>
   <listitem>
    <para>
     nand chip info structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>buf</parameter></term>
   <listitem>
    <para>
     data buffer
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>oob_required</parameter></term>
   <listitem>
    <para>
     must write chip-&gt;oob_poi to OOB
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Not for syndrome calculating ECC controllers, which use a special oob layout.
</para>
</refsect1>
</refentry>

<refentry id="API-nand-write-page-raw-syndrome">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>nand_write_page_raw_syndrome</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>nand_write_page_raw_syndrome</refname>
 <refpurpose>
     [INTERN] raw page write function
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>nand_write_page_raw_syndrome </function></funcdef>
   <paramdef>struct mtd_info * <parameter>mtd</parameter></paramdef>
   <paramdef>struct nand_chip * <parameter>chip</parameter></paramdef>
   <paramdef>const uint8_t * <parameter>buf</parameter></paramdef>
   <paramdef>int <parameter>oob_required</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>mtd</parameter></term>
   <listitem>
    <para>
     mtd info structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>chip</parameter></term>
   <listitem>
    <para>
     nand chip info structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>buf</parameter></term>
   <listitem>
    <para>
     data buffer
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>oob_required</parameter></term>
   <listitem>
    <para>
     must write chip-&gt;oob_poi to OOB
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   We need a special oob layout and handling even when ECC isn't checked.
</para>
</refsect1>
</refentry>

<refentry id="API-nand-write-page-swecc">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>nand_write_page_swecc</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>nand_write_page_swecc</refname>
 <refpurpose>
     [REPLACEABLE] software ECC based page write function
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>nand_write_page_swecc </function></funcdef>
   <paramdef>struct mtd_info * <parameter>mtd</parameter></paramdef>
   <paramdef>struct nand_chip * <parameter>chip</parameter></paramdef>
   <paramdef>const uint8_t * <parameter>buf</parameter></paramdef>
   <paramdef>int <parameter>oob_required</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>mtd</parameter></term>
   <listitem>
    <para>
     mtd info structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>chip</parameter></term>
   <listitem>
    <para>
     nand chip info structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>buf</parameter></term>
   <listitem>
    <para>
     data buffer
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>oob_required</parameter></term>
   <listitem>
    <para>
     must write chip-&gt;oob_poi to OOB
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-nand-write-page-hwecc">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>nand_write_page_hwecc</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>nand_write_page_hwecc</refname>
 <refpurpose>
     [REPLACEABLE] hardware ECC based page write function
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>nand_write_page_hwecc </function></funcdef>
   <paramdef>struct mtd_info * <parameter>mtd</parameter></paramdef>
   <paramdef>struct nand_chip * <parameter>chip</parameter></paramdef>
   <paramdef>const uint8_t * <parameter>buf</parameter></paramdef>
   <paramdef>int <parameter>oob_required</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>mtd</parameter></term>
   <listitem>
    <para>
     mtd info structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>chip</parameter></term>
   <listitem>
    <para>
     nand chip info structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>buf</parameter></term>
   <listitem>
    <para>
     data buffer
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>oob_required</parameter></term>
   <listitem>
    <para>
     must write chip-&gt;oob_poi to OOB
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-nand-write-subpage-hwecc">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>nand_write_subpage_hwecc</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>nand_write_subpage_hwecc</refname>
 <refpurpose>
     [REPLACABLE] hardware ECC based subpage write
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>nand_write_subpage_hwecc </function></funcdef>
   <paramdef>struct mtd_info * <parameter>mtd</parameter></paramdef>
   <paramdef>struct nand_chip * <parameter>chip</parameter></paramdef>
   <paramdef>uint32_t <parameter>offset</parameter></paramdef>
   <paramdef>uint32_t <parameter>data_len</parameter></paramdef>
   <paramdef>const uint8_t * <parameter>buf</parameter></paramdef>
   <paramdef>int <parameter>oob_required</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>mtd</parameter></term>
   <listitem>
    <para>
     mtd info structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>chip</parameter></term>
   <listitem>
    <para>
     nand chip info structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>offset</parameter></term>
   <listitem>
    <para>
     column address of subpage within the page
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>data_len</parameter></term>
   <listitem>
    <para>
     data length
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>buf</parameter></term>
   <listitem>
    <para>
     data buffer
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>oob_required</parameter></term>
   <listitem>
    <para>
     must write chip-&gt;oob_poi to OOB
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-nand-write-page-syndrome">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>nand_write_page_syndrome</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>nand_write_page_syndrome</refname>
 <refpurpose>
     [REPLACEABLE] hardware ECC syndrome based page write
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>nand_write_page_syndrome </function></funcdef>
   <paramdef>struct mtd_info * <parameter>mtd</parameter></paramdef>
   <paramdef>struct nand_chip * <parameter>chip</parameter></paramdef>
   <paramdef>const uint8_t * <parameter>buf</parameter></paramdef>
   <paramdef>int <parameter>oob_required</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>mtd</parameter></term>
   <listitem>
    <para>
     mtd info structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>chip</parameter></term>
   <listitem>
    <para>
     nand chip info structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>buf</parameter></term>
   <listitem>
    <para>
     data buffer
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>oob_required</parameter></term>
   <listitem>
    <para>
     must write chip-&gt;oob_poi to OOB
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   The hw generator calculates the error syndrome automatically. Therefore we
   need a special oob layout and handling.
</para>
</refsect1>
</refentry>

<refentry id="API-nand-write-page">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>nand_write_page</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>nand_write_page</refname>
 <refpurpose>
     [REPLACEABLE] write one page
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>nand_write_page </function></funcdef>
   <paramdef>struct mtd_info * <parameter>mtd</parameter></paramdef>
   <paramdef>struct nand_chip * <parameter>chip</parameter></paramdef>
   <paramdef>uint32_t <parameter>offset</parameter></paramdef>
   <paramdef>int <parameter>data_len</parameter></paramdef>
   <paramdef>const uint8_t * <parameter>buf</parameter></paramdef>
   <paramdef>int <parameter>oob_required</parameter></paramdef>
   <paramdef>int <parameter>page</parameter></paramdef>
   <paramdef>int <parameter>cached</parameter></paramdef>
   <paramdef>int <parameter>raw</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>mtd</parameter></term>
   <listitem>
    <para>
     MTD device structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>chip</parameter></term>
   <listitem>
    <para>
     NAND chip descriptor
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>offset</parameter></term>
   <listitem>
    <para>
     address offset within the page
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>data_len</parameter></term>
   <listitem>
    <para>
     length of actual data to be written
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>buf</parameter></term>
   <listitem>
    <para>
     the data to write
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>oob_required</parameter></term>
   <listitem>
    <para>
     must write chip-&gt;oob_poi to OOB
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>page</parameter></term>
   <listitem>
    <para>
     page number to write
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>cached</parameter></term>
   <listitem>
    <para>
     cached programming
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>raw</parameter></term>
   <listitem>
    <para>
     use _raw version of write_page
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-nand-fill-oob">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>nand_fill_oob</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>nand_fill_oob</refname>
 <refpurpose>
     [INTERN] Transfer client buffer to oob
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>uint8_t * <function>nand_fill_oob </function></funcdef>
   <paramdef>struct mtd_info * <parameter>mtd</parameter></paramdef>
   <paramdef>uint8_t * <parameter>oob</parameter></paramdef>
   <paramdef>size_t <parameter>len</parameter></paramdef>
   <paramdef>struct mtd_oob_ops * <parameter>ops</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>mtd</parameter></term>
   <listitem>
    <para>
     MTD device structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>oob</parameter></term>
   <listitem>
    <para>
     oob data buffer
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>len</parameter></term>
   <listitem>
    <para>
     oob data write length
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>ops</parameter></term>
   <listitem>
    <para>
     oob ops structure
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-nand-do-write-ops">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>nand_do_write_ops</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>nand_do_write_ops</refname>
 <refpurpose>
     [INTERN] NAND write with ECC
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>nand_do_write_ops </function></funcdef>
   <paramdef>struct mtd_info * <parameter>mtd</parameter></paramdef>
   <paramdef>loff_t <parameter>to</parameter></paramdef>
   <paramdef>struct mtd_oob_ops * <parameter>ops</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>mtd</parameter></term>
   <listitem>
    <para>
     MTD device structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>to</parameter></term>
   <listitem>
    <para>
     offset to write to
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>ops</parameter></term>
   <listitem>
    <para>
     oob operations description structure
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   NAND write with ECC.
</para>
</refsect1>
</refentry>

<refentry id="API-panic-nand-write">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>panic_nand_write</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>panic_nand_write</refname>
 <refpurpose>
     [MTD Interface] NAND write with ECC
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>panic_nand_write </function></funcdef>
   <paramdef>struct mtd_info * <parameter>mtd</parameter></paramdef>
   <paramdef>loff_t <parameter>to</parameter></paramdef>
   <paramdef>size_t <parameter>len</parameter></paramdef>
   <paramdef>size_t * <parameter>retlen</parameter></paramdef>
   <paramdef>const uint8_t * <parameter>buf</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>mtd</parameter></term>
   <listitem>
    <para>
     MTD device structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>to</parameter></term>
   <listitem>
    <para>
     offset to write to
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>len</parameter></term>
   <listitem>
    <para>
     number of bytes to write
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>retlen</parameter></term>
   <listitem>
    <para>
     pointer to variable to store the number of written bytes
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>buf</parameter></term>
   <listitem>
    <para>
     the data to write
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   NAND write with ECC. Used when performing writes in interrupt context, this
   may for example be called by mtdoops when writing an oops while in panic.
</para>
</refsect1>
</refentry>

<refentry id="API-nand-write">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>nand_write</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>nand_write</refname>
 <refpurpose>
     [MTD Interface] NAND write with ECC
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>nand_write </function></funcdef>
   <paramdef>struct mtd_info * <parameter>mtd</parameter></paramdef>
   <paramdef>loff_t <parameter>to</parameter></paramdef>
   <paramdef>size_t <parameter>len</parameter></paramdef>
   <paramdef>size_t * <parameter>retlen</parameter></paramdef>
   <paramdef>const uint8_t * <parameter>buf</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>mtd</parameter></term>
   <listitem>
    <para>
     MTD device structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>to</parameter></term>
   <listitem>
    <para>
     offset to write to
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>len</parameter></term>
   <listitem>
    <para>
     number of bytes to write
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>retlen</parameter></term>
   <listitem>
    <para>
     pointer to variable to store the number of written bytes
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>buf</parameter></term>
   <listitem>
    <para>
     the data to write
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   NAND write with ECC.
</para>
</refsect1>
</refentry>

<refentry id="API-nand-do-write-oob">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>nand_do_write_oob</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>nand_do_write_oob</refname>
 <refpurpose>
     [MTD Interface] NAND write out-of-band
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>nand_do_write_oob </function></funcdef>
   <paramdef>struct mtd_info * <parameter>mtd</parameter></paramdef>
   <paramdef>loff_t <parameter>to</parameter></paramdef>
   <paramdef>struct mtd_oob_ops * <parameter>ops</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>mtd</parameter></term>
   <listitem>
    <para>
     MTD device structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>to</parameter></term>
   <listitem>
    <para>
     offset to write to
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>ops</parameter></term>
   <listitem>
    <para>
     oob operation description structure
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   NAND write out-of-band.
</para>
</refsect1>
</refentry>

<refentry id="API-nand-write-oob">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>nand_write_oob</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>nand_write_oob</refname>
 <refpurpose>
     [MTD Interface] NAND write data and/or out-of-band
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>nand_write_oob </function></funcdef>
   <paramdef>struct mtd_info * <parameter>mtd</parameter></paramdef>
   <paramdef>loff_t <parameter>to</parameter></paramdef>
   <paramdef>struct mtd_oob_ops * <parameter>ops</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>mtd</parameter></term>
   <listitem>
    <para>
     MTD device structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>to</parameter></term>
   <listitem>
    <para>
     offset to write to
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>ops</parameter></term>
   <listitem>
    <para>
     oob operation description structure
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-single-erase">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>single_erase</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>single_erase</refname>
 <refpurpose>
     [GENERIC] NAND standard block erase command function
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>single_erase </function></funcdef>
   <paramdef>struct mtd_info * <parameter>mtd</parameter></paramdef>
   <paramdef>int <parameter>page</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>mtd</parameter></term>
   <listitem>
    <para>
     MTD device structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>page</parameter></term>
   <listitem>
    <para>
     the page address of the block which will be erased
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Standard erase command for NAND chips. Returns NAND status.
</para>
</refsect1>
</refentry>

<refentry id="API-nand-erase">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>nand_erase</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>nand_erase</refname>
 <refpurpose>
     [MTD Interface] erase block(s)
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>nand_erase </function></funcdef>
   <paramdef>struct mtd_info * <parameter>mtd</parameter></paramdef>
   <paramdef>struct erase_info * <parameter>instr</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>mtd</parameter></term>
   <listitem>
    <para>
     MTD device structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>instr</parameter></term>
   <listitem>
    <para>
     erase instruction
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Erase one ore more blocks.
</para>
</refsect1>
</refentry>

<refentry id="API-nand-erase-nand">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>nand_erase_nand</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>nand_erase_nand</refname>
 <refpurpose>
     [INTERN] erase block(s)
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>nand_erase_nand </function></funcdef>
   <paramdef>struct mtd_info * <parameter>mtd</parameter></paramdef>
   <paramdef>struct erase_info * <parameter>instr</parameter></paramdef>
   <paramdef>int <parameter>allowbbt</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>mtd</parameter></term>
   <listitem>
    <para>
     MTD device structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>instr</parameter></term>
   <listitem>
    <para>
     erase instruction
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>allowbbt</parameter></term>
   <listitem>
    <para>
     allow erasing the bbt area
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Erase one ore more blocks.
</para>
</refsect1>
</refentry>

<refentry id="API-nand-sync">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>nand_sync</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>nand_sync</refname>
 <refpurpose>
     [MTD Interface] sync
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>nand_sync </function></funcdef>
   <paramdef>struct mtd_info * <parameter>mtd</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>mtd</parameter></term>
   <listitem>
    <para>
     MTD device structure
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Sync is actually a wait for chip ready function.
</para>
</refsect1>
</refentry>

<refentry id="API-nand-block-isbad">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>nand_block_isbad</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>nand_block_isbad</refname>
 <refpurpose>
     [MTD Interface] Check if block at offset is bad
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>nand_block_isbad </function></funcdef>
   <paramdef>struct mtd_info * <parameter>mtd</parameter></paramdef>
   <paramdef>loff_t <parameter>offs</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>mtd</parameter></term>
   <listitem>
    <para>
     MTD device structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>offs</parameter></term>
   <listitem>
    <para>
     offset relative to mtd start
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-nand-block-markbad">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>nand_block_markbad</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>nand_block_markbad</refname>
 <refpurpose>
     [MTD Interface] Mark block at the given offset as bad
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>nand_block_markbad </function></funcdef>
   <paramdef>struct mtd_info * <parameter>mtd</parameter></paramdef>
   <paramdef>loff_t <parameter>ofs</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>mtd</parameter></term>
   <listitem>
    <para>
     MTD device structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>ofs</parameter></term>
   <listitem>
    <para>
     offset relative to mtd start
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-nand-onfi-set-features">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>nand_onfi_set_features</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>nand_onfi_set_features</refname>
 <refpurpose>
     [REPLACEABLE] set features for ONFI nand
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>nand_onfi_set_features </function></funcdef>
   <paramdef>struct mtd_info * <parameter>mtd</parameter></paramdef>
   <paramdef>struct nand_chip * <parameter>chip</parameter></paramdef>
   <paramdef>int <parameter>addr</parameter></paramdef>
   <paramdef>uint8_t * <parameter>subfeature_param</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>mtd</parameter></term>
   <listitem>
    <para>
     MTD device structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>chip</parameter></term>
   <listitem>
    <para>
     nand chip info structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>addr</parameter></term>
   <listitem>
    <para>
     feature address.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>subfeature_param</parameter></term>
   <listitem>
    <para>
     the subfeature parameters, a four bytes array.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-nand-onfi-get-features">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>nand_onfi_get_features</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>nand_onfi_get_features</refname>
 <refpurpose>
     [REPLACEABLE] get features for ONFI nand
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>nand_onfi_get_features </function></funcdef>
   <paramdef>struct mtd_info * <parameter>mtd</parameter></paramdef>
   <paramdef>struct nand_chip * <parameter>chip</parameter></paramdef>
   <paramdef>int <parameter>addr</parameter></paramdef>
   <paramdef>uint8_t * <parameter>subfeature_param</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>mtd</parameter></term>
   <listitem>
    <para>
     MTD device structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>chip</parameter></term>
   <listitem>
    <para>
     nand chip info structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>addr</parameter></term>
   <listitem>
    <para>
     feature address.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>subfeature_param</parameter></term>
   <listitem>
    <para>
     the subfeature parameters, a four bytes array.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-nand-suspend">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>nand_suspend</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>nand_suspend</refname>
 <refpurpose>
     [MTD Interface] Suspend the NAND flash
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>nand_suspend </function></funcdef>
   <paramdef>struct mtd_info * <parameter>mtd</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>mtd</parameter></term>
   <listitem>
    <para>
     MTD device structure
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-nand-resume">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>nand_resume</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>nand_resume</refname>
 <refpurpose>
     [MTD Interface] Resume the NAND flash
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>nand_resume </function></funcdef>
   <paramdef>struct mtd_info * <parameter>mtd</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>mtd</parameter></term>
   <listitem>
    <para>
     MTD device structure
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<!-- drivers/mtd/nand/nand_bbt.c -->
<refentry id="API-check-pattern">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>check_pattern</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>check_pattern</refname>
 <refpurpose>
  [GENERIC] check if a pattern is in the buffer
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>check_pattern </function></funcdef>
   <paramdef>uint8_t * <parameter>buf</parameter></paramdef>
   <paramdef>int <parameter>len</parameter></paramdef>
   <paramdef>int <parameter>paglen</parameter></paramdef>
   <paramdef>struct nand_bbt_descr * <parameter>td</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>buf</parameter></term>
   <listitem>
    <para>
     the buffer to search
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>len</parameter></term>
   <listitem>
    <para>
     the length of buffer to search
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>paglen</parameter></term>
   <listitem>
    <para>
     the pagelength
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>td</parameter></term>
   <listitem>
    <para>
     search pattern descriptor
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Check for a pattern at the given place. Used to search bad block tables and
   good / bad block identifiers.
</para>
</refsect1>
</refentry>

<refentry id="API-check-short-pattern">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>check_short_pattern</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>check_short_pattern</refname>
 <refpurpose>
     [GENERIC] check if a pattern is in the buffer
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>check_short_pattern </function></funcdef>
   <paramdef>uint8_t * <parameter>buf</parameter></paramdef>
   <paramdef>struct nand_bbt_descr * <parameter>td</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>buf</parameter></term>
   <listitem>
    <para>
     the buffer to search
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>td</parameter></term>
   <listitem>
    <para>
     search pattern descriptor
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Check for a pattern at the given place. Used to search bad block tables and
   good / bad block identifiers. Same as check_pattern, but no optional empty
   check.
</para>
</refsect1>
</refentry>

<refentry id="API-add-marker-len">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>add_marker_len</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>add_marker_len</refname>
 <refpurpose>
     compute the length of the marker in data area
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>u32 <function>add_marker_len </function></funcdef>
   <paramdef>struct nand_bbt_descr * <parameter>td</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>td</parameter></term>
   <listitem>
    <para>
     BBT descriptor used for computation
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   The length will be 0 if the marker is located in OOB area.
</para>
</refsect1>
</refentry>

<refentry id="API-read-bbt">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>read_bbt</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>read_bbt</refname>
 <refpurpose>
     [GENERIC] Read the bad block table starting from page
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>read_bbt </function></funcdef>
   <paramdef>struct mtd_info * <parameter>mtd</parameter></paramdef>
   <paramdef>uint8_t * <parameter>buf</parameter></paramdef>
   <paramdef>int <parameter>page</parameter></paramdef>
   <paramdef>int <parameter>num</parameter></paramdef>
   <paramdef>struct nand_bbt_descr * <parameter>td</parameter></paramdef>
   <paramdef>int <parameter>offs</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>mtd</parameter></term>
   <listitem>
    <para>
     MTD device structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>buf</parameter></term>
   <listitem>
    <para>
     temporary buffer
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>page</parameter></term>
   <listitem>
    <para>
     the starting page
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>num</parameter></term>
   <listitem>
    <para>
     the number of bbt descriptors to read
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>td</parameter></term>
   <listitem>
    <para>
     the bbt describtion table
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>offs</parameter></term>
   <listitem>
    <para>
     block number offset in the table
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Read the bad block table starting from page.
</para>
</refsect1>
</refentry>

<refentry id="API-read-abs-bbt">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>read_abs_bbt</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>read_abs_bbt</refname>
 <refpurpose>
     [GENERIC] Read the bad block table starting at a given page
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>read_abs_bbt </function></funcdef>
   <paramdef>struct mtd_info * <parameter>mtd</parameter></paramdef>
   <paramdef>uint8_t * <parameter>buf</parameter></paramdef>
   <paramdef>struct nand_bbt_descr * <parameter>td</parameter></paramdef>
   <paramdef>int <parameter>chip</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>mtd</parameter></term>
   <listitem>
    <para>
     MTD device structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>buf</parameter></term>
   <listitem>
    <para>
     temporary buffer
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>td</parameter></term>
   <listitem>
    <para>
     descriptor for the bad block table
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>chip</parameter></term>
   <listitem>
    <para>
     read the table for a specific chip, -1 read all chips; applies only if
     NAND_BBT_PERCHIP option is set
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Read the bad block table for all chips starting at a given page. We assume
   that the bbt bits are in consecutive order.
</para>
</refsect1>
</refentry>

<refentry id="API-scan-read-oob">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>scan_read_oob</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>scan_read_oob</refname>
 <refpurpose>
     [GENERIC] Scan data+OOB region to buffer
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>scan_read_oob </function></funcdef>
   <paramdef>struct mtd_info * <parameter>mtd</parameter></paramdef>
   <paramdef>uint8_t * <parameter>buf</parameter></paramdef>
   <paramdef>loff_t <parameter>offs</parameter></paramdef>
   <paramdef>size_t <parameter>len</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>mtd</parameter></term>
   <listitem>
    <para>
     MTD device structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>buf</parameter></term>
   <listitem>
    <para>
     temporary buffer
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>offs</parameter></term>
   <listitem>
    <para>
     offset at which to scan
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>len</parameter></term>
   <listitem>
    <para>
     length of data region to read
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Scan read data from data+OOB. May traverse multiple pages, interleaving
   page,OOB,page,OOB,... in buf. Completes transfer and returns the <quote>strongest</quote>
   ECC condition (error or bitflip). May quit on the first (non-ECC) error.
</para>
</refsect1>
</refentry>

<refentry id="API-read-abs-bbts">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>read_abs_bbts</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>read_abs_bbts</refname>
 <refpurpose>
     [GENERIC] Read the bad block table(s) for all chips starting at a given page
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>read_abs_bbts </function></funcdef>
   <paramdef>struct mtd_info * <parameter>mtd</parameter></paramdef>
   <paramdef>uint8_t * <parameter>buf</parameter></paramdef>
   <paramdef>struct nand_bbt_descr * <parameter>td</parameter></paramdef>
   <paramdef>struct nand_bbt_descr * <parameter>md</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>mtd</parameter></term>
   <listitem>
    <para>
     MTD device structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>buf</parameter></term>
   <listitem>
    <para>
     temporary buffer
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>td</parameter></term>
   <listitem>
    <para>
     descriptor for the bad block table
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>md</parameter></term>
   <listitem>
    <para>
     descriptor for the bad block table mirror
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Read the bad block table(s) for all chips starting at a given page. We
   assume that the bbt bits are in consecutive order.
</para>
</refsect1>
</refentry>

<refentry id="API-create-bbt">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>create_bbt</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>create_bbt</refname>
 <refpurpose>
     [GENERIC] Create a bad block table by scanning the device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>create_bbt </function></funcdef>
   <paramdef>struct mtd_info * <parameter>mtd</parameter></paramdef>
   <paramdef>uint8_t * <parameter>buf</parameter></paramdef>
   <paramdef>struct nand_bbt_descr * <parameter>bd</parameter></paramdef>
   <paramdef>int <parameter>chip</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>mtd</parameter></term>
   <listitem>
    <para>
     MTD device structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>buf</parameter></term>
   <listitem>
    <para>
     temporary buffer
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>bd</parameter></term>
   <listitem>
    <para>
     descriptor for the good/bad block search pattern
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>chip</parameter></term>
   <listitem>
    <para>
     create the table for a specific chip, -1 read all chips; applies only
     if NAND_BBT_PERCHIP option is set
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Create a bad block table by scanning the device for the given good/bad block
   identify pattern.
</para>
</refsect1>
</refentry>

<refentry id="API-search-bbt">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>search_bbt</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>search_bbt</refname>
 <refpurpose>
     [GENERIC] scan the device for a specific bad block table
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>search_bbt </function></funcdef>
   <paramdef>struct mtd_info * <parameter>mtd</parameter></paramdef>
   <paramdef>uint8_t * <parameter>buf</parameter></paramdef>
   <paramdef>struct nand_bbt_descr * <parameter>td</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>mtd</parameter></term>
   <listitem>
    <para>
     MTD device structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>buf</parameter></term>
   <listitem>
    <para>
     temporary buffer
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>td</parameter></term>
   <listitem>
    <para>
     descriptor for the bad block table
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Read the bad block table by searching for a given ident pattern. Search is
   preformed either from the beginning up or from the end of the device
   downwards. The search starts always at the start of a block. If the option
   NAND_BBT_PERCHIP is given, each chip is searched for a bbt, which contains
   the bad block information of this chip. This is necessary to provide support
   for certain DOC devices.
   </para><para>

   The bbt ident pattern resides in the oob area of the first page in a block.
</para>
</refsect1>
</refentry>

<refentry id="API-search-read-bbts">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>search_read_bbts</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>search_read_bbts</refname>
 <refpurpose>
     [GENERIC] scan the device for bad block table(s)
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>search_read_bbts </function></funcdef>
   <paramdef>struct mtd_info * <parameter>mtd</parameter></paramdef>
   <paramdef>uint8_t * <parameter>buf</parameter></paramdef>
   <paramdef>struct nand_bbt_descr * <parameter>td</parameter></paramdef>
   <paramdef>struct nand_bbt_descr * <parameter>md</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>mtd</parameter></term>
   <listitem>
    <para>
     MTD device structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>buf</parameter></term>
   <listitem>
    <para>
     temporary buffer
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>td</parameter></term>
   <listitem>
    <para>
     descriptor for the bad block table
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>md</parameter></term>
   <listitem>
    <para>
     descriptor for the bad block table mirror
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Search and read the bad block table(s).
</para>
</refsect1>
</refentry>

<refentry id="API-write-bbt">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>write_bbt</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>write_bbt</refname>
 <refpurpose>
     [GENERIC] (Re)write the bad block table
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>write_bbt </function></funcdef>
   <paramdef>struct mtd_info * <parameter>mtd</parameter></paramdef>
   <paramdef>uint8_t * <parameter>buf</parameter></paramdef>
   <paramdef>struct nand_bbt_descr * <parameter>td</parameter></paramdef>
   <paramdef>struct nand_bbt_descr * <parameter>md</parameter></paramdef>
   <paramdef>int <parameter>chipsel</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>mtd</parameter></term>
   <listitem>
    <para>
     MTD device structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>buf</parameter></term>
   <listitem>
    <para>
     temporary buffer
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>td</parameter></term>
   <listitem>
    <para>
     descriptor for the bad block table
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>md</parameter></term>
   <listitem>
    <para>
     descriptor for the bad block table mirror
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>chipsel</parameter></term>
   <listitem>
    <para>
     selector for a specific chip, -1 for all
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   (Re)write the bad block table.
</para>
</refsect1>
</refentry>

<refentry id="API-nand-memory-bbt">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>nand_memory_bbt</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>nand_memory_bbt</refname>
 <refpurpose>
     [GENERIC] create a memory based bad block table
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>nand_memory_bbt </function></funcdef>
   <paramdef>struct mtd_info * <parameter>mtd</parameter></paramdef>
   <paramdef>struct nand_bbt_descr * <parameter>bd</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>mtd</parameter></term>
   <listitem>
    <para>
     MTD device structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>bd</parameter></term>
   <listitem>
    <para>
     descriptor for the good/bad block search pattern
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   The function creates a memory based bbt by scanning the device for
   manufacturer / software marked good / bad blocks.
</para>
</refsect1>
</refentry>

<refentry id="API-check-create">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>check_create</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>check_create</refname>
 <refpurpose>
     [GENERIC] create and write bbt(s) if necessary
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>check_create </function></funcdef>
   <paramdef>struct mtd_info * <parameter>mtd</parameter></paramdef>
   <paramdef>uint8_t * <parameter>buf</parameter></paramdef>
   <paramdef>struct nand_bbt_descr * <parameter>bd</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>mtd</parameter></term>
   <listitem>
    <para>
     MTD device structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>buf</parameter></term>
   <listitem>
    <para>
     temporary buffer
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>bd</parameter></term>
   <listitem>
    <para>
     descriptor for the good/bad block search pattern
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   The function checks the results of the previous call to read_bbt and creates
   / updates the bbt(s) if necessary. Creation is necessary if no bbt was found
   for the chip/device. Update is necessary if one of the tables is missing or
   the version nr. of one table is less than the other.
</para>
</refsect1>
</refentry>

<refentry id="API-mark-bbt-region">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>mark_bbt_region</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>mark_bbt_region</refname>
 <refpurpose>
     [GENERIC] mark the bad block table regions
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>mark_bbt_region </function></funcdef>
   <paramdef>struct mtd_info * <parameter>mtd</parameter></paramdef>
   <paramdef>struct nand_bbt_descr * <parameter>td</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>mtd</parameter></term>
   <listitem>
    <para>
     MTD device structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>td</parameter></term>
   <listitem>
    <para>
     bad block table descriptor
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   The bad block table regions are marked as <quote>bad</quote> to prevent accidental
   erasures / writes. The regions are identified by the mark 0x02.
</para>
</refsect1>
</refentry>

<refentry id="API-verify-bbt-descr">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>verify_bbt_descr</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>verify_bbt_descr</refname>
 <refpurpose>
     verify the bad block description
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>verify_bbt_descr </function></funcdef>
   <paramdef>struct mtd_info * <parameter>mtd</parameter></paramdef>
   <paramdef>struct nand_bbt_descr * <parameter>bd</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>mtd</parameter></term>
   <listitem>
    <para>
     MTD device structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>bd</parameter></term>
   <listitem>
    <para>
     the table to verify
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This functions performs a few sanity checks on the bad block description
   table.
</para>
</refsect1>
</refentry>

<refentry id="API-nand-update-bbt">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>nand_update_bbt</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>nand_update_bbt</refname>
 <refpurpose>
     update bad block table(s)
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>nand_update_bbt </function></funcdef>
   <paramdef>struct mtd_info * <parameter>mtd</parameter></paramdef>
   <paramdef>loff_t <parameter>offs</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>mtd</parameter></term>
   <listitem>
    <para>
     MTD device structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>offs</parameter></term>
   <listitem>
    <para>
     the offset of the newly marked block
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   The function updates the bad block table(s).
</para>
</refsect1>
</refentry>

<refentry id="API-nand-create-badblock-pattern">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>nand_create_badblock_pattern</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>nand_create_badblock_pattern</refname>
 <refpurpose>
     [INTERN] Creates a BBT descriptor structure
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>nand_create_badblock_pattern </function></funcdef>
   <paramdef>struct nand_chip * <parameter>this</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>this</parameter></term>
   <listitem>
    <para>
     NAND chip to create descriptor for
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This function allocates and initializes a nand_bbt_descr for BBM detection
   based on the properties of <parameter>this</parameter>. The new descriptor is stored in
   this-&gt;badblock_pattern. Thus, this-&gt;badblock_pattern should be NULL when
   passed to this function.
</para>
</refsect1>
</refentry>

<refentry id="API-nand-default-bbt">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>nand_default_bbt</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>nand_default_bbt</refname>
 <refpurpose>
     [NAND Interface] Select a default bad block table for the device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>nand_default_bbt </function></funcdef>
   <paramdef>struct mtd_info * <parameter>mtd</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>mtd</parameter></term>
   <listitem>
    <para>
     MTD device structure
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This function selects the default bad block table support for the device and
   calls the nand_scan_bbt function.
</para>
</refsect1>
</refentry>

<refentry id="API-nand-isreserved-bbt">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>nand_isreserved_bbt</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>nand_isreserved_bbt</refname>
 <refpurpose>
     [NAND Interface] Check if a block is reserved
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>nand_isreserved_bbt </function></funcdef>
   <paramdef>struct mtd_info * <parameter>mtd</parameter></paramdef>
   <paramdef>loff_t <parameter>offs</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>mtd</parameter></term>
   <listitem>
    <para>
     MTD device structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>offs</parameter></term>
   <listitem>
    <para>
     offset in the device
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-nand-isbad-bbt">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>nand_isbad_bbt</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>nand_isbad_bbt</refname>
 <refpurpose>
     [NAND Interface] Check if a block is bad
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>nand_isbad_bbt </function></funcdef>
   <paramdef>struct mtd_info * <parameter>mtd</parameter></paramdef>
   <paramdef>loff_t <parameter>offs</parameter></paramdef>
   <paramdef>int <parameter>allowbbt</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>mtd</parameter></term>
   <listitem>
    <para>
     MTD device structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>offs</parameter></term>
   <listitem>
    <para>
     offset in the device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>allowbbt</parameter></term>
   <listitem>
    <para>
     allow access to bad block table region
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-nand-markbad-bbt">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>nand_markbad_bbt</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>nand_markbad_bbt</refname>
 <refpurpose>
     [NAND Interface] Mark a block bad in the BBT
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>nand_markbad_bbt </function></funcdef>
   <paramdef>struct mtd_info * <parameter>mtd</parameter></paramdef>
   <paramdef>loff_t <parameter>offs</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>mtd</parameter></term>
   <listitem>
    <para>
     MTD device structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>offs</parameter></term>
   <listitem>
    <para>
     offset of the bad block
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<!-- No internal functions for kernel-doc:
X!Idrivers/mtd/nand/nand_ecc.c
-->
  </chapter>

  <chapter id="credits">
     <title>Credits</title>
	<para>
		The following people have contributed to the NAND driver:
		<orderedlist>
			<listitem><para>Steven J. Hill<email>sjhill@realitydiluted.com</email></para></listitem>
			<listitem><para>David Woodhouse<email>dwmw2@infradead.org</email></para></listitem>
			<listitem><para>Thomas Gleixner<email>tglx@linutronix.de</email></para></listitem>
		</orderedlist>
		A lot of users have provided bugfixes, improvements and helping hands for testing.
		Thanks a lot.
	</para>
	<para>
		The following people have contributed to this document:
		<orderedlist>
			<listitem><para>Thomas Gleixner<email>tglx@linutronix.de</email></para></listitem>
		</orderedlist>
	</para>
  </chapter>
</book>
