<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN"
	"http://www.oasis-open.org/docbook/xml/4.1.2/docbookx.dtd" []>

<book id="LinuxNetworking">
 <bookinfo>
  <title>Linux Networking and Network Devices APIs</title>

  <legalnotice>
   <para>
     This documentation is free software; you can redistribute
     it and/or modify it under the terms of the GNU General Public
     License as published by the Free Software Foundation; either
     version 2 of the License, or (at your option) any later
     version.
   </para>

   <para>
     This program is distributed in the hope that it will be
     useful, but WITHOUT ANY WARRANTY; without even the implied
     warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
     See the GNU General Public License for more details.
   </para>

   <para>
     You should have received a copy of the GNU General Public
     License along with this program; if not, write to the Free
     Software Foundation, Inc., 59 Temple Place, Suite 330, Boston,
     MA 02111-1307 USA
   </para>

   <para>
     For more details see the file COPYING in the source
     distribution of Linux.
   </para>
  </legalnotice>
 </bookinfo>

<toc></toc>

  <chapter id="netcore">
     <title>Linux Networking</title>
     <sect1><title>Networking Base Types</title>
<!-- include/linux/net.h -->
<refentry id="API-enum-sock-type">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>enum sock_type</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>enum sock_type</refname>
 <refpurpose>
  Socket types
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
enum sock_type {
  SOCK_STREAM,
  SOCK_DGRAM,
  SOCK_RAW,
  SOCK_RDM,
  SOCK_SEQPACKET,
  SOCK_DCCP,
  SOCK_PACKET
};  </programlisting>
</refsynopsisdiv>
<refsect1>
 <title>Constants</title>
  <variablelist>
    <varlistentry>      <term>SOCK_STREAM</term>
      <listitem><para>
stream (connection) socket
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>SOCK_DGRAM</term>
      <listitem><para>
datagram (conn.less) socket
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>SOCK_RAW</term>
      <listitem><para>
raw socket
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>SOCK_RDM</term>
      <listitem><para>
reliably-delivered message
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>SOCK_SEQPACKET</term>
      <listitem><para>
sequential packet socket
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>SOCK_DCCP</term>
      <listitem><para>
Datagram Congestion Control Protocol socket
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>SOCK_PACKET</term>
      <listitem><para>
linux specific way of getting packets at the dev level.
For writing rarp and other similar things on the user level.
      </para></listitem>
    </varlistentry>
  </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   When adding some new socket type please
   grep ARCH_HAS_SOCKET_TYPE include/asm-* /socket.h, at least MIPS
   overrides this enum for binary compat reasons.
</para>
</refsect1>
</refentry>

<refentry id="API-struct-socket">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct socket</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct socket</refname>
 <refpurpose>
     general BSD socket
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct socket {
  socket_state state;
  short type;
  unsigned long flags;
  struct socket_wq __rcu * wq;
  struct file * file;
  struct sock * sk;
  const struct proto_ops * ops;
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>state</term>
      <listitem><para>
   socket state (<constant>SS_CONNECTED</constant>, etc)
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>type</term>
      <listitem><para>
   socket type (<constant>SOCK_STREAM</constant>, etc)
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>flags</term>
      <listitem><para>
   socket flags (<constant>SOCK_ASYNC_NOSPACE</constant>, etc)
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>wq</term>
      <listitem><para>
   wait queue for several uses
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>file</term>
      <listitem><para>
   File back pointer for gc
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>sk</term>
      <listitem><para>
   internal networking protocol agnostic socket representation
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>ops</term>
      <listitem><para>
   protocol specific socket operations
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
</refentry>

     </sect1>
     <sect1><title>Socket Buffer Functions</title>
<!-- include/linux/skbuff.h -->
<refentry id="API-struct-skb-shared-hwtstamps">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct skb_shared_hwtstamps</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct skb_shared_hwtstamps</refname>
 <refpurpose>
  hardware time stamps
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct skb_shared_hwtstamps {
  ktime_t hwtstamp;
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>hwtstamp</term>
      <listitem><para>
hardware time stamp transformed into duration
since arbitrary point in time
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
<refsect1>
<title>Description</title>
<para>
   Software time stamps generated by <function>ktime_get_real</function> are stored in
   skb-&gt;tstamp.
   </para><para>

   hwtstamps can only be compared against other hwtstamps from
   the same device.
   </para><para>

   This structure is attached to packets as part of the
   <structname>skb_shared_info</structname>. Use <function>skb_hwtstamps</function> to get a pointer.
</para>
</refsect1>
</refentry>

<refentry id="API-struct-skb-mstamp">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct skb_mstamp</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct skb_mstamp</refname>
 <refpurpose>
     multi resolution time stamps
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct skb_mstamp {
  union {unnamed_union};
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>{unnamed_union}</term>
      <listitem><para>
   anonymous
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
</refentry>

<refentry id="API-skb-mstamp-get">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>skb_mstamp_get</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>skb_mstamp_get</refname>
 <refpurpose>
     get current timestamp
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>skb_mstamp_get </function></funcdef>
   <paramdef>struct skb_mstamp * <parameter>cl</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>cl</parameter></term>
   <listitem>
    <para>
     place to store timestamps
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-skb-mstamp-us-delta">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>skb_mstamp_us_delta</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>skb_mstamp_us_delta</refname>
 <refpurpose>
     compute the difference in usec between two skb_mstamp
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>u32 <function>skb_mstamp_us_delta </function></funcdef>
   <paramdef>const struct skb_mstamp * <parameter>t1</parameter></paramdef>
   <paramdef>const struct skb_mstamp * <parameter>t0</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>t1</parameter></term>
   <listitem>
    <para>
     pointer to newest sample
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>t0</parameter></term>
   <listitem>
    <para>
     pointer to oldest sample
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-struct-sk-buff">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct sk_buff</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct sk_buff</refname>
 <refpurpose>
     socket buffer
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct sk_buff {
  struct sk_buff * next;
  struct sk_buff * prev;
  union {unnamed_union};
  __u16 inner_transport_header;
  __u16 inner_network_header;
  __u16 inner_mac_header;
  __be16 protocol;
  __u16 transport_header;
  __u16 network_header;
  __u16 mac_header;
  sk_buff_data_t tail;
  sk_buff_data_t end;
  unsigned char * head;
  unsigned char * data;
  unsigned int truesize;
  atomic_t users;
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>next</term>
      <listitem><para>
   Next buffer in list
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>prev</term>
      <listitem><para>
   Previous buffer in list
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>{unnamed_union}</term>
      <listitem><para>
   anonymous
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>inner_transport_header</term>
      <listitem><para>
   Inner transport layer header (encapsulation)
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>inner_network_header</term>
      <listitem><para>
   Network layer header (encapsulation)
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>inner_mac_header</term>
      <listitem><para>
   Link layer header (encapsulation)
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>protocol</term>
      <listitem><para>
   Packet protocol from driver
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>transport_header</term>
      <listitem><para>
   Transport layer header
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>network_header</term>
      <listitem><para>
   Network layer header
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>mac_header</term>
      <listitem><para>
   Link layer header
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>tail</term>
      <listitem><para>
   Tail pointer
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>end</term>
      <listitem><para>
   End pointer
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>head</term>
      <listitem><para>
   Head of buffer
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>data</term>
      <listitem><para>
   Data head pointer
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>truesize</term>
      <listitem><para>
   Buffer size
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>users</term>
      <listitem><para>
   User count - see {datagram,tcp}.c
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
</refentry>

<refentry id="API-skb-dst">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>skb_dst</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>skb_dst</refname>
 <refpurpose>
     returns skb dst_entry
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct dst_entry * <function>skb_dst </function></funcdef>
   <paramdef>const struct sk_buff * <parameter>skb</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>skb</parameter></term>
   <listitem>
    <para>
     buffer
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Returns skb dst_entry, regardless of reference taken or not.
</para>
</refsect1>
</refentry>

<refentry id="API-skb-dst-set">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>skb_dst_set</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>skb_dst_set</refname>
 <refpurpose>
     sets skb dst
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>skb_dst_set </function></funcdef>
   <paramdef>struct sk_buff * <parameter>skb</parameter></paramdef>
   <paramdef>struct dst_entry * <parameter>dst</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>skb</parameter></term>
   <listitem>
    <para>
     buffer
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>dst</parameter></term>
   <listitem>
    <para>
     dst entry
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Sets skb dst, assuming a reference was taken on dst and should
   be released by <function>skb_dst_drop</function>
</para>
</refsect1>
</refentry>

<refentry id="API-skb-dst-set-noref">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>skb_dst_set_noref</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>skb_dst_set_noref</refname>
 <refpurpose>
     sets skb dst, hopefully, without taking reference
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>skb_dst_set_noref </function></funcdef>
   <paramdef>struct sk_buff * <parameter>skb</parameter></paramdef>
   <paramdef>struct dst_entry * <parameter>dst</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>skb</parameter></term>
   <listitem>
    <para>
     buffer
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>dst</parameter></term>
   <listitem>
    <para>
     dst entry
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Sets skb dst, assuming a reference was not taken on dst.
   If dst entry is cached, we do not take reference and dst_release
   will be avoided by refdst_drop. If dst entry is not cached, we take
   reference, so that last dst_release can destroy the dst immediately.
</para>
</refsect1>
</refentry>

<refentry id="API-skb-dst-set-noref-force">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>skb_dst_set_noref_force</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>skb_dst_set_noref_force</refname>
 <refpurpose>
     sets skb dst, without taking reference
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>skb_dst_set_noref_force </function></funcdef>
   <paramdef>struct sk_buff * <parameter>skb</parameter></paramdef>
   <paramdef>struct dst_entry * <parameter>dst</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>skb</parameter></term>
   <listitem>
    <para>
     buffer
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>dst</parameter></term>
   <listitem>
    <para>
     dst entry
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Sets skb dst, assuming a reference was not taken on dst.
   No reference is taken and no dst_release will be called. While for
   cached dsts deferred reclaim is a basic feature, for entries that are
   not cached it is caller's job to guarantee that last dst_release for
   provided dst happens when nobody uses it, eg. after a RCU grace period.
</para>
</refsect1>
</refentry>

<refentry id="API-skb-dst-is-noref">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>skb_dst_is_noref</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>skb_dst_is_noref</refname>
 <refpurpose>
     Test if skb dst isn't refcounted
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>bool <function>skb_dst_is_noref </function></funcdef>
   <paramdef>const struct sk_buff * <parameter>skb</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>skb</parameter></term>
   <listitem>
    <para>
     buffer
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-skb-fclone-busy">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>skb_fclone_busy</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>skb_fclone_busy</refname>
 <refpurpose>
     check if fclone is busy
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>bool <function>skb_fclone_busy </function></funcdef>
   <paramdef>const struct sock * <parameter>sk</parameter></paramdef>
   <paramdef>const struct sk_buff * <parameter>skb</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>sk</parameter></term>
   <listitem>
    <para>
     -- undescribed --
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>skb</parameter></term>
   <listitem>
    <para>
     buffer
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Returns true is skb is a fast clone, and its clone is not freed.
   Some drivers call <function>skb_orphan</function> in their <function>ndo_start_xmit</function>,
   so we also check that this didnt happen.
</para>
</refsect1>
</refentry>

<refentry id="API-skb-queue-empty">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>skb_queue_empty</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>skb_queue_empty</refname>
 <refpurpose>
     check if a queue is empty
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>skb_queue_empty </function></funcdef>
   <paramdef>const struct sk_buff_head * <parameter>list</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>list</parameter></term>
   <listitem>
    <para>
     queue head
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Returns true if the queue is empty, false otherwise.
</para>
</refsect1>
</refentry>

<refentry id="API-skb-queue-is-last">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>skb_queue_is_last</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>skb_queue_is_last</refname>
 <refpurpose>
     check if skb is the last entry in the queue
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>bool <function>skb_queue_is_last </function></funcdef>
   <paramdef>const struct sk_buff_head * <parameter>list</parameter></paramdef>
   <paramdef>const struct sk_buff * <parameter>skb</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>list</parameter></term>
   <listitem>
    <para>
     queue head
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>skb</parameter></term>
   <listitem>
    <para>
     buffer
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Returns true if <parameter>skb</parameter> is the last buffer on the list.
</para>
</refsect1>
</refentry>

<refentry id="API-skb-queue-is-first">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>skb_queue_is_first</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>skb_queue_is_first</refname>
 <refpurpose>
     check if skb is the first entry in the queue
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>bool <function>skb_queue_is_first </function></funcdef>
   <paramdef>const struct sk_buff_head * <parameter>list</parameter></paramdef>
   <paramdef>const struct sk_buff * <parameter>skb</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>list</parameter></term>
   <listitem>
    <para>
     queue head
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>skb</parameter></term>
   <listitem>
    <para>
     buffer
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Returns true if <parameter>skb</parameter> is the first buffer on the list.
</para>
</refsect1>
</refentry>

<refentry id="API-skb-queue-next">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>skb_queue_next</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>skb_queue_next</refname>
 <refpurpose>
     return the next packet in the queue
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct sk_buff * <function>skb_queue_next </function></funcdef>
   <paramdef>const struct sk_buff_head * <parameter>list</parameter></paramdef>
   <paramdef>const struct sk_buff * <parameter>skb</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>list</parameter></term>
   <listitem>
    <para>
     queue head
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>skb</parameter></term>
   <listitem>
    <para>
     current buffer
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Return the next packet in <parameter>list</parameter> after <parameter>skb</parameter>.  It is only valid to
   call this if <function>skb_queue_is_last</function> evaluates to false.
</para>
</refsect1>
</refentry>

<refentry id="API-skb-queue-prev">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>skb_queue_prev</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>skb_queue_prev</refname>
 <refpurpose>
     return the prev packet in the queue
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct sk_buff * <function>skb_queue_prev </function></funcdef>
   <paramdef>const struct sk_buff_head * <parameter>list</parameter></paramdef>
   <paramdef>const struct sk_buff * <parameter>skb</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>list</parameter></term>
   <listitem>
    <para>
     queue head
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>skb</parameter></term>
   <listitem>
    <para>
     current buffer
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Return the prev packet in <parameter>list</parameter> before <parameter>skb</parameter>.  It is only valid to
   call this if <function>skb_queue_is_first</function> evaluates to false.
</para>
</refsect1>
</refentry>

<refentry id="API-skb-get">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>skb_get</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>skb_get</refname>
 <refpurpose>
     reference buffer
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct sk_buff * <function>skb_get </function></funcdef>
   <paramdef>struct sk_buff * <parameter>skb</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>skb</parameter></term>
   <listitem>
    <para>
     buffer to reference
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Makes another reference to a socket buffer and returns a pointer
   to the buffer.
</para>
</refsect1>
</refentry>

<refentry id="API-skb-cloned">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>skb_cloned</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>skb_cloned</refname>
 <refpurpose>
     is the buffer a clone
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>skb_cloned </function></funcdef>
   <paramdef>const struct sk_buff * <parameter>skb</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>skb</parameter></term>
   <listitem>
    <para>
     buffer to check
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Returns true if the buffer was generated with <function>skb_clone</function> and is
   one of multiple shared copies of the buffer. Cloned buffers are
   shared data so must not be written to under normal circumstances.
</para>
</refsect1>
</refentry>

<refentry id="API-skb-header-cloned">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>skb_header_cloned</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>skb_header_cloned</refname>
 <refpurpose>
     is the header a clone
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>skb_header_cloned </function></funcdef>
   <paramdef>const struct sk_buff * <parameter>skb</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>skb</parameter></term>
   <listitem>
    <para>
     buffer to check
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Returns true if modifying the header part of the buffer requires
   the data to be copied.
</para>
</refsect1>
</refentry>

<refentry id="API-skb-header-release">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>skb_header_release</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>skb_header_release</refname>
 <refpurpose>
     release reference to header
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>skb_header_release </function></funcdef>
   <paramdef>struct sk_buff * <parameter>skb</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>skb</parameter></term>
   <listitem>
    <para>
     buffer to operate on
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Drop a reference to the header part of the buffer.  This is done
   by acquiring a payload reference.  You must not read from the header
   part of skb-&gt;data after this.
</para>
</refsect1>
<refsect1>
<title>Note </title>
<para>
   Check if you can use <function>__skb_header_release</function> instead.
</para>
</refsect1>
</refentry>

<refentry id="API---skb-header-release">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>__skb_header_release</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>__skb_header_release</refname>
 <refpurpose>
     release reference to header
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>__skb_header_release </function></funcdef>
   <paramdef>struct sk_buff * <parameter>skb</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>skb</parameter></term>
   <listitem>
    <para>
     buffer to operate on
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Variant of <function>skb_header_release</function> assuming skb is private to caller.
   We can avoid one atomic operation.
</para>
</refsect1>
</refentry>

<refentry id="API-skb-shared">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>skb_shared</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>skb_shared</refname>
 <refpurpose>
     is the buffer shared
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>skb_shared </function></funcdef>
   <paramdef>const struct sk_buff * <parameter>skb</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>skb</parameter></term>
   <listitem>
    <para>
     buffer to check
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Returns true if more than one person has a reference to this
   buffer.
</para>
</refsect1>
</refentry>

<refentry id="API-skb-share-check">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>skb_share_check</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>skb_share_check</refname>
 <refpurpose>
     check if buffer is shared and if so clone it
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct sk_buff * <function>skb_share_check </function></funcdef>
   <paramdef>struct sk_buff * <parameter>skb</parameter></paramdef>
   <paramdef>gfp_t <parameter>pri</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>skb</parameter></term>
   <listitem>
    <para>
     buffer to check
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>pri</parameter></term>
   <listitem>
    <para>
     priority for memory allocation
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   If the buffer is shared the buffer is cloned and the old copy
   drops a reference. A new clone with a single reference is returned.
   If the buffer is not shared the original buffer is returned. When
   being called from interrupt status or with spinlocks held pri must
   be GFP_ATOMIC.
   </para><para>

   NULL is returned on a memory allocation failure.
</para>
</refsect1>
</refentry>

<refentry id="API-skb-unshare">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>skb_unshare</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>skb_unshare</refname>
 <refpurpose>
     make a copy of a shared buffer
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct sk_buff * <function>skb_unshare </function></funcdef>
   <paramdef>struct sk_buff * <parameter>skb</parameter></paramdef>
   <paramdef>gfp_t <parameter>pri</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>skb</parameter></term>
   <listitem>
    <para>
     buffer to check
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>pri</parameter></term>
   <listitem>
    <para>
     priority for memory allocation
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   If the socket buffer is a clone then this function creates a new
   copy of the data, drops a reference count on the old copy and returns
   the new copy with the reference count at 1. If the buffer is not a clone
   the original buffer is returned. When called with a spinlock held or
   from interrupt state <parameter>pri</parameter> must be <constant>GFP_ATOMIC</constant>
   </para><para>

   <constant>NULL</constant> is returned on a memory allocation failure.
</para>
</refsect1>
</refentry>

<refentry id="API-skb-peek">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>skb_peek</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>skb_peek</refname>
 <refpurpose>
     peek at the head of an <structname>sk_buff_head</structname>
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct sk_buff * <function>skb_peek </function></funcdef>
   <paramdef>const struct sk_buff_head * <parameter>list_</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>list_</parameter></term>
   <listitem>
    <para>
     list to peek at
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Peek an <structname>sk_buff</structname>. Unlike most other operations you _MUST_
   be careful with this one. A peek leaves the buffer on the
   list and someone else may run off with it. You must hold
   the appropriate locks or have a private queue to do this.
   </para><para>

   Returns <constant>NULL</constant> for an empty list or a pointer to the head element.
   The reference count is not incremented and the reference is therefore
   volatile. Use with caution.
</para>
</refsect1>
</refentry>

<refentry id="API-skb-peek-next">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>skb_peek_next</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>skb_peek_next</refname>
 <refpurpose>
     peek skb following the given one from a queue
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct sk_buff * <function>skb_peek_next </function></funcdef>
   <paramdef>struct sk_buff * <parameter>skb</parameter></paramdef>
   <paramdef>const struct sk_buff_head * <parameter>list_</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>skb</parameter></term>
   <listitem>
    <para>
     skb to start from
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>list_</parameter></term>
   <listitem>
    <para>
     list to peek at
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Returns <constant>NULL</constant> when the end of the list is met or a pointer to the
   next element. The reference count is not incremented and the
   reference is therefore volatile. Use with caution.
</para>
</refsect1>
</refentry>

<refentry id="API-skb-peek-tail">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>skb_peek_tail</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>skb_peek_tail</refname>
 <refpurpose>
     peek at the tail of an <structname>sk_buff_head</structname>
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct sk_buff * <function>skb_peek_tail </function></funcdef>
   <paramdef>const struct sk_buff_head * <parameter>list_</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>list_</parameter></term>
   <listitem>
    <para>
     list to peek at
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Peek an <structname>sk_buff</structname>. Unlike most other operations you _MUST_
   be careful with this one. A peek leaves the buffer on the
   list and someone else may run off with it. You must hold
   the appropriate locks or have a private queue to do this.
   </para><para>

   Returns <constant>NULL</constant> for an empty list or a pointer to the tail element.
   The reference count is not incremented and the reference is therefore
   volatile. Use with caution.
</para>
</refsect1>
</refentry>

<refentry id="API-skb-queue-len">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>skb_queue_len</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>skb_queue_len</refname>
 <refpurpose>
     get queue length
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>__u32 <function>skb_queue_len </function></funcdef>
   <paramdef>const struct sk_buff_head * <parameter>list_</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>list_</parameter></term>
   <listitem>
    <para>
     list to measure
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Return the length of an <structname>sk_buff</structname> queue.
</para>
</refsect1>
</refentry>

<refentry id="API---skb-queue-head-init">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>__skb_queue_head_init</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>__skb_queue_head_init</refname>
 <refpurpose>
     initialize non-spinlock portions of sk_buff_head
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>__skb_queue_head_init </function></funcdef>
   <paramdef>struct sk_buff_head * <parameter>list</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>list</parameter></term>
   <listitem>
    <para>
     queue to initialize
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This initializes only the list and queue length aspects of
   an sk_buff_head object.  This allows to initialize the list
   aspects of an sk_buff_head without reinitializing things like
   the spinlock.  It can also be used for on-stack sk_buff_head
   objects where the spinlock is known to not be used.
</para>
</refsect1>
</refentry>

<refentry id="API-skb-queue-splice">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>skb_queue_splice</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>skb_queue_splice</refname>
 <refpurpose>
     join two skb lists, this is designed for stacks
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>skb_queue_splice </function></funcdef>
   <paramdef>const struct sk_buff_head * <parameter>list</parameter></paramdef>
   <paramdef>struct sk_buff_head * <parameter>head</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>list</parameter></term>
   <listitem>
    <para>
     the new list to add
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>head</parameter></term>
   <listitem>
    <para>
     the place to add it in the first list
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-skb-queue-splice-init">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>skb_queue_splice_init</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>skb_queue_splice_init</refname>
 <refpurpose>
     join two skb lists and reinitialise the emptied list
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>skb_queue_splice_init </function></funcdef>
   <paramdef>struct sk_buff_head * <parameter>list</parameter></paramdef>
   <paramdef>struct sk_buff_head * <parameter>head</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>list</parameter></term>
   <listitem>
    <para>
     the new list to add
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>head</parameter></term>
   <listitem>
    <para>
     the place to add it in the first list
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   The list at <parameter>list</parameter> is reinitialised
</para>
</refsect1>
</refentry>

<refentry id="API-skb-queue-splice-tail">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>skb_queue_splice_tail</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>skb_queue_splice_tail</refname>
 <refpurpose>
     join two skb lists, each list being a queue
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>skb_queue_splice_tail </function></funcdef>
   <paramdef>const struct sk_buff_head * <parameter>list</parameter></paramdef>
   <paramdef>struct sk_buff_head * <parameter>head</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>list</parameter></term>
   <listitem>
    <para>
     the new list to add
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>head</parameter></term>
   <listitem>
    <para>
     the place to add it in the first list
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-skb-queue-splice-tail-init">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>skb_queue_splice_tail_init</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>skb_queue_splice_tail_init</refname>
 <refpurpose>
     join two skb lists and reinitialise the emptied list
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>skb_queue_splice_tail_init </function></funcdef>
   <paramdef>struct sk_buff_head * <parameter>list</parameter></paramdef>
   <paramdef>struct sk_buff_head * <parameter>head</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>list</parameter></term>
   <listitem>
    <para>
     the new list to add
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>head</parameter></term>
   <listitem>
    <para>
     the place to add it in the first list
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Each of the lists is a queue.
   The list at <parameter>list</parameter> is reinitialised
</para>
</refsect1>
</refentry>

<refentry id="API---skb-queue-after">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>__skb_queue_after</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>__skb_queue_after</refname>
 <refpurpose>
     queue a buffer at the list head
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>__skb_queue_after </function></funcdef>
   <paramdef>struct sk_buff_head * <parameter>list</parameter></paramdef>
   <paramdef>struct sk_buff * <parameter>prev</parameter></paramdef>
   <paramdef>struct sk_buff * <parameter>newsk</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>list</parameter></term>
   <listitem>
    <para>
     list to use
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>prev</parameter></term>
   <listitem>
    <para>
     place after this buffer
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>newsk</parameter></term>
   <listitem>
    <para>
     buffer to queue
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Queue a buffer int the middle of a list. This function takes no locks
   and you must therefore hold required locks before calling it.
   </para><para>

   A buffer cannot be placed on two lists at the same time.
</para>
</refsect1>
</refentry>

<refentry id="API---skb-fill-page-desc">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>__skb_fill_page_desc</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>__skb_fill_page_desc</refname>
 <refpurpose>
     initialise a paged fragment in an skb
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>__skb_fill_page_desc </function></funcdef>
   <paramdef>struct sk_buff * <parameter>skb</parameter></paramdef>
   <paramdef>int <parameter>i</parameter></paramdef>
   <paramdef>struct page * <parameter>page</parameter></paramdef>
   <paramdef>int <parameter>off</parameter></paramdef>
   <paramdef>int <parameter>size</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>skb</parameter></term>
   <listitem>
    <para>
     buffer containing fragment to be initialised
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>i</parameter></term>
   <listitem>
    <para>
     paged fragment index to initialise
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>page</parameter></term>
   <listitem>
    <para>
     the page to use for this fragment
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>off</parameter></term>
   <listitem>
    <para>
     the offset to the data with <parameter>page</parameter>
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>size</parameter></term>
   <listitem>
    <para>
     the length of the data
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Initialises the <parameter>i</parameter>'th fragment of <parameter>skb</parameter> to point to <structname>size</structname> bytes at
   offset <parameter>off</parameter> within <parameter>page</parameter>.
   </para><para>

   Does not take any additional reference on the fragment.
</para>
</refsect1>
</refentry>

<refentry id="API-skb-fill-page-desc">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>skb_fill_page_desc</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>skb_fill_page_desc</refname>
 <refpurpose>
     initialise a paged fragment in an skb
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>skb_fill_page_desc </function></funcdef>
   <paramdef>struct sk_buff * <parameter>skb</parameter></paramdef>
   <paramdef>int <parameter>i</parameter></paramdef>
   <paramdef>struct page * <parameter>page</parameter></paramdef>
   <paramdef>int <parameter>off</parameter></paramdef>
   <paramdef>int <parameter>size</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>skb</parameter></term>
   <listitem>
    <para>
     buffer containing fragment to be initialised
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>i</parameter></term>
   <listitem>
    <para>
     paged fragment index to initialise
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>page</parameter></term>
   <listitem>
    <para>
     the page to use for this fragment
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>off</parameter></term>
   <listitem>
    <para>
     the offset to the data with <parameter>page</parameter>
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>size</parameter></term>
   <listitem>
    <para>
     the length of the data
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   As per <function>__skb_fill_page_desc</function> -- initialises the <parameter>i</parameter>'th fragment of
   <parameter>skb</parameter> to point to <parameter>size</parameter> bytes at offset <parameter>off</parameter> within <parameter>page</parameter>. In
   addition updates <parameter>skb</parameter> such that <parameter>i</parameter> is the last fragment.
   </para><para>

   Does not take any additional reference on the fragment.
</para>
</refsect1>
</refentry>

<refentry id="API-skb-headroom">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>skb_headroom</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>skb_headroom</refname>
 <refpurpose>
     bytes at buffer head
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>unsigned int <function>skb_headroom </function></funcdef>
   <paramdef>const struct sk_buff * <parameter>skb</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>skb</parameter></term>
   <listitem>
    <para>
     buffer to check
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Return the number of bytes of free space at the head of an <structname>sk_buff</structname>.
</para>
</refsect1>
</refentry>

<refentry id="API-skb-tailroom">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>skb_tailroom</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>skb_tailroom</refname>
 <refpurpose>
     bytes at buffer end
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>skb_tailroom </function></funcdef>
   <paramdef>const struct sk_buff * <parameter>skb</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>skb</parameter></term>
   <listitem>
    <para>
     buffer to check
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Return the number of bytes of free space at the tail of an sk_buff
</para>
</refsect1>
</refentry>

<refentry id="API-skb-availroom">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>skb_availroom</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>skb_availroom</refname>
 <refpurpose>
     bytes at buffer end
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>skb_availroom </function></funcdef>
   <paramdef>const struct sk_buff * <parameter>skb</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>skb</parameter></term>
   <listitem>
    <para>
     buffer to check
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Return the number of bytes of free space at the tail of an sk_buff
   allocated by <function>sk_stream_alloc</function>
</para>
</refsect1>
</refentry>

<refentry id="API-skb-reserve">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>skb_reserve</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>skb_reserve</refname>
 <refpurpose>
     adjust headroom
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>skb_reserve </function></funcdef>
   <paramdef>struct sk_buff * <parameter>skb</parameter></paramdef>
   <paramdef>int <parameter>len</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>skb</parameter></term>
   <listitem>
    <para>
     buffer to alter
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>len</parameter></term>
   <listitem>
    <para>
     bytes to move
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Increase the headroom of an empty <structname>sk_buff</structname> by reducing the tail
   room. This is only allowed for an empty buffer.
</para>
</refsect1>
</refentry>

<refentry id="API-pskb-trim-unique">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>pskb_trim_unique</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>pskb_trim_unique</refname>
 <refpurpose>
     remove end from a paged unique (not cloned) buffer
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>pskb_trim_unique </function></funcdef>
   <paramdef>struct sk_buff * <parameter>skb</parameter></paramdef>
   <paramdef>unsigned int <parameter>len</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>skb</parameter></term>
   <listitem>
    <para>
     buffer to alter
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>len</parameter></term>
   <listitem>
    <para>
     new length
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This is identical to pskb_trim except that the caller knows that
   the skb is not cloned so we should never get an error due to out-
   of-memory.
</para>
</refsect1>
</refentry>

<refentry id="API-skb-orphan">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>skb_orphan</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>skb_orphan</refname>
 <refpurpose>
     orphan a buffer
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>skb_orphan </function></funcdef>
   <paramdef>struct sk_buff * <parameter>skb</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>skb</parameter></term>
   <listitem>
    <para>
     buffer to orphan
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   If a buffer currently has an owner then we call the owner's
   destructor function and make the <parameter>skb</parameter> unowned. The buffer continues
   to exist but is no longer charged to its former owner.
</para>
</refsect1>
</refentry>

<refentry id="API-skb-orphan-frags">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>skb_orphan_frags</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>skb_orphan_frags</refname>
 <refpurpose>
     orphan the frags contained in a buffer
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>skb_orphan_frags </function></funcdef>
   <paramdef>struct sk_buff * <parameter>skb</parameter></paramdef>
   <paramdef>gfp_t <parameter>gfp_mask</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>skb</parameter></term>
   <listitem>
    <para>
     buffer to orphan frags from
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>gfp_mask</parameter></term>
   <listitem>
    <para>
     allocation mask for replacement pages
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   For each frag in the SKB which needs a destructor (i.e. has an
   owner) create a copy of that frag and release the original
   page by calling the destructor.
</para>
</refsect1>
</refentry>

<refentry id="API-netdev-alloc-skb">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>netdev_alloc_skb</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>netdev_alloc_skb</refname>
 <refpurpose>
     allocate an skbuff for rx on a specific device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct sk_buff * <function>netdev_alloc_skb </function></funcdef>
   <paramdef>struct net_device * <parameter>dev</parameter></paramdef>
   <paramdef>unsigned int <parameter>length</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     network device to receive on
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>length</parameter></term>
   <listitem>
    <para>
     length to allocate
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Allocate a new <structname>sk_buff</structname> and assign it a usage count of one. The
   buffer has unspecified headroom built in. Users should allocate
   the headroom they think they need without accounting for the
   built in space. The built in space is used for optimisations.
   </para><para>

   <constant>NULL</constant> is returned if there is no free memory. Although this function
   allocates memory it can be called from an interrupt.
</para>
</refsect1>
</refentry>

<refentry id="API---skb-alloc-pages">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>__skb_alloc_pages</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>__skb_alloc_pages</refname>
 <refpurpose>
     allocate pages for ps-rx on a skb and preserve pfmemalloc data
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct page * <function>__skb_alloc_pages </function></funcdef>
   <paramdef>gfp_t <parameter>gfp_mask</parameter></paramdef>
   <paramdef>struct sk_buff * <parameter>skb</parameter></paramdef>
   <paramdef>unsigned int <parameter>order</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>gfp_mask</parameter></term>
   <listitem>
    <para>
     alloc_pages_node mask. Set __GFP_NOMEMALLOC if not for network packet RX
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>skb</parameter></term>
   <listitem>
    <para>
     skb to set pfmemalloc on if __GFP_MEMALLOC is used
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>order</parameter></term>
   <listitem>
    <para>
     size of the allocation
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Allocate a new page.
   </para><para>

   <constant>NULL</constant> is returned if there is no free memory.
</para>
</refsect1>
</refentry>

<refentry id="API---skb-alloc-page">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>__skb_alloc_page</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>__skb_alloc_page</refname>
 <refpurpose>
     allocate a page for ps-rx for a given skb and preserve pfmemalloc data
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct page * <function>__skb_alloc_page </function></funcdef>
   <paramdef>gfp_t <parameter>gfp_mask</parameter></paramdef>
   <paramdef>struct sk_buff * <parameter>skb</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>gfp_mask</parameter></term>
   <listitem>
    <para>
     alloc_pages_node mask. Set __GFP_NOMEMALLOC if not for network packet RX
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>skb</parameter></term>
   <listitem>
    <para>
     skb to set pfmemalloc on if __GFP_MEMALLOC is used
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Allocate a new page.
   </para><para>

   <constant>NULL</constant> is returned if there is no free memory.
</para>
</refsect1>
</refentry>

<refentry id="API-skb-propagate-pfmemalloc">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>skb_propagate_pfmemalloc</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>skb_propagate_pfmemalloc</refname>
 <refpurpose>
     Propagate pfmemalloc if skb is allocated after RX page
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>skb_propagate_pfmemalloc </function></funcdef>
   <paramdef>struct page * <parameter>page</parameter></paramdef>
   <paramdef>struct sk_buff * <parameter>skb</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>page</parameter></term>
   <listitem>
    <para>
     The page that was allocated from skb_alloc_page
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>skb</parameter></term>
   <listitem>
    <para>
     The skb that may need pfmemalloc set
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-skb-frag-page">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>skb_frag_page</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>skb_frag_page</refname>
 <refpurpose>
     retrieve the page referred to by a paged fragment
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct page * <function>skb_frag_page </function></funcdef>
   <paramdef>const skb_frag_t * <parameter>frag</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>frag</parameter></term>
   <listitem>
    <para>
     the paged fragment
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Returns the <structname>struct page</structname> associated with <parameter>frag</parameter>.
</para>
</refsect1>
</refentry>

<refentry id="API---skb-frag-ref">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>__skb_frag_ref</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>__skb_frag_ref</refname>
 <refpurpose>
     take an addition reference on a paged fragment.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>__skb_frag_ref </function></funcdef>
   <paramdef>skb_frag_t * <parameter>frag</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>frag</parameter></term>
   <listitem>
    <para>
     the paged fragment
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Takes an additional reference on the paged fragment <parameter>frag</parameter>.
</para>
</refsect1>
</refentry>

<refentry id="API-skb-frag-ref">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>skb_frag_ref</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>skb_frag_ref</refname>
 <refpurpose>
     take an addition reference on a paged fragment of an skb.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>skb_frag_ref </function></funcdef>
   <paramdef>struct sk_buff * <parameter>skb</parameter></paramdef>
   <paramdef>int <parameter>f</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>skb</parameter></term>
   <listitem>
    <para>
     the buffer
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>f</parameter></term>
   <listitem>
    <para>
     the fragment offset.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Takes an additional reference on the <parameter>f</parameter>'th paged fragment of <parameter>skb</parameter>.
</para>
</refsect1>
</refentry>

<refentry id="API---skb-frag-unref">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>__skb_frag_unref</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>__skb_frag_unref</refname>
 <refpurpose>
     release a reference on a paged fragment.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>__skb_frag_unref </function></funcdef>
   <paramdef>skb_frag_t * <parameter>frag</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>frag</parameter></term>
   <listitem>
    <para>
     the paged fragment
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Releases a reference on the paged fragment <parameter>frag</parameter>.
</para>
</refsect1>
</refentry>

<refentry id="API-skb-frag-unref">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>skb_frag_unref</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>skb_frag_unref</refname>
 <refpurpose>
     release a reference on a paged fragment of an skb.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>skb_frag_unref </function></funcdef>
   <paramdef>struct sk_buff * <parameter>skb</parameter></paramdef>
   <paramdef>int <parameter>f</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>skb</parameter></term>
   <listitem>
    <para>
     the buffer
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>f</parameter></term>
   <listitem>
    <para>
     the fragment offset
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Releases a reference on the <parameter>f</parameter>'th paged fragment of <parameter>skb</parameter>.
</para>
</refsect1>
</refentry>

<refentry id="API-skb-frag-address">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>skb_frag_address</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>skb_frag_address</refname>
 <refpurpose>
     gets the address of the data contained in a paged fragment
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void * <function>skb_frag_address </function></funcdef>
   <paramdef>const skb_frag_t * <parameter>frag</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>frag</parameter></term>
   <listitem>
    <para>
     the paged fragment buffer
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Returns the address of the data within <parameter>frag</parameter>. The page must already
   be mapped.
</para>
</refsect1>
</refentry>

<refentry id="API-skb-frag-address-safe">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>skb_frag_address_safe</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>skb_frag_address_safe</refname>
 <refpurpose>
     gets the address of the data contained in a paged fragment
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void * <function>skb_frag_address_safe </function></funcdef>
   <paramdef>const skb_frag_t * <parameter>frag</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>frag</parameter></term>
   <listitem>
    <para>
     the paged fragment buffer
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Returns the address of the data within <parameter>frag</parameter>. Checks that the page
   is mapped and returns <constant>NULL</constant> otherwise.
</para>
</refsect1>
</refentry>

<refentry id="API---skb-frag-set-page">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>__skb_frag_set_page</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>__skb_frag_set_page</refname>
 <refpurpose>
     sets the page contained in a paged fragment
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>__skb_frag_set_page </function></funcdef>
   <paramdef>skb_frag_t * <parameter>frag</parameter></paramdef>
   <paramdef>struct page * <parameter>page</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>frag</parameter></term>
   <listitem>
    <para>
     the paged fragment
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>page</parameter></term>
   <listitem>
    <para>
     the page to set
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Sets the fragment <parameter>frag</parameter> to contain <parameter>page</parameter>.
</para>
</refsect1>
</refentry>

<refentry id="API-skb-frag-set-page">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>skb_frag_set_page</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>skb_frag_set_page</refname>
 <refpurpose>
     sets the page contained in a paged fragment of an skb
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>skb_frag_set_page </function></funcdef>
   <paramdef>struct sk_buff * <parameter>skb</parameter></paramdef>
   <paramdef>int <parameter>f</parameter></paramdef>
   <paramdef>struct page * <parameter>page</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>skb</parameter></term>
   <listitem>
    <para>
     the buffer
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>f</parameter></term>
   <listitem>
    <para>
     the fragment offset
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>page</parameter></term>
   <listitem>
    <para>
     the page to set
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Sets the <parameter>f</parameter>'th fragment of <parameter>skb</parameter> to contain <parameter>page</parameter>.
</para>
</refsect1>
</refentry>

<refentry id="API-skb-frag-dma-map">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>skb_frag_dma_map</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>skb_frag_dma_map</refname>
 <refpurpose>
     maps a paged fragment via the DMA API
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>dma_addr_t <function>skb_frag_dma_map </function></funcdef>
   <paramdef>struct device * <parameter>dev</parameter></paramdef>
   <paramdef>const skb_frag_t * <parameter>frag</parameter></paramdef>
   <paramdef>size_t <parameter>offset</parameter></paramdef>
   <paramdef>size_t <parameter>size</parameter></paramdef>
   <paramdef>enum dma_data_direction <parameter>dir</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     the device to map the fragment to
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>frag</parameter></term>
   <listitem>
    <para>
     the paged fragment to map
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>offset</parameter></term>
   <listitem>
    <para>
     the offset within the fragment (starting at the
     fragment's own offset)
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>size</parameter></term>
   <listitem>
    <para>
     the number of bytes to map
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>dir</parameter></term>
   <listitem>
    <para>
     the direction of the mapping (<constant>PCI_DMA_</constant>*)
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Maps the page associated with <parameter>frag</parameter> to <parameter>device</parameter>.
</para>
</refsect1>
</refentry>

<refentry id="API-skb-clone-writable">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>skb_clone_writable</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>skb_clone_writable</refname>
 <refpurpose>
     is the header of a clone writable
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>skb_clone_writable </function></funcdef>
   <paramdef>const struct sk_buff * <parameter>skb</parameter></paramdef>
   <paramdef>unsigned int <parameter>len</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>skb</parameter></term>
   <listitem>
    <para>
     buffer to check
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>len</parameter></term>
   <listitem>
    <para>
     length up to which to write
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Returns true if modifying the header part of the cloned buffer
   does not requires the data to be copied.
</para>
</refsect1>
</refentry>

<refentry id="API-skb-cow">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>skb_cow</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>skb_cow</refname>
 <refpurpose>
     copy header of skb when it is required
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>skb_cow </function></funcdef>
   <paramdef>struct sk_buff * <parameter>skb</parameter></paramdef>
   <paramdef>unsigned int <parameter>headroom</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>skb</parameter></term>
   <listitem>
    <para>
     buffer to cow
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>headroom</parameter></term>
   <listitem>
    <para>
     needed headroom
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   If the skb passed lacks sufficient headroom or its data part
   is shared, data is reallocated. If reallocation fails, an error
   is returned and original skb is not changed.
   </para><para>

   The result is skb with writable area skb-&gt;head...skb-&gt;tail
   and at least <parameter>headroom</parameter> of space at head.
</para>
</refsect1>
</refentry>

<refentry id="API-skb-cow-head">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>skb_cow_head</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>skb_cow_head</refname>
 <refpurpose>
     skb_cow but only making the head writable
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>skb_cow_head </function></funcdef>
   <paramdef>struct sk_buff * <parameter>skb</parameter></paramdef>
   <paramdef>unsigned int <parameter>headroom</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>skb</parameter></term>
   <listitem>
    <para>
     buffer to cow
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>headroom</parameter></term>
   <listitem>
    <para>
     needed headroom
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This function is identical to skb_cow except that we replace the
   skb_cloned check by skb_header_cloned.  It should be used when
   you only need to push on some header and do not need to modify
   the data.
</para>
</refsect1>
</refentry>

<refentry id="API-skb-padto">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>skb_padto</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>skb_padto</refname>
 <refpurpose>
     pad an skbuff up to a minimal size
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>skb_padto </function></funcdef>
   <paramdef>struct sk_buff * <parameter>skb</parameter></paramdef>
   <paramdef>unsigned int <parameter>len</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>skb</parameter></term>
   <listitem>
    <para>
     buffer to pad
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>len</parameter></term>
   <listitem>
    <para>
     minimal length
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Pads up a buffer to ensure the trailing bytes exist and are
   blanked. If the buffer already contains sufficient data it
   is untouched. Otherwise it is extended. Returns zero on
   success. The skb is freed on error.
</para>
</refsect1>
</refentry>

<refentry id="API-skb-linearize">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>skb_linearize</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>skb_linearize</refname>
 <refpurpose>
     convert paged skb to linear one
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>skb_linearize </function></funcdef>
   <paramdef>struct sk_buff * <parameter>skb</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>skb</parameter></term>
   <listitem>
    <para>
     buffer to linarize
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   If there is no free memory -ENOMEM is returned, otherwise zero
   is returned and the old skb data released.
</para>
</refsect1>
</refentry>

<refentry id="API-skb-has-shared-frag">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>skb_has_shared_frag</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>skb_has_shared_frag</refname>
 <refpurpose>
     can any frag be overwritten
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>bool <function>skb_has_shared_frag </function></funcdef>
   <paramdef>const struct sk_buff * <parameter>skb</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>skb</parameter></term>
   <listitem>
    <para>
     buffer to test
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Return true if the skb has at least one frag that might be modified
   by an external entity (as in <function>vmsplice</function>/<function>sendfile</function>)
</para>
</refsect1>
</refentry>

<refentry id="API-skb-linearize-cow">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>skb_linearize_cow</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>skb_linearize_cow</refname>
 <refpurpose>
     make sure skb is linear and writable
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>skb_linearize_cow </function></funcdef>
   <paramdef>struct sk_buff * <parameter>skb</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>skb</parameter></term>
   <listitem>
    <para>
     buffer to process
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   If there is no free memory -ENOMEM is returned, otherwise zero
   is returned and the old skb data released.
</para>
</refsect1>
</refentry>

<refentry id="API-skb-postpull-rcsum">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>skb_postpull_rcsum</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>skb_postpull_rcsum</refname>
 <refpurpose>
     update checksum for received skb after pull
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>skb_postpull_rcsum </function></funcdef>
   <paramdef>struct sk_buff * <parameter>skb</parameter></paramdef>
   <paramdef>const void * <parameter>start</parameter></paramdef>
   <paramdef>unsigned int <parameter>len</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>skb</parameter></term>
   <listitem>
    <para>
     buffer to update
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>start</parameter></term>
   <listitem>
    <para>
     start of data before pull
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>len</parameter></term>
   <listitem>
    <para>
     length of data pulled
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   After doing a pull on a received packet, you need to call this to
   update the CHECKSUM_COMPLETE checksum, or set ip_summed to
   CHECKSUM_NONE so that it can be recomputed from scratch.
</para>
</refsect1>
</refentry>

<refentry id="API-pskb-trim-rcsum">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>pskb_trim_rcsum</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>pskb_trim_rcsum</refname>
 <refpurpose>
     trim received skb and update checksum
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>pskb_trim_rcsum </function></funcdef>
   <paramdef>struct sk_buff * <parameter>skb</parameter></paramdef>
   <paramdef>unsigned int <parameter>len</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>skb</parameter></term>
   <listitem>
    <para>
     buffer to trim
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>len</parameter></term>
   <listitem>
    <para>
     new length
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This is exactly the same as pskb_trim except that it ensures the
   checksum of received packets are still valid after the operation.
</para>
</refsect1>
</refentry>

<refentry id="API-skb-needs-linearize">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>skb_needs_linearize</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>skb_needs_linearize</refname>
 <refpurpose>
     check if we need to linearize a given skb depending on the given device features.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>bool <function>skb_needs_linearize </function></funcdef>
   <paramdef>struct sk_buff * <parameter>skb</parameter></paramdef>
   <paramdef>netdev_features_t <parameter>features</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>skb</parameter></term>
   <listitem>
    <para>
     socket buffer to check
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>features</parameter></term>
   <listitem>
    <para>
     net device features
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Returns true if either</title>
<para>
   1. skb has frag_list and the device doesn't support FRAGLIST, or
   2. skb is fragmented and the device does not support SG.
</para>
</refsect1>
</refentry>

<refentry id="API-skb-get-timestamp">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>skb_get_timestamp</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>skb_get_timestamp</refname>
 <refpurpose>
     get timestamp from a skb
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>skb_get_timestamp </function></funcdef>
   <paramdef>const struct sk_buff * <parameter>skb</parameter></paramdef>
   <paramdef>struct timeval * <parameter>stamp</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>skb</parameter></term>
   <listitem>
    <para>
     skb to get stamp from
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>stamp</parameter></term>
   <listitem>
    <para>
     pointer to struct timeval to store stamp in
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Timestamps are stored in the skb as offsets to a base timestamp.
   This function converts the offset back to a struct timeval and stores
   it in stamp.
</para>
</refsect1>
</refentry>

<refentry id="API-skb-tx-timestamp">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>skb_tx_timestamp</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>skb_tx_timestamp</refname>
 <refpurpose>
     Driver hook for transmit timestamping
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>skb_tx_timestamp </function></funcdef>
   <paramdef>struct sk_buff * <parameter>skb</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>skb</parameter></term>
   <listitem>
    <para>
     A socket buffer.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   </para><para>

   Ethernet MAC Drivers should call this function in their <function>hard_xmit</function>
   function immediately before giving the sk_buff to the MAC hardware.
   </para><para>

   Specifically, one should make absolutely sure that this function is
   called before TX completion of this packet can trigger.  Otherwise
   the packet could potentially already be freed.
</para>
</refsect1>
</refentry>

<refentry id="API-skb-checksum-complete">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>skb_checksum_complete</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>skb_checksum_complete</refname>
 <refpurpose>
     Calculate checksum of an entire packet
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>__sum16 <function>skb_checksum_complete </function></funcdef>
   <paramdef>struct sk_buff * <parameter>skb</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>skb</parameter></term>
   <listitem>
    <para>
     packet to process
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This function calculates the checksum over the entire packet plus
   the value of skb-&gt;csum.  The latter can be used to supply the
   checksum of a pseudo header as used by TCP/UDP.  It returns the
   checksum.
   </para><para>

   For protocols that contain complete checksums such as ICMP/TCP/UDP,
   this function can be used to verify that checksum on received
   packets.  In that case the function should return zero if the
   checksum is correct.  In particular, this function will return zero
   if skb-&gt;ip_summed is CHECKSUM_UNNECESSARY which indicates that the
   hardware has already verified the correctness of the checksum.
</para>
</refsect1>
</refentry>

<refentry id="API-skb-checksum-none-assert">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>skb_checksum_none_assert</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>skb_checksum_none_assert</refname>
 <refpurpose>
     make sure skb ip_summed is CHECKSUM_NONE
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>skb_checksum_none_assert </function></funcdef>
   <paramdef>const struct sk_buff * <parameter>skb</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>skb</parameter></term>
   <listitem>
    <para>
     skb to check
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   fresh skbs have their ip_summed set to CHECKSUM_NONE.
   Instead of forcing ip_summed to CHECKSUM_NONE, we can
   use this helper, to document places where we make this assertion.
</para>
</refsect1>
</refentry>

<refentry id="API-skb-head-is-locked">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>skb_head_is_locked</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>skb_head_is_locked</refname>
 <refpurpose>
     Determine if the skb-&gt;head is locked down
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>bool <function>skb_head_is_locked </function></funcdef>
   <paramdef>const struct sk_buff * <parameter>skb</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>skb</parameter></term>
   <listitem>
    <para>
     skb to check
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   The head on skbs build around a head frag can be removed if they are
   not cloned.  This function returns true if the skb head is locked down
   due to either being allocated via kmalloc, or by being a clone with
   multiple references to the head.
</para>
</refsect1>
</refentry>

<refentry id="API-skb-gso-network-seglen">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>skb_gso_network_seglen</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>skb_gso_network_seglen</refname>
 <refpurpose>
     Return length of individual segments of a gso packet
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>unsigned int <function>skb_gso_network_seglen </function></funcdef>
   <paramdef>const struct sk_buff * <parameter>skb</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>skb</parameter></term>
   <listitem>
    <para>
     GSO skb
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   skb_gso_network_seglen is used to determine the real size of the
   individual segments, including Layer3 (IP, IPv6) and L4 headers (TCP/UDP).
   </para><para>

   The MAC/L2 header is not accounted for.
</para>
</refsect1>
</refentry>

<!-- include/net/sock.h -->
<refentry id="API-struct-sock-common">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct sock_common</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct sock_common</refname>
 <refpurpose>
  minimal network layer representation of sockets
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct sock_common {
  union {unnamed_union};
  int skc_tx_queue_mapping;
  atomic_t skc_refcnt;
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>{unnamed_union}</term>
      <listitem><para>
anonymous
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>skc_tx_queue_mapping</term>
      <listitem><para>
tx queue number for this connection
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>skc_refcnt</term>
      <listitem><para>
reference count
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
<refsect1>
<title>Description</title>
<para>
   This is the minimal network layer representation of sockets, the header
   for struct sock and struct inet_timewait_sock.
</para>
</refsect1>
</refentry>

<refentry id="API-struct-sock">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct sock</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct sock</refname>
 <refpurpose>
     network layer representation of sockets
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct sock {
  struct sock_common __sk_common;
#define sk_node			__sk_common.skc_node
#define sk_nulls_node		__sk_common.skc_nulls_node
#define sk_refcnt		__sk_common.skc_refcnt
#define sk_tx_queue_mapping	__sk_common.skc_tx_queue_mapping
#define sk_dontcopy_begin	__sk_common.skc_dontcopy_begin
#define sk_dontcopy_end		__sk_common.skc_dontcopy_end
#define sk_hash			__sk_common.skc_hash
#define sk_portpair		__sk_common.skc_portpair
#define sk_num			__sk_common.skc_num
#define sk_dport		__sk_common.skc_dport
#define sk_addrpair		__sk_common.skc_addrpair
#define sk_daddr		__sk_common.skc_daddr
#define sk_rcv_saddr		__sk_common.skc_rcv_saddr
#define sk_family		__sk_common.skc_family
#define sk_state		__sk_common.skc_state
#define sk_reuse		__sk_common.skc_reuse
#define sk_reuseport		__sk_common.skc_reuseport
#define sk_ipv6only		__sk_common.skc_ipv6only
#define sk_bound_dev_if		__sk_common.skc_bound_dev_if
#define sk_bind_node		__sk_common.skc_bind_node
#define sk_prot			__sk_common.skc_prot
#define sk_net			__sk_common.skc_net
#define sk_v6_daddr		__sk_common.skc_v6_daddr
#define sk_v6_rcv_saddr	__sk_common.skc_v6_rcv_saddr
  socket_lock_t sk_lock;
  struct sk_buff_head sk_receive_queue;
  struct sk_backlog;
#define sk_rmem_alloc sk_backlog.rmem_alloc
  int sk_forward_alloc;
#ifdef CONFIG_RPS
  __u32 sk_rxhash;
#endif
  __u32 sk_txhash;
#ifdef CONFIG_NET_RX_BUSY_POLL
  unsigned int sk_napi_id;
  unsigned int sk_ll_usec;
#endif
  atomic_t sk_drops;
  int sk_rcvbuf;
  struct sk_filter __rcu * sk_filter;
  struct socket_wq __rcu * sk_wq;
#ifdef CONFIG_XFRM
  struct xfrm_policy * sk_policy[2];
#endif
  unsigned long sk_flags;
  struct dst_entry * sk_rx_dst;
  struct dst_entry __rcu * sk_dst_cache;
  spinlock_t sk_dst_lock;
  atomic_t sk_wmem_alloc;
  atomic_t sk_omem_alloc;
  int sk_sndbuf;
  struct sk_buff_head sk_write_queue;
  unsigned int sk_shutdown:2;
  unsigned int sk_no_check_tx:1;
  unsigned int sk_no_check_rx:1;
  unsigned int sk_userlocks:4;
  unsigned int sk_protocol:8;
  unsigned int sk_type:16;
#define SK_PROTOCOL_MAX U8_MAX
  int sk_wmem_queued;
  gfp_t sk_allocation;
  u32 sk_pacing_rate;
  u32 sk_max_pacing_rate;
  netdev_features_t sk_route_caps;
  netdev_features_t sk_route_nocaps;
  int sk_gso_type;
  unsigned int sk_gso_max_size;
  u16 sk_gso_max_segs;
  int sk_rcvlowat;
  unsigned long sk_lingertime;
  struct sk_buff_head sk_error_queue;
  struct proto * sk_prot_creator;
  rwlock_t sk_callback_lock;
  int sk_err;
  int sk_err_soft;
  unsigned short sk_ack_backlog;
  unsigned short sk_max_ack_backlog;
  __u32 sk_priority;
#if IS_ENABLED(CONFIG_CGROUP_NET_PRIO)
  __u32 sk_cgrp_prioidx;
#endif
  struct pid * sk_peer_pid;
  const struct cred * sk_peer_cred;
  long sk_rcvtimeo;
  long sk_sndtimeo;
  void * sk_protinfo;
  struct timer_list sk_timer;
  ktime_t sk_stamp;
#if BITS_PER_LONG==32
  seqlock_t sk_stamp_seq;
#endif
  u16 sk_tsflags;
  u32 sk_tskey;
  struct socket * sk_socket;
  void * sk_user_data;
  struct page_frag sk_frag;
  struct sk_buff * sk_send_head;
  __s32 sk_peek_off;
  int sk_write_pending;
#ifdef CONFIG_SECURITY
  void * sk_security;
#endif
  __u32 sk_mark;
  u32 sk_classid;
  struct cg_proto * sk_cgrp;
  void (* sk_state_change) (struct sock *sk);
  void (* sk_data_ready) (struct sock *sk);
  void (* sk_write_space) (struct sock *sk);
  void (* sk_error_report) (struct sock *sk);
  int (* sk_backlog_rcv) (struct sock *sk,struct sk_buff *skb);
  void (* sk_destruct) (struct sock *sk);
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>__sk_common</term>
      <listitem><para>
   shared layout with inet_timewait_sock
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>sk_lock</term>
      <listitem><para>
   synchronizer
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>sk_receive_queue</term>
      <listitem><para>
   incoming packets
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>sk_backlog</term>
      <listitem><para>
   always used with the per-socket spinlock held
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>sk_forward_alloc</term>
      <listitem><para>
   space allocated forward
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>sk_rxhash</term>
      <listitem><para>
   flow hash received from netif layer
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>sk_txhash</term>
      <listitem><para>
   computed flow hash for use on transmit
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>sk_napi_id</term>
      <listitem><para>
   id of the last napi context to receive data for sk
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>sk_ll_usec</term>
      <listitem><para>
   usecs to busypoll when there is no data
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>sk_drops</term>
      <listitem><para>
   raw/udp drops counter
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>sk_rcvbuf</term>
      <listitem><para>
   size of receive buffer in bytes
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>sk_filter</term>
      <listitem><para>
   socket filtering instructions
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>sk_wq</term>
      <listitem><para>
   sock wait queue and async head
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>sk_policy[2]</term>
      <listitem><para>
   flow policy
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>sk_flags</term>
      <listitem><para>
   <constant>SO_LINGER</constant> (l_onoff), <constant>SO_BROADCAST</constant>, <constant>SO_KEEPALIVE</constant>,
   <constant>SO_OOBINLINE</constant> settings, <constant>SO_TIMESTAMPING</constant> settings
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>sk_rx_dst</term>
      <listitem><para>
   receive input route used by early demux
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>sk_dst_cache</term>
      <listitem><para>
   destination cache
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>sk_dst_lock</term>
      <listitem><para>
   destination cache lock
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>sk_wmem_alloc</term>
      <listitem><para>
   transmit queue bytes committed
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>sk_omem_alloc</term>
      <listitem><para>
   "o<quote> is </quote>option<quote> or </quote>other"
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>sk_sndbuf</term>
      <listitem><para>
   size of send buffer in bytes
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>sk_write_queue</term>
      <listitem><para>
   Packet sending queue
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>sk_shutdown</term>
      <listitem><para>
   mask of <constant>SEND_SHUTDOWN</constant> and/or <constant>RCV_SHUTDOWN</constant>
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>sk_no_check_tx</term>
      <listitem><para>
   <constant>SO_NO_CHECK</constant> setting, set checksum in TX packets
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>sk_no_check_rx</term>
      <listitem><para>
   allow zero checksum in RX packets
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>sk_userlocks</term>
      <listitem><para>
   <constant>SO_SNDBUF</constant> and <constant>SO_RCVBUF</constant> settings
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>sk_protocol</term>
      <listitem><para>
   which protocol this socket belongs in this network family
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>sk_type</term>
      <listitem><para>
   socket type (<constant>SOCK_STREAM</constant>, etc)
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>sk_wmem_queued</term>
      <listitem><para>
   persistent queue size
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>sk_allocation</term>
      <listitem><para>
   allocation mode
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>sk_pacing_rate</term>
      <listitem><para>
   Pacing rate (if supported by transport/packet scheduler)
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>sk_max_pacing_rate</term>
      <listitem><para>
   Maximum pacing rate (<constant>SO_MAX_PACING_RATE</constant>)
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>sk_route_caps</term>
      <listitem><para>
   route capabilities (e.g. <constant>NETIF_F_TSO</constant>)
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>sk_route_nocaps</term>
      <listitem><para>
   forbidden route capabilities (e.g NETIF_F_GSO_MASK)
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>sk_gso_type</term>
      <listitem><para>
   GSO type (e.g. <constant>SKB_GSO_TCPV4</constant>)
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>sk_gso_max_size</term>
      <listitem><para>
   Maximum GSO segment size to build
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>sk_gso_max_segs</term>
      <listitem><para>
   Maximum number of GSO segments
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>sk_rcvlowat</term>
      <listitem><para>
   <constant>SO_RCVLOWAT</constant> setting
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>sk_lingertime</term>
      <listitem><para>
   <constant>SO_LINGER</constant> l_linger setting
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>sk_error_queue</term>
      <listitem><para>
   rarely used
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>sk_prot_creator</term>
      <listitem><para>
   sk_prot of original sock creator (see ipv6_setsockopt,
   IPV6_ADDRFORM for instance)
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>sk_callback_lock</term>
      <listitem><para>
   used with the callbacks in the end of this struct
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>sk_err</term>
      <listitem><para>
   last error
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>sk_err_soft</term>
      <listitem><para>
   errors that don't cause failure but are the cause of a
   persistent failure not just 'timed out'
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>sk_ack_backlog</term>
      <listitem><para>
   current listen backlog
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>sk_max_ack_backlog</term>
      <listitem><para>
   listen backlog set in <function>listen</function>
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>sk_priority</term>
      <listitem><para>
   <constant>SO_PRIORITY</constant> setting
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>sk_cgrp_prioidx</term>
      <listitem><para>
   socket group's priority map index
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>sk_peer_pid</term>
      <listitem><para>
   <structname>struct pid</structname> for this socket's peer
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>sk_peer_cred</term>
      <listitem><para>
   <constant>SO_PEERCRED</constant> setting
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>sk_rcvtimeo</term>
      <listitem><para>
   <constant>SO_RCVTIMEO</constant> setting
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>sk_sndtimeo</term>
      <listitem><para>
   <constant>SO_SNDTIMEO</constant> setting
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>sk_protinfo</term>
      <listitem><para>
   private area, net family specific, when not using slab
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>sk_timer</term>
      <listitem><para>
   sock cleanup timer
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>sk_stamp</term>
      <listitem><para>
   time stamp of last packet received
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>sk_stamp_seq</term>
      <listitem><para>
   lock for accessing sk_stamp on 32 bit architectures only
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>sk_tsflags</term>
      <listitem><para>
   SO_TIMESTAMPING socket options
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>sk_tskey</term>
      <listitem><para>
   counter to disambiguate concurrent tstamp requests
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>sk_socket</term>
      <listitem><para>
   Identd and reporting IO signals
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>sk_user_data</term>
      <listitem><para>
   RPC layer private data
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>sk_frag</term>
      <listitem><para>
   cached page frag
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>sk_send_head</term>
      <listitem><para>
   front of stuff to transmit
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>sk_peek_off</term>
      <listitem><para>
   current peek_offset value
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>sk_write_pending</term>
      <listitem><para>
   a write to stream socket waits to start
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>sk_security</term>
      <listitem><para>
   used by security modules
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>sk_mark</term>
      <listitem><para>
   generic packet mark
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>sk_classid</term>
      <listitem><para>
   this socket's cgroup classid
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>sk_cgrp</term>
      <listitem><para>
   this socket's cgroup-specific proto data
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>sk_state_change</term>
      <listitem><para>
   callback to indicate change in the state of the sock
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>sk_data_ready</term>
      <listitem><para>
   callback to indicate there is data to be processed
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>sk_write_space</term>
      <listitem><para>
   callback to indicate there is bf sending space available
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>sk_error_report</term>
      <listitem><para>
   callback to indicate errors (e.g. <constant>MSG_ERRQUEUE</constant>)
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>sk_backlog_rcv</term>
      <listitem><para>
   callback to process the backlog
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>sk_destruct</term>
      <listitem><para>
   called at sock freeing time, i.e. when all refcnt == 0
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
</refentry>

<refentry id="API-sk-nulls-for-each-entry-offset">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>sk_nulls_for_each_entry_offset</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>sk_nulls_for_each_entry_offset</refname>
 <refpurpose>
     iterate over a list at a given struct offset
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef> <function>sk_nulls_for_each_entry_offset </function></funcdef>
   <paramdef> <parameter>tpos</parameter></paramdef>
   <paramdef> <parameter>pos</parameter></paramdef>
   <paramdef> <parameter>head</parameter></paramdef>
   <paramdef> <parameter>offset</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>tpos</parameter></term>
   <listitem>
    <para>
     the type * to use as a loop cursor.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>pos</parameter></term>
   <listitem>
    <para>
     the <structname>struct hlist_node</structname> to use as a loop cursor.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>head</parameter></term>
   <listitem>
    <para>
     the head for your list.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>offset</parameter></term>
   <listitem>
    <para>
     offset of hlist_node within the struct.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-unlock-sock-fast">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>unlock_sock_fast</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>unlock_sock_fast</refname>
 <refpurpose>
     complement of lock_sock_fast
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>unlock_sock_fast </function></funcdef>
   <paramdef>struct sock * <parameter>sk</parameter></paramdef>
   <paramdef>bool <parameter>slow</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>sk</parameter></term>
   <listitem>
    <para>
     socket
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>slow</parameter></term>
   <listitem>
    <para>
     slow mode
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   fast unlock socket for user context.
   If slow mode is on, we call regular <function>release_sock</function>
</para>
</refsect1>
</refentry>

<refentry id="API-sk-wmem-alloc-get">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>sk_wmem_alloc_get</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>sk_wmem_alloc_get</refname>
 <refpurpose>
     returns write allocations
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>sk_wmem_alloc_get </function></funcdef>
   <paramdef>const struct sock * <parameter>sk</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>sk</parameter></term>
   <listitem>
    <para>
     socket
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Returns sk_wmem_alloc minus initial offset of one
</para>
</refsect1>
</refentry>

<refentry id="API-sk-rmem-alloc-get">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>sk_rmem_alloc_get</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>sk_rmem_alloc_get</refname>
 <refpurpose>
     returns read allocations
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>sk_rmem_alloc_get </function></funcdef>
   <paramdef>const struct sock * <parameter>sk</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>sk</parameter></term>
   <listitem>
    <para>
     socket
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Returns sk_rmem_alloc
</para>
</refsect1>
</refentry>

<refentry id="API-sk-has-allocations">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>sk_has_allocations</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>sk_has_allocations</refname>
 <refpurpose>
     check if allocations are outstanding
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>bool <function>sk_has_allocations </function></funcdef>
   <paramdef>const struct sock * <parameter>sk</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>sk</parameter></term>
   <listitem>
    <para>
     socket
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Returns true if socket has write or read allocations
</para>
</refsect1>
</refentry>

<refentry id="API-wq-has-sleeper">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>wq_has_sleeper</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>wq_has_sleeper</refname>
 <refpurpose>
     check if there are any waiting processes
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>bool <function>wq_has_sleeper </function></funcdef>
   <paramdef>struct socket_wq * <parameter>wq</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>wq</parameter></term>
   <listitem>
    <para>
     struct socket_wq
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Returns true if socket_wq has waiting processes
   </para><para>

   The purpose of the wq_has_sleeper and sock_poll_wait is to wrap the memory
   barrier call. They were added due to the race found within the tcp code.
</para>
</refsect1>
<refsect1>
<title>Consider following tcp code paths</title>
<para>
   </para><para>

   CPU1                  CPU2
   </para><para>

   sys_select            receive packet
   ...                 ...
   __add_wait_queue    update tp-&gt;rcv_nxt
   ...                 ...
   tp-&gt;rcv_nxt check   sock_def_readable
   ...                 {
   schedule               <function>rcu_read_lock</function>;
   wq = rcu_dereference(sk-&gt;sk_wq);
   if (wq &amp;&amp; waitqueue_active(<structname>wq</structname>-&gt;wait))
   wake_up_interruptible(<structname>wq</structname>-&gt;wait)
   ...
   }
   </para><para>

   The race for tcp fires when the __add_wait_queue changes done by CPU1 stay
   in its cache, and so does the tp-&gt;rcv_nxt update on CPU2 side.  The CPU1
   could then endup calling schedule and sleep forever if there are no more
   data on the socket.
</para>
</refsect1>
</refentry>

<refentry id="API-sock-poll-wait">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>sock_poll_wait</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>sock_poll_wait</refname>
 <refpurpose>
     place memory barrier behind the poll_wait call.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>sock_poll_wait </function></funcdef>
   <paramdef>struct file * <parameter>filp</parameter></paramdef>
   <paramdef>wait_queue_head_t * <parameter>wait_address</parameter></paramdef>
   <paramdef>poll_table * <parameter>p</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>filp</parameter></term>
   <listitem>
    <para>
     file
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>wait_address</parameter></term>
   <listitem>
    <para>
     socket wait queue
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>p</parameter></term>
   <listitem>
    <para>
     poll_table
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   See the comments in the wq_has_sleeper function.
</para>
</refsect1>
</refentry>

<refentry id="API-sk-page-frag">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>sk_page_frag</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>sk_page_frag</refname>
 <refpurpose>
     return an appropriate page_frag
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct page_frag * <function>sk_page_frag </function></funcdef>
   <paramdef>struct sock * <parameter>sk</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>sk</parameter></term>
   <listitem>
    <para>
     socket
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   If socket allocation mode allows current thread to sleep, it means its
   safe to use the per task page_frag instead of the per socket one.
</para>
</refsect1>
</refentry>

<refentry id="API-sock-tx-timestamp">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>sock_tx_timestamp</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>sock_tx_timestamp</refname>
 <refpurpose>
     checks whether the outgoing packet is to be time stamped
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>sock_tx_timestamp </function></funcdef>
   <paramdef>const struct sock * <parameter>sk</parameter></paramdef>
   <paramdef>__u8 * <parameter>tx_flags</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>sk</parameter></term>
   <listitem>
    <para>
     socket sending this packet
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>tx_flags</parameter></term>
   <listitem>
    <para>
     completed with instructions for time stamping
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Note </title>
<para>
   callers should take care of initial *tx_flags value (usually 0)
</para>
</refsect1>
</refentry>

<refentry id="API-sk-eat-skb">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>sk_eat_skb</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>sk_eat_skb</refname>
 <refpurpose>
     Release a skb if it is no longer needed
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>sk_eat_skb </function></funcdef>
   <paramdef>struct sock * <parameter>sk</parameter></paramdef>
   <paramdef>struct sk_buff * <parameter>skb</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>sk</parameter></term>
   <listitem>
    <para>
     socket to eat this skb from
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>skb</parameter></term>
   <listitem>
    <para>
     socket buffer to eat
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This routine must be called with interrupts disabled or with the socket
   locked so that the sk_buff queue operation is ok.
</para>
</refsect1>
</refentry>

<!-- net/socket.c -->
<refentry id="API-sockfd-lookup">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>sockfd_lookup</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>sockfd_lookup</refname>
 <refpurpose>
  Go from a file number to its socket slot
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct socket * <function>sockfd_lookup </function></funcdef>
   <paramdef>int <parameter>fd</parameter></paramdef>
   <paramdef>int * <parameter>err</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>fd</parameter></term>
   <listitem>
    <para>
     file handle
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>err</parameter></term>
   <listitem>
    <para>
     pointer to an error code return
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   The file handle passed in is locked and the socket it is bound
   too is returned. If an error occurs the err pointer is overwritten
   with a negative errno code and NULL is returned. The function checks
   for both invalid handles and passing a handle which is not a socket.
   </para><para>

   On a success the socket object pointer is returned.
</para>
</refsect1>
</refentry>

<refentry id="API-sock-release">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>sock_release</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>sock_release</refname>
 <refpurpose>
     close a socket
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>sock_release </function></funcdef>
   <paramdef>struct socket * <parameter>sock</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>sock</parameter></term>
   <listitem>
    <para>
     socket to close
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   The socket is released from the protocol stack if it has a release
   callback, and the inode is then released if the socket is bound to
   an inode not a file.
</para>
</refsect1>
</refentry>

<refentry id="API-kernel-recvmsg">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>kernel_recvmsg</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>kernel_recvmsg</refname>
 <refpurpose>
     Receive a message from a socket (kernel space)
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>kernel_recvmsg </function></funcdef>
   <paramdef>struct socket * <parameter>sock</parameter></paramdef>
   <paramdef>struct msghdr * <parameter>msg</parameter></paramdef>
   <paramdef>struct kvec * <parameter>vec</parameter></paramdef>
   <paramdef>size_t <parameter>num</parameter></paramdef>
   <paramdef>size_t <parameter>size</parameter></paramdef>
   <paramdef>int <parameter>flags</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>sock</parameter></term>
   <listitem>
    <para>
     The socket to receive the message from
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>msg</parameter></term>
   <listitem>
    <para>
     Received message
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>vec</parameter></term>
   <listitem>
    <para>
     Input s/g array for message data
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>num</parameter></term>
   <listitem>
    <para>
     Size of input s/g array
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>size</parameter></term>
   <listitem>
    <para>
     Number of bytes to read
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>flags</parameter></term>
   <listitem>
    <para>
     Message flags (MSG_DONTWAIT, etc...)
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   On return the msg structure contains the scatter/gather array passed in the
   vec argument. The array is modified so that it consists of the unfilled
   portion of the original array.
   </para><para>

   The returned value is the total number of bytes received, or an error.
</para>
</refsect1>
</refentry>

<refentry id="API-sock-register">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>sock_register</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>sock_register</refname>
 <refpurpose>
     add a socket protocol handler
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>sock_register </function></funcdef>
   <paramdef>const struct net_proto_family * <parameter>ops</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ops</parameter></term>
   <listitem>
    <para>
     description of protocol
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This function is called by a protocol handler that wants to
   advertise its address family, and have it linked into the
   socket interface. The value ops-&gt;family corresponds to the
   socket system call protocol family.
</para>
</refsect1>
</refentry>

<refentry id="API-sock-unregister">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>sock_unregister</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>sock_unregister</refname>
 <refpurpose>
     remove a protocol handler
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>sock_unregister </function></funcdef>
   <paramdef>int <parameter>family</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>family</parameter></term>
   <listitem>
    <para>
     protocol family to remove
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This function is called by a protocol handler that wants to
   remove its address family, and have it unlinked from the
   new socket creation.
   </para><para>

   If protocol handler is a module, then it can use module reference
   counts to protect against new references. If protocol handler is not
   a module then it needs to provide its own protection in
   the ops-&gt;create routine.
</para>
</refsect1>
</refentry>

<!-- net/core/skbuff.c -->
<refentry id="API---alloc-skb">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>__alloc_skb</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>__alloc_skb</refname>
 <refpurpose>
  allocate a network buffer
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct sk_buff * <function>__alloc_skb </function></funcdef>
   <paramdef>unsigned int <parameter>size</parameter></paramdef>
   <paramdef>gfp_t <parameter>gfp_mask</parameter></paramdef>
   <paramdef>int <parameter>flags</parameter></paramdef>
   <paramdef>int <parameter>node</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>size</parameter></term>
   <listitem>
    <para>
     size to allocate
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>gfp_mask</parameter></term>
   <listitem>
    <para>
     allocation mask
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>flags</parameter></term>
   <listitem>
    <para>
     If SKB_ALLOC_FCLONE is set, allocate from fclone cache
     instead of head cache and allocate a cloned (child) skb.
     If SKB_ALLOC_RX is set, __GFP_MEMALLOC will be used for
     allocations in case the data is required for writeback
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>node</parameter></term>
   <listitem>
    <para>
     numa node to allocate memory on
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Allocate a new <structname>sk_buff</structname>. The returned buffer has no headroom and a
   tail room of at least size bytes. The object has a reference count
   of one. The return is the buffer. On a failure the return is <constant>NULL</constant>.
   </para><para>

   Buffers may only be allocated from interrupts using a <parameter>gfp_mask</parameter> of
   <constant>GFP_ATOMIC</constant>.
</para>
</refsect1>
</refentry>

<refentry id="API-netdev-alloc-frag">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>netdev_alloc_frag</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>netdev_alloc_frag</refname>
 <refpurpose>
     allocate a page fragment
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void * <function>netdev_alloc_frag </function></funcdef>
   <paramdef>unsigned int <parameter>fragsz</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>fragsz</parameter></term>
   <listitem>
    <para>
     fragment size
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Allocates a frag from a page for receive buffer.
   Uses GFP_ATOMIC allocations.
</para>
</refsect1>
</refentry>

<refentry id="API---netdev-alloc-skb">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>__netdev_alloc_skb</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>__netdev_alloc_skb</refname>
 <refpurpose>
     allocate an skbuff for rx on a specific device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct sk_buff * <function>__netdev_alloc_skb </function></funcdef>
   <paramdef>struct net_device * <parameter>dev</parameter></paramdef>
   <paramdef>unsigned int <parameter>length</parameter></paramdef>
   <paramdef>gfp_t <parameter>gfp_mask</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     network device to receive on
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>length</parameter></term>
   <listitem>
    <para>
     length to allocate
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>gfp_mask</parameter></term>
   <listitem>
    <para>
     get_free_pages mask, passed to alloc_skb
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Allocate a new <structname>sk_buff</structname> and assign it a usage count of one. The
   buffer has unspecified headroom built in. Users should allocate
   the headroom they think they need without accounting for the
   built in space. The built in space is used for optimisations.
   </para><para>

   <constant>NULL</constant> is returned if there is no free memory.
</para>
</refsect1>
</refentry>

<refentry id="API---kfree-skb">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>__kfree_skb</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>__kfree_skb</refname>
 <refpurpose>
     private function
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>__kfree_skb </function></funcdef>
   <paramdef>struct sk_buff * <parameter>skb</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>skb</parameter></term>
   <listitem>
    <para>
     buffer
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Free an sk_buff. Release anything attached to the buffer.
   Clean the state. This is an internal helper function. Users should
   always call kfree_skb
</para>
</refsect1>
</refentry>

<refentry id="API-kfree-skb">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>kfree_skb</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>kfree_skb</refname>
 <refpurpose>
     free an sk_buff
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>kfree_skb </function></funcdef>
   <paramdef>struct sk_buff * <parameter>skb</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>skb</parameter></term>
   <listitem>
    <para>
     buffer to free
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Drop a reference to the buffer and free it if the usage count has
   hit zero.
</para>
</refsect1>
</refentry>

<refentry id="API-skb-tx-error">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>skb_tx_error</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>skb_tx_error</refname>
 <refpurpose>
     report an sk_buff xmit error
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>skb_tx_error </function></funcdef>
   <paramdef>struct sk_buff * <parameter>skb</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>skb</parameter></term>
   <listitem>
    <para>
     buffer that triggered an error
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Report xmit error if a device callback is tracking this skb.
   skb must be freed afterwards.
</para>
</refsect1>
</refentry>

<refentry id="API-consume-skb">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>consume_skb</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>consume_skb</refname>
 <refpurpose>
     free an skbuff
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>consume_skb </function></funcdef>
   <paramdef>struct sk_buff * <parameter>skb</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>skb</parameter></term>
   <listitem>
    <para>
     buffer to free
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Drop a ref to the buffer and free it if the usage count has hit zero
   Functions identically to kfree_skb, but kfree_skb assumes that the frame
   is being dropped after a failure and notes that
</para>
</refsect1>
</refentry>

<refentry id="API-skb-morph">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>skb_morph</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>skb_morph</refname>
 <refpurpose>
     morph one skb into another
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct sk_buff * <function>skb_morph </function></funcdef>
   <paramdef>struct sk_buff * <parameter>dst</parameter></paramdef>
   <paramdef>struct sk_buff * <parameter>src</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dst</parameter></term>
   <listitem>
    <para>
     the skb to receive the contents
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>src</parameter></term>
   <listitem>
    <para>
     the skb to supply the contents
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This is identical to skb_clone except that the target skb is
   supplied by the user.
   </para><para>

   The target skb is returned upon exit.
</para>
</refsect1>
</refentry>

<refentry id="API-skb-copy-ubufs">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>skb_copy_ubufs</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>skb_copy_ubufs</refname>
 <refpurpose>
     copy userspace skb frags buffers to kernel
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>skb_copy_ubufs </function></funcdef>
   <paramdef>struct sk_buff * <parameter>skb</parameter></paramdef>
   <paramdef>gfp_t <parameter>gfp_mask</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>skb</parameter></term>
   <listitem>
    <para>
     the skb to modify
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>gfp_mask</parameter></term>
   <listitem>
    <para>
     allocation priority
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This must be called on SKBTX_DEV_ZEROCOPY skb.
   It will copy all frags into kernel and drop the reference
   to userspace pages.
   </para><para>

   If this function is called from an interrupt <function>gfp_mask</function> must be
   <constant>GFP_ATOMIC</constant>.
   </para><para>

   Returns 0 on success or a negative error code on failure
   to allocate kernel memory to copy to.
</para>
</refsect1>
</refentry>

<refentry id="API-skb-clone">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>skb_clone</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>skb_clone</refname>
 <refpurpose>
     duplicate an sk_buff
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct sk_buff * <function>skb_clone </function></funcdef>
   <paramdef>struct sk_buff * <parameter>skb</parameter></paramdef>
   <paramdef>gfp_t <parameter>gfp_mask</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>skb</parameter></term>
   <listitem>
    <para>
     buffer to clone
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>gfp_mask</parameter></term>
   <listitem>
    <para>
     allocation priority
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Duplicate an <structname>sk_buff</structname>. The new one is not owned by a socket. Both
   copies share the same packet data but not structure. The new
   buffer has a reference count of 1. If the allocation fails the
   function returns <constant>NULL</constant> otherwise the new buffer is returned.
   </para><para>

   If this function is called from an interrupt <function>gfp_mask</function> must be
   <constant>GFP_ATOMIC</constant>.
</para>
</refsect1>
</refentry>

<refentry id="API-skb-copy">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>skb_copy</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>skb_copy</refname>
 <refpurpose>
     create private copy of an sk_buff
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct sk_buff * <function>skb_copy </function></funcdef>
   <paramdef>const struct sk_buff * <parameter>skb</parameter></paramdef>
   <paramdef>gfp_t <parameter>gfp_mask</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>skb</parameter></term>
   <listitem>
    <para>
     buffer to copy
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>gfp_mask</parameter></term>
   <listitem>
    <para>
     allocation priority
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Make a copy of both an <structname>sk_buff</structname> and its data. This is used when the
   caller wishes to modify the data and needs a private copy of the
   data to alter. Returns <constant>NULL</constant> on failure or the pointer to the buffer
   on success. The returned buffer has a reference count of 1.
   </para><para>

   As by-product this function converts non-linear <structname>sk_buff</structname> to linear
   one, so that <structname>sk_buff</structname> becomes completely private and caller is allowed
   to modify all the data of returned buffer. This means that this
   function is not recommended for use in circumstances when only
   header is going to be modified. Use <function>pskb_copy</function> instead.
</para>
</refsect1>
</refentry>

<refentry id="API---pskb-copy-fclone">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>__pskb_copy_fclone</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>__pskb_copy_fclone</refname>
 <refpurpose>
     create copy of an sk_buff with private head.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct sk_buff * <function>__pskb_copy_fclone </function></funcdef>
   <paramdef>struct sk_buff * <parameter>skb</parameter></paramdef>
   <paramdef>int <parameter>headroom</parameter></paramdef>
   <paramdef>gfp_t <parameter>gfp_mask</parameter></paramdef>
   <paramdef>bool <parameter>fclone</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>skb</parameter></term>
   <listitem>
    <para>
     buffer to copy
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>headroom</parameter></term>
   <listitem>
    <para>
     headroom of new skb
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>gfp_mask</parameter></term>
   <listitem>
    <para>
     allocation priority
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>fclone</parameter></term>
   <listitem>
    <para>
     if true allocate the copy of the skb from the fclone
     cache instead of the head cache; it is recommended to set this
     to true for the cases where the copy will likely be cloned
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Make a copy of both an <structname>sk_buff</structname> and part of its data, located
   in header. Fragmented data remain shared. This is used when
   the caller wishes to modify only header of <structname>sk_buff</structname> and needs
   private copy of the header to alter. Returns <constant>NULL</constant> on failure
   or the pointer to the buffer on success.
   The returned buffer has a reference count of 1.
</para>
</refsect1>
</refentry>

<refentry id="API-pskb-expand-head">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>pskb_expand_head</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>pskb_expand_head</refname>
 <refpurpose>
     reallocate header of <structname>sk_buff</structname>
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>pskb_expand_head </function></funcdef>
   <paramdef>struct sk_buff * <parameter>skb</parameter></paramdef>
   <paramdef>int <parameter>nhead</parameter></paramdef>
   <paramdef>int <parameter>ntail</parameter></paramdef>
   <paramdef>gfp_t <parameter>gfp_mask</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>skb</parameter></term>
   <listitem>
    <para>
     buffer to reallocate
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>nhead</parameter></term>
   <listitem>
    <para>
     room to add at head
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>ntail</parameter></term>
   <listitem>
    <para>
     room to add at tail
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>gfp_mask</parameter></term>
   <listitem>
    <para>
     allocation priority
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Expands (or creates identical copy, if <parameter>nhead</parameter> and <parameter>ntail</parameter> are zero)
   header of <parameter>skb</parameter>. <structname>sk_buff</structname> itself is not changed. <structname>sk_buff</structname> MUST have
   reference count of 1. Returns zero in the case of success or error,
   if expansion failed. In the last case, <structname>sk_buff</structname> is not changed.
   </para><para>

   All the pointers pointing into skb header may change and must be
   reloaded after call to this function.
</para>
</refsect1>
</refentry>

<refentry id="API-skb-copy-expand">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>skb_copy_expand</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>skb_copy_expand</refname>
 <refpurpose>
     copy and expand sk_buff
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct sk_buff * <function>skb_copy_expand </function></funcdef>
   <paramdef>const struct sk_buff * <parameter>skb</parameter></paramdef>
   <paramdef>int <parameter>newheadroom</parameter></paramdef>
   <paramdef>int <parameter>newtailroom</parameter></paramdef>
   <paramdef>gfp_t <parameter>gfp_mask</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>skb</parameter></term>
   <listitem>
    <para>
     buffer to copy
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>newheadroom</parameter></term>
   <listitem>
    <para>
     new free bytes at head
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>newtailroom</parameter></term>
   <listitem>
    <para>
     new free bytes at tail
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>gfp_mask</parameter></term>
   <listitem>
    <para>
     allocation priority
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Make a copy of both an <structname>sk_buff</structname> and its data and while doing so
   allocate additional space.
   </para><para>

   This is used when the caller wishes to modify the data and needs a
   private copy of the data to alter as well as more space for new fields.
   Returns <constant>NULL</constant> on failure or the pointer to the buffer
   on success. The returned buffer has a reference count of 1.
   </para><para>

   You must pass <constant>GFP_ATOMIC</constant> as the allocation priority if this function
   is called from an interrupt.
</para>
</refsect1>
</refentry>

<refentry id="API-skb-pad">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>skb_pad</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>skb_pad</refname>
 <refpurpose>
     zero pad the tail of an skb
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>skb_pad </function></funcdef>
   <paramdef>struct sk_buff * <parameter>skb</parameter></paramdef>
   <paramdef>int <parameter>pad</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>skb</parameter></term>
   <listitem>
    <para>
     buffer to pad
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>pad</parameter></term>
   <listitem>
    <para>
     space to pad
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Ensure that a buffer is followed by a padding area that is zero
   filled. Used by network drivers which may DMA or transfer data
   beyond the buffer end onto the wire.
   </para><para>

   May return error in out of memory cases. The skb is freed on error.
</para>
</refsect1>
</refentry>

<refentry id="API-pskb-put">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>pskb_put</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>pskb_put</refname>
 <refpurpose>
     add data to the tail of a potentially fragmented buffer
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>unsigned char * <function>pskb_put </function></funcdef>
   <paramdef>struct sk_buff * <parameter>skb</parameter></paramdef>
   <paramdef>struct sk_buff * <parameter>tail</parameter></paramdef>
   <paramdef>int <parameter>len</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>skb</parameter></term>
   <listitem>
    <para>
     start of the buffer to use
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>tail</parameter></term>
   <listitem>
    <para>
     tail fragment of the buffer to use
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>len</parameter></term>
   <listitem>
    <para>
     amount of data to add
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This function extends the used data area of the potentially
   fragmented buffer. <parameter>tail</parameter> must be the last fragment of <parameter>skb</parameter> -- or
   <parameter>skb</parameter> itself. If this would exceed the total buffer size the kernel
   will panic. A pointer to the first byte of the extra data is
   returned.
</para>
</refsect1>
</refentry>

<refentry id="API-skb-put">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>skb_put</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>skb_put</refname>
 <refpurpose>
     add data to a buffer
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>unsigned char * <function>skb_put </function></funcdef>
   <paramdef>struct sk_buff * <parameter>skb</parameter></paramdef>
   <paramdef>unsigned int <parameter>len</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>skb</parameter></term>
   <listitem>
    <para>
     buffer to use
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>len</parameter></term>
   <listitem>
    <para>
     amount of data to add
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This function extends the used data area of the buffer. If this would
   exceed the total buffer size the kernel will panic. A pointer to the
   first byte of the extra data is returned.
</para>
</refsect1>
</refentry>

<refentry id="API-skb-push">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>skb_push</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>skb_push</refname>
 <refpurpose>
     add data to the start of a buffer
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>unsigned char * <function>skb_push </function></funcdef>
   <paramdef>struct sk_buff * <parameter>skb</parameter></paramdef>
   <paramdef>unsigned int <parameter>len</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>skb</parameter></term>
   <listitem>
    <para>
     buffer to use
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>len</parameter></term>
   <listitem>
    <para>
     amount of data to add
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This function extends the used data area of the buffer at the buffer
   start. If this would exceed the total buffer headroom the kernel will
   panic. A pointer to the first byte of the extra data is returned.
</para>
</refsect1>
</refentry>

<refentry id="API-skb-pull">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>skb_pull</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>skb_pull</refname>
 <refpurpose>
     remove data from the start of a buffer
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>unsigned char * <function>skb_pull </function></funcdef>
   <paramdef>struct sk_buff * <parameter>skb</parameter></paramdef>
   <paramdef>unsigned int <parameter>len</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>skb</parameter></term>
   <listitem>
    <para>
     buffer to use
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>len</parameter></term>
   <listitem>
    <para>
     amount of data to remove
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This function removes data from the start of a buffer, returning
   the memory to the headroom. A pointer to the next data in the buffer
   is returned. Once the data has been pulled future pushes will overwrite
   the old data.
</para>
</refsect1>
</refentry>

<refentry id="API-skb-trim">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>skb_trim</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>skb_trim</refname>
 <refpurpose>
     remove end from a buffer
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>skb_trim </function></funcdef>
   <paramdef>struct sk_buff * <parameter>skb</parameter></paramdef>
   <paramdef>unsigned int <parameter>len</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>skb</parameter></term>
   <listitem>
    <para>
     buffer to alter
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>len</parameter></term>
   <listitem>
    <para>
     new length
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Cut the length of a buffer down by removing data from the tail. If
   the buffer is already under the length specified it is not modified.
   The skb must be linear.
</para>
</refsect1>
</refentry>

<refentry id="API---pskb-pull-tail">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>__pskb_pull_tail</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>__pskb_pull_tail</refname>
 <refpurpose>
     advance tail of skb header
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>unsigned char * <function>__pskb_pull_tail </function></funcdef>
   <paramdef>struct sk_buff * <parameter>skb</parameter></paramdef>
   <paramdef>int <parameter>delta</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>skb</parameter></term>
   <listitem>
    <para>
     buffer to reallocate
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>delta</parameter></term>
   <listitem>
    <para>
     number of bytes to advance tail
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   The function makes a sense only on a fragmented <structname>sk_buff</structname>,
   it expands header moving its tail forward and copying necessary
   data from fragmented part.
   </para><para>

   <structname>sk_buff</structname> MUST have reference count of 1.
   </para><para>

   Returns <constant>NULL</constant> (and <structname>sk_buff</structname> does not change) if pull failed
   or value of new tail of skb in the case of success.
   </para><para>

   All the pointers pointing into skb header may change and must be
   reloaded after call to this function.
</para>
</refsect1>
</refentry>

<refentry id="API-skb-copy-bits">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>skb_copy_bits</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>skb_copy_bits</refname>
 <refpurpose>
     copy bits from skb to kernel buffer
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>skb_copy_bits </function></funcdef>
   <paramdef>const struct sk_buff * <parameter>skb</parameter></paramdef>
   <paramdef>int <parameter>offset</parameter></paramdef>
   <paramdef>void * <parameter>to</parameter></paramdef>
   <paramdef>int <parameter>len</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>skb</parameter></term>
   <listitem>
    <para>
     source skb
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>offset</parameter></term>
   <listitem>
    <para>
     offset in source
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>to</parameter></term>
   <listitem>
    <para>
     destination buffer
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>len</parameter></term>
   <listitem>
    <para>
     number of bytes to copy
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Copy the specified number of bytes from the source skb to the
   destination buffer.
   </para><para>

   CAUTION ! :
   If its prototype is ever changed,
   check arch/{*}/net/{*}.S files,
   since it is called from BPF assembly code.
</para>
</refsect1>
</refentry>

<refentry id="API-skb-store-bits">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>skb_store_bits</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>skb_store_bits</refname>
 <refpurpose>
     store bits from kernel buffer to skb
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>skb_store_bits </function></funcdef>
   <paramdef>struct sk_buff * <parameter>skb</parameter></paramdef>
   <paramdef>int <parameter>offset</parameter></paramdef>
   <paramdef>const void * <parameter>from</parameter></paramdef>
   <paramdef>int <parameter>len</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>skb</parameter></term>
   <listitem>
    <para>
     destination buffer
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>offset</parameter></term>
   <listitem>
    <para>
     offset in destination
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>from</parameter></term>
   <listitem>
    <para>
     source buffer
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>len</parameter></term>
   <listitem>
    <para>
     number of bytes to copy
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Copy the specified number of bytes from the source buffer to the
   destination skb.  This function handles all the messy bits of
   traversing fragment lists and such.
</para>
</refsect1>
</refentry>

<refentry id="API-skb-zerocopy">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>skb_zerocopy</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>skb_zerocopy</refname>
 <refpurpose>
     Zero copy skb to skb
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>skb_zerocopy </function></funcdef>
   <paramdef>struct sk_buff * <parameter>to</parameter></paramdef>
   <paramdef>struct sk_buff * <parameter>from</parameter></paramdef>
   <paramdef>int <parameter>len</parameter></paramdef>
   <paramdef>int <parameter>hlen</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>to</parameter></term>
   <listitem>
    <para>
     destination buffer
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>from</parameter></term>
   <listitem>
    <para>
     source buffer
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>len</parameter></term>
   <listitem>
    <para>
     number of bytes to copy from source buffer
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>hlen</parameter></term>
   <listitem>
    <para>
     size of linear headroom in destination buffer
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Copies up to `len` bytes from `from` to `to` by creating references
   to the frags in the source buffer.
   </para><para>

   The `hlen` as calculated by <function>skb_zerocopy_headlen</function> specifies the
   headroom in the `to` buffer.
</para>
</refsect1>
<refsect1>
<title>0</title>
<para>
   everything is OK
   -ENOMEM: couldn't orphan frags of <parameter>from</parameter> due to lack of memory
   -EFAULT: <function>skb_copy_bits</function> found some problem with skb geometry
</para>
</refsect1>
</refentry>

<refentry id="API-skb-dequeue">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>skb_dequeue</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>skb_dequeue</refname>
 <refpurpose>
     remove from the head of the queue
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct sk_buff * <function>skb_dequeue </function></funcdef>
   <paramdef>struct sk_buff_head * <parameter>list</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>list</parameter></term>
   <listitem>
    <para>
     list to dequeue from
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Remove the head of the list. The list lock is taken so the function
   may be used safely with other locking list functions. The head item is
   returned or <constant>NULL</constant> if the list is empty.
</para>
</refsect1>
</refentry>

<refentry id="API-skb-dequeue-tail">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>skb_dequeue_tail</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>skb_dequeue_tail</refname>
 <refpurpose>
     remove from the tail of the queue
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct sk_buff * <function>skb_dequeue_tail </function></funcdef>
   <paramdef>struct sk_buff_head * <parameter>list</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>list</parameter></term>
   <listitem>
    <para>
     list to dequeue from
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Remove the tail of the list. The list lock is taken so the function
   may be used safely with other locking list functions. The tail item is
   returned or <constant>NULL</constant> if the list is empty.
</para>
</refsect1>
</refentry>

<refentry id="API-skb-queue-purge">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>skb_queue_purge</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>skb_queue_purge</refname>
 <refpurpose>
     empty a list
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>skb_queue_purge </function></funcdef>
   <paramdef>struct sk_buff_head * <parameter>list</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>list</parameter></term>
   <listitem>
    <para>
     list to empty
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Delete all buffers on an <structname>sk_buff</structname> list. Each buffer is removed from
   the list and one reference dropped. This function takes the list
   lock and is atomic with respect to other list locking functions.
</para>
</refsect1>
</refentry>

<refentry id="API-skb-queue-head">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>skb_queue_head</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>skb_queue_head</refname>
 <refpurpose>
     queue a buffer at the list head
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>skb_queue_head </function></funcdef>
   <paramdef>struct sk_buff_head * <parameter>list</parameter></paramdef>
   <paramdef>struct sk_buff * <parameter>newsk</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>list</parameter></term>
   <listitem>
    <para>
     list to use
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>newsk</parameter></term>
   <listitem>
    <para>
     buffer to queue
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Queue a buffer at the start of the list. This function takes the
   list lock and can be used safely with other locking <structname>sk_buff</structname> functions
   safely.
   </para><para>

   A buffer cannot be placed on two lists at the same time.
</para>
</refsect1>
</refentry>

<refentry id="API-skb-queue-tail">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>skb_queue_tail</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>skb_queue_tail</refname>
 <refpurpose>
     queue a buffer at the list tail
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>skb_queue_tail </function></funcdef>
   <paramdef>struct sk_buff_head * <parameter>list</parameter></paramdef>
   <paramdef>struct sk_buff * <parameter>newsk</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>list</parameter></term>
   <listitem>
    <para>
     list to use
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>newsk</parameter></term>
   <listitem>
    <para>
     buffer to queue
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Queue a buffer at the tail of the list. This function takes the
   list lock and can be used safely with other locking <structname>sk_buff</structname> functions
   safely.
   </para><para>

   A buffer cannot be placed on two lists at the same time.
</para>
</refsect1>
</refentry>

<refentry id="API-skb-unlink">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>skb_unlink</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>skb_unlink</refname>
 <refpurpose>
     remove a buffer from a list
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>skb_unlink </function></funcdef>
   <paramdef>struct sk_buff * <parameter>skb</parameter></paramdef>
   <paramdef>struct sk_buff_head * <parameter>list</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>skb</parameter></term>
   <listitem>
    <para>
     buffer to remove
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>list</parameter></term>
   <listitem>
    <para>
     list to use
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Remove a packet from a list. The list locks are taken and this
   function is atomic with respect to other list locked calls
   </para><para>

   You must know what list the SKB is on.
</para>
</refsect1>
</refentry>

<refentry id="API-skb-append">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>skb_append</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>skb_append</refname>
 <refpurpose>
     append a buffer
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>skb_append </function></funcdef>
   <paramdef>struct sk_buff * <parameter>old</parameter></paramdef>
   <paramdef>struct sk_buff * <parameter>newsk</parameter></paramdef>
   <paramdef>struct sk_buff_head * <parameter>list</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>old</parameter></term>
   <listitem>
    <para>
     buffer to insert after
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>newsk</parameter></term>
   <listitem>
    <para>
     buffer to insert
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>list</parameter></term>
   <listitem>
    <para>
     list to use
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Place a packet after a given packet in a list. The list locks are taken
   and this function is atomic with respect to other list locked calls.
   A buffer cannot be placed on two lists at the same time.
</para>
</refsect1>
</refentry>

<refentry id="API-skb-insert">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>skb_insert</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>skb_insert</refname>
 <refpurpose>
     insert a buffer
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>skb_insert </function></funcdef>
   <paramdef>struct sk_buff * <parameter>old</parameter></paramdef>
   <paramdef>struct sk_buff * <parameter>newsk</parameter></paramdef>
   <paramdef>struct sk_buff_head * <parameter>list</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>old</parameter></term>
   <listitem>
    <para>
     buffer to insert before
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>newsk</parameter></term>
   <listitem>
    <para>
     buffer to insert
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>list</parameter></term>
   <listitem>
    <para>
     list to use
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Place a packet before a given packet in a list. The list locks are
   taken and this function is atomic with respect to other list locked
   calls.
   </para><para>

   A buffer cannot be placed on two lists at the same time.
</para>
</refsect1>
</refentry>

<refentry id="API-skb-split">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>skb_split</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>skb_split</refname>
 <refpurpose>
     Split fragmented skb to two parts at length len.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>skb_split </function></funcdef>
   <paramdef>struct sk_buff * <parameter>skb</parameter></paramdef>
   <paramdef>struct sk_buff * <parameter>skb1</parameter></paramdef>
   <paramdef>const u32 <parameter>len</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>skb</parameter></term>
   <listitem>
    <para>
     the buffer to split
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>skb1</parameter></term>
   <listitem>
    <para>
     the buffer to receive the second part
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>len</parameter></term>
   <listitem>
    <para>
     new length for skb
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-skb-prepare-seq-read">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>skb_prepare_seq_read</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>skb_prepare_seq_read</refname>
 <refpurpose>
     Prepare a sequential read of skb data
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>skb_prepare_seq_read </function></funcdef>
   <paramdef>struct sk_buff * <parameter>skb</parameter></paramdef>
   <paramdef>unsigned int <parameter>from</parameter></paramdef>
   <paramdef>unsigned int <parameter>to</parameter></paramdef>
   <paramdef>struct skb_seq_state * <parameter>st</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>skb</parameter></term>
   <listitem>
    <para>
     the buffer to read
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>from</parameter></term>
   <listitem>
    <para>
     lower offset of data to be read
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>to</parameter></term>
   <listitem>
    <para>
     upper offset of data to be read
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>st</parameter></term>
   <listitem>
    <para>
     state variable
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Initializes the specified state variable. Must be called before
   invoking <function>skb_seq_read</function> for the first time.
</para>
</refsect1>
</refentry>

<refentry id="API-skb-seq-read">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>skb_seq_read</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>skb_seq_read</refname>
 <refpurpose>
     Sequentially read skb data
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>unsigned int <function>skb_seq_read </function></funcdef>
   <paramdef>unsigned int <parameter>consumed</parameter></paramdef>
   <paramdef>const u8 ** <parameter>data</parameter></paramdef>
   <paramdef>struct skb_seq_state * <parameter>st</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>consumed</parameter></term>
   <listitem>
    <para>
     number of bytes consumed by the caller so far
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>data</parameter></term>
   <listitem>
    <para>
     destination pointer for data to be returned
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>st</parameter></term>
   <listitem>
    <para>
     state variable
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Reads a block of skb data at <parameter>consumed</parameter> relative to the
   lower offset specified to <function>skb_prepare_seq_read</function>. Assigns
   the head of the data block to <parameter>data</parameter> and returns the length
   of the block or 0 if the end of the skb data or the upper
   offset has been reached.
   </para><para>

   The caller is not required to consume all of the data
   returned, i.e. <parameter>consumed</parameter> is typically set to the number
   of bytes already consumed and the next call to
   <function>skb_seq_read</function> will return the remaining part of the block.
</para>
</refsect1>
<refsect1>
<title>Note 1</title>
<para>
   The size of each block of data returned can be arbitrary,
   this limitation is the cost for zerocopy sequential
   reads of potentially non linear data.
</para>
</refsect1>
<refsect1>
<title>Note 2</title>
<para>
   Fragment lists within fragments are not implemented
   at the moment, state-&gt;root_skb could be replaced with
   a stack for this purpose.
</para>
</refsect1>
</refentry>

<refentry id="API-skb-abort-seq-read">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>skb_abort_seq_read</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>skb_abort_seq_read</refname>
 <refpurpose>
     Abort a sequential read of skb data
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>skb_abort_seq_read </function></funcdef>
   <paramdef>struct skb_seq_state * <parameter>st</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>st</parameter></term>
   <listitem>
    <para>
     state variable
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Must be called if <function>skb_seq_read</function> was not called until it
   returned 0.
</para>
</refsect1>
</refentry>

<refentry id="API-skb-find-text">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>skb_find_text</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>skb_find_text</refname>
 <refpurpose>
     Find a text pattern in skb data
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>unsigned int <function>skb_find_text </function></funcdef>
   <paramdef>struct sk_buff * <parameter>skb</parameter></paramdef>
   <paramdef>unsigned int <parameter>from</parameter></paramdef>
   <paramdef>unsigned int <parameter>to</parameter></paramdef>
   <paramdef>struct ts_config * <parameter>config</parameter></paramdef>
   <paramdef>struct ts_state * <parameter>state</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>skb</parameter></term>
   <listitem>
    <para>
     the buffer to look in
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>from</parameter></term>
   <listitem>
    <para>
     search offset
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>to</parameter></term>
   <listitem>
    <para>
     search limit
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>config</parameter></term>
   <listitem>
    <para>
     textsearch configuration
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>state</parameter></term>
   <listitem>
    <para>
     uninitialized textsearch state variable
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Finds a pattern in the skb data according to the specified
   textsearch configuration. Use <function>textsearch_next</function> to retrieve
   subsequent occurrences of the pattern. Returns the offset
   to the first occurrence or UINT_MAX if no match was found.
</para>
</refsect1>
</refentry>

<refentry id="API-skb-append-datato-frags">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>skb_append_datato_frags</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>skb_append_datato_frags</refname>
 <refpurpose>
     append the user data to a skb
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>skb_append_datato_frags </function></funcdef>
   <paramdef>struct sock * <parameter>sk</parameter></paramdef>
   <paramdef>struct sk_buff * <parameter>skb</parameter></paramdef>
   <paramdef>int (*<parameter>getfrag</parameter>)
     <funcparams>void *from, char *to, int offset, 					int len, int odd, struct sk_buff *skb</funcparams></paramdef>
   <paramdef>void * <parameter>from</parameter></paramdef>
   <paramdef>int <parameter>length</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>sk</parameter></term>
   <listitem>
    <para>
     sock  structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>skb</parameter></term>
   <listitem>
    <para>
     skb structure to be appended with user data.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>getfrag</parameter></term>
   <listitem>
    <para>
     call back function to be used for getting the user data
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>from</parameter></term>
   <listitem>
    <para>
     pointer to user message iov
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>length</parameter></term>
   <listitem>
    <para>
     length of the iov message
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This procedure append the user data in the fragment part
   of the skb if any page alloc fails user this procedure returns  -ENOMEM
</para>
</refsect1>
</refentry>

<refentry id="API-skb-pull-rcsum">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>skb_pull_rcsum</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>skb_pull_rcsum</refname>
 <refpurpose>
     pull skb and update receive checksum
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>unsigned char * <function>skb_pull_rcsum </function></funcdef>
   <paramdef>struct sk_buff * <parameter>skb</parameter></paramdef>
   <paramdef>unsigned int <parameter>len</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>skb</parameter></term>
   <listitem>
    <para>
     buffer to update
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>len</parameter></term>
   <listitem>
    <para>
     length of data pulled
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This function performs an skb_pull on the packet and updates
   the CHECKSUM_COMPLETE checksum.  It should be used on
   receive path processing instead of skb_pull unless you know
   that the checksum difference is zero (e.g., a valid IP header)
   or you are setting ip_summed to CHECKSUM_NONE.
</para>
</refsect1>
</refentry>

<refentry id="API-skb-segment">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>skb_segment</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>skb_segment</refname>
 <refpurpose>
     Perform protocol segmentation on skb.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct sk_buff * <function>skb_segment </function></funcdef>
   <paramdef>struct sk_buff * <parameter>head_skb</parameter></paramdef>
   <paramdef>netdev_features_t <parameter>features</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>head_skb</parameter></term>
   <listitem>
    <para>
     buffer to segment
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>features</parameter></term>
   <listitem>
    <para>
     features for the output path (see dev-&gt;features)
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This function performs segmentation on the given skb.  It returns
   a pointer to the first in a list of new skbs for the segments.
   In case of error it returns ERR_PTR(err).
</para>
</refsect1>
</refentry>

<refentry id="API-skb-to-sgvec">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>skb_to_sgvec</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>skb_to_sgvec</refname>
 <refpurpose>
     Fill a scatter-gather list from a socket buffer
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>skb_to_sgvec </function></funcdef>
   <paramdef>struct sk_buff * <parameter>skb</parameter></paramdef>
   <paramdef>struct scatterlist * <parameter>sg</parameter></paramdef>
   <paramdef>int <parameter>offset</parameter></paramdef>
   <paramdef>int <parameter>len</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>skb</parameter></term>
   <listitem>
    <para>
     Socket buffer containing the buffers to be mapped
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>sg</parameter></term>
   <listitem>
    <para>
     The scatter-gather list to map into
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>offset</parameter></term>
   <listitem>
    <para>
     The offset into the buffer's contents to start mapping
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>len</parameter></term>
   <listitem>
    <para>
     Length of buffer space to be mapped
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Fill the specified scatter-gather list with mappings/pointers into a
   region of the buffer space attached to a socket buffer. Returns either
   the number of scatterlist items used, or -EMSGSIZE if the contents
   could not fit.
</para>
</refsect1>
</refentry>

<refentry id="API-skb-cow-data">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>skb_cow_data</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>skb_cow_data</refname>
 <refpurpose>
     Check that a socket buffer's data buffers are writable
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>skb_cow_data </function></funcdef>
   <paramdef>struct sk_buff * <parameter>skb</parameter></paramdef>
   <paramdef>int <parameter>tailbits</parameter></paramdef>
   <paramdef>struct sk_buff ** <parameter>trailer</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>skb</parameter></term>
   <listitem>
    <para>
     The socket buffer to check.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>tailbits</parameter></term>
   <listitem>
    <para>
     Amount of trailing space to be added
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>trailer</parameter></term>
   <listitem>
    <para>
     Returned pointer to the skb where the <parameter>tailbits</parameter> space begins
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Make sure that the data buffers attached to a socket buffer are
   writable. If they are not, private copies are made of the data buffers
   and the socket buffer is set to use these instead.
   </para><para>

   If <parameter>tailbits</parameter> is given, make sure that there is space to write <parameter>tailbits</parameter>
   bytes of data beyond current end of socket buffer.  <parameter>trailer</parameter> will be
   set to point to the skb in which this space begins.
   </para><para>

   The number of scatterlist elements required to completely map the
   COW'd and extended socket buffer will be returned.
</para>
</refsect1>
</refentry>

<refentry id="API-skb-clone-sk">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>skb_clone_sk</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>skb_clone_sk</refname>
 <refpurpose>
     create clone of skb, and take reference to socket
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct sk_buff * <function>skb_clone_sk </function></funcdef>
   <paramdef>struct sk_buff * <parameter>skb</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>skb</parameter></term>
   <listitem>
    <para>
     the skb to clone
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This function creates a clone of a buffer that holds a reference on
   sk_refcnt.  Buffers created via this function are meant to be
   returned using sock_queue_err_skb, or free via kfree_skb.
   </para><para>

   When passing buffers allocated with this function to sock_queue_err_skb
   it is necessary to wrap the call with sock_hold/sock_put in order to
   prevent the socket from being released prior to being enqueued on
   the sk_error_queue.
</para>
</refsect1>
</refentry>

<refentry id="API-skb-partial-csum-set">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>skb_partial_csum_set</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>skb_partial_csum_set</refname>
 <refpurpose>
     set up and verify partial csum values for packet
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>bool <function>skb_partial_csum_set </function></funcdef>
   <paramdef>struct sk_buff * <parameter>skb</parameter></paramdef>
   <paramdef>u16 <parameter>start</parameter></paramdef>
   <paramdef>u16 <parameter>off</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>skb</parameter></term>
   <listitem>
    <para>
     the skb to set
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>start</parameter></term>
   <listitem>
    <para>
     the number of bytes after skb-&gt;data to start checksumming.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>off</parameter></term>
   <listitem>
    <para>
     the offset from start to place the checksum.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   For untrusted partially-checksummed packets, we need to make sure the values
   for skb-&gt;csum_start and skb-&gt;csum_offset are valid so we don't oops.
   </para><para>

   This function checks and sets those values and skb-&gt;ip_summed: if this
   returns false you should drop the packet.
</para>
</refsect1>
</refentry>

<refentry id="API-skb-checksum-setup">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>skb_checksum_setup</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>skb_checksum_setup</refname>
 <refpurpose>
     set up partial checksum offset
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>skb_checksum_setup </function></funcdef>
   <paramdef>struct sk_buff * <parameter>skb</parameter></paramdef>
   <paramdef>bool <parameter>recalculate</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>skb</parameter></term>
   <listitem>
    <para>
     the skb to set up
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>recalculate</parameter></term>
   <listitem>
    <para>
     if true the pseudo-header checksum will be recalculated
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-skb-try-coalesce">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>skb_try_coalesce</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>skb_try_coalesce</refname>
 <refpurpose>
     try to merge skb to prior one
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>bool <function>skb_try_coalesce </function></funcdef>
   <paramdef>struct sk_buff * <parameter>to</parameter></paramdef>
   <paramdef>struct sk_buff * <parameter>from</parameter></paramdef>
   <paramdef>bool * <parameter>fragstolen</parameter></paramdef>
   <paramdef>int * <parameter>delta_truesize</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>to</parameter></term>
   <listitem>
    <para>
     prior buffer
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>from</parameter></term>
   <listitem>
    <para>
     buffer to add
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>fragstolen</parameter></term>
   <listitem>
    <para>
     pointer to boolean
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>delta_truesize</parameter></term>
   <listitem>
    <para>
     how much more was allocated than was requested
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-skb-scrub-packet">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>skb_scrub_packet</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>skb_scrub_packet</refname>
 <refpurpose>
     scrub an skb
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>skb_scrub_packet </function></funcdef>
   <paramdef>struct sk_buff * <parameter>skb</parameter></paramdef>
   <paramdef>bool <parameter>xnet</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>skb</parameter></term>
   <listitem>
    <para>
     buffer to clean
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>xnet</parameter></term>
   <listitem>
    <para>
     packet is crossing netns
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   skb_scrub_packet can be used after encapsulating or decapsulting a packet
   into/from a tunnel. Some information have to be cleared during these
   operations.
   skb_scrub_packet can also be used to clean a skb before injecting it in
   another namespace (<parameter>xnet</parameter> == true). We have to clear all information in the
   skb that could impact namespace isolation.
</para>
</refsect1>
</refentry>

<refentry id="API-skb-gso-transport-seglen">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>skb_gso_transport_seglen</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>skb_gso_transport_seglen</refname>
 <refpurpose>
     Return length of individual segments of a gso packet
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>unsigned int <function>skb_gso_transport_seglen </function></funcdef>
   <paramdef>const struct sk_buff * <parameter>skb</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>skb</parameter></term>
   <listitem>
    <para>
     GSO skb
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   skb_gso_transport_seglen is used to determine the real size of the
   individual segments, including Layer4 headers (TCP/UDP).
   </para><para>

   The MAC/L2 or network (IP, IPv6) headers are not accounted for.
</para>
</refsect1>
</refentry>

<refentry id="API-alloc-skb-with-frags">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>alloc_skb_with_frags</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>alloc_skb_with_frags</refname>
 <refpurpose>
     allocate skb with page frags
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct sk_buff * <function>alloc_skb_with_frags </function></funcdef>
   <paramdef>unsigned long <parameter>header_len</parameter></paramdef>
   <paramdef>unsigned long <parameter>data_len</parameter></paramdef>
   <paramdef>int <parameter>max_page_order</parameter></paramdef>
   <paramdef>int * <parameter>errcode</parameter></paramdef>
   <paramdef>gfp_t <parameter>gfp_mask</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>header_len</parameter></term>
   <listitem>
    <para>
     size of linear part
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>data_len</parameter></term>
   <listitem>
    <para>
     needed length in frags
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>max_page_order</parameter></term>
   <listitem>
    <para>
     max page order desired.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>errcode</parameter></term>
   <listitem>
    <para>
     pointer to error code if any
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>gfp_mask</parameter></term>
   <listitem>
    <para>
     allocation mask
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This can be used to allocate a paged skb, given a maximal order for frags.
</para>
</refsect1>
</refentry>

<!-- net/core/sock.c -->
<refentry id="API-sk-ns-capable">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>sk_ns_capable</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>sk_ns_capable</refname>
 <refpurpose>
  General socket capability test
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>bool <function>sk_ns_capable </function></funcdef>
   <paramdef>const struct sock * <parameter>sk</parameter></paramdef>
   <paramdef>struct user_namespace * <parameter>user_ns</parameter></paramdef>
   <paramdef>int <parameter>cap</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>sk</parameter></term>
   <listitem>
    <para>
     Socket to use a capability on or through
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>user_ns</parameter></term>
   <listitem>
    <para>
     The user namespace of the capability to use
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>cap</parameter></term>
   <listitem>
    <para>
     The capability to use
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Test to see if the opener of the socket had when the socket was
   created and the current process has the capability <parameter>cap</parameter> in the user
   namespace <parameter>user_ns</parameter>.
</para>
</refsect1>
</refentry>

<refentry id="API-sk-capable">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>sk_capable</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>sk_capable</refname>
 <refpurpose>
     Socket global capability test
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>bool <function>sk_capable </function></funcdef>
   <paramdef>const struct sock * <parameter>sk</parameter></paramdef>
   <paramdef>int <parameter>cap</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>sk</parameter></term>
   <listitem>
    <para>
     Socket to use a capability on or through
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>cap</parameter></term>
   <listitem>
    <para>
     The global capability to use
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Test to see if the opener of the socket had when the socket was
   created and the current process has the capability <parameter>cap</parameter> in all user
   namespaces.
</para>
</refsect1>
</refentry>

<refentry id="API-sk-net-capable">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>sk_net_capable</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>sk_net_capable</refname>
 <refpurpose>
     Network namespace socket capability test
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>bool <function>sk_net_capable </function></funcdef>
   <paramdef>const struct sock * <parameter>sk</parameter></paramdef>
   <paramdef>int <parameter>cap</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>sk</parameter></term>
   <listitem>
    <para>
     Socket to use a capability on or through
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>cap</parameter></term>
   <listitem>
    <para>
     The capability to use
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Test to see if the opener of the socket had when the socket was created
   and the current process has the capability <parameter>cap</parameter> over the network namespace
   the socket is a member of.
</para>
</refsect1>
</refentry>

<refentry id="API-sk-set-memalloc">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>sk_set_memalloc</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>sk_set_memalloc</refname>
 <refpurpose>
     sets <constant>SOCK_MEMALLOC</constant>
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>sk_set_memalloc </function></funcdef>
   <paramdef>struct sock * <parameter>sk</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>sk</parameter></term>
   <listitem>
    <para>
     socket to set it on
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Set <constant>SOCK_MEMALLOC</constant> on a socket for access to emergency reserves.
   It's the responsibility of the admin to adjust min_free_kbytes
   to meet the requirements
</para>
</refsect1>
</refentry>

<refentry id="API-sk-alloc">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>sk_alloc</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>sk_alloc</refname>
 <refpurpose>
     All socket objects are allocated here
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct sock * <function>sk_alloc </function></funcdef>
   <paramdef>struct net * <parameter>net</parameter></paramdef>
   <paramdef>int <parameter>family</parameter></paramdef>
   <paramdef>gfp_t <parameter>priority</parameter></paramdef>
   <paramdef>struct proto * <parameter>prot</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>net</parameter></term>
   <listitem>
    <para>
     the applicable net namespace
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>family</parameter></term>
   <listitem>
    <para>
     protocol family
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>priority</parameter></term>
   <listitem>
    <para>
     for allocation (<constant>GFP_KERNEL</constant>, <constant>GFP_ATOMIC</constant>, etc)
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>prot</parameter></term>
   <listitem>
    <para>
     struct proto associated with this new sock instance
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-sk-clone-lock">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>sk_clone_lock</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>sk_clone_lock</refname>
 <refpurpose>
     clone a socket, and lock its clone
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct sock * <function>sk_clone_lock </function></funcdef>
   <paramdef>const struct sock * <parameter>sk</parameter></paramdef>
   <paramdef>const gfp_t <parameter>priority</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>sk</parameter></term>
   <listitem>
    <para>
     the socket to clone
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>priority</parameter></term>
   <listitem>
    <para>
     for allocation (<constant>GFP_KERNEL</constant>, <constant>GFP_ATOMIC</constant>, etc)
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Caller must unlock socket even in error path (bh_unlock_sock(newsk))
</para>
</refsect1>
</refentry>

<refentry id="API-skb-page-frag-refill">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>skb_page_frag_refill</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>skb_page_frag_refill</refname>
 <refpurpose>
     check that a page_frag contains enough room
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>bool <function>skb_page_frag_refill </function></funcdef>
   <paramdef>unsigned int <parameter>sz</parameter></paramdef>
   <paramdef>struct page_frag * <parameter>pfrag</parameter></paramdef>
   <paramdef>gfp_t <parameter>gfp</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>sz</parameter></term>
   <listitem>
    <para>
     minimum size of the fragment we want to get
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>pfrag</parameter></term>
   <listitem>
    <para>
     pointer to page_frag
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>gfp</parameter></term>
   <listitem>
    <para>
     priority for memory allocation
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Note</title>
<para>
   While this allocator tries to use high order pages, there is
   no guarantee that allocations succeed. Therefore, <parameter>sz</parameter> MUST be
   less or equal than PAGE_SIZE.
</para>
</refsect1>
</refentry>

<refentry id="API-sk-wait-data">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>sk_wait_data</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>sk_wait_data</refname>
 <refpurpose>
     wait for data to arrive at sk_receive_queue
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>sk_wait_data </function></funcdef>
   <paramdef>struct sock * <parameter>sk</parameter></paramdef>
   <paramdef>long * <parameter>timeo</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>sk</parameter></term>
   <listitem>
    <para>
     sock to wait on
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>timeo</parameter></term>
   <listitem>
    <para>
     for how long
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Now socket state including sk-&gt;sk_err is changed only under lock,
   hence we may omit checks after joining wait queue.
   We check receive queue before <function>schedule</function> only as optimization;
   it is very likely that <function>release_sock</function> added new data.
</para>
</refsect1>
</refentry>

<refentry id="API---sk-mem-schedule">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>__sk_mem_schedule</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>__sk_mem_schedule</refname>
 <refpurpose>
     increase sk_forward_alloc and memory_allocated
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>__sk_mem_schedule </function></funcdef>
   <paramdef>struct sock * <parameter>sk</parameter></paramdef>
   <paramdef>int <parameter>size</parameter></paramdef>
   <paramdef>int <parameter>kind</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>sk</parameter></term>
   <listitem>
    <para>
     socket
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>size</parameter></term>
   <listitem>
    <para>
     memory size to allocate
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>kind</parameter></term>
   <listitem>
    <para>
     allocation type
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   If kind is SK_MEM_SEND, it means wmem allocation. Otherwise it means
   rmem allocation. This function assumes that protocols which have
   memory_pressure use sk_wmem_queued as write buffer accounting.
</para>
</refsect1>
</refentry>

<refentry id="API---sk-mem-reclaim">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>__sk_mem_reclaim</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>__sk_mem_reclaim</refname>
 <refpurpose>
     reclaim memory_allocated
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>__sk_mem_reclaim </function></funcdef>
   <paramdef>struct sock * <parameter>sk</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>sk</parameter></term>
   <listitem>
    <para>
     socket
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-lock-sock-fast">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>lock_sock_fast</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>lock_sock_fast</refname>
 <refpurpose>
     fast version of lock_sock
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>bool <function>lock_sock_fast </function></funcdef>
   <paramdef>struct sock * <parameter>sk</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>sk</parameter></term>
   <listitem>
    <para>
     socket
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This version should be used for very small section, where process wont block
   return false if fast path is taken
   sk_lock.slock locked, owned = 0, BH disabled
   return true if slow path is taken
   sk_lock.slock unlocked, owned = 1, BH enabled
</para>
</refsect1>
</refentry>

<!-- net/core/datagram.c -->
<refentry id="API---skb-recv-datagram">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>__skb_recv_datagram</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>__skb_recv_datagram</refname>
 <refpurpose>
  Receive a datagram skbuff
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct sk_buff * <function>__skb_recv_datagram </function></funcdef>
   <paramdef>struct sock * <parameter>sk</parameter></paramdef>
   <paramdef>unsigned int <parameter>flags</parameter></paramdef>
   <paramdef>int * <parameter>peeked</parameter></paramdef>
   <paramdef>int * <parameter>off</parameter></paramdef>
   <paramdef>int * <parameter>err</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>sk</parameter></term>
   <listitem>
    <para>
     socket
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>flags</parameter></term>
   <listitem>
    <para>
     MSG_ flags
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>peeked</parameter></term>
   <listitem>
    <para>
     returns non-zero if this packet has been seen before
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>off</parameter></term>
   <listitem>
    <para>
     an offset in bytes to peek skb from. Returns an offset
     within an skb where data actually starts
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>err</parameter></term>
   <listitem>
    <para>
     error code returned
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Get a datagram skbuff, understands the peeking, nonblocking wakeups
   and possible races. This replaces identical code in packet, raw and
   udp, as well as the IPX AX.25 and Appletalk. It also finally fixes
   the long standing peek and read race for datagram sockets. If you
   alter this routine remember it must be re-entrant.
   </para><para>

   This function will lock the socket if a skb is returned, so the caller
   needs to unlock the socket in that case (usually by calling
   skb_free_datagram)
   </para><para>

   * It does not lock socket since today. This function is
   * free of race conditions. This measure should/can improve
   * significantly datagram socket latencies at high loads,
   * when data copying to user space takes lots of time.
   * (BTW I've just killed the last <function>cli</function> in IP/IPv6/core/netlink/packet
   *  8) Great win.)
   *			                    --ANK (980729)
   </para><para>

   The order of the tests when we find no data waiting are specified
   quite explicitly by POSIX 1003.1g, don't change them without having
   the standard around please.
</para>
</refsect1>
</refentry>

<refentry id="API-skb-kill-datagram">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>skb_kill_datagram</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>skb_kill_datagram</refname>
 <refpurpose>
     Free a datagram skbuff forcibly
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>skb_kill_datagram </function></funcdef>
   <paramdef>struct sock * <parameter>sk</parameter></paramdef>
   <paramdef>struct sk_buff * <parameter>skb</parameter></paramdef>
   <paramdef>unsigned int <parameter>flags</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>sk</parameter></term>
   <listitem>
    <para>
     socket
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>skb</parameter></term>
   <listitem>
    <para>
     datagram skbuff
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>flags</parameter></term>
   <listitem>
    <para>
     MSG_ flags
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This function frees a datagram skbuff that was received by
   skb_recv_datagram.  The flags argument must match the one
   used for skb_recv_datagram.
   </para><para>

   If the MSG_PEEK flag is set, and the packet is still on the
   receive queue of the socket, it will be taken off the queue
   before it is freed.
   </para><para>

   This function currently only disables BH when acquiring the
   sk_receive_queue lock.  Therefore it must not be used in a
   context where that lock is acquired in an IRQ context.
   </para><para>

   It returns 0 if the packet was removed by us.
</para>
</refsect1>
</refentry>

<refentry id="API-skb-copy-datagram-iovec">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>skb_copy_datagram_iovec</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>skb_copy_datagram_iovec</refname>
 <refpurpose>
     Copy a datagram to an iovec.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>skb_copy_datagram_iovec </function></funcdef>
   <paramdef>const struct sk_buff * <parameter>skb</parameter></paramdef>
   <paramdef>int <parameter>offset</parameter></paramdef>
   <paramdef>struct iovec * <parameter>to</parameter></paramdef>
   <paramdef>int <parameter>len</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>skb</parameter></term>
   <listitem>
    <para>
     buffer to copy
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>offset</parameter></term>
   <listitem>
    <para>
     offset in the buffer to start copying from
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>to</parameter></term>
   <listitem>
    <para>
     io vector to copy to
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>len</parameter></term>
   <listitem>
    <para>
     amount of data to copy from buffer to iovec
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Note</title>
<para>
   the iovec is modified during the copy.
</para>
</refsect1>
</refentry>

<refentry id="API-skb-copy-datagram-const-iovec">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>skb_copy_datagram_const_iovec</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>skb_copy_datagram_const_iovec</refname>
 <refpurpose>
     Copy a datagram to an iovec.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>skb_copy_datagram_const_iovec </function></funcdef>
   <paramdef>const struct sk_buff * <parameter>skb</parameter></paramdef>
   <paramdef>int <parameter>offset</parameter></paramdef>
   <paramdef>const struct iovec * <parameter>to</parameter></paramdef>
   <paramdef>int <parameter>to_offset</parameter></paramdef>
   <paramdef>int <parameter>len</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>skb</parameter></term>
   <listitem>
    <para>
     buffer to copy
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>offset</parameter></term>
   <listitem>
    <para>
     offset in the buffer to start copying from
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>to</parameter></term>
   <listitem>
    <para>
     io vector to copy to
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>to_offset</parameter></term>
   <listitem>
    <para>
     offset in the io vector to start copying to
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>len</parameter></term>
   <listitem>
    <para>
     amount of data to copy from buffer to iovec
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Returns 0 or -EFAULT.
</para>
</refsect1>
<refsect1>
<title>Note</title>
<para>
   the iovec is not modified during the copy.
</para>
</refsect1>
</refentry>

<refentry id="API-skb-copy-datagram-from-iovec">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>skb_copy_datagram_from_iovec</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>skb_copy_datagram_from_iovec</refname>
 <refpurpose>
     Copy a datagram from an iovec.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>skb_copy_datagram_from_iovec </function></funcdef>
   <paramdef>struct sk_buff * <parameter>skb</parameter></paramdef>
   <paramdef>int <parameter>offset</parameter></paramdef>
   <paramdef>const struct iovec * <parameter>from</parameter></paramdef>
   <paramdef>int <parameter>from_offset</parameter></paramdef>
   <paramdef>int <parameter>len</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>skb</parameter></term>
   <listitem>
    <para>
     buffer to copy
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>offset</parameter></term>
   <listitem>
    <para>
     offset in the buffer to start copying to
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>from</parameter></term>
   <listitem>
    <para>
     io vector to copy to
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>from_offset</parameter></term>
   <listitem>
    <para>
     offset in the io vector to start copying from
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>len</parameter></term>
   <listitem>
    <para>
     amount of data to copy to buffer from iovec
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Returns 0 or -EFAULT.
</para>
</refsect1>
<refsect1>
<title>Note</title>
<para>
   the iovec is not modified during the copy.
</para>
</refsect1>
</refentry>

<refentry id="API-zerocopy-sg-from-iovec">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>zerocopy_sg_from_iovec</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>zerocopy_sg_from_iovec</refname>
 <refpurpose>
     Build a zerocopy datagram from an iovec
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>zerocopy_sg_from_iovec </function></funcdef>
   <paramdef>struct sk_buff * <parameter>skb</parameter></paramdef>
   <paramdef>const struct iovec * <parameter>from</parameter></paramdef>
   <paramdef>int <parameter>offset</parameter></paramdef>
   <paramdef>size_t <parameter>count</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>skb</parameter></term>
   <listitem>
    <para>
     buffer to copy
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>from</parameter></term>
   <listitem>
    <para>
     io vector to copy from
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>offset</parameter></term>
   <listitem>
    <para>
     offset in the io vector to start copying from
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>count</parameter></term>
   <listitem>
    <para>
     amount of vectors to copy to buffer from
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   The function will first copy up to headlen, and then pin the userspace
   pages and build frags through them.
   </para><para>

   Returns 0, -EFAULT or -EMSGSIZE.
</para>
</refsect1>
<refsect1>
<title>Note</title>
<para>
   the iovec is not modified during the copy
</para>
</refsect1>
</refentry>

<refentry id="API-skb-copy-and-csum-datagram-iovec">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>skb_copy_and_csum_datagram_iovec</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>skb_copy_and_csum_datagram_iovec</refname>
 <refpurpose>
     Copy and checksum skb to user iovec.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>skb_copy_and_csum_datagram_iovec </function></funcdef>
   <paramdef>struct sk_buff * <parameter>skb</parameter></paramdef>
   <paramdef>int <parameter>hlen</parameter></paramdef>
   <paramdef>struct iovec * <parameter>iov</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>skb</parameter></term>
   <listitem>
    <para>
     skbuff
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>hlen</parameter></term>
   <listitem>
    <para>
     hardware length
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>iov</parameter></term>
   <listitem>
    <para>
     io vector
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Caller _must_ check that skb will fit to this iovec.
</para>
</refsect1>
<refsect1>
<title>Returns</title>
<para>
   0       - success.
   -EINVAL - checksum failure.
   -EFAULT - fault during copy. Beware, in this case iovec
   can be modified!
</para>
</refsect1>
</refentry>

<refentry id="API-datagram-poll">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>datagram_poll</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>datagram_poll</refname>
 <refpurpose>
     generic datagram poll
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>unsigned int <function>datagram_poll </function></funcdef>
   <paramdef>struct file * <parameter>file</parameter></paramdef>
   <paramdef>struct socket * <parameter>sock</parameter></paramdef>
   <paramdef>poll_table * <parameter>wait</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>file</parameter></term>
   <listitem>
    <para>
     file struct
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>sock</parameter></term>
   <listitem>
    <para>
     socket
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>wait</parameter></term>
   <listitem>
    <para>
     poll table
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Datagram poll</title>
<para>
   Again totally generic. This also handles
   sequenced packet sockets providing the socket receive queue
   is only ever holding data ready to receive.
</para>
</refsect1>
<refsect1>
<title>Note</title>
<para>
   when you _don't_ use this routine for this protocol,
   and you use a different write policy from <function>sock_writeable</function>
   then please supply your own write_space callback.
</para>
</refsect1>
</refentry>

<!-- net/core/stream.c -->
<refentry id="API-sk-stream-write-space">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>sk_stream_write_space</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>sk_stream_write_space</refname>
 <refpurpose>
  stream socket write_space callback.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>sk_stream_write_space </function></funcdef>
   <paramdef>struct sock * <parameter>sk</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>sk</parameter></term>
   <listitem>
    <para>
     socket
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>FIXME</title>
<para>
   write proper description
</para>
</refsect1>
</refentry>

<refentry id="API-sk-stream-wait-connect">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>sk_stream_wait_connect</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>sk_stream_wait_connect</refname>
 <refpurpose>
     Wait for a socket to get into the connected state
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>sk_stream_wait_connect </function></funcdef>
   <paramdef>struct sock * <parameter>sk</parameter></paramdef>
   <paramdef>long * <parameter>timeo_p</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>sk</parameter></term>
   <listitem>
    <para>
     sock to wait on
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>timeo_p</parameter></term>
   <listitem>
    <para>
     for how long to wait
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Must be called with the socket locked.
</para>
</refsect1>
</refentry>

<refentry id="API-sk-stream-wait-memory">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>sk_stream_wait_memory</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>sk_stream_wait_memory</refname>
 <refpurpose>
     Wait for more memory for a socket
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>sk_stream_wait_memory </function></funcdef>
   <paramdef>struct sock * <parameter>sk</parameter></paramdef>
   <paramdef>long * <parameter>timeo_p</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>sk</parameter></term>
   <listitem>
    <para>
     socket to wait for memory
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>timeo_p</parameter></term>
   <listitem>
    <para>
     for how long
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

     </sect1>
     <sect1><title>Socket Filter</title>
<!-- net/core/filter.c -->
<refentry id="API-sk-filter">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>sk_filter</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>sk_filter</refname>
 <refpurpose>
  run a packet through a socket filter
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>sk_filter </function></funcdef>
   <paramdef>struct sock * <parameter>sk</parameter></paramdef>
   <paramdef>struct sk_buff * <parameter>skb</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>sk</parameter></term>
   <listitem>
    <para>
     sock associated with <structname>sk_buff</structname>
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>skb</parameter></term>
   <listitem>
    <para>
     buffer to filter
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Run the filter code and then cut skb-&gt;data to correct size returned by
   SK_RUN_FILTER. If pkt_len is 0 we toss packet. If skb-&gt;len is smaller
   than pkt_len we keep whole skb-&gt;data. This is the socket level
   wrapper to SK_RUN_FILTER. It returns 0 if the packet should
   be accepted or -EPERM if the packet should be tossed.
</para>
</refsect1>
</refentry>

<refentry id="API-bpf-check-classic">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>bpf_check_classic</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>bpf_check_classic</refname>
 <refpurpose>
     verify socket filter code
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>bpf_check_classic </function></funcdef>
   <paramdef>const struct sock_filter * <parameter>filter</parameter></paramdef>
   <paramdef>unsigned int <parameter>flen</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>filter</parameter></term>
   <listitem>
    <para>
     filter to verify
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>flen</parameter></term>
   <listitem>
    <para>
     length of filter
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Check the user's filter code. If we let some ugly
   filter code slip through kaboom! The filter must contain
   no references or jumps that are out of range, no illegal
   instructions, and must end with a RET instruction.
   </para><para>

   All jumps are forward as they are not signed.
   </para><para>

   Returns 0 if the rule set is legal or -EINVAL if not.
</para>
</refsect1>
</refentry>

<refentry id="API-bpf-prog-create">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>bpf_prog_create</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>bpf_prog_create</refname>
 <refpurpose>
     create an unattached filter
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>bpf_prog_create </function></funcdef>
   <paramdef>struct bpf_prog ** <parameter>pfp</parameter></paramdef>
   <paramdef>struct sock_fprog_kern * <parameter>fprog</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>pfp</parameter></term>
   <listitem>
    <para>
     the unattached filter that is created
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>fprog</parameter></term>
   <listitem>
    <para>
     the filter program
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Create a filter independent of any socket. We first run some
   sanity checks on it to make sure it does not explode on us later.
   If an error occurs or there is insufficient memory for the filter
   a negative errno code is returned. On success the return is zero.
</para>
</refsect1>
</refentry>

<refentry id="API-sk-attach-filter">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>sk_attach_filter</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>sk_attach_filter</refname>
 <refpurpose>
     attach a socket filter
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>sk_attach_filter </function></funcdef>
   <paramdef>struct sock_fprog * <parameter>fprog</parameter></paramdef>
   <paramdef>struct sock * <parameter>sk</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>fprog</parameter></term>
   <listitem>
    <para>
     the filter program
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>sk</parameter></term>
   <listitem>
    <para>
     the socket to use
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Attach the user's filter code. We first run some sanity checks on
   it to make sure it does not explode on us later. If an error
   occurs or there is insufficient memory for the filter a negative
   errno code is returned. On success the return is zero.
</para>
</refsect1>
</refentry>

     </sect1>
     <sect1><title>Generic Network Statistics</title>
<!-- include/uapi/linux/gen_stats.h -->
<refentry id="API-struct-gnet-stats-basic">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct gnet_stats_basic</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct gnet_stats_basic</refname>
 <refpurpose>
  byte/packet throughput statistics
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct gnet_stats_basic {
  __u64 bytes;
  __u32 packets;
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>bytes</term>
      <listitem><para>
number of seen bytes
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>packets</term>
      <listitem><para>
number of seen packets
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
</refentry>

<refentry id="API-struct-gnet-stats-rate-est">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct gnet_stats_rate_est</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct gnet_stats_rate_est</refname>
 <refpurpose>
     rate estimator
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct gnet_stats_rate_est {
  __u32 bps;
  __u32 pps;
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>bps</term>
      <listitem><para>
   current byte rate
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>pps</term>
      <listitem><para>
   current packet rate
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
</refentry>

<refentry id="API-struct-gnet-stats-rate-est64">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct gnet_stats_rate_est64</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct gnet_stats_rate_est64</refname>
 <refpurpose>
     rate estimator
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct gnet_stats_rate_est64 {
  __u64 bps;
  __u64 pps;
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>bps</term>
      <listitem><para>
   current byte rate
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>pps</term>
      <listitem><para>
   current packet rate
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
</refentry>

<refentry id="API-struct-gnet-stats-queue">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct gnet_stats_queue</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct gnet_stats_queue</refname>
 <refpurpose>
     queuing statistics
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct gnet_stats_queue {
  __u32 qlen;
  __u32 backlog;
  __u32 drops;
  __u32 requeues;
  __u32 overlimits;
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>qlen</term>
      <listitem><para>
   queue length
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>backlog</term>
      <listitem><para>
   backlog size of queue
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>drops</term>
      <listitem><para>
   number of dropped packets
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>requeues</term>
      <listitem><para>
   number of requeues
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>overlimits</term>
      <listitem><para>
   number of enqueues over the limit
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
</refentry>

<refentry id="API-struct-gnet-estimator">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct gnet_estimator</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct gnet_estimator</refname>
 <refpurpose>
     rate estimator configuration
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct gnet_estimator {
  signed char interval;
  unsigned char ewma_log;
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>interval</term>
      <listitem><para>
   sampling period
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>ewma_log</term>
      <listitem><para>
   the log of measurement window weight
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
</refentry>

<!-- net/core/gen_stats.c -->
<refentry id="API-gnet-stats-start-copy-compat">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>gnet_stats_start_copy_compat</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>gnet_stats_start_copy_compat</refname>
 <refpurpose>
  start dumping procedure in compatibility mode
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>gnet_stats_start_copy_compat </function></funcdef>
   <paramdef>struct sk_buff * <parameter>skb</parameter></paramdef>
   <paramdef>int <parameter>type</parameter></paramdef>
   <paramdef>int <parameter>tc_stats_type</parameter></paramdef>
   <paramdef>int <parameter>xstats_type</parameter></paramdef>
   <paramdef>spinlock_t * <parameter>lock</parameter></paramdef>
   <paramdef>struct gnet_dump * <parameter>d</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>skb</parameter></term>
   <listitem>
    <para>
     socket buffer to put statistics TLVs into
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>type</parameter></term>
   <listitem>
    <para>
     TLV type for top level statistic TLV
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>tc_stats_type</parameter></term>
   <listitem>
    <para>
     TLV type for backward compatibility struct tc_stats TLV
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>xstats_type</parameter></term>
   <listitem>
    <para>
     TLV type for backward compatibility xstats TLV
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>lock</parameter></term>
   <listitem>
    <para>
     statistics lock
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>d</parameter></term>
   <listitem>
    <para>
     dumping handle
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Initializes the dumping handle, grabs the statistic lock and appends
   an empty TLV header to the socket buffer for use a container for all
   other statistic TLVS.
   </para><para>

   The dumping handle is marked to be in backward compatibility mode telling
   all <function>gnet_stats_copy_XXX</function> functions to fill a local copy of struct tc_stats.
   </para><para>

   Returns 0 on success or -1 if the room in the socket buffer was not sufficient.
</para>
</refsect1>
</refentry>

<refentry id="API-gnet-stats-start-copy">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>gnet_stats_start_copy</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>gnet_stats_start_copy</refname>
 <refpurpose>
     start dumping procedure in compatibility mode
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>gnet_stats_start_copy </function></funcdef>
   <paramdef>struct sk_buff * <parameter>skb</parameter></paramdef>
   <paramdef>int <parameter>type</parameter></paramdef>
   <paramdef>spinlock_t * <parameter>lock</parameter></paramdef>
   <paramdef>struct gnet_dump * <parameter>d</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>skb</parameter></term>
   <listitem>
    <para>
     socket buffer to put statistics TLVs into
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>type</parameter></term>
   <listitem>
    <para>
     TLV type for top level statistic TLV
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>lock</parameter></term>
   <listitem>
    <para>
     statistics lock
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>d</parameter></term>
   <listitem>
    <para>
     dumping handle
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Initializes the dumping handle, grabs the statistic lock and appends
   an empty TLV header to the socket buffer for use a container for all
   other statistic TLVS.
   </para><para>

   Returns 0 on success or -1 if the room in the socket buffer was not sufficient.
</para>
</refsect1>
</refentry>

<refentry id="API-gnet-stats-copy-basic">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>gnet_stats_copy_basic</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>gnet_stats_copy_basic</refname>
 <refpurpose>
     copy basic statistics into statistic TLV
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>gnet_stats_copy_basic </function></funcdef>
   <paramdef>struct gnet_dump * <parameter>d</parameter></paramdef>
   <paramdef>struct gnet_stats_basic_cpu __percpu * <parameter>cpu</parameter></paramdef>
   <paramdef>struct gnet_stats_basic_packed * <parameter>b</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>d</parameter></term>
   <listitem>
    <para>
     dumping handle
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>cpu</parameter></term>
   <listitem>
    <para>
     -- undescribed --
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>b</parameter></term>
   <listitem>
    <para>
     basic statistics
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Appends the basic statistics to the top level TLV created by
   <function>gnet_stats_start_copy</function>.
   </para><para>

   Returns 0 on success or -1 with the statistic lock released
   if the room in the socket buffer was not sufficient.
</para>
</refsect1>
</refentry>

<refentry id="API-gnet-stats-copy-rate-est">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>gnet_stats_copy_rate_est</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>gnet_stats_copy_rate_est</refname>
 <refpurpose>
     copy rate estimator statistics into statistics TLV
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>gnet_stats_copy_rate_est </function></funcdef>
   <paramdef>struct gnet_dump * <parameter>d</parameter></paramdef>
   <paramdef>const struct gnet_stats_basic_packed * <parameter>b</parameter></paramdef>
   <paramdef>struct gnet_stats_rate_est64 * <parameter>r</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>d</parameter></term>
   <listitem>
    <para>
     dumping handle
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>b</parameter></term>
   <listitem>
    <para>
     basic statistics
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>r</parameter></term>
   <listitem>
    <para>
     rate estimator statistics
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Appends the rate estimator statistics to the top level TLV created by
   <function>gnet_stats_start_copy</function>.
   </para><para>

   Returns 0 on success or -1 with the statistic lock released
   if the room in the socket buffer was not sufficient.
</para>
</refsect1>
</refentry>

<refentry id="API-gnet-stats-copy-queue">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>gnet_stats_copy_queue</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>gnet_stats_copy_queue</refname>
 <refpurpose>
     copy queue statistics into statistics TLV
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>gnet_stats_copy_queue </function></funcdef>
   <paramdef>struct gnet_dump * <parameter>d</parameter></paramdef>
   <paramdef>struct gnet_stats_queue __percpu * <parameter>cpu_q</parameter></paramdef>
   <paramdef>struct gnet_stats_queue * <parameter>q</parameter></paramdef>
   <paramdef>__u32 <parameter>qlen</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>d</parameter></term>
   <listitem>
    <para>
     dumping handle
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>cpu_q</parameter></term>
   <listitem>
    <para>
     per cpu queue statistics
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>q</parameter></term>
   <listitem>
    <para>
     queue statistics
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>qlen</parameter></term>
   <listitem>
    <para>
     queue length statistics
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Appends the queue statistics to the top level TLV created by
   <function>gnet_stats_start_copy</function>. Using per cpu queue statistics if
   they are available.
   </para><para>

   Returns 0 on success or -1 with the statistic lock released
   if the room in the socket buffer was not sufficient.
</para>
</refsect1>
</refentry>

<refentry id="API-gnet-stats-copy-app">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>gnet_stats_copy_app</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>gnet_stats_copy_app</refname>
 <refpurpose>
     copy application specific statistics into statistics TLV
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>gnet_stats_copy_app </function></funcdef>
   <paramdef>struct gnet_dump * <parameter>d</parameter></paramdef>
   <paramdef>void * <parameter>st</parameter></paramdef>
   <paramdef>int <parameter>len</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>d</parameter></term>
   <listitem>
    <para>
     dumping handle
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>st</parameter></term>
   <listitem>
    <para>
     application specific statistics data
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>len</parameter></term>
   <listitem>
    <para>
     length of data
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Appends the application specific statistics to the top level TLV created by
   <function>gnet_stats_start_copy</function> and remembers the data for XSTATS if the dumping
   handle is in backward compatibility mode.
   </para><para>

   Returns 0 on success or -1 with the statistic lock released
   if the room in the socket buffer was not sufficient.
</para>
</refsect1>
</refentry>

<refentry id="API-gnet-stats-finish-copy">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>gnet_stats_finish_copy</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>gnet_stats_finish_copy</refname>
 <refpurpose>
     finish dumping procedure
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>gnet_stats_finish_copy </function></funcdef>
   <paramdef>struct gnet_dump * <parameter>d</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>d</parameter></term>
   <listitem>
    <para>
     dumping handle
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Corrects the length of the top level TLV to include all TLVs added
   by <function>gnet_stats_copy_XXX</function> calls. Adds the backward compatibility TLVs
   if <function>gnet_stats_start_copy_compat</function> was used and releases the statistics
   lock.
   </para><para>

   Returns 0 on success or -1 with the statistic lock released
   if the room in the socket buffer was not sufficient.
</para>
</refsect1>
</refentry>

<!-- net/core/gen_estimator.c -->
<refentry id="API-gen-new-estimator">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>gen_new_estimator</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>gen_new_estimator</refname>
 <refpurpose>
  create a new rate estimator
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>gen_new_estimator </function></funcdef>
   <paramdef>struct gnet_stats_basic_packed * <parameter>bstats</parameter></paramdef>
   <paramdef>struct gnet_stats_basic_cpu __percpu * <parameter>cpu_bstats</parameter></paramdef>
   <paramdef>struct gnet_stats_rate_est64 * <parameter>rate_est</parameter></paramdef>
   <paramdef>spinlock_t * <parameter>stats_lock</parameter></paramdef>
   <paramdef>struct nlattr * <parameter>opt</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>bstats</parameter></term>
   <listitem>
    <para>
     basic statistics
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>cpu_bstats</parameter></term>
   <listitem>
    <para>
     -- undescribed --
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>rate_est</parameter></term>
   <listitem>
    <para>
     rate estimator statistics
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>stats_lock</parameter></term>
   <listitem>
    <para>
     statistics lock
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>opt</parameter></term>
   <listitem>
    <para>
     rate estimator configuration TLV
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Creates a new rate estimator with <structname>bstats</structname> as source and <structname>rate_est</structname>
   as destination. A new timer with the interval specified in the
   configuration TLV is created. Upon each interval, the latest statistics
   will be read from <structname>bstats</structname> and the estimated rate will be stored in
   <structname>rate_est</structname> with the statistics lock grabbed during this period.
   </para><para>

   Returns 0 on success or a negative error code.
</para>
</refsect1>
</refentry>

<refentry id="API-gen-kill-estimator">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>gen_kill_estimator</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>gen_kill_estimator</refname>
 <refpurpose>
     remove a rate estimator
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>gen_kill_estimator </function></funcdef>
   <paramdef>struct gnet_stats_basic_packed * <parameter>bstats</parameter></paramdef>
   <paramdef>struct gnet_stats_rate_est64 * <parameter>rate_est</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>bstats</parameter></term>
   <listitem>
    <para>
     basic statistics
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>rate_est</parameter></term>
   <listitem>
    <para>
     rate estimator statistics
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Removes the rate estimator specified by <structname>bstats</structname> and <structname>rate_est</structname>.
</para>
</refsect1>
<refsect1>
<title>Note </title>
<para>
   Caller should respect an RCU grace period before freeing stats_lock
</para>
</refsect1>
</refentry>

<refentry id="API-gen-replace-estimator">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>gen_replace_estimator</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>gen_replace_estimator</refname>
 <refpurpose>
     replace rate estimator configuration
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>gen_replace_estimator </function></funcdef>
   <paramdef>struct gnet_stats_basic_packed * <parameter>bstats</parameter></paramdef>
   <paramdef>struct gnet_stats_basic_cpu __percpu * <parameter>cpu_bstats</parameter></paramdef>
   <paramdef>struct gnet_stats_rate_est64 * <parameter>rate_est</parameter></paramdef>
   <paramdef>spinlock_t * <parameter>stats_lock</parameter></paramdef>
   <paramdef>struct nlattr * <parameter>opt</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>bstats</parameter></term>
   <listitem>
    <para>
     basic statistics
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>cpu_bstats</parameter></term>
   <listitem>
    <para>
     -- undescribed --
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>rate_est</parameter></term>
   <listitem>
    <para>
     rate estimator statistics
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>stats_lock</parameter></term>
   <listitem>
    <para>
     statistics lock
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>opt</parameter></term>
   <listitem>
    <para>
     rate estimator configuration TLV
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Replaces the configuration of a rate estimator by calling
   <function>gen_kill_estimator</function> and <function>gen_new_estimator</function>.
   </para><para>

   Returns 0 on success or a negative error code.
</para>
</refsect1>
</refentry>

<refentry id="API-gen-estimator-active">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>gen_estimator_active</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>gen_estimator_active</refname>
 <refpurpose>
     test if estimator is currently in use
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>bool <function>gen_estimator_active </function></funcdef>
   <paramdef>const struct gnet_stats_basic_packed * <parameter>bstats</parameter></paramdef>
   <paramdef>const struct gnet_stats_rate_est64 * <parameter>rate_est</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>bstats</parameter></term>
   <listitem>
    <para>
     basic statistics
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>rate_est</parameter></term>
   <listitem>
    <para>
     rate estimator statistics
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Returns true if estimator is active, and false if not.
</para>
</refsect1>
</refentry>

     </sect1>
     <sect1><title>SUN RPC subsystem</title>
<!-- The !D functionality is not perfect, garbage has to be protected by comments
net/sunrpc/sunrpc_syms.c-->
<!-- net/sunrpc/xdr.c -->
<refentry id="API-xdr-encode-opaque-fixed">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>xdr_encode_opaque_fixed</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>xdr_encode_opaque_fixed</refname>
 <refpurpose>
  Encode fixed length opaque data
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>__be32 * <function>xdr_encode_opaque_fixed </function></funcdef>
   <paramdef>__be32 * <parameter>p</parameter></paramdef>
   <paramdef>const void * <parameter>ptr</parameter></paramdef>
   <paramdef>unsigned int <parameter>nbytes</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>p</parameter></term>
   <listitem>
    <para>
     pointer to current position in XDR buffer.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>ptr</parameter></term>
   <listitem>
    <para>
     pointer to data to encode (or NULL)
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>nbytes</parameter></term>
   <listitem>
    <para>
     size of data.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Copy the array of data of length nbytes at ptr to the XDR buffer
   at position p, then align to the next 32-bit boundary by padding
   with zero bytes (see RFC1832).
</para>
</refsect1>
<refsect1>
<title>Note</title>
<para>
   if ptr is NULL, only the padding is performed.
   </para><para>

   Returns the updated current XDR buffer position
</para>
</refsect1>
</refentry>

<refentry id="API-xdr-encode-opaque">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>xdr_encode_opaque</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>xdr_encode_opaque</refname>
 <refpurpose>
     Encode variable length opaque data
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>__be32 * <function>xdr_encode_opaque </function></funcdef>
   <paramdef>__be32 * <parameter>p</parameter></paramdef>
   <paramdef>const void * <parameter>ptr</parameter></paramdef>
   <paramdef>unsigned int <parameter>nbytes</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>p</parameter></term>
   <listitem>
    <para>
     pointer to current position in XDR buffer.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>ptr</parameter></term>
   <listitem>
    <para>
     pointer to data to encode (or NULL)
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>nbytes</parameter></term>
   <listitem>
    <para>
     size of data.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Returns the updated current XDR buffer position
</para>
</refsect1>
</refentry>

<refentry id="API-xdr-terminate-string">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>xdr_terminate_string</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>xdr_terminate_string</refname>
 <refpurpose>
     '\0'-terminate a string residing in an xdr_buf
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>xdr_terminate_string </function></funcdef>
   <paramdef>struct xdr_buf * <parameter>buf</parameter></paramdef>
   <paramdef>const u32 <parameter>len</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>buf</parameter></term>
   <listitem>
    <para>
     XDR buffer where string resides
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>len</parameter></term>
   <listitem>
    <para>
     length of string, in bytes
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API--copy-from-pages">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>_copy_from_pages</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>_copy_from_pages</refname>
 <refpurpose>
   </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>_copy_from_pages </function></funcdef>
   <paramdef>char * <parameter>p</parameter></paramdef>
   <paramdef>struct page ** <parameter>pages</parameter></paramdef>
   <paramdef>size_t <parameter>pgbase</parameter></paramdef>
   <paramdef>size_t <parameter>len</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>p</parameter></term>
   <listitem>
    <para>
     pointer to destination
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>pages</parameter></term>
   <listitem>
    <para>
     array of pages
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>pgbase</parameter></term>
   <listitem>
    <para>
     offset of source data
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>len</parameter></term>
   <listitem>
    <para>
     length
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Copies data into an arbitrary memory location from an array of pages
   The copy is assumed to be non-overlapping.
</para>
</refsect1>
</refentry>

<refentry id="API-xdr-stream-pos">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>xdr_stream_pos</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>xdr_stream_pos</refname>
 <refpurpose>
     Return the current offset from the start of the xdr_stream
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>unsigned int <function>xdr_stream_pos </function></funcdef>
   <paramdef>const struct xdr_stream * <parameter>xdr</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>xdr</parameter></term>
   <listitem>
    <para>
     pointer to struct xdr_stream
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-xdr-init-encode">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>xdr_init_encode</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>xdr_init_encode</refname>
 <refpurpose>
     Initialize a struct xdr_stream for sending data.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>xdr_init_encode </function></funcdef>
   <paramdef>struct xdr_stream * <parameter>xdr</parameter></paramdef>
   <paramdef>struct xdr_buf * <parameter>buf</parameter></paramdef>
   <paramdef>__be32 * <parameter>p</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>xdr</parameter></term>
   <listitem>
    <para>
     pointer to xdr_stream struct
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>buf</parameter></term>
   <listitem>
    <para>
     pointer to XDR buffer in which to encode data
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>p</parameter></term>
   <listitem>
    <para>
     current pointer inside XDR buffer
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Note</title>
<para>
   at the moment the RPC client only passes the length of our
   scratch buffer in the xdr_buf's header kvec. Previously this
   meant we needed to call <function>xdr_adjust_iovec</function> after encoding the
   data. With the new scheme, the xdr_stream manages the details
   of the buffer length, and takes care of adjusting the kvec
   length for us.
</para>
</refsect1>
</refentry>

<refentry id="API-xdr-commit-encode">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>xdr_commit_encode</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>xdr_commit_encode</refname>
 <refpurpose>
     Ensure all data is written to buffer
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>xdr_commit_encode </function></funcdef>
   <paramdef>struct xdr_stream * <parameter>xdr</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>xdr</parameter></term>
   <listitem>
    <para>
     pointer to xdr_stream
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   We handle encoding across page boundaries by giving the caller a
   temporary location to write to, then later copying the data into
   place; xdr_commit_encode does that copying.
   </para><para>

   Normally the caller doesn't need to call this directly, as the
   following xdr_reserve_space will do it.  But an explicit call may be
   required at the end of encoding, or any other time when the xdr_buf
   data might be read.
</para>
</refsect1>
</refentry>

<refentry id="API-xdr-reserve-space">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>xdr_reserve_space</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>xdr_reserve_space</refname>
 <refpurpose>
     Reserve buffer space for sending
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>__be32 * <function>xdr_reserve_space </function></funcdef>
   <paramdef>struct xdr_stream * <parameter>xdr</parameter></paramdef>
   <paramdef>size_t <parameter>nbytes</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>xdr</parameter></term>
   <listitem>
    <para>
     pointer to xdr_stream
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>nbytes</parameter></term>
   <listitem>
    <para>
     number of bytes to reserve
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Checks that we have enough buffer space to encode 'nbytes' more
   bytes of data. If so, update the total xdr_buf length, and
   adjust the length of the current kvec.
</para>
</refsect1>
</refentry>

<refentry id="API-xdr-truncate-encode">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>xdr_truncate_encode</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>xdr_truncate_encode</refname>
 <refpurpose>
     truncate an encode buffer
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>xdr_truncate_encode </function></funcdef>
   <paramdef>struct xdr_stream * <parameter>xdr</parameter></paramdef>
   <paramdef>size_t <parameter>len</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>xdr</parameter></term>
   <listitem>
    <para>
     pointer to xdr_stream
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>len</parameter></term>
   <listitem>
    <para>
     new length of buffer
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Truncates the xdr stream, so that xdr-&gt;buf-&gt;len == len,
   and xdr-&gt;p points at offset len from the start of the buffer, and
   head, tail, and page lengths are adjusted to correspond.
   </para><para>

   If this means moving xdr-&gt;p to a different buffer, we assume that
   that the end pointer should be set to the end of the current page,
   except in the case of the head buffer when we assume the head
   buffer's current length represents the end of the available buffer.
   </para><para>

   This is *not* safe to use on a buffer that already has inlined page
   cache pages (as in a zero-copy server read reply), except for the
   simple case of truncating from one position in the tail to another.
</para>
</refsect1>
</refentry>

<refentry id="API-xdr-restrict-buflen">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>xdr_restrict_buflen</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>xdr_restrict_buflen</refname>
 <refpurpose>
     decrease available buffer space
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>xdr_restrict_buflen </function></funcdef>
   <paramdef>struct xdr_stream * <parameter>xdr</parameter></paramdef>
   <paramdef>int <parameter>newbuflen</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>xdr</parameter></term>
   <listitem>
    <para>
     pointer to xdr_stream
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>newbuflen</parameter></term>
   <listitem>
    <para>
     new maximum number of bytes available
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Adjust our idea of how much space is available in the buffer.
   If we've already used too much space in the buffer, returns -1.
   If the available space is already smaller than newbuflen, returns 0
   and does nothing.  Otherwise, adjusts xdr-&gt;buf-&gt;buflen to newbuflen
   and ensures xdr-&gt;end is set at most offset newbuflen from the start
   of the buffer.
</para>
</refsect1>
</refentry>

<refentry id="API-xdr-write-pages">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>xdr_write_pages</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>xdr_write_pages</refname>
 <refpurpose>
     Insert a list of pages into an XDR buffer for sending
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>xdr_write_pages </function></funcdef>
   <paramdef>struct xdr_stream * <parameter>xdr</parameter></paramdef>
   <paramdef>struct page ** <parameter>pages</parameter></paramdef>
   <paramdef>unsigned int <parameter>base</parameter></paramdef>
   <paramdef>unsigned int <parameter>len</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>xdr</parameter></term>
   <listitem>
    <para>
     pointer to xdr_stream
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>pages</parameter></term>
   <listitem>
    <para>
     list of pages
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>base</parameter></term>
   <listitem>
    <para>
     offset of first byte
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>len</parameter></term>
   <listitem>
    <para>
     length of data in bytes
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-xdr-init-decode">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>xdr_init_decode</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>xdr_init_decode</refname>
 <refpurpose>
     Initialize an xdr_stream for decoding data.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>xdr_init_decode </function></funcdef>
   <paramdef>struct xdr_stream * <parameter>xdr</parameter></paramdef>
   <paramdef>struct xdr_buf * <parameter>buf</parameter></paramdef>
   <paramdef>__be32 * <parameter>p</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>xdr</parameter></term>
   <listitem>
    <para>
     pointer to xdr_stream struct
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>buf</parameter></term>
   <listitem>
    <para>
     pointer to XDR buffer from which to decode data
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>p</parameter></term>
   <listitem>
    <para>
     current pointer inside XDR buffer
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-xdr-init-decode-pages">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>xdr_init_decode_pages</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>xdr_init_decode_pages</refname>
 <refpurpose>
     Initialize an xdr_stream for decoding data.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>xdr_init_decode_pages </function></funcdef>
   <paramdef>struct xdr_stream * <parameter>xdr</parameter></paramdef>
   <paramdef>struct xdr_buf * <parameter>buf</parameter></paramdef>
   <paramdef>struct page ** <parameter>pages</parameter></paramdef>
   <paramdef>unsigned int <parameter>len</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>xdr</parameter></term>
   <listitem>
    <para>
     pointer to xdr_stream struct
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>buf</parameter></term>
   <listitem>
    <para>
     pointer to XDR buffer from which to decode data
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>pages</parameter></term>
   <listitem>
    <para>
     list of pages to decode into
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>len</parameter></term>
   <listitem>
    <para>
     length in bytes of buffer in pages
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-xdr-set-scratch-buffer">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>xdr_set_scratch_buffer</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>xdr_set_scratch_buffer</refname>
 <refpurpose>
     Attach a scratch buffer for decoding data.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>xdr_set_scratch_buffer </function></funcdef>
   <paramdef>struct xdr_stream * <parameter>xdr</parameter></paramdef>
   <paramdef>void * <parameter>buf</parameter></paramdef>
   <paramdef>size_t <parameter>buflen</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>xdr</parameter></term>
   <listitem>
    <para>
     pointer to xdr_stream struct
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>buf</parameter></term>
   <listitem>
    <para>
     pointer to an empty buffer
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>buflen</parameter></term>
   <listitem>
    <para>
     size of 'buf'
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   The scratch buffer is used when decoding from an array of pages.
   If an <function>xdr_inline_decode</function> call spans across page boundaries, then
   we copy the data into the scratch buffer in order to allow linear
   access.
</para>
</refsect1>
</refentry>

<refentry id="API-xdr-inline-decode">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>xdr_inline_decode</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>xdr_inline_decode</refname>
 <refpurpose>
     Retrieve XDR data to decode
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>__be32 * <function>xdr_inline_decode </function></funcdef>
   <paramdef>struct xdr_stream * <parameter>xdr</parameter></paramdef>
   <paramdef>size_t <parameter>nbytes</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>xdr</parameter></term>
   <listitem>
    <para>
     pointer to xdr_stream struct
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>nbytes</parameter></term>
   <listitem>
    <para>
     number of bytes of data to decode
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Check if the input buffer is long enough to enable us to decode
   'nbytes' more bytes of data starting at the current position.
   If so return the current pointer, then update the current
   pointer position.
</para>
</refsect1>
</refentry>

<refentry id="API-xdr-read-pages">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>xdr_read_pages</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>xdr_read_pages</refname>
 <refpurpose>
     Ensure page-based XDR data to decode is aligned at current pointer position
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>unsigned int <function>xdr_read_pages </function></funcdef>
   <paramdef>struct xdr_stream * <parameter>xdr</parameter></paramdef>
   <paramdef>unsigned int <parameter>len</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>xdr</parameter></term>
   <listitem>
    <para>
     pointer to xdr_stream struct
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>len</parameter></term>
   <listitem>
    <para>
     number of bytes of page data
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Moves data beyond the current pointer position from the XDR head[] buffer
   into the page list. Any data that lies beyond current position + <quote>len</quote>
   bytes is moved into the XDR tail[].
   </para><para>

   Returns the number of XDR encoded bytes now contained in the pages
</para>
</refsect1>
</refentry>

<refentry id="API-xdr-enter-page">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>xdr_enter_page</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>xdr_enter_page</refname>
 <refpurpose>
     decode data from the XDR page
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>xdr_enter_page </function></funcdef>
   <paramdef>struct xdr_stream * <parameter>xdr</parameter></paramdef>
   <paramdef>unsigned int <parameter>len</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>xdr</parameter></term>
   <listitem>
    <para>
     pointer to xdr_stream struct
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>len</parameter></term>
   <listitem>
    <para>
     number of bytes of page data
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Moves data beyond the current pointer position from the XDR head[] buffer
   into the page list. Any data that lies beyond current position + <quote>len</quote>
   bytes is moved into the XDR tail[]. The current pointer is then
   repositioned at the beginning of the first XDR page.
</para>
</refsect1>
</refentry>

<refentry id="API-xdr-buf-subsegment">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>xdr_buf_subsegment</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>xdr_buf_subsegment</refname>
 <refpurpose>
     set subbuf to a portion of buf
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>xdr_buf_subsegment </function></funcdef>
   <paramdef>struct xdr_buf * <parameter>buf</parameter></paramdef>
   <paramdef>struct xdr_buf * <parameter>subbuf</parameter></paramdef>
   <paramdef>unsigned int <parameter>base</parameter></paramdef>
   <paramdef>unsigned int <parameter>len</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>buf</parameter></term>
   <listitem>
    <para>
     an xdr buffer
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>subbuf</parameter></term>
   <listitem>
    <para>
     the result buffer
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>base</parameter></term>
   <listitem>
    <para>
     beginning of range in bytes
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>len</parameter></term>
   <listitem>
    <para>
     length of range in bytes
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   sets <parameter>subbuf</parameter> to an xdr buffer representing the portion of <parameter>buf</parameter> of
   length <parameter>len</parameter> starting at offset <parameter>base</parameter>.
   </para><para>

   <parameter>buf</parameter> and <parameter>subbuf</parameter> may be pointers to the same struct xdr_buf.
   </para><para>

   Returns -1 if base of length are out of bounds.
</para>
</refsect1>
</refentry>

<refentry id="API-xdr-buf-trim">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>xdr_buf_trim</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>xdr_buf_trim</refname>
 <refpurpose>
     lop at most <quote>len</quote> bytes off the end of <quote>buf</quote>
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>xdr_buf_trim </function></funcdef>
   <paramdef>struct xdr_buf * <parameter>buf</parameter></paramdef>
   <paramdef>unsigned int <parameter>len</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>buf</parameter></term>
   <listitem>
    <para>
     buf to be trimmed
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>len</parameter></term>
   <listitem>
    <para>
     number of bytes to reduce <quote>buf</quote> by
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Trim an xdr_buf by the given number of bytes by fixing up the lengths. Note
   that it's possible that we'll trim less than that amount if the xdr_buf is
   too small, or if (for instance) it's all in the head and the parser has
   already read too far into it.
</para>
</refsect1>
</refentry>

<!-- net/sunrpc/svc_xprt.c -->
<refentry id="API-svc-print-addr">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>svc_print_addr</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>svc_print_addr</refname>
 <refpurpose>
  Format rq_addr field for printing
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>char * <function>svc_print_addr </function></funcdef>
   <paramdef>struct svc_rqst * <parameter>rqstp</parameter></paramdef>
   <paramdef>char * <parameter>buf</parameter></paramdef>
   <paramdef>size_t <parameter>len</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>rqstp</parameter></term>
   <listitem>
    <para>
     svc_rqst struct containing address to print
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>buf</parameter></term>
   <listitem>
    <para>
     target buffer for formatted address
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>len</parameter></term>
   <listitem>
    <para>
     length of target buffer
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-svc-reserve">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>svc_reserve</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>svc_reserve</refname>
 <refpurpose>
     change the space reserved for the reply to a request.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>svc_reserve </function></funcdef>
   <paramdef>struct svc_rqst * <parameter>rqstp</parameter></paramdef>
   <paramdef>int <parameter>space</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>rqstp</parameter></term>
   <listitem>
    <para>
     The request in question
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>space</parameter></term>
   <listitem>
    <para>
     new max space to reserve
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Each request reserves some space on the output queue of the transport
   to make sure the reply fits.  This function reduces that reserved
   space to be the amount of space used already, plus <parameter>space</parameter>.
</para>
</refsect1>
</refentry>

<refentry id="API-svc-find-xprt">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>svc_find_xprt</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>svc_find_xprt</refname>
 <refpurpose>
     find an RPC transport instance
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct svc_xprt * <function>svc_find_xprt </function></funcdef>
   <paramdef>struct svc_serv * <parameter>serv</parameter></paramdef>
   <paramdef>const char * <parameter>xcl_name</parameter></paramdef>
   <paramdef>struct net * <parameter>net</parameter></paramdef>
   <paramdef>const sa_family_t <parameter>af</parameter></paramdef>
   <paramdef>const unsigned short <parameter>port</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>serv</parameter></term>
   <listitem>
    <para>
     pointer to svc_serv to search
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>xcl_name</parameter></term>
   <listitem>
    <para>
     C string containing transport's class name
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>net</parameter></term>
   <listitem>
    <para>
     owner net pointer
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>af</parameter></term>
   <listitem>
    <para>
     Address family of transport's local address
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>port</parameter></term>
   <listitem>
    <para>
     transport's IP port number
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Return the transport instance pointer for the endpoint accepting
   connections/peer traffic from the specified transport class,
   address family and port.
   </para><para>

   Specifying 0 for the address family or port is effectively a
   wild-card, and will result in matching the first transport in the
   service's list that has a matching class name.
</para>
</refsect1>
</refentry>

<refentry id="API-svc-xprt-names">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>svc_xprt_names</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>svc_xprt_names</refname>
 <refpurpose>
     format a buffer with a list of transport names
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>svc_xprt_names </function></funcdef>
   <paramdef>struct svc_serv * <parameter>serv</parameter></paramdef>
   <paramdef>char * <parameter>buf</parameter></paramdef>
   <paramdef>const int <parameter>buflen</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>serv</parameter></term>
   <listitem>
    <para>
     pointer to an RPC service
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>buf</parameter></term>
   <listitem>
    <para>
     pointer to a buffer to be filled in
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>buflen</parameter></term>
   <listitem>
    <para>
     length of buffer to be filled in
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Fills in <parameter>buf</parameter> with a string containing a list of transport names,
   each name terminated with '\n'.
   </para><para>

   Returns positive length of the filled-in string on success; otherwise
   a negative errno value is returned if an error occurs.
</para>
</refsect1>
</refentry>

<!-- net/sunrpc/xprt.c -->
<refentry id="API-xprt-register-transport">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>xprt_register_transport</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>xprt_register_transport</refname>
 <refpurpose>
  register a transport implementation
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>xprt_register_transport </function></funcdef>
   <paramdef>struct xprt_class * <parameter>transport</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>transport</parameter></term>
   <listitem>
    <para>
     transport to register
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   If a transport implementation is loaded as a kernel module, it can
   call this interface to make itself known to the RPC client.
</para>
</refsect1>
<refsect1>
<title>0</title>
<para>
   transport successfully registered
   -EEXIST:	transport already registered
   -EINVAL:	transport module being unloaded
</para>
</refsect1>
</refentry>

<refentry id="API-xprt-unregister-transport">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>xprt_unregister_transport</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>xprt_unregister_transport</refname>
 <refpurpose>
     unregister a transport implementation
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>xprt_unregister_transport </function></funcdef>
   <paramdef>struct xprt_class * <parameter>transport</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>transport</parameter></term>
   <listitem>
    <para>
     transport to unregister
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>0</title>
<para>
   transport successfully unregistered
   -ENOENT:	transport never registered
</para>
</refsect1>
</refentry>

<refentry id="API-xprt-load-transport">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>xprt_load_transport</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>xprt_load_transport</refname>
 <refpurpose>
     load a transport implementation
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>xprt_load_transport </function></funcdef>
   <paramdef>const char * <parameter>transport_name</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>transport_name</parameter></term>
   <listitem>
    <para>
     transport to load
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>0</title>
<para>
   transport successfully loaded
   -ENOENT:	transport module not available
</para>
</refsect1>
</refentry>

<refentry id="API-xprt-reserve-xprt">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>xprt_reserve_xprt</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>xprt_reserve_xprt</refname>
 <refpurpose>
     serialize write access to transports
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>xprt_reserve_xprt </function></funcdef>
   <paramdef>struct rpc_xprt * <parameter>xprt</parameter></paramdef>
   <paramdef>struct rpc_task * <parameter>task</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>xprt</parameter></term>
   <listitem>
    <para>
     pointer to the target transport
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>task</parameter></term>
   <listitem>
    <para>
     task that is requesting access to the transport
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This prevents mixing the payload of separate requests, and prevents
   transport connects from colliding with writes.  No congestion control
   is provided.
</para>
</refsect1>
</refentry>

<refentry id="API-xprt-release-xprt">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>xprt_release_xprt</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>xprt_release_xprt</refname>
 <refpurpose>
     allow other requests to use a transport
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>xprt_release_xprt </function></funcdef>
   <paramdef>struct rpc_xprt * <parameter>xprt</parameter></paramdef>
   <paramdef>struct rpc_task * <parameter>task</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>xprt</parameter></term>
   <listitem>
    <para>
     transport with other tasks potentially waiting
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>task</parameter></term>
   <listitem>
    <para>
     task that is releasing access to the transport
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Note that <quote>task</quote> can be NULL.  No congestion control is provided.
</para>
</refsect1>
</refentry>

<refentry id="API-xprt-release-xprt-cong">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>xprt_release_xprt_cong</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>xprt_release_xprt_cong</refname>
 <refpurpose>
     allow other requests to use a transport
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>xprt_release_xprt_cong </function></funcdef>
   <paramdef>struct rpc_xprt * <parameter>xprt</parameter></paramdef>
   <paramdef>struct rpc_task * <parameter>task</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>xprt</parameter></term>
   <listitem>
    <para>
     transport with other tasks potentially waiting
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>task</parameter></term>
   <listitem>
    <para>
     task that is releasing access to the transport
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Note that <quote>task</quote> can be NULL.  Another task is awoken to use the
   transport if the transport's congestion window allows it.
</para>
</refsect1>
</refentry>

<refentry id="API-xprt-release-rqst-cong">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>xprt_release_rqst_cong</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>xprt_release_rqst_cong</refname>
 <refpurpose>
     housekeeping when request is complete
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>xprt_release_rqst_cong </function></funcdef>
   <paramdef>struct rpc_task * <parameter>task</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>task</parameter></term>
   <listitem>
    <para>
     RPC request that recently completed
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Useful for transports that require congestion control.
</para>
</refsect1>
</refentry>

<refentry id="API-xprt-adjust-cwnd">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>xprt_adjust_cwnd</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>xprt_adjust_cwnd</refname>
 <refpurpose>
     adjust transport congestion window
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>xprt_adjust_cwnd </function></funcdef>
   <paramdef>struct rpc_xprt * <parameter>xprt</parameter></paramdef>
   <paramdef>struct rpc_task * <parameter>task</parameter></paramdef>
   <paramdef>int <parameter>result</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>xprt</parameter></term>
   <listitem>
    <para>
     pointer to xprt
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>task</parameter></term>
   <listitem>
    <para>
     recently completed RPC request used to adjust window
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>result</parameter></term>
   <listitem>
    <para>
     result code of completed RPC request
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   The transport code maintains an estimate on the maximum number of out-
   standing RPC requests, using a smoothed version of the congestion
   avoidance implemented in 44BSD. This is basically the Van Jacobson
</para>
</refsect1>
<refsect1>
<title>congestion algorithm</title>
<para>
   If a retransmit occurs, the congestion window is
   halved; otherwise, it is incremented by 1/cwnd when
   </para><para>

   -	a reply is received and
   -	a full number of requests are outstanding and
   -	the congestion window hasn't been updated recently.
</para>
</refsect1>
</refentry>

<refentry id="API-xprt-wake-pending-tasks">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>xprt_wake_pending_tasks</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>xprt_wake_pending_tasks</refname>
 <refpurpose>
     wake all tasks on a transport's pending queue
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>xprt_wake_pending_tasks </function></funcdef>
   <paramdef>struct rpc_xprt * <parameter>xprt</parameter></paramdef>
   <paramdef>int <parameter>status</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>xprt</parameter></term>
   <listitem>
    <para>
     transport with waiting tasks
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>status</parameter></term>
   <listitem>
    <para>
     result code to plant in each task before waking it
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-xprt-wait-for-buffer-space">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>xprt_wait_for_buffer_space</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>xprt_wait_for_buffer_space</refname>
 <refpurpose>
     wait for transport output buffer to clear
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>xprt_wait_for_buffer_space </function></funcdef>
   <paramdef>struct rpc_task * <parameter>task</parameter></paramdef>
   <paramdef>rpc_action <parameter>action</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>task</parameter></term>
   <listitem>
    <para>
     task to be put to sleep
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>action</parameter></term>
   <listitem>
    <para>
     function pointer to be executed after wait
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Note that we only set the timer for the case of <function>RPC_IS_SOFT</function>, since
   we don't in general want to force a socket disconnection due to
   an incomplete RPC call transmission.
</para>
</refsect1>
</refentry>

<refentry id="API-xprt-write-space">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>xprt_write_space</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>xprt_write_space</refname>
 <refpurpose>
     wake the task waiting for transport output buffer space
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>xprt_write_space </function></funcdef>
   <paramdef>struct rpc_xprt * <parameter>xprt</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>xprt</parameter></term>
   <listitem>
    <para>
     transport with waiting tasks
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Can be called in a soft IRQ context, so xprt_write_space never sleeps.
</para>
</refsect1>
</refentry>

<refentry id="API-xprt-set-retrans-timeout-def">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>xprt_set_retrans_timeout_def</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>xprt_set_retrans_timeout_def</refname>
 <refpurpose>
     set a request's retransmit timeout
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>xprt_set_retrans_timeout_def </function></funcdef>
   <paramdef>struct rpc_task * <parameter>task</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>task</parameter></term>
   <listitem>
    <para>
     task whose timeout is to be set
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Set a request's retransmit timeout based on the transport's
   default timeout parameters.  Used by transports that don't adjust
   the retransmit timeout based on round-trip time estimation.
</para>
</refsect1>
</refentry>

<refentry id="API-xprt-set-retrans-timeout-rtt">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>xprt_set_retrans_timeout_rtt</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>xprt_set_retrans_timeout_rtt</refname>
 <refpurpose>
     set a request's retransmit timeout
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>xprt_set_retrans_timeout_rtt </function></funcdef>
   <paramdef>struct rpc_task * <parameter>task</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>task</parameter></term>
   <listitem>
    <para>
     task whose timeout is to be set
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Set a request's retransmit timeout using the RTT estimator.
</para>
</refsect1>
</refentry>

<refentry id="API-xprt-disconnect-done">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>xprt_disconnect_done</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>xprt_disconnect_done</refname>
 <refpurpose>
     mark a transport as disconnected
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>xprt_disconnect_done </function></funcdef>
   <paramdef>struct rpc_xprt * <parameter>xprt</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>xprt</parameter></term>
   <listitem>
    <para>
     transport to flag for disconnect
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-xprt-lookup-rqst">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>xprt_lookup_rqst</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>xprt_lookup_rqst</refname>
 <refpurpose>
     find an RPC request corresponding to an XID
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct rpc_rqst * <function>xprt_lookup_rqst </function></funcdef>
   <paramdef>struct rpc_xprt * <parameter>xprt</parameter></paramdef>
   <paramdef>__be32 <parameter>xid</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>xprt</parameter></term>
   <listitem>
    <para>
     transport on which the original request was transmitted
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>xid</parameter></term>
   <listitem>
    <para>
     RPC XID of incoming reply
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-xprt-complete-rqst">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>xprt_complete_rqst</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>xprt_complete_rqst</refname>
 <refpurpose>
     called when reply processing is complete
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>xprt_complete_rqst </function></funcdef>
   <paramdef>struct rpc_task * <parameter>task</parameter></paramdef>
   <paramdef>int <parameter>copied</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>task</parameter></term>
   <listitem>
    <para>
     RPC request that recently completed
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>copied</parameter></term>
   <listitem>
    <para>
     actual number of bytes received from the transport
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Caller holds transport lock.
</para>
</refsect1>
</refentry>

<!-- net/sunrpc/sched.c -->
<refentry id="API-rpc-wake-up">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>rpc_wake_up</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>rpc_wake_up</refname>
 <refpurpose>
  wake up all rpc_tasks
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>rpc_wake_up </function></funcdef>
   <paramdef>struct rpc_wait_queue * <parameter>queue</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>queue</parameter></term>
   <listitem>
    <para>
     rpc_wait_queue on which the tasks are sleeping
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Grabs queue-&gt;lock
</para>
</refsect1>
</refentry>

<refentry id="API-rpc-wake-up-status">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>rpc_wake_up_status</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>rpc_wake_up_status</refname>
 <refpurpose>
     wake up all rpc_tasks and set their status value.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>rpc_wake_up_status </function></funcdef>
   <paramdef>struct rpc_wait_queue * <parameter>queue</parameter></paramdef>
   <paramdef>int <parameter>status</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>queue</parameter></term>
   <listitem>
    <para>
     rpc_wait_queue on which the tasks are sleeping
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>status</parameter></term>
   <listitem>
    <para>
     status value to set
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Grabs queue-&gt;lock
</para>
</refsect1>
</refentry>

<refentry id="API-rpc-malloc">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>rpc_malloc</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>rpc_malloc</refname>
 <refpurpose>
     allocate an RPC buffer
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void * <function>rpc_malloc </function></funcdef>
   <paramdef>struct rpc_task * <parameter>task</parameter></paramdef>
   <paramdef>size_t <parameter>size</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>task</parameter></term>
   <listitem>
    <para>
     RPC task that will use this buffer
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>size</parameter></term>
   <listitem>
    <para>
     requested byte size
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   To prevent rpciod from hanging, this allocator never sleeps,
   returning NULL and suppressing warning if the request cannot be serviced
   immediately.
   The caller can arrange to sleep in a way that is safe for rpciod.
   </para><para>

   Most requests are 'small' (under 2KiB) and can be serviced from a
   mempool, ensuring that NFS reads and writes can always proceed,
   and that there is good locality of reference for these buffers.
   </para><para>

   In order to avoid memory starvation triggering more writebacks of
   NFS requests, we avoid using GFP_KERNEL.
</para>
</refsect1>
</refentry>

<refentry id="API-rpc-free">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>rpc_free</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>rpc_free</refname>
 <refpurpose>
     free buffer allocated via rpc_malloc
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>rpc_free </function></funcdef>
   <paramdef>void * <parameter>buffer</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>buffer</parameter></term>
   <listitem>
    <para>
     buffer to free
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<!-- net/sunrpc/socklib.c -->
<refentry id="API-xdr-skb-read-bits">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>xdr_skb_read_bits</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>xdr_skb_read_bits</refname>
 <refpurpose>
  copy some data bits from skb to internal buffer
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>size_t <function>xdr_skb_read_bits </function></funcdef>
   <paramdef>struct xdr_skb_reader * <parameter>desc</parameter></paramdef>
   <paramdef>void * <parameter>to</parameter></paramdef>
   <paramdef>size_t <parameter>len</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>desc</parameter></term>
   <listitem>
    <para>
     sk_buff copy helper
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>to</parameter></term>
   <listitem>
    <para>
     copy destination
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>len</parameter></term>
   <listitem>
    <para>
     number of bytes to copy
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Possibly called several times to iterate over an sk_buff and copy
   data out of it.
</para>
</refsect1>
</refentry>

<refentry id="API-xdr-partial-copy-from-skb">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>xdr_partial_copy_from_skb</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>xdr_partial_copy_from_skb</refname>
 <refpurpose>
     copy data out of an skb
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>ssize_t <function>xdr_partial_copy_from_skb </function></funcdef>
   <paramdef>struct xdr_buf * <parameter>xdr</parameter></paramdef>
   <paramdef>unsigned int <parameter>base</parameter></paramdef>
   <paramdef>struct xdr_skb_reader * <parameter>desc</parameter></paramdef>
   <paramdef>xdr_skb_read_actor <parameter>copy_actor</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>xdr</parameter></term>
   <listitem>
    <para>
     target XDR buffer
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>base</parameter></term>
   <listitem>
    <para>
     starting offset
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>desc</parameter></term>
   <listitem>
    <para>
     sk_buff copy helper
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>copy_actor</parameter></term>
   <listitem>
    <para>
     virtual method for copying data
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-csum-partial-copy-to-xdr">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>csum_partial_copy_to_xdr</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>csum_partial_copy_to_xdr</refname>
 <refpurpose>
     checksum and copy data
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>csum_partial_copy_to_xdr </function></funcdef>
   <paramdef>struct xdr_buf * <parameter>xdr</parameter></paramdef>
   <paramdef>struct sk_buff * <parameter>skb</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>xdr</parameter></term>
   <listitem>
    <para>
     target XDR buffer
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>skb</parameter></term>
   <listitem>
    <para>
     source skb
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   We have set things up such that we perform the checksum of the UDP
   packet in parallel with the copies into the RPC client iovec.  -DaveM
</para>
</refsect1>
</refentry>

<!-- net/sunrpc/stats.c -->
<refentry id="API-rpc-alloc-iostats">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>rpc_alloc_iostats</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>rpc_alloc_iostats</refname>
 <refpurpose>
  allocate an rpc_iostats structure
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct rpc_iostats * <function>rpc_alloc_iostats </function></funcdef>
   <paramdef>struct rpc_clnt * <parameter>clnt</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>clnt</parameter></term>
   <listitem>
    <para>
     RPC program, version, and xprt
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-rpc-free-iostats">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>rpc_free_iostats</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>rpc_free_iostats</refname>
 <refpurpose>
     release an rpc_iostats structure
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>rpc_free_iostats </function></funcdef>
   <paramdef>struct rpc_iostats * <parameter>stats</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>stats</parameter></term>
   <listitem>
    <para>
     doomed rpc_iostats structure
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-rpc-count-iostats">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>rpc_count_iostats</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>rpc_count_iostats</refname>
 <refpurpose>
     tally up per-task stats
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>rpc_count_iostats </function></funcdef>
   <paramdef>const struct rpc_task * <parameter>task</parameter></paramdef>
   <paramdef>struct rpc_iostats * <parameter>stats</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>task</parameter></term>
   <listitem>
    <para>
     completed rpc_task
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>stats</parameter></term>
   <listitem>
    <para>
     array of stat structures
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Relies on the caller for serialization.
</para>
</refsect1>
</refentry>

<!-- net/sunrpc/rpc_pipe.c -->
<refentry id="API-rpc-queue-upcall">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>rpc_queue_upcall</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>rpc_queue_upcall</refname>
 <refpurpose>
  queue an upcall message to userspace
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>rpc_queue_upcall </function></funcdef>
   <paramdef>struct rpc_pipe * <parameter>pipe</parameter></paramdef>
   <paramdef>struct rpc_pipe_msg * <parameter>msg</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>pipe</parameter></term>
   <listitem>
    <para>
     upcall pipe on which to queue given message
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>msg</parameter></term>
   <listitem>
    <para>
     message to queue
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Call with an <parameter>inode</parameter> created by <function>rpc_mkpipe</function> to queue an upcall.
   A userspace process may then later read the upcall by performing a
   read on an open file for this inode.  It is up to the caller to
   initialize the fields of <parameter>msg</parameter> (other than <parameter>msg</parameter>-&gt;list) appropriately.
</para>
</refsect1>
</refentry>

<refentry id="API-rpc-mkpipe-dentry">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>rpc_mkpipe_dentry</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>rpc_mkpipe_dentry</refname>
 <refpurpose>
     make an rpc_pipefs file for kernel&lt;-&gt;userspace communication
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct dentry * <function>rpc_mkpipe_dentry </function></funcdef>
   <paramdef>struct dentry * <parameter>parent</parameter></paramdef>
   <paramdef>const char * <parameter>name</parameter></paramdef>
   <paramdef>void * <parameter>private</parameter></paramdef>
   <paramdef>struct rpc_pipe * <parameter>pipe</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>parent</parameter></term>
   <listitem>
    <para>
     dentry of directory to create new <quote>pipe</quote> in
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>name</parameter></term>
   <listitem>
    <para>
     name of pipe
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>private</parameter></term>
   <listitem>
    <para>
     private data to associate with the pipe, for the caller's use
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>pipe</parameter></term>
   <listitem>
    <para>
     <structname>rpc_pipe</structname> containing input parameters
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Data is made available for userspace to read by calls to
   <function>rpc_queue_upcall</function>.  The actual reads will result in calls to
   <parameter>ops</parameter>-&gt;upcall, which will be called with the file pointer,
   message, and userspace buffer to copy to.
   </para><para>

   Writes can come at any time, and do not necessarily have to be
   responses to upcalls.  They will result in calls to <parameter>msg</parameter>-&gt;downcall.
   </para><para>

   The <parameter>private</parameter> argument passed here will be available to all these methods
   from the file pointer, via RPC_I(file_inode(file))-&gt;private.
</para>
</refsect1>
</refentry>

<refentry id="API-rpc-unlink">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>rpc_unlink</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>rpc_unlink</refname>
 <refpurpose>
     remove a pipe
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>rpc_unlink </function></funcdef>
   <paramdef>struct dentry * <parameter>dentry</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dentry</parameter></term>
   <listitem>
    <para>
     dentry for the pipe, as returned from rpc_mkpipe
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   After this call, lookups will no longer find the pipe, and any
   attempts to read or write using preexisting opens of the pipe will
   return -EPIPE.
</para>
</refsect1>
</refentry>

<refentry id="API-rpc-init-pipe-dir-head">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>rpc_init_pipe_dir_head</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>rpc_init_pipe_dir_head</refname>
 <refpurpose>
     initialise a struct rpc_pipe_dir_head
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>rpc_init_pipe_dir_head </function></funcdef>
   <paramdef>struct rpc_pipe_dir_head * <parameter>pdh</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>pdh</parameter></term>
   <listitem>
    <para>
     pointer to struct rpc_pipe_dir_head
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-rpc-init-pipe-dir-object">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>rpc_init_pipe_dir_object</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>rpc_init_pipe_dir_object</refname>
 <refpurpose>
     initialise a struct rpc_pipe_dir_object
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>rpc_init_pipe_dir_object </function></funcdef>
   <paramdef>struct rpc_pipe_dir_object * <parameter>pdo</parameter></paramdef>
   <paramdef>const struct rpc_pipe_dir_object_ops * <parameter>pdo_ops</parameter></paramdef>
   <paramdef>void * <parameter>pdo_data</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>pdo</parameter></term>
   <listitem>
    <para>
     pointer to struct rpc_pipe_dir_object
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>pdo_ops</parameter></term>
   <listitem>
    <para>
     pointer to const struct rpc_pipe_dir_object_ops
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>pdo_data</parameter></term>
   <listitem>
    <para>
     pointer to caller-defined data
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-rpc-add-pipe-dir-object">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>rpc_add_pipe_dir_object</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>rpc_add_pipe_dir_object</refname>
 <refpurpose>
     associate a rpc_pipe_dir_object to a directory
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>rpc_add_pipe_dir_object </function></funcdef>
   <paramdef>struct net * <parameter>net</parameter></paramdef>
   <paramdef>struct rpc_pipe_dir_head * <parameter>pdh</parameter></paramdef>
   <paramdef>struct rpc_pipe_dir_object * <parameter>pdo</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>net</parameter></term>
   <listitem>
    <para>
     pointer to struct net
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>pdh</parameter></term>
   <listitem>
    <para>
     pointer to struct rpc_pipe_dir_head
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>pdo</parameter></term>
   <listitem>
    <para>
     pointer to struct rpc_pipe_dir_object
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-rpc-remove-pipe-dir-object">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>rpc_remove_pipe_dir_object</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>rpc_remove_pipe_dir_object</refname>
 <refpurpose>
     remove a rpc_pipe_dir_object from a directory
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>rpc_remove_pipe_dir_object </function></funcdef>
   <paramdef>struct net * <parameter>net</parameter></paramdef>
   <paramdef>struct rpc_pipe_dir_head * <parameter>pdh</parameter></paramdef>
   <paramdef>struct rpc_pipe_dir_object * <parameter>pdo</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>net</parameter></term>
   <listitem>
    <para>
     pointer to struct net
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>pdh</parameter></term>
   <listitem>
    <para>
     pointer to struct rpc_pipe_dir_head
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>pdo</parameter></term>
   <listitem>
    <para>
     pointer to struct rpc_pipe_dir_object
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-rpc-find-or-alloc-pipe-dir-object">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>rpc_find_or_alloc_pipe_dir_object</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>rpc_find_or_alloc_pipe_dir_object</refname>
 <refpurpose>
   </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct rpc_pipe_dir_object * <function>rpc_find_or_alloc_pipe_dir_object </function></funcdef>
   <paramdef>struct net * <parameter>net</parameter></paramdef>
   <paramdef>struct rpc_pipe_dir_head * <parameter>pdh</parameter></paramdef>
   <paramdef>int (*<parameter>match</parameter>)
     <funcparams>struct rpc_pipe_dir_object *, void *</funcparams></paramdef>
   <paramdef>struct rpc_pipe_dir_object *(*<parameter>alloc</parameter>)
     <funcparams>void *</funcparams></paramdef>
   <paramdef>void * <parameter>data</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>net</parameter></term>
   <listitem>
    <para>
     pointer to struct net
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>pdh</parameter></term>
   <listitem>
    <para>
     pointer to struct rpc_pipe_dir_head
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>match</parameter></term>
   <listitem>
    <para>
     match struct rpc_pipe_dir_object to data
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>alloc</parameter></term>
   <listitem>
    <para>
     allocate a new struct rpc_pipe_dir_object
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>data</parameter></term>
   <listitem>
    <para>
     user defined data for <function>match</function> and <function>alloc</function>
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<!-- net/sunrpc/rpcb_clnt.c -->
<refentry id="API-rpcb-getport-async">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>rpcb_getport_async</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>rpcb_getport_async</refname>
 <refpurpose>
  obtain the port for a given RPC service on a given host
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>rpcb_getport_async </function></funcdef>
   <paramdef>struct rpc_task * <parameter>task</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>task</parameter></term>
   <listitem>
    <para>
     task that is waiting for portmapper request
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This one can be called for an ongoing RPC request, and can be used in
   an async (rpciod) context.
</para>
</refsect1>
</refentry>

<!-- net/sunrpc/clnt.c -->
<refentry id="API-rpc-create">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>rpc_create</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>rpc_create</refname>
 <refpurpose>
  create an RPC client and transport with one call
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct rpc_clnt * <function>rpc_create </function></funcdef>
   <paramdef>struct rpc_create_args * <parameter>args</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>args</parameter></term>
   <listitem>
    <para>
     rpc_clnt create argument structure
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Creates and initializes an RPC transport and an RPC client.
   </para><para>

   It can ping the server in order to determine if it is up, and to see if
   it supports this program and version.  RPC_CLNT_CREATE_NOPING disables
   this behavior so asynchronous tasks can also use rpc_create.
</para>
</refsect1>
</refentry>

<refentry id="API-rpc-clone-client">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>rpc_clone_client</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>rpc_clone_client</refname>
 <refpurpose>
     Clone an RPC client structure
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct rpc_clnt * <function>rpc_clone_client </function></funcdef>
   <paramdef>struct rpc_clnt * <parameter>clnt</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>clnt</parameter></term>
   <listitem>
    <para>
     RPC client whose parameters are copied
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Returns a fresh RPC client or an ERR_PTR.
</para>
</refsect1>
</refentry>

<refentry id="API-rpc-clone-client-set-auth">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>rpc_clone_client_set_auth</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>rpc_clone_client_set_auth</refname>
 <refpurpose>
     Clone an RPC client structure and set its auth
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct rpc_clnt * <function>rpc_clone_client_set_auth </function></funcdef>
   <paramdef>struct rpc_clnt * <parameter>clnt</parameter></paramdef>
   <paramdef>rpc_authflavor_t <parameter>flavor</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>clnt</parameter></term>
   <listitem>
    <para>
     RPC client whose parameters are copied
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>flavor</parameter></term>
   <listitem>
    <para>
     security flavor for new client
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Returns a fresh RPC client or an ERR_PTR.
</para>
</refsect1>
</refentry>

<refentry id="API-rpc-switch-client-transport">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>rpc_switch_client_transport</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>rpc_switch_client_transport</refname>
 <refpurpose>
   </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>rpc_switch_client_transport </function></funcdef>
   <paramdef>struct rpc_clnt * <parameter>clnt</parameter></paramdef>
   <paramdef>struct xprt_create * <parameter>args</parameter></paramdef>
   <paramdef>const struct rpc_timeout * <parameter>timeout</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>clnt</parameter></term>
   <listitem>
    <para>
     pointer to a struct rpc_clnt
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>args</parameter></term>
   <listitem>
    <para>
     pointer to the new transport arguments
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>timeout</parameter></term>
   <listitem>
    <para>
     pointer to the new timeout parameters
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This function allows the caller to switch the RPC transport for the
   rpc_clnt structure 'clnt' to allow it to connect to a mirrored NFS
   server, for instance.  It assumes that the caller has ensured that
   there are no active RPC tasks by using some form of locking.
   </para><para>

   Returns zero if <quote>clnt</quote> is now using the new xprt.  Otherwise a
   negative errno is returned, and <quote>clnt</quote> continues to use the old
   xprt.
</para>
</refsect1>
</refentry>

<refentry id="API-rpc-bind-new-program">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>rpc_bind_new_program</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>rpc_bind_new_program</refname>
 <refpurpose>
     bind a new RPC program to an existing client
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct rpc_clnt * <function>rpc_bind_new_program </function></funcdef>
   <paramdef>struct rpc_clnt * <parameter>old</parameter></paramdef>
   <paramdef>const struct rpc_program * <parameter>program</parameter></paramdef>
   <paramdef>u32 <parameter>vers</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>old</parameter></term>
   <listitem>
    <para>
     old rpc_client
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>program</parameter></term>
   <listitem>
    <para>
     rpc program to set
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>vers</parameter></term>
   <listitem>
    <para>
     rpc program version
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Clones the rpc client and sets up a new RPC program. This is mainly
   of use for enabling different RPC programs to share the same transport.
   The Sun NFSv2/v3 ACL protocol can do this.
</para>
</refsect1>
</refentry>

<refentry id="API-rpc-run-task">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>rpc_run_task</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>rpc_run_task</refname>
 <refpurpose>
     Allocate a new RPC task, then run rpc_execute against it
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct rpc_task * <function>rpc_run_task </function></funcdef>
   <paramdef>const struct rpc_task_setup * <parameter>task_setup_data</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>task_setup_data</parameter></term>
   <listitem>
    <para>
     pointer to task initialisation data
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-rpc-call-sync">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>rpc_call_sync</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>rpc_call_sync</refname>
 <refpurpose>
     Perform a synchronous RPC call
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>rpc_call_sync </function></funcdef>
   <paramdef>struct rpc_clnt * <parameter>clnt</parameter></paramdef>
   <paramdef>const struct rpc_message * <parameter>msg</parameter></paramdef>
   <paramdef>int <parameter>flags</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>clnt</parameter></term>
   <listitem>
    <para>
     pointer to RPC client
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>msg</parameter></term>
   <listitem>
    <para>
     RPC call parameters
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>flags</parameter></term>
   <listitem>
    <para>
     RPC call flags
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-rpc-call-async">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>rpc_call_async</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>rpc_call_async</refname>
 <refpurpose>
     Perform an asynchronous RPC call
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>rpc_call_async </function></funcdef>
   <paramdef>struct rpc_clnt * <parameter>clnt</parameter></paramdef>
   <paramdef>const struct rpc_message * <parameter>msg</parameter></paramdef>
   <paramdef>int <parameter>flags</parameter></paramdef>
   <paramdef>const struct rpc_call_ops * <parameter>tk_ops</parameter></paramdef>
   <paramdef>void * <parameter>data</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>clnt</parameter></term>
   <listitem>
    <para>
     pointer to RPC client
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>msg</parameter></term>
   <listitem>
    <para>
     RPC call parameters
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>flags</parameter></term>
   <listitem>
    <para>
     RPC call flags
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>tk_ops</parameter></term>
   <listitem>
    <para>
     RPC call ops
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>data</parameter></term>
   <listitem>
    <para>
     user call data
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-rpc-peeraddr">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>rpc_peeraddr</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>rpc_peeraddr</refname>
 <refpurpose>
     extract remote peer address from clnt's xprt
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>size_t <function>rpc_peeraddr </function></funcdef>
   <paramdef>struct rpc_clnt * <parameter>clnt</parameter></paramdef>
   <paramdef>struct sockaddr * <parameter>buf</parameter></paramdef>
   <paramdef>size_t <parameter>bufsize</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>clnt</parameter></term>
   <listitem>
    <para>
     RPC client structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>buf</parameter></term>
   <listitem>
    <para>
     target buffer
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>bufsize</parameter></term>
   <listitem>
    <para>
     length of target buffer
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Returns the number of bytes that are actually in the stored address.
</para>
</refsect1>
</refentry>

<refentry id="API-rpc-peeraddr2str">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>rpc_peeraddr2str</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>rpc_peeraddr2str</refname>
 <refpurpose>
     return remote peer address in printable format
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>const char * <function>rpc_peeraddr2str </function></funcdef>
   <paramdef>struct rpc_clnt * <parameter>clnt</parameter></paramdef>
   <paramdef>enum rpc_display_format_t <parameter>format</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>clnt</parameter></term>
   <listitem>
    <para>
     RPC client structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>format</parameter></term>
   <listitem>
    <para>
     address format
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>NB</title>
<para>
   the lifetime of the memory referenced by the returned pointer is
   the same as the rpc_xprt itself.  As long as the caller uses this
   pointer, it must hold the RCU read lock.
</para>
</refsect1>
</refentry>

<refentry id="API-rpc-localaddr">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>rpc_localaddr</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>rpc_localaddr</refname>
 <refpurpose>
     discover local endpoint address for an RPC client
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>rpc_localaddr </function></funcdef>
   <paramdef>struct rpc_clnt * <parameter>clnt</parameter></paramdef>
   <paramdef>struct sockaddr * <parameter>buf</parameter></paramdef>
   <paramdef>size_t <parameter>buflen</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>clnt</parameter></term>
   <listitem>
    <para>
     RPC client structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>buf</parameter></term>
   <listitem>
    <para>
     target buffer
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>buflen</parameter></term>
   <listitem>
    <para>
     size of target buffer, in bytes
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Returns zero and fills in <quote>buf</quote> and <quote>buflen</quote> if successful;
   otherwise, a negative errno is returned.
   </para><para>

   This works even if the underlying transport is not currently connected,
   or if the upper layer never previously provided a source address.
</para>
</refsect1>
<refsect1>
<title>The result of this function call is transient</title>
<para>
   multiple calls in
   succession may give different results, depending on how local
   networking configuration changes over time.
</para>
</refsect1>
</refentry>

<refentry id="API-rpc-protocol">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>rpc_protocol</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>rpc_protocol</refname>
 <refpurpose>
     Get transport protocol number for an RPC client
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>rpc_protocol </function></funcdef>
   <paramdef>struct rpc_clnt * <parameter>clnt</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>clnt</parameter></term>
   <listitem>
    <para>
     RPC client to query
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-rpc-net-ns">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>rpc_net_ns</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>rpc_net_ns</refname>
 <refpurpose>
     Get the network namespace for this RPC client
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct net * <function>rpc_net_ns </function></funcdef>
   <paramdef>struct rpc_clnt * <parameter>clnt</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>clnt</parameter></term>
   <listitem>
    <para>
     RPC client to query
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-rpc-max-payload">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>rpc_max_payload</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>rpc_max_payload</refname>
 <refpurpose>
     Get maximum payload size for a transport, in bytes
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>size_t <function>rpc_max_payload </function></funcdef>
   <paramdef>struct rpc_clnt * <parameter>clnt</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>clnt</parameter></term>
   <listitem>
    <para>
     RPC client to query
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   For stream transports, this is one RPC record fragment (see RFC
   1831), as we don't support multi-record requests yet.  For datagram
   transports, this is the size of an IP packet minus the IP, UDP, and
   RPC header sizes.
</para>
</refsect1>
</refentry>

<refentry id="API-rpc-get-timeout">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>rpc_get_timeout</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>rpc_get_timeout</refname>
 <refpurpose>
     Get timeout for transport in units of HZ
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>unsigned long <function>rpc_get_timeout </function></funcdef>
   <paramdef>struct rpc_clnt * <parameter>clnt</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>clnt</parameter></term>
   <listitem>
    <para>
     RPC client to query
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-rpc-force-rebind">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>rpc_force_rebind</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>rpc_force_rebind</refname>
 <refpurpose>
     force transport to check that remote port is unchanged
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>rpc_force_rebind </function></funcdef>
   <paramdef>struct rpc_clnt * <parameter>clnt</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>clnt</parameter></term>
   <listitem>
    <para>
     client to rebind
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

     </sect1>
     <sect1><title>WiMAX</title>
<!-- net/wimax/op-msg.c -->
<refentry id="API-wimax-msg-alloc">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>wimax_msg_alloc</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>wimax_msg_alloc</refname>
 <refpurpose>
  Create a new skb for sending a message to userspace
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct sk_buff * <function>wimax_msg_alloc </function></funcdef>
   <paramdef>struct wimax_dev * <parameter>wimax_dev</parameter></paramdef>
   <paramdef>const char * <parameter>pipe_name</parameter></paramdef>
   <paramdef>const void * <parameter>msg</parameter></paramdef>
   <paramdef>size_t <parameter>size</parameter></paramdef>
   <paramdef>gfp_t <parameter>gfp_flags</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>wimax_dev</parameter></term>
   <listitem>
    <para>
     WiMAX device descriptor
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>pipe_name</parameter></term>
   <listitem>
    <para>
     "named pipe" the message will be sent to
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>msg</parameter></term>
   <listitem>
    <para>
     pointer to the message data to send
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>size</parameter></term>
   <listitem>
    <para>
     size of the message to send (in bytes), including the header.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>gfp_flags</parameter></term>
   <listitem>
    <para>
     flags for memory allocation.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Returns</title>
<para>
   <constant>0</constant> if ok, negative errno code on error
</para>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   </para><para>

   Allocates an skb that will contain the message to send to user
   space over the messaging pipe and initializes it, copying the
   payload.
   </para><para>

   Once this call is done, you can deliver it with
   <function>wimax_msg_send</function>.
</para>
</refsect1>
<refsect1>
<title>IMPORTANT</title>
<para>
   </para><para>

   Don't use <function>skb_push</function>/<function>skb_pull</function>/<function>skb_reserve</function> on the skb, as
   <function>wimax_msg_send</function> depends on skb-&gt;data being placed at the
   beginning of the user message.
   </para><para>

   Unlike other WiMAX stack calls, this call can be used way early,
   even before <function>wimax_dev_add</function> is called, as long as the
   wimax_dev-&gt;net_dev pointer is set to point to a proper
   net_dev. This is so that drivers can use it early in case they need
   to send stuff around or communicate with user space.
</para>
</refsect1>
</refentry>

<refentry id="API-wimax-msg-data-len">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>wimax_msg_data_len</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>wimax_msg_data_len</refname>
 <refpurpose>
     Return a pointer and size of a message's payload
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>const void * <function>wimax_msg_data_len </function></funcdef>
   <paramdef>struct sk_buff * <parameter>msg</parameter></paramdef>
   <paramdef>size_t * <parameter>size</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>msg</parameter></term>
   <listitem>
    <para>
     Pointer to a message created with <function>wimax_msg_alloc</function>
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>size</parameter></term>
   <listitem>
    <para>
     Pointer to where to store the message's size
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Returns the pointer to the message data.
</para>
</refsect1>
</refentry>

<refentry id="API-wimax-msg-data">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>wimax_msg_data</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>wimax_msg_data</refname>
 <refpurpose>
     Return a pointer to a message's payload
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>const void * <function>wimax_msg_data </function></funcdef>
   <paramdef>struct sk_buff * <parameter>msg</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>msg</parameter></term>
   <listitem>
    <para>
     Pointer to a message created with <function>wimax_msg_alloc</function>
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-wimax-msg-len">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>wimax_msg_len</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>wimax_msg_len</refname>
 <refpurpose>
     Return a message's payload length
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>ssize_t <function>wimax_msg_len </function></funcdef>
   <paramdef>struct sk_buff * <parameter>msg</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>msg</parameter></term>
   <listitem>
    <para>
     Pointer to a message created with <function>wimax_msg_alloc</function>
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-wimax-msg-send">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>wimax_msg_send</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>wimax_msg_send</refname>
 <refpurpose>
     Send a pre-allocated message to user space
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>wimax_msg_send </function></funcdef>
   <paramdef>struct wimax_dev * <parameter>wimax_dev</parameter></paramdef>
   <paramdef>struct sk_buff * <parameter>skb</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>wimax_dev</parameter></term>
   <listitem>
    <para>
     WiMAX device descriptor
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>skb</parameter></term>
   <listitem>
    <para>
     <structname>struct sk_buff</structname> returned by <function>wimax_msg_alloc</function>. Note the
     ownership of <parameter>skb</parameter> is transferred to this function.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Returns</title>
<para>
   0 if ok, &lt; 0 errno code on error
</para>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   </para><para>

   Sends a free-form message that was preallocated with
   <function>wimax_msg_alloc</function> and filled up.
   </para><para>

   Assumes that once you pass an skb to this function for sending, it
   owns it and will release it when done (on success).
</para>
</refsect1>
<refsect1>
<title>IMPORTANT</title>
<para>
   </para><para>

   Don't use <function>skb_push</function>/<function>skb_pull</function>/<function>skb_reserve</function> on the skb, as
   <function>wimax_msg_send</function> depends on skb-&gt;data being placed at the
   beginning of the user message.
   </para><para>

   Unlike other WiMAX stack calls, this call can be used way early,
   even before <function>wimax_dev_add</function> is called, as long as the
   wimax_dev-&gt;net_dev pointer is set to point to a proper
   net_dev. This is so that drivers can use it early in case they need
   to send stuff around or communicate with user space.
</para>
</refsect1>
</refentry>

<refentry id="API-wimax-msg">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>wimax_msg</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>wimax_msg</refname>
 <refpurpose>
     Send a message to user space
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>wimax_msg </function></funcdef>
   <paramdef>struct wimax_dev * <parameter>wimax_dev</parameter></paramdef>
   <paramdef>const char * <parameter>pipe_name</parameter></paramdef>
   <paramdef>const void * <parameter>buf</parameter></paramdef>
   <paramdef>size_t <parameter>size</parameter></paramdef>
   <paramdef>gfp_t <parameter>gfp_flags</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>wimax_dev</parameter></term>
   <listitem>
    <para>
     WiMAX device descriptor (properly referenced)
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>pipe_name</parameter></term>
   <listitem>
    <para>
     "named pipe" the message will be sent to
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>buf</parameter></term>
   <listitem>
    <para>
     pointer to the message to send.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>size</parameter></term>
   <listitem>
    <para>
     size of the buffer pointed to by <parameter>buf</parameter> (in bytes).
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>gfp_flags</parameter></term>
   <listitem>
    <para>
     flags for memory allocation.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Returns</title>
<para>
   <constant>0</constant> if ok, negative errno code on error.
</para>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   </para><para>

   Sends a free-form message to user space on the device <parameter>wimax_dev</parameter>.
</para>
</refsect1>
<refsect1>
<title>NOTES</title>
<para>
   </para><para>

   Once the <parameter>skb</parameter> is given to this function, who will own it and will
   release it when done (unless it returns error).
</para>
</refsect1>
</refentry>

<!-- net/wimax/op-reset.c -->
<refentry id="API-wimax-reset">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>wimax_reset</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>wimax_reset</refname>
 <refpurpose>
  Reset a WiMAX device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>wimax_reset </function></funcdef>
   <paramdef>struct wimax_dev * <parameter>wimax_dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>wimax_dev</parameter></term>
   <listitem>
    <para>
     WiMAX device descriptor
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Returns</title>
<para>
   </para><para>

   <constant>0</constant> if ok and a warm reset was done (the device still exists in
   the system).
   </para><para>

   -<constant>ENODEV</constant> if a cold/bus reset had to be done (device has
   disconnected and reconnected, so current handle is not valid
   any more).
   </para><para>

   -<constant>EINVAL</constant> if the device is not even registered.
   </para><para>

   Any other negative error code shall be considered as
   non-recoverable.
</para>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   </para><para>

   Called when wanting to reset the device for any reason. Device is
   taken back to power on status.
   </para><para>

   This call blocks; on successful return, the device has completed the
   reset process and is ready to operate.
</para>
</refsect1>
</refentry>

<!-- net/wimax/op-rfkill.c -->
<refentry id="API-wimax-report-rfkill-hw">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>wimax_report_rfkill_hw</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>wimax_report_rfkill_hw</refname>
 <refpurpose>
  Reports changes in the hardware RF switch
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>wimax_report_rfkill_hw </function></funcdef>
   <paramdef>struct wimax_dev * <parameter>wimax_dev</parameter></paramdef>
   <paramdef>enum wimax_rf_state <parameter>state</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>wimax_dev</parameter></term>
   <listitem>
    <para>
     WiMAX device descriptor
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>state</parameter></term>
   <listitem>
    <para>
     New state of the RF Kill switch. <constant>WIMAX_RF_ON</constant> radio on,
     <constant>WIMAX_RF_OFF</constant> radio off.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   When the device detects a change in the state of thehardware RF
   switch, it must call this function to let the WiMAX kernel stack
   know that the state has changed so it can be properly propagated.
   </para><para>

   The WiMAX stack caches the state (the driver doesn't need to). As
   well, as the change is propagated it will come back as a request to
   change the software state to mirror the hardware state.
   </para><para>

   If the device doesn't have a hardware kill switch, just report
   it on initialization as always on (<constant>WIMAX_RF_ON</constant>, radio on).
</para>
</refsect1>
</refentry>

<refentry id="API-wimax-report-rfkill-sw">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>wimax_report_rfkill_sw</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>wimax_report_rfkill_sw</refname>
 <refpurpose>
     Reports changes in the software RF switch
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>wimax_report_rfkill_sw </function></funcdef>
   <paramdef>struct wimax_dev * <parameter>wimax_dev</parameter></paramdef>
   <paramdef>enum wimax_rf_state <parameter>state</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>wimax_dev</parameter></term>
   <listitem>
    <para>
     WiMAX device descriptor
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>state</parameter></term>
   <listitem>
    <para>
     New state of the RF kill switch. <constant>WIMAX_RF_ON</constant> radio on,
     <constant>WIMAX_RF_OFF</constant> radio off.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Reports changes in the software RF switch state to the the WiMAX
   stack.
   </para><para>

   The main use is during initialization, so the driver can query the
   device for its current software radio kill switch state and feed it
   to the system.
   </para><para>

   On the side, the device does not change the software state by
   itself. In practice, this can happen, as the device might decide to
   switch (in software) the radio off for different reasons.
</para>
</refsect1>
</refentry>

<refentry id="API-wimax-rfkill">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>wimax_rfkill</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>wimax_rfkill</refname>
 <refpurpose>
     Set the software RF switch state for a WiMAX device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>wimax_rfkill </function></funcdef>
   <paramdef>struct wimax_dev * <parameter>wimax_dev</parameter></paramdef>
   <paramdef>enum wimax_rf_state <parameter>state</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>wimax_dev</parameter></term>
   <listitem>
    <para>
     WiMAX device descriptor
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>state</parameter></term>
   <listitem>
    <para>
     New RF state.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Returns</title>
<para>
   </para><para>

   &gt;= 0 toggle state if ok, &lt; 0 errno code on error. The toggle state
   is returned as a bitmap, bit 0 being the hardware RF state, bit 1
   the software RF state.
   </para><para>

   0 means disabled (<constant>WIMAX_RF_ON</constant>, radio on), 1 means enabled radio
   off (<constant>WIMAX_RF_OFF</constant>).
</para>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   </para><para>

   Called by the user when he wants to request the WiMAX radio to be
   switched on (<constant>WIMAX_RF_ON</constant>) or off (<constant>WIMAX_RF_OFF</constant>). With
   <constant>WIMAX_RF_QUERY</constant>, just the current state is returned.
</para>
</refsect1>
<refsect1>
<title>NOTE</title>
<para>
   </para><para>

   This call will block until the operation is complete.
</para>
</refsect1>
</refentry>

<!-- net/wimax/stack.c -->
<refentry id="API-wimax-state-change">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>wimax_state_change</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>wimax_state_change</refname>
 <refpurpose>
  Set the current state of a WiMAX device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>wimax_state_change </function></funcdef>
   <paramdef>struct wimax_dev * <parameter>wimax_dev</parameter></paramdef>
   <paramdef>enum wimax_st <parameter>new_state</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>wimax_dev</parameter></term>
   <listitem>
    <para>
     WiMAX device descriptor (properly referenced)
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>new_state</parameter></term>
   <listitem>
    <para>
     New state to switch to
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This implements the state changes for the wimax devices. It will
   </para><para>

   - verify that the state transition is legal (for now it'll just
   print a warning if not) according to the table in
   linux/wimax.h's documentation for 'enum wimax_st'.
   </para><para>

   - perform the actions needed for leaving the current state and
   whichever are needed for entering the new state.
   </para><para>

   - issue a report to user space indicating the new state (and an
   optional payload with information about the new state).
</para>
</refsect1>
<refsect1>
<title>NOTE</title>
<para>
   <parameter>wimax_dev</parameter> must be locked
</para>
</refsect1>
</refentry>

<refentry id="API-wimax-state-get">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>wimax_state_get</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>wimax_state_get</refname>
 <refpurpose>
     Return the current state of a WiMAX device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>enum wimax_st <function>wimax_state_get </function></funcdef>
   <paramdef>struct wimax_dev * <parameter>wimax_dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>wimax_dev</parameter></term>
   <listitem>
    <para>
     WiMAX device descriptor
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Returns</title>
<para>
   Current state of the device according to its driver.
</para>
</refsect1>
</refentry>

<refentry id="API-wimax-dev-init">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>wimax_dev_init</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>wimax_dev_init</refname>
 <refpurpose>
     initialize a newly allocated instance
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>wimax_dev_init </function></funcdef>
   <paramdef>struct wimax_dev * <parameter>wimax_dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>wimax_dev</parameter></term>
   <listitem>
    <para>
     WiMAX device descriptor to initialize.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Initializes fields of a freshly allocated <parameter>wimax_dev</parameter> instance. This
   function assumes that after allocation, the memory occupied by
   <parameter>wimax_dev</parameter> was zeroed.
</para>
</refsect1>
</refentry>

<refentry id="API-wimax-dev-add">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>wimax_dev_add</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>wimax_dev_add</refname>
 <refpurpose>
     Register a new WiMAX device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>wimax_dev_add </function></funcdef>
   <paramdef>struct wimax_dev * <parameter>wimax_dev</parameter></paramdef>
   <paramdef>struct net_device * <parameter>net_dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>wimax_dev</parameter></term>
   <listitem>
    <para>
     WiMAX device descriptor (as embedded in your <parameter>net_dev</parameter>'s
     priv data). You must have called <function>wimax_dev_init</function> on it before.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>net_dev</parameter></term>
   <listitem>
    <para>
     net device the <parameter>wimax_dev</parameter> is associated with. The
     function expects <function>SET_NETDEV_DEV</function> and <function>register_netdev</function> were
     already called on it.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Registers the new WiMAX device, sets up the user-kernel control
   interface (generic netlink) and common WiMAX infrastructure.
   </para><para>

   Note that the parts that will allow interaction with user space are
   setup at the very end, when the rest is in place, as once that
   happens, the driver might get user space control requests via
   netlink or from debugfs that might translate into calls into
   wimax_dev-&gt;op_*().
</para>
</refsect1>
</refentry>

<refentry id="API-wimax-dev-rm">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>wimax_dev_rm</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>wimax_dev_rm</refname>
 <refpurpose>
     Unregister an existing WiMAX device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>wimax_dev_rm </function></funcdef>
   <paramdef>struct wimax_dev * <parameter>wimax_dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>wimax_dev</parameter></term>
   <listitem>
    <para>
     WiMAX device descriptor
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Unregisters a WiMAX device previously registered for use with
   <function>wimax_add_rm</function>.
   </para><para>

   IMPORTANT! Must call before calling <function>unregister_netdev</function>.
   </para><para>

   After this function returns, you will not get any more user space
   control requests (via netlink or debugfs) and thus to wimax_dev-&gt;ops.
   </para><para>

   Reentrancy control is ensured by setting the state to
   <constant>__WIMAX_ST_QUIESCING</constant>. rfkill operations coming through
   wimax_*rfkill*() will be stopped by the quiescing state; ops coming
   from the rfkill subsystem will be stopped by the support being
   removed by <function>wimax_rfkill_rm</function>.
</para>
</refsect1>
</refentry>

<!-- include/net/wimax.h -->
<refentry id="API-struct-wimax-dev">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct wimax_dev</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct wimax_dev</refname>
 <refpurpose>
  Generic WiMAX device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct wimax_dev {
  struct net_device * net_dev;
  struct list_head id_table_node;
  struct mutex mutex;
  struct mutex mutex_reset;
  enum wimax_st state;
  int (* op_msg_from_user) (struct wimax_dev *wimax_dev,const char *,const void *, size_t,const struct genl_info *info);
  int (* op_rfkill_sw_toggle) (struct wimax_dev *wimax_dev,enum wimax_rf_state);
  int (* op_reset) (struct wimax_dev *wimax_dev);
  struct rfkill * rfkill;
  unsigned int rf_hw;
  unsigned int rf_sw;
  char name[32];
  struct dentry * debugfs_dentry;
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>net_dev</term>
      <listitem><para>
[fill] Pointer to the <structname>struct net_device</structname> this WiMAX
device implements.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>id_table_node</term>
      <listitem><para>
[private] link to the list of wimax devices kept by
id-table.c. Protected by it's own spinlock.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>mutex</term>
      <listitem><para>
[private] Serializes all concurrent access and execution of
operations.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>mutex_reset</term>
      <listitem><para>
[private] Serializes reset operations. Needs to be a
different mutex because as part of the reset operation, the
driver has to call back into the stack to do things such as
state change, that require wimax_dev-&gt;mutex.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>state</term>
      <listitem><para>
[private] Current state of the WiMAX device.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>op_msg_from_user</term>
      <listitem><para>
[fill] Driver-specific operation to
handle a raw message from user space to the driver. The
driver can send messages to user space using with
<function>wimax_msg_to_user</function>.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>op_rfkill_sw_toggle</term>
      <listitem><para>
[fill] Driver-specific operation to act on
userspace (or any other agent) requesting the WiMAX device to
change the RF Kill software switch (WIMAX_RF_ON or
WIMAX_RF_OFF).
If such hardware support is not present, it is assumed the
radio cannot be switched off and it is always on (and the stack
will error out when trying to switch it off). In such case,
this function pointer can be left as NULL.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>op_reset</term>
      <listitem><para>
[fill] Driver specific operation to reset the
device.
This operation should always attempt first a warm reset that
does not disconnect the device from the bus and return 0.
If that fails, it should resort to some sort of cold or bus
reset (even if it implies a bus disconnection and device
disappearance). In that case, -ENODEV should be returned to
indicate the device is gone.
This operation has to be synchronous, and return only when the
reset is complete. In case of having had to resort to bus/cold
reset implying a device disconnection, the call is allowed to
return immediately.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>rfkill</term>
      <listitem><para>
[private] integration into the RF-Kill infrastructure.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>rf_hw</term>
      <listitem><para>
[private] State of the hardware radio switch (OFF/ON)
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>rf_sw</term>
      <listitem><para>
[private] State of the software radio switch (OFF/ON)
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>name[32]</term>
      <listitem><para>
[fill] A way to identify this device. We need to register a
name with many subsystems (rfkill, workqueue creation, etc).
We can't use the network device name as that
might change and in some instances we don't know it yet (until
we don't call <function>register_netdev</function>). So we generate an unique one
using the driver name and device bus id, place it here and use
it across the board. Recommended naming:
DRIVERNAME-BUSNAME:BUSID (dev-&gt;bus-&gt;name, dev-&gt;bus_id).
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>debugfs_dentry</term>
      <listitem><para>
[private] Used to hook up a debugfs entry. This
shows up in the debugfs root as wimax\:DEVICENAME.
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
<refsect1>
<title>NOTE</title>
<para>
   wimax_dev-&gt;mutex is NOT locked when this op is being
   called; however, wimax_dev-&gt;mutex_reset IS locked to ensure
   serialization of calls to <function>wimax_reset</function>.
   See <function>wimax_reset</function>'s documentation.
</para>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This structure defines a common interface to access all WiMAX
   devices from different vendors and provides a common API as well as
   a free-form device-specific messaging channel.
</para>
</refsect1>
<refsect1>
<title>Usage</title>
<para>
   1. Embed a <structname>struct wimax_dev</structname> at *the beginning* the network
   device structure so that <function>netdev_priv</function> points to it.
   </para><para>

   2. <function>memset</function> it to zero
   </para><para>

   3. Initialize with <function>wimax_dev_init</function>. This will leave the WiMAX
   device in the <constant>__WIMAX_ST_NULL</constant> state.
   </para><para>

   4. Fill all the fields marked with [fill]; once called
   <function>wimax_dev_add</function>, those fields CANNOT be modified.
   </para><para>

   5. Call <function>wimax_dev_add</function> *after* registering the network
   device. This will leave the WiMAX device in the <constant>WIMAX_ST_DOWN</constant>
   state.
   Protect the driver's net_device-&gt;<function>open</function> against succeeding if
   the wimax device state is lower than <constant>WIMAX_ST_DOWN</constant>.
   </para><para>

   6. Select when the device is going to be turned on/initialized;
   for example, it could be initialized on 'ifconfig up' (when the
   netdev op '<function>open</function>' is called on the driver).
   </para><para>

   When the device is initialized (at `ifconfig up` time, or right
   after calling <function>wimax_dev_add</function> from <function>_probe</function>, make sure the
   following steps are taken
   </para><para>

   a. Move the device to <constant>WIMAX_ST_UNINITIALIZED</constant>. This is needed so
   some API calls that shouldn't work until the device is ready
   can be blocked.
   </para><para>

   b. Initialize the device. Make sure to turn the SW radio switch
   off and move the device to state <constant>WIMAX_ST_RADIO_OFF</constant> when
   done. When just initialized, a device should be left in RADIO
   OFF state until user space devices to turn it on.
   </para><para>

   c. Query the device for the state of the hardware rfkill switch
   and call <function>wimax_rfkill_report_hw</function> and <function>wimax_rfkill_report_sw</function>
   as needed. See below.
   </para><para>

   <function>wimax_dev_rm</function> undoes before unregistering the network device. Once
   <function>wimax_dev_add</function> is called, the driver can get called on the
   wimax_dev-&gt;op_* function pointers
</para>
</refsect1>
<refsect1>
<title>CONCURRENCY</title>
<para>
   </para><para>

   The stack provides a mutex for each device that will disallow API
   calls happening concurrently; thus, op calls into the driver
   through the wimax_dev-&gt;op*() function pointers will always be
   serialized and *never* concurrent.
   </para><para>

   For locking, take wimax_dev-&gt;mutex is taken; (most) operations in
   the API have to check for <function>wimax_dev_is_ready</function> to return 0 before
   continuing (this is done internally).
</para>
</refsect1>
<refsect1>
<title>REFERENCE COUNTING</title>
<para>
   </para><para>

   The WiMAX device is reference counted by the associated network
   device. The only operation that can be used to reference the device
   is <function>wimax_dev_get_by_genl_info</function>, and the reference it acquires has
   to be released with dev_put(wimax_dev-&gt;net_dev).
</para>
</refsect1>
<refsect1>
<title>RFKILL</title>
<para>
   </para><para>

   At startup, both HW and SW radio switchess are assumed to be off.
   </para><para>

   At initialization time [after calling <function>wimax_dev_add</function>], have the
   driver query the device for the status of the software and hardware
   RF kill switches and call <function>wimax_report_rfkill_hw</function> and
   <function>wimax_rfkill_report_sw</function> to indicate their state. If any is
   missing, just call it to indicate it is ON (radio always on).
   </para><para>

   Whenever the driver detects a change in the state of the RF kill
   switches, it should call <function>wimax_report_rfkill_hw</function> or
   <function>wimax_report_rfkill_sw</function> to report it to the stack.
</para>
</refsect1>
</refentry>

<!-- include/uapi/linux/wimax.h -->
<refentry id="API-enum-wimax-st">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>enum wimax_st</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>enum wimax_st</refname>
 <refpurpose>
  The different states of a WiMAX device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
enum wimax_st {
  __WIMAX_ST_NULL,
  WIMAX_ST_DOWN,
  __WIMAX_ST_QUIESCING,
  WIMAX_ST_UNINITIALIZED,
  WIMAX_ST_RADIO_OFF,
  WIMAX_ST_READY,
  WIMAX_ST_SCANNING,
  WIMAX_ST_CONNECTING,
  WIMAX_ST_CONNECTED,
  __WIMAX_ST_INVALID
};  </programlisting>
</refsynopsisdiv>
<refsect1>
 <title>Constants</title>
  <variablelist>
    <varlistentry>      <term>__WIMAX_ST_NULL</term>
      <listitem><para>
The device structure has been allocated and zeroed,
but still <function>wimax_dev_add</function> hasn't been called. There is no state.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>WIMAX_ST_DOWN</term>
      <listitem><para>
The device has been registered with the WiMAX and
networking stacks, but it is not initialized (normally that is
done with 'ifconfig DEV up' [or equivalent], which can upload
firmware and enable communications with the device).
In this state, the device is powered down and using as less
power as possible.
This state is the default after a call to <function>wimax_dev_add</function>. It
is ok to have drivers move directly to <constant>WIMAX_ST_UNINITIALIZED</constant>
or <constant>WIMAX_ST_RADIO_OFF</constant> in <function>_probe</function> after the call to
<function>wimax_dev_add</function>.
It is recommended that the driver leaves this state when
calling 'ifconfig DEV up' and enters it back on 'ifconfig DEV
down'.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>__WIMAX_ST_QUIESCING</term>
      <listitem><para>
The device is being torn down, so no API
operations are allowed to proceed except the ones needed to
complete the device clean up process.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>WIMAX_ST_UNINITIALIZED</term>
      <listitem><para>
[optional] Communication with the device
is setup, but the device still requires some configuration
before being operational.
Some WiMAX API calls might work.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>WIMAX_ST_RADIO_OFF</term>
      <listitem><para>
The device is fully up; radio is off (wether
by hardware or software switches).
It is recommended to always leave the device in this state
after initialization.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>WIMAX_ST_READY</term>
      <listitem><para>
The device is fully up and radio is on.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>WIMAX_ST_SCANNING</term>
      <listitem><para>
[optional] The device has been instructed to
scan. In this state, the device cannot be actively connected to
a network.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>WIMAX_ST_CONNECTING</term>
      <listitem><para>
The device is connecting to a network. This
state exists because in some devices, the connect process can
include a number of negotiations between user space, kernel
space and the device. User space needs to know what the device
is doing. If the connect sequence in a device is atomic and
fast, the device can transition directly to CONNECTED
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>WIMAX_ST_CONNECTED</term>
      <listitem><para>
The device is connected to a network.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>__WIMAX_ST_INVALID</term>
      <listitem><para>
This is an invalid state used to mark the
maximum numeric value of states.
      </para></listitem>
    </varlistentry>
  </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   </para><para>

   Transitions from one state to another one are atomic and can only
   be caused in kernel space with <function>wimax_state_change</function>. To read the
   state, use <function>wimax_state_get</function>.
   </para><para>

   States starting with __ are internal and shall not be used or
   referred to by drivers or userspace. They look ugly, but that's the
   point -- if any use is made non-internal to the stack, it is easier
   to catch on review.
   </para><para>

   All API operations [with well defined exceptions] will take the
   device mutex before starting and then check the state. If the state
   is <constant>__WIMAX_ST_NULL</constant>, <constant>WIMAX_ST_DOWN</constant>, <constant>WIMAX_ST_UNINITIALIZED</constant> or
   <constant>__WIMAX_ST_QUIESCING</constant>, it will drop the lock and quit with
   -<constant>EINVAL</constant>, -<constant>ENOMEDIUM</constant>, -<constant>ENOTCONN</constant> or -<constant>ESHUTDOWN</constant>.
   </para><para>

   The order of the definitions is important, so we can do numerical
   comparisons (eg: &lt; <constant>WIMAX_ST_RADIO_OFF</constant> means the device is not ready
   to operate).
</para>
</refsect1>
</refentry>

     </sect1>
  </chapter>

  <chapter id="netdev">
     <title>Network device support</title>
     <sect1><title>Driver Support</title>
<!-- net/core/dev.c -->
<refentry id="API-dev-add-pack">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>dev_add_pack</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>dev_add_pack</refname>
 <refpurpose>
  add packet handler
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>dev_add_pack </function></funcdef>
   <paramdef>struct packet_type * <parameter>pt</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>pt</parameter></term>
   <listitem>
    <para>
     packet type declaration
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Add a protocol handler to the networking stack. The passed <structname>packet_type</structname>
   is linked into kernel lists and may not be freed until it has been
   removed from the kernel lists.
   </para><para>

   This call does not sleep therefore it can not
   guarantee all CPU's that are in middle of receiving packets
   will see the new packet type (until the next received packet).
</para>
</refsect1>
</refentry>

<refentry id="API---dev-remove-pack">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>__dev_remove_pack</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>__dev_remove_pack</refname>
 <refpurpose>
     remove packet handler
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>__dev_remove_pack </function></funcdef>
   <paramdef>struct packet_type * <parameter>pt</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>pt</parameter></term>
   <listitem>
    <para>
     packet type declaration
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Remove a protocol handler that was previously added to the kernel
   protocol handlers by <function>dev_add_pack</function>. The passed <structname>packet_type</structname> is removed
   from the kernel lists and can be freed or reused once this function
   returns.
   </para><para>

   The packet type might still be in use by receivers
   and must not be freed until after all the CPU's have gone
   through a quiescent state.
</para>
</refsect1>
</refentry>

<refentry id="API-dev-remove-pack">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>dev_remove_pack</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>dev_remove_pack</refname>
 <refpurpose>
     remove packet handler
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>dev_remove_pack </function></funcdef>
   <paramdef>struct packet_type * <parameter>pt</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>pt</parameter></term>
   <listitem>
    <para>
     packet type declaration
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Remove a protocol handler that was previously added to the kernel
   protocol handlers by <function>dev_add_pack</function>. The passed <structname>packet_type</structname> is removed
   from the kernel lists and can be freed or reused once this function
   returns.
   </para><para>

   This call sleeps to guarantee that no CPU is looking at the packet
   type after return.
</para>
</refsect1>
</refentry>

<refentry id="API-dev-add-offload">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>dev_add_offload</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>dev_add_offload</refname>
 <refpurpose>
     register offload handlers
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>dev_add_offload </function></funcdef>
   <paramdef>struct packet_offload * <parameter>po</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>po</parameter></term>
   <listitem>
    <para>
     protocol offload declaration
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Add protocol offload handlers to the networking stack. The passed
   <structname>proto_offload</structname> is linked into kernel lists and may not be freed until
   it has been removed from the kernel lists.
   </para><para>

   This call does not sleep therefore it can not
   guarantee all CPU's that are in middle of receiving packets
   will see the new offload handlers (until the next received packet).
</para>
</refsect1>
</refentry>

<refentry id="API-dev-remove-offload">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>dev_remove_offload</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>dev_remove_offload</refname>
 <refpurpose>
     remove packet offload handler
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>dev_remove_offload </function></funcdef>
   <paramdef>struct packet_offload * <parameter>po</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>po</parameter></term>
   <listitem>
    <para>
     packet offload declaration
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Remove a packet offload handler that was previously added to the kernel
   offload handlers by <function>dev_add_offload</function>. The passed <structname>offload_type</structname> is
   removed from the kernel lists and can be freed or reused once this
   function returns.
   </para><para>

   This call sleeps to guarantee that no CPU is looking at the packet
   type after return.
</para>
</refsect1>
</refentry>

<refentry id="API-netdev-boot-setup-check">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>netdev_boot_setup_check</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>netdev_boot_setup_check</refname>
 <refpurpose>
     check boot time settings
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>netdev_boot_setup_check </function></funcdef>
   <paramdef>struct net_device * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     the netdevice
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Check boot time settings for the device.
   The found settings are set for the device to be used
   later in the device probing.
   Returns 0 if no settings found, 1 if they are.
</para>
</refsect1>
</refentry>

<refentry id="API---dev-get-by-name">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>__dev_get_by_name</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>__dev_get_by_name</refname>
 <refpurpose>
     find a device by its name
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct net_device * <function>__dev_get_by_name </function></funcdef>
   <paramdef>struct net * <parameter>net</parameter></paramdef>
   <paramdef>const char * <parameter>name</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>net</parameter></term>
   <listitem>
    <para>
     the applicable net namespace
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>name</parameter></term>
   <listitem>
    <para>
     name to find
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Find an interface by name. Must be called under RTNL semaphore
   or <parameter>dev_base_lock</parameter>. If the name is found a pointer to the device
   is returned. If the name is not found then <constant>NULL</constant> is returned. The
   reference counters are not incremented so the caller must be
   careful with locks.
</para>
</refsect1>
</refentry>

<refentry id="API-dev-get-by-name-rcu">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>dev_get_by_name_rcu</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>dev_get_by_name_rcu</refname>
 <refpurpose>
     find a device by its name
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct net_device * <function>dev_get_by_name_rcu </function></funcdef>
   <paramdef>struct net * <parameter>net</parameter></paramdef>
   <paramdef>const char * <parameter>name</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>net</parameter></term>
   <listitem>
    <para>
     the applicable net namespace
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>name</parameter></term>
   <listitem>
    <para>
     name to find
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Find an interface by name.
   If the name is found a pointer to the device is returned.
   If the name is not found then <constant>NULL</constant> is returned.
   The reference counters are not incremented so the caller must be
   careful with locks. The caller must hold RCU lock.
</para>
</refsect1>
</refentry>

<refentry id="API-dev-get-by-name">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>dev_get_by_name</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>dev_get_by_name</refname>
 <refpurpose>
     find a device by its name
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct net_device * <function>dev_get_by_name </function></funcdef>
   <paramdef>struct net * <parameter>net</parameter></paramdef>
   <paramdef>const char * <parameter>name</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>net</parameter></term>
   <listitem>
    <para>
     the applicable net namespace
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>name</parameter></term>
   <listitem>
    <para>
     name to find
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Find an interface by name. This can be called from any
   context and does its own locking. The returned handle has
   the usage count incremented and the caller must use <function>dev_put</function> to
   release it when it is no longer needed. <constant>NULL</constant> is returned if no
   matching device is found.
</para>
</refsect1>
</refentry>

<refentry id="API---dev-get-by-index">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>__dev_get_by_index</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>__dev_get_by_index</refname>
 <refpurpose>
     find a device by its ifindex
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct net_device * <function>__dev_get_by_index </function></funcdef>
   <paramdef>struct net * <parameter>net</parameter></paramdef>
   <paramdef>int <parameter>ifindex</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>net</parameter></term>
   <listitem>
    <para>
     the applicable net namespace
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>ifindex</parameter></term>
   <listitem>
    <para>
     index of device
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Search for an interface by index. Returns <constant>NULL</constant> if the device
   is not found or a pointer to the device. The device has not
   had its reference counter increased so the caller must be careful
   about locking. The caller must hold either the RTNL semaphore
   or <parameter>dev_base_lock</parameter>.
</para>
</refsect1>
</refentry>

<refentry id="API-dev-get-by-index-rcu">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>dev_get_by_index_rcu</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>dev_get_by_index_rcu</refname>
 <refpurpose>
     find a device by its ifindex
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct net_device * <function>dev_get_by_index_rcu </function></funcdef>
   <paramdef>struct net * <parameter>net</parameter></paramdef>
   <paramdef>int <parameter>ifindex</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>net</parameter></term>
   <listitem>
    <para>
     the applicable net namespace
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>ifindex</parameter></term>
   <listitem>
    <para>
     index of device
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Search for an interface by index. Returns <constant>NULL</constant> if the device
   is not found or a pointer to the device. The device has not
   had its reference counter increased so the caller must be careful
   about locking. The caller must hold RCU lock.
</para>
</refsect1>
</refentry>

<refentry id="API-dev-get-by-index">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>dev_get_by_index</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>dev_get_by_index</refname>
 <refpurpose>
     find a device by its ifindex
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct net_device * <function>dev_get_by_index </function></funcdef>
   <paramdef>struct net * <parameter>net</parameter></paramdef>
   <paramdef>int <parameter>ifindex</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>net</parameter></term>
   <listitem>
    <para>
     the applicable net namespace
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>ifindex</parameter></term>
   <listitem>
    <para>
     index of device
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Search for an interface by index. Returns NULL if the device
   is not found or a pointer to the device. The device returned has
   had a reference added and the pointer is safe until the user calls
   dev_put to indicate they have finished with it.
</para>
</refsect1>
</refentry>

<refentry id="API-dev-getbyhwaddr-rcu">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>dev_getbyhwaddr_rcu</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>dev_getbyhwaddr_rcu</refname>
 <refpurpose>
     find a device by its hardware address
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct net_device * <function>dev_getbyhwaddr_rcu </function></funcdef>
   <paramdef>struct net * <parameter>net</parameter></paramdef>
   <paramdef>unsigned short <parameter>type</parameter></paramdef>
   <paramdef>const char * <parameter>ha</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>net</parameter></term>
   <listitem>
    <para>
     the applicable net namespace
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>type</parameter></term>
   <listitem>
    <para>
     media type of device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>ha</parameter></term>
   <listitem>
    <para>
     hardware address
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Search for an interface by MAC address. Returns NULL if the device
   is not found or a pointer to the device.
   The caller must hold RCU or RTNL.
   The returned device has not had its ref count increased
   and the caller must therefore be careful about locking
</para>
</refsect1>
</refentry>

<refentry id="API---dev-get-by-flags">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>__dev_get_by_flags</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>__dev_get_by_flags</refname>
 <refpurpose>
     find any device with given flags
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct net_device * <function>__dev_get_by_flags </function></funcdef>
   <paramdef>struct net * <parameter>net</parameter></paramdef>
   <paramdef>unsigned short <parameter>if_flags</parameter></paramdef>
   <paramdef>unsigned short <parameter>mask</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>net</parameter></term>
   <listitem>
    <para>
     the applicable net namespace
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>if_flags</parameter></term>
   <listitem>
    <para>
     IFF_* values
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>mask</parameter></term>
   <listitem>
    <para>
     bitmask of bits in if_flags to check
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Search for any interface with the given flags. Returns NULL if a device
   is not found or a pointer to the device. Must be called inside
   <function>rtnl_lock</function>, and result refcount is unchanged.
</para>
</refsect1>
</refentry>

<refentry id="API-dev-valid-name">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>dev_valid_name</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>dev_valid_name</refname>
 <refpurpose>
     check if name is okay for network device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>bool <function>dev_valid_name </function></funcdef>
   <paramdef>const char * <parameter>name</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>name</parameter></term>
   <listitem>
    <para>
     name string
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Network device names need to be valid file names to
   to allow sysfs to work.  We also disallow any kind of
   whitespace.
</para>
</refsect1>
</refentry>

<refentry id="API-dev-alloc-name">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>dev_alloc_name</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>dev_alloc_name</refname>
 <refpurpose>
     allocate a name for a device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>dev_alloc_name </function></funcdef>
   <paramdef>struct net_device * <parameter>dev</parameter></paramdef>
   <paramdef>const char * <parameter>name</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>name</parameter></term>
   <listitem>
    <para>
     name format string
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Passed a format string - eg <quote>lt<constant>d</constant></quote> it will try and find a suitable
   id. It scans list of devices to build up a free map, then chooses
   the first empty slot. The caller must hold the dev_base or rtnl lock
   while allocating the name and adding the device in order to avoid
   duplicates.
   Limited to bits_per_byte * page size devices (ie 32K on most platforms).
   Returns the number of the unit assigned or a negative errno code.
</para>
</refsect1>
</refentry>

<refentry id="API-netdev-features-change">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>netdev_features_change</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>netdev_features_change</refname>
 <refpurpose>
     device changes features
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>netdev_features_change </function></funcdef>
   <paramdef>struct net_device * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     device to cause notification
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Called to indicate a device has changed features.
</para>
</refsect1>
</refentry>

<refentry id="API-netdev-state-change">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>netdev_state_change</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>netdev_state_change</refname>
 <refpurpose>
     device changes state
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>netdev_state_change </function></funcdef>
   <paramdef>struct net_device * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     device to cause notification
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Called to indicate a device has changed state. This function calls
   the notifier chains for netdev_chain and sends a NEWLINK message
   to the routing socket.
</para>
</refsect1>
</refentry>

<refentry id="API-netdev-notify-peers">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>netdev_notify_peers</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>netdev_notify_peers</refname>
 <refpurpose>
     notify network peers about existence of <parameter>dev</parameter>
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>netdev_notify_peers </function></funcdef>
   <paramdef>struct net_device * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     network device
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Generate traffic such that interested network peers are aware of
   <parameter>dev</parameter>, such as by generating a gratuitous ARP. This may be used when
   a device wants to inform the rest of the network about some sort of
   reconfiguration such as a failover event or virtual machine
   migration.
</para>
</refsect1>
</refentry>

<refentry id="API-dev-open">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>dev_open</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>dev_open</refname>
 <refpurpose>
     prepare an interface for use.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>dev_open </function></funcdef>
   <paramdef>struct net_device * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     device to open
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Takes a device from down to up state. The device's private open
   function is invoked and then the multicast lists are loaded. Finally
   the device is moved into the up state and a <constant>NETDEV_UP</constant> message is
   sent to the netdev notifier chain.
   </para><para>

   Calling this function on an active interface is a nop. On a failure
   a negative errno code is returned.
</para>
</refsect1>
</refentry>

<refentry id="API-dev-close">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>dev_close</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>dev_close</refname>
 <refpurpose>
     shutdown an interface.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>dev_close </function></funcdef>
   <paramdef>struct net_device * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     device to shutdown
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This function moves an active device into down state. A
   <constant>NETDEV_GOING_DOWN</constant> is sent to the netdev notifier chain. The device
   is then deactivated and finally a <constant>NETDEV_DOWN</constant> is sent to the notifier
   chain.
</para>
</refsect1>
</refentry>

<refentry id="API-dev-disable-lro">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>dev_disable_lro</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>dev_disable_lro</refname>
 <refpurpose>
     disable Large Receive Offload on a device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>dev_disable_lro </function></funcdef>
   <paramdef>struct net_device * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     device
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Disable Large Receive Offload (LRO) on a net device.  Must be
   called under RTNL.  This is needed if received packets may be
   forwarded to another interface.
</para>
</refsect1>
</refentry>

<refentry id="API-register-netdevice-notifier">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>register_netdevice_notifier</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>register_netdevice_notifier</refname>
 <refpurpose>
     register a network notifier block
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>register_netdevice_notifier </function></funcdef>
   <paramdef>struct notifier_block * <parameter>nb</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>nb</parameter></term>
   <listitem>
    <para>
     notifier
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Register a notifier to be called when network device events occur.
   The notifier passed is linked into the kernel structures and must
   not be reused until it has been unregistered. A negative errno code
   is returned on a failure.
   </para><para>

   When registered all registration and up events are replayed
   to the new notifier to allow device to have a race free
   view of the network device list.
</para>
</refsect1>
</refentry>

<refentry id="API-unregister-netdevice-notifier">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>unregister_netdevice_notifier</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>unregister_netdevice_notifier</refname>
 <refpurpose>
     unregister a network notifier block
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>unregister_netdevice_notifier </function></funcdef>
   <paramdef>struct notifier_block * <parameter>nb</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>nb</parameter></term>
   <listitem>
    <para>
     notifier
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Unregister a notifier previously registered by
   <function>register_netdevice_notifier</function>. The notifier is unlinked into the
   kernel structures and may then be reused. A negative errno code
   is returned on a failure.
   </para><para>

   After unregistering unregister and down device events are synthesized
   for all devices on the device list to the removed notifier to remove
   the need for special case cleanup code.
</para>
</refsect1>
</refentry>

<refentry id="API-call-netdevice-notifiers">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>call_netdevice_notifiers</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>call_netdevice_notifiers</refname>
 <refpurpose>
     call all network notifier blocks
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>call_netdevice_notifiers </function></funcdef>
   <paramdef>unsigned long <parameter>val</parameter></paramdef>
   <paramdef>struct net_device * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>val</parameter></term>
   <listitem>
    <para>
     value passed unmodified to notifier function
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     net_device pointer passed unmodified to notifier function
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Call all network notifier blocks.  Parameters and return value
   are as for <function>raw_notifier_call_chain</function>.
</para>
</refsect1>
</refentry>

<refentry id="API-dev-forward-skb">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>dev_forward_skb</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>dev_forward_skb</refname>
 <refpurpose>
     loopback an skb to another netif
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>dev_forward_skb </function></funcdef>
   <paramdef>struct net_device * <parameter>dev</parameter></paramdef>
   <paramdef>struct sk_buff * <parameter>skb</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     destination network device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>skb</parameter></term>
   <listitem>
    <para>
     buffer to forward
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>return values</title>
<para>
   NET_RX_SUCCESS	(no congestion)
   NET_RX_DROP     (packet was dropped, but freed)
   </para><para>

   dev_forward_skb can be used for injecting an skb from the
   start_xmit function of one device into the receive queue
   of another device.
   </para><para>

   The receiving device may be in another namespace, so
   we have to clear all information in the skb that could
   impact namespace isolation.
</para>
</refsect1>
</refentry>

<refentry id="API-netif-set-real-num-rx-queues">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>netif_set_real_num_rx_queues</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>netif_set_real_num_rx_queues</refname>
 <refpurpose>
     set actual number of RX queues used
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>netif_set_real_num_rx_queues </function></funcdef>
   <paramdef>struct net_device * <parameter>dev</parameter></paramdef>
   <paramdef>unsigned int <parameter>rxq</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     Network device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>rxq</parameter></term>
   <listitem>
    <para>
     Actual number of RX queues
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This must be called either with the rtnl_lock held or before
   registration of the net device.  Returns 0 on success, or a
   negative error code.  If called before registration, it always
   succeeds.
</para>
</refsect1>
</refentry>

<refentry id="API-netif-get-num-default-rss-queues">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>netif_get_num_default_rss_queues</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>netif_get_num_default_rss_queues</refname>
 <refpurpose>
     default number of RSS queues
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>netif_get_num_default_rss_queues </function></funcdef>
   <paramdef> <parameter>void</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>void</parameter></term>
   <listitem>
    <para>
     no arguments
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   </para><para>

   This routine should set an upper limit on the number of RSS queues
   used by default by multiqueue devices.
</para>
</refsect1>
</refentry>

<refentry id="API-netif-wake-subqueue">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>netif_wake_subqueue</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>netif_wake_subqueue</refname>
 <refpurpose>
     allow sending packets on subqueue
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>netif_wake_subqueue </function></funcdef>
   <paramdef>struct net_device * <parameter>dev</parameter></paramdef>
   <paramdef>u16 <parameter>queue_index</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     network device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>queue_index</parameter></term>
   <listitem>
    <para>
     sub queue index
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Resume individual transmit queue of a device with multiple transmit queues.
</para>
</refsect1>
</refentry>

<refentry id="API-netif-device-detach">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>netif_device_detach</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>netif_device_detach</refname>
 <refpurpose>
     mark device as removed
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>netif_device_detach </function></funcdef>
   <paramdef>struct net_device * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     network device
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Mark device as removed from system and therefore no longer available.
</para>
</refsect1>
</refentry>

<refentry id="API-netif-device-attach">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>netif_device_attach</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>netif_device_attach</refname>
 <refpurpose>
     mark device as attached
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>netif_device_attach </function></funcdef>
   <paramdef>struct net_device * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     network device
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Mark device as attached from system and restart if needed.
</para>
</refsect1>
</refentry>

<refentry id="API-skb-mac-gso-segment">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>skb_mac_gso_segment</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>skb_mac_gso_segment</refname>
 <refpurpose>
     mac layer segmentation handler.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct sk_buff * <function>skb_mac_gso_segment </function></funcdef>
   <paramdef>struct sk_buff * <parameter>skb</parameter></paramdef>
   <paramdef>netdev_features_t <parameter>features</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>skb</parameter></term>
   <listitem>
    <para>
     buffer to segment
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>features</parameter></term>
   <listitem>
    <para>
     features for the output path (see dev-&gt;features)
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API---skb-gso-segment">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>__skb_gso_segment</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>__skb_gso_segment</refname>
 <refpurpose>
     Perform segmentation on skb.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct sk_buff * <function>__skb_gso_segment </function></funcdef>
   <paramdef>struct sk_buff * <parameter>skb</parameter></paramdef>
   <paramdef>netdev_features_t <parameter>features</parameter></paramdef>
   <paramdef>bool <parameter>tx_path</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>skb</parameter></term>
   <listitem>
    <para>
     buffer to segment
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>features</parameter></term>
   <listitem>
    <para>
     features for the output path (see dev-&gt;features)
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>tx_path</parameter></term>
   <listitem>
    <para>
     whether it is called in TX path
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This function segments the given skb and returns a list of segments.
   </para><para>

   It may return NULL if the skb requires no segmentation.  This is
   only possible when GSO is used for verifying header integrity.
</para>
</refsect1>
</refentry>

<refentry id="API-dev-loopback-xmit">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>dev_loopback_xmit</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>dev_loopback_xmit</refname>
 <refpurpose>
     loop back <parameter>skb</parameter>
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>dev_loopback_xmit </function></funcdef>
   <paramdef>struct sk_buff * <parameter>skb</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>skb</parameter></term>
   <listitem>
    <para>
     buffer to transmit
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-rps-may-expire-flow">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>rps_may_expire_flow</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>rps_may_expire_flow</refname>
 <refpurpose>
     check whether an RFS hardware filter may be removed
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>bool <function>rps_may_expire_flow </function></funcdef>
   <paramdef>struct net_device * <parameter>dev</parameter></paramdef>
   <paramdef>u16 <parameter>rxq_index</parameter></paramdef>
   <paramdef>u32 <parameter>flow_id</parameter></paramdef>
   <paramdef>u16 <parameter>filter_id</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     Device on which the filter was set
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>rxq_index</parameter></term>
   <listitem>
    <para>
     RX queue index
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>flow_id</parameter></term>
   <listitem>
    <para>
     Flow ID passed to <function>ndo_rx_flow_steer</function>
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>filter_id</parameter></term>
   <listitem>
    <para>
     Filter ID returned by <function>ndo_rx_flow_steer</function>
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Drivers that implement <function>ndo_rx_flow_steer</function> should periodically call
   this function for each installed filter and remove the filters for
   which it returns <constant>true</constant>.
</para>
</refsect1>
</refentry>

<refentry id="API-netif-rx">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>netif_rx</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>netif_rx</refname>
 <refpurpose>
     post buffer to the network code
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>netif_rx </function></funcdef>
   <paramdef>struct sk_buff * <parameter>skb</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>skb</parameter></term>
   <listitem>
    <para>
     buffer to post
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This function receives a packet from a device driver and queues it for
   the upper (protocol) levels to process.  It always succeeds. The buffer
   may be dropped during processing for congestion control or by the
   protocol layers.
</para>
</refsect1>
<refsect1>
<title>return values</title>
<para>
   NET_RX_SUCCESS	(no congestion)
   NET_RX_DROP     (packet was dropped)
</para>
</refsect1>
</refentry>

<refentry id="API-netdev-rx-handler-register">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>netdev_rx_handler_register</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>netdev_rx_handler_register</refname>
 <refpurpose>
     register receive handler
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>netdev_rx_handler_register </function></funcdef>
   <paramdef>struct net_device * <parameter>dev</parameter></paramdef>
   <paramdef>rx_handler_func_t * <parameter>rx_handler</parameter></paramdef>
   <paramdef>void * <parameter>rx_handler_data</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     device to register a handler for
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>rx_handler</parameter></term>
   <listitem>
    <para>
     receive handler to register
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>rx_handler_data</parameter></term>
   <listitem>
    <para>
     data pointer that is used by rx handler
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Register a receive handler for a device. This handler will then be
   called from __netif_receive_skb. A negative errno code is returned
   on a failure.
   </para><para>

   The caller must hold the rtnl_mutex.
   </para><para>

   For a general description of rx_handler, see enum rx_handler_result.
</para>
</refsect1>
</refentry>

<refentry id="API-netdev-rx-handler-unregister">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>netdev_rx_handler_unregister</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>netdev_rx_handler_unregister</refname>
 <refpurpose>
     unregister receive handler
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>netdev_rx_handler_unregister </function></funcdef>
   <paramdef>struct net_device * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     device to unregister a handler from
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Unregister a receive handler from a device.
   </para><para>

   The caller must hold the rtnl_mutex.
</para>
</refsect1>
</refentry>

<refentry id="API-netif-receive-skb">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>netif_receive_skb</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>netif_receive_skb</refname>
 <refpurpose>
     process receive buffer from network
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>netif_receive_skb </function></funcdef>
   <paramdef>struct sk_buff * <parameter>skb</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>skb</parameter></term>
   <listitem>
    <para>
     buffer to process
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   <function>netif_receive_skb</function> is the main receive data processing function.
   It always succeeds. The buffer may be dropped during processing
   for congestion control or by the protocol layers.
   </para><para>

   This function may only be called from softirq context and interrupts
   should be enabled.
   </para><para>

   Return values (usually ignored):
</para>
</refsect1>
<refsect1>
<title>NET_RX_SUCCESS</title>
<para>
   no congestion
</para>
</refsect1>
<refsect1>
<title>NET_RX_DROP</title>
<para>
   packet was dropped
</para>
</refsect1>
</refentry>

<refentry id="API---napi-schedule">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>__napi_schedule</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>__napi_schedule</refname>
 <refpurpose>
     schedule for receive
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>__napi_schedule </function></funcdef>
   <paramdef>struct napi_struct * <parameter>n</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>n</parameter></term>
   <listitem>
    <para>
     entry to schedule
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   The entry's receive function will be scheduled to run
</para>
</refsect1>
</refentry>

<refentry id="API-netdev-has-upper-dev">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>netdev_has_upper_dev</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>netdev_has_upper_dev</refname>
 <refpurpose>
     Check if device is linked to an upper device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>bool <function>netdev_has_upper_dev </function></funcdef>
   <paramdef>struct net_device * <parameter>dev</parameter></paramdef>
   <paramdef>struct net_device * <parameter>upper_dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>upper_dev</parameter></term>
   <listitem>
    <para>
     upper device to check
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Find out if a device is linked to specified upper device and return true
   in case it is. Note that this checks only immediate upper device,
   not through a complete stack of devices. The caller must hold the RTNL lock.
</para>
</refsect1>
</refentry>

<refentry id="API-netdev-master-upper-dev-get">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>netdev_master_upper_dev_get</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>netdev_master_upper_dev_get</refname>
 <refpurpose>
     Get master upper device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct net_device * <function>netdev_master_upper_dev_get </function></funcdef>
   <paramdef>struct net_device * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     device
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Find a master upper device and return pointer to it or NULL in case
   it's not there. The caller must hold the RTNL lock.
</para>
</refsect1>
</refentry>

<refentry id="API-netdev-upper-get-next-dev-rcu">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>netdev_upper_get_next_dev_rcu</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>netdev_upper_get_next_dev_rcu</refname>
 <refpurpose>
     Get the next dev from upper list
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct net_device * <function>netdev_upper_get_next_dev_rcu </function></funcdef>
   <paramdef>struct net_device * <parameter>dev</parameter></paramdef>
   <paramdef>struct list_head ** <parameter>iter</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>iter</parameter></term>
   <listitem>
    <para>
     list_head ** of the current position
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Gets the next device from the dev's upper list, starting from iter
   position. The caller must hold RCU read lock.
</para>
</refsect1>
</refentry>

<refentry id="API-netdev-all-upper-get-next-dev-rcu">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>netdev_all_upper_get_next_dev_rcu</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>netdev_all_upper_get_next_dev_rcu</refname>
 <refpurpose>
     Get the next dev from upper list
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct net_device * <function>netdev_all_upper_get_next_dev_rcu </function></funcdef>
   <paramdef>struct net_device * <parameter>dev</parameter></paramdef>
   <paramdef>struct list_head ** <parameter>iter</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>iter</parameter></term>
   <listitem>
    <para>
     list_head ** of the current position
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Gets the next device from the dev's upper list, starting from iter
   position. The caller must hold RCU read lock.
</para>
</refsect1>
</refentry>

<refentry id="API-netdev-lower-get-next-private">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>netdev_lower_get_next_private</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>netdev_lower_get_next_private</refname>
 <refpurpose>
     Get the next -&gt;private from the lower neighbour list
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void * <function>netdev_lower_get_next_private </function></funcdef>
   <paramdef>struct net_device * <parameter>dev</parameter></paramdef>
   <paramdef>struct list_head ** <parameter>iter</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>iter</parameter></term>
   <listitem>
    <para>
     list_head ** of the current position
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Gets the next netdev_adjacent-&gt;private from the dev's lower neighbour
   list, starting from iter position. The caller must hold either hold the
   RTNL lock or its own locking that guarantees that the neighbour lower
   list will remain unchainged.
</para>
</refsect1>
</refentry>

<refentry id="API-netdev-lower-get-next-private-rcu">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>netdev_lower_get_next_private_rcu</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>netdev_lower_get_next_private_rcu</refname>
 <refpurpose>
     Get the next -&gt;private from the lower neighbour list, RCU variant
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void * <function>netdev_lower_get_next_private_rcu </function></funcdef>
   <paramdef>struct net_device * <parameter>dev</parameter></paramdef>
   <paramdef>struct list_head ** <parameter>iter</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>iter</parameter></term>
   <listitem>
    <para>
     list_head ** of the current position
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Gets the next netdev_adjacent-&gt;private from the dev's lower neighbour
   list, starting from iter position. The caller must hold RCU read lock.
</para>
</refsect1>
</refentry>

<refentry id="API-netdev-lower-get-next">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>netdev_lower_get_next</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>netdev_lower_get_next</refname>
 <refpurpose>
     Get the next device from the lower neighbour list
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void * <function>netdev_lower_get_next </function></funcdef>
   <paramdef>struct net_device * <parameter>dev</parameter></paramdef>
   <paramdef>struct list_head ** <parameter>iter</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>iter</parameter></term>
   <listitem>
    <para>
     list_head ** of the current position
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Gets the next netdev_adjacent from the dev's lower neighbour
   list, starting from iter position. The caller must hold RTNL lock or
   its own locking that guarantees that the neighbour lower
   list will remain unchainged.
</para>
</refsect1>
</refentry>

<refentry id="API-netdev-lower-get-first-private-rcu">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>netdev_lower_get_first_private_rcu</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>netdev_lower_get_first_private_rcu</refname>
 <refpurpose>
     Get the first -&gt;private from the lower neighbour list, RCU variant
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void * <function>netdev_lower_get_first_private_rcu </function></funcdef>
   <paramdef>struct net_device * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     device
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Gets the first netdev_adjacent-&gt;private from the dev's lower neighbour
   list. The caller must hold RCU read lock.
</para>
</refsect1>
</refentry>

<refentry id="API-netdev-master-upper-dev-get-rcu">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>netdev_master_upper_dev_get_rcu</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>netdev_master_upper_dev_get_rcu</refname>
 <refpurpose>
     Get master upper device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct net_device * <function>netdev_master_upper_dev_get_rcu </function></funcdef>
   <paramdef>struct net_device * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     device
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Find a master upper device and return pointer to it or NULL in case
   it's not there. The caller must hold the RCU read lock.
</para>
</refsect1>
</refentry>

<refentry id="API-netdev-upper-dev-link">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>netdev_upper_dev_link</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>netdev_upper_dev_link</refname>
 <refpurpose>
     Add a link to the upper device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>netdev_upper_dev_link </function></funcdef>
   <paramdef>struct net_device * <parameter>dev</parameter></paramdef>
   <paramdef>struct net_device * <parameter>upper_dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>upper_dev</parameter></term>
   <listitem>
    <para>
     new upper device
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Adds a link to device which is upper to this one. The caller must hold
   the RTNL lock. On a failure a negative errno code is returned.
   On success the reference counts are adjusted and the function
   returns zero.
</para>
</refsect1>
</refentry>

<refentry id="API-netdev-master-upper-dev-link">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>netdev_master_upper_dev_link</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>netdev_master_upper_dev_link</refname>
 <refpurpose>
     Add a master link to the upper device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>netdev_master_upper_dev_link </function></funcdef>
   <paramdef>struct net_device * <parameter>dev</parameter></paramdef>
   <paramdef>struct net_device * <parameter>upper_dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>upper_dev</parameter></term>
   <listitem>
    <para>
     new upper device
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Adds a link to device which is upper to this one. In this case, only
   one master upper device can be linked, although other non-master devices
   might be linked as well. The caller must hold the RTNL lock.
   On a failure a negative errno code is returned. On success the reference
   counts are adjusted and the function returns zero.
</para>
</refsect1>
</refentry>

<refentry id="API-netdev-upper-dev-unlink">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>netdev_upper_dev_unlink</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>netdev_upper_dev_unlink</refname>
 <refpurpose>
     Removes a link to upper device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>netdev_upper_dev_unlink </function></funcdef>
   <paramdef>struct net_device * <parameter>dev</parameter></paramdef>
   <paramdef>struct net_device * <parameter>upper_dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>upper_dev</parameter></term>
   <listitem>
    <para>
     new upper device
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Removes a link to device which is upper to this one. The caller must hold
   the RTNL lock.
</para>
</refsect1>
</refentry>

<refentry id="API-dev-set-promiscuity">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>dev_set_promiscuity</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>dev_set_promiscuity</refname>
 <refpurpose>
     update promiscuity count on a device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>dev_set_promiscuity </function></funcdef>
   <paramdef>struct net_device * <parameter>dev</parameter></paramdef>
   <paramdef>int <parameter>inc</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>inc</parameter></term>
   <listitem>
    <para>
     modifier
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Add or remove promiscuity from a device. While the count in the device
   remains above zero the interface remains promiscuous. Once it hits zero
   the device reverts back to normal filtering operation. A negative inc
   value is used to drop promiscuity on the device.
   Return 0 if successful or a negative errno code on error.
</para>
</refsect1>
</refentry>

<refentry id="API-dev-set-allmulti">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>dev_set_allmulti</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>dev_set_allmulti</refname>
 <refpurpose>
     update allmulti count on a device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>dev_set_allmulti </function></funcdef>
   <paramdef>struct net_device * <parameter>dev</parameter></paramdef>
   <paramdef>int <parameter>inc</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>inc</parameter></term>
   <listitem>
    <para>
     modifier
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Add or remove reception of all multicast frames to a device. While the
   count in the device remains above zero the interface remains listening
   to all interfaces. Once it hits zero the device reverts back to normal
   filtering operation. A negative <parameter>inc</parameter> value is used to drop the counter
   when releasing a resource needing all multicasts.
   Return 0 if successful or a negative errno code on error.
</para>
</refsect1>
</refentry>

<refentry id="API-dev-get-flags">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>dev_get_flags</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>dev_get_flags</refname>
 <refpurpose>
     get flags reported to userspace
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>unsigned int <function>dev_get_flags </function></funcdef>
   <paramdef>const struct net_device * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     device
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Get the combination of flag bits exported through APIs to userspace.
</para>
</refsect1>
</refentry>

<refentry id="API-dev-change-flags">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>dev_change_flags</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>dev_change_flags</refname>
 <refpurpose>
     change device settings
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>dev_change_flags </function></funcdef>
   <paramdef>struct net_device * <parameter>dev</parameter></paramdef>
   <paramdef>unsigned int <parameter>flags</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>flags</parameter></term>
   <listitem>
    <para>
     device state flags
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Change settings on device based state flags. The flags are
   in the userspace exported format.
</para>
</refsect1>
</refentry>

<refentry id="API-dev-set-mtu">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>dev_set_mtu</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>dev_set_mtu</refname>
 <refpurpose>
     Change maximum transfer unit
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>dev_set_mtu </function></funcdef>
   <paramdef>struct net_device * <parameter>dev</parameter></paramdef>
   <paramdef>int <parameter>new_mtu</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>new_mtu</parameter></term>
   <listitem>
    <para>
     new transfer unit
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Change the maximum transfer size of the network device.
</para>
</refsect1>
</refentry>

<refentry id="API-dev-set-group">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>dev_set_group</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>dev_set_group</refname>
 <refpurpose>
     Change group this device belongs to
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>dev_set_group </function></funcdef>
   <paramdef>struct net_device * <parameter>dev</parameter></paramdef>
   <paramdef>int <parameter>new_group</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>new_group</parameter></term>
   <listitem>
    <para>
     group this device should belong to
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-dev-set-mac-address">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>dev_set_mac_address</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>dev_set_mac_address</refname>
 <refpurpose>
     Change Media Access Control Address
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>dev_set_mac_address </function></funcdef>
   <paramdef>struct net_device * <parameter>dev</parameter></paramdef>
   <paramdef>struct sockaddr * <parameter>sa</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>sa</parameter></term>
   <listitem>
    <para>
     new address
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Change the hardware (MAC) address of the device
</para>
</refsect1>
</refentry>

<refentry id="API-dev-change-carrier">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>dev_change_carrier</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>dev_change_carrier</refname>
 <refpurpose>
     Change device carrier
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>dev_change_carrier </function></funcdef>
   <paramdef>struct net_device * <parameter>dev</parameter></paramdef>
   <paramdef>bool <parameter>new_carrier</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>new_carrier</parameter></term>
   <listitem>
    <para>
     new value
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Change device carrier
</para>
</refsect1>
</refentry>

<refentry id="API-dev-get-phys-port-id">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>dev_get_phys_port_id</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>dev_get_phys_port_id</refname>
 <refpurpose>
     Get device physical port ID
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>dev_get_phys_port_id </function></funcdef>
   <paramdef>struct net_device * <parameter>dev</parameter></paramdef>
   <paramdef>struct netdev_phys_port_id * <parameter>ppid</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>ppid</parameter></term>
   <listitem>
    <para>
     port ID
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Get device physical port ID
</para>
</refsect1>
</refentry>

<refentry id="API-netdev-update-features">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>netdev_update_features</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>netdev_update_features</refname>
 <refpurpose>
     recalculate device features
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>netdev_update_features </function></funcdef>
   <paramdef>struct net_device * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     the device to check
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Recalculate dev-&gt;features set and send notifications if it
   has changed. Should be called after driver or hardware dependent
   conditions might have changed that influence the features.
</para>
</refsect1>
</refentry>

<refentry id="API-netdev-change-features">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>netdev_change_features</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>netdev_change_features</refname>
 <refpurpose>
     recalculate device features
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>netdev_change_features </function></funcdef>
   <paramdef>struct net_device * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     the device to check
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Recalculate dev-&gt;features set and send notifications even
   if they have not changed. Should be called instead of
   <function>netdev_update_features</function> if also dev-&gt;vlan_features might
   have changed to allow the changes to be propagated to stacked
   VLAN devices.
</para>
</refsect1>
</refentry>

<refentry id="API-netif-stacked-transfer-operstate">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>netif_stacked_transfer_operstate</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>netif_stacked_transfer_operstate</refname>
 <refpurpose>
     transfer operstate
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>netif_stacked_transfer_operstate </function></funcdef>
   <paramdef>const struct net_device * <parameter>rootdev</parameter></paramdef>
   <paramdef>struct net_device * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>rootdev</parameter></term>
   <listitem>
    <para>
     the root or lower level device to transfer state from
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     the device to transfer operstate to
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Transfer operational state from root to device. This is normally
   called when a stacking relationship exists between the root
   device and the device(a leaf device).
</para>
</refsect1>
</refentry>

<refentry id="API-register-netdevice">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>register_netdevice</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>register_netdevice</refname>
 <refpurpose>
     register a network device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>register_netdevice </function></funcdef>
   <paramdef>struct net_device * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     device to register
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Take a completed network device structure and add it to the kernel
   interfaces. A <constant>NETDEV_REGISTER</constant> message is sent to the netdev notifier
   chain. 0 is returned on success. A negative errno code is returned
   on a failure to set up the device, or if the name is a duplicate.
   </para><para>

   Callers must hold the rtnl semaphore. You may want
   <function>register_netdev</function> instead of this.
</para>
</refsect1>
<refsect1>
<title>BUGS</title>
<para>
   The locking appears insufficient to guarantee two parallel registers
   will not get the same name.
</para>
</refsect1>
</refentry>

<refentry id="API-init-dummy-netdev">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>init_dummy_netdev</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>init_dummy_netdev</refname>
 <refpurpose>
     init a dummy network device for NAPI
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>init_dummy_netdev </function></funcdef>
   <paramdef>struct net_device * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     device to init
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This takes a network device structure and initialize the minimum
   amount of fields so it can be used to schedule NAPI polls without
   registering a full blown interface. This is to be used by drivers
   that need to tie several hardware interfaces to a single NAPI
   poll scheduler due to HW limitations.
</para>
</refsect1>
</refentry>

<refentry id="API-register-netdev">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>register_netdev</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>register_netdev</refname>
 <refpurpose>
     register a network device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>register_netdev </function></funcdef>
   <paramdef>struct net_device * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     device to register
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Take a completed network device structure and add it to the kernel
   interfaces. A <constant>NETDEV_REGISTER</constant> message is sent to the netdev notifier
   chain. 0 is returned on success. A negative errno code is returned
   on a failure to set up the device, or if the name is a duplicate.
   </para><para>

   This is a wrapper around register_netdevice that takes the rtnl semaphore
   and expands the device name if you passed a format string to
   alloc_netdev.
</para>
</refsect1>
</refentry>

<refentry id="API-dev-get-stats">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>dev_get_stats</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>dev_get_stats</refname>
 <refpurpose>
     get network device statistics
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct rtnl_link_stats64 * <function>dev_get_stats </function></funcdef>
   <paramdef>struct net_device * <parameter>dev</parameter></paramdef>
   <paramdef>struct rtnl_link_stats64 * <parameter>storage</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     device to get statistics from
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>storage</parameter></term>
   <listitem>
    <para>
     place to store stats
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Get network statistics from device. Return <parameter>storage</parameter>.
   The device driver may provide its own method by setting
   dev-&gt;netdev_ops-&gt;get_stats64 or dev-&gt;netdev_ops-&gt;get_stats;
   otherwise the internal statistics structure is used.
</para>
</refsect1>
</refentry>

<refentry id="API-alloc-netdev-mqs">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>alloc_netdev_mqs</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>alloc_netdev_mqs</refname>
 <refpurpose>
     allocate network device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct net_device * <function>alloc_netdev_mqs </function></funcdef>
   <paramdef>int <parameter>sizeof_priv</parameter></paramdef>
   <paramdef>const char * <parameter>name</parameter></paramdef>
   <paramdef>unsigned char <parameter>name_assign_type</parameter></paramdef>
   <paramdef>void (*<parameter>setup</parameter>)
     <funcparams>struct net_device *</funcparams></paramdef>
   <paramdef>unsigned int <parameter>txqs</parameter></paramdef>
   <paramdef>unsigned int <parameter>rxqs</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>sizeof_priv</parameter></term>
   <listitem>
    <para>
     size of private data to allocate space for
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>name</parameter></term>
   <listitem>
    <para>
     device name format string
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>name_assign_type</parameter></term>
   <listitem>
    <para>
     origin of device name
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>setup</parameter></term>
   <listitem>
    <para>
     callback to initialize device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>txqs</parameter></term>
   <listitem>
    <para>
     the number of TX subqueues to allocate
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>rxqs</parameter></term>
   <listitem>
    <para>
     the number of RX subqueues to allocate
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Allocates a struct net_device with private data area for driver use
   and performs basic initialization.  Also allocates subqueue structs
   for each queue on the device.
</para>
</refsect1>
</refentry>

<refentry id="API-free-netdev">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>free_netdev</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>free_netdev</refname>
 <refpurpose>
     free network device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>free_netdev </function></funcdef>
   <paramdef>struct net_device * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     device
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This function does the last stage of destroying an allocated device
   interface. The reference to the device object is released.
   If this is the last reference then it will be freed.
</para>
</refsect1>
</refentry>

<refentry id="API-synchronize-net">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>synchronize_net</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>synchronize_net</refname>
 <refpurpose>
     Synchronize with packet receive processing
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>synchronize_net </function></funcdef>
   <paramdef> <parameter>void</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>void</parameter></term>
   <listitem>
    <para>
     no arguments
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   </para><para>

   Wait for packets currently being received to be done.
   Does not block later packets from starting.
</para>
</refsect1>
</refentry>

<refentry id="API-unregister-netdevice-queue">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>unregister_netdevice_queue</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>unregister_netdevice_queue</refname>
 <refpurpose>
     remove device from the kernel
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>unregister_netdevice_queue </function></funcdef>
   <paramdef>struct net_device * <parameter>dev</parameter></paramdef>
   <paramdef>struct list_head * <parameter>head</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>head</parameter></term>
   <listitem>
    <para>
     list
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This function shuts down a device interface and removes it
   from the kernel tables.
   If head not NULL, device is queued to be unregistered later.
   </para><para>

   Callers must hold the rtnl semaphore.  You may want
   <function>unregister_netdev</function> instead of this.
</para>
</refsect1>
</refentry>

<refentry id="API-unregister-netdevice-many">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>unregister_netdevice_many</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>unregister_netdevice_many</refname>
 <refpurpose>
     unregister many devices
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>unregister_netdevice_many </function></funcdef>
   <paramdef>struct list_head * <parameter>head</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>head</parameter></term>
   <listitem>
    <para>
     list of devices
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Note</title>
<para>
   As most callers use a stack allocated list_head,
   we force a <function>list_del</function> to make sure stack wont be corrupted later.
</para>
</refsect1>
</refentry>

<refentry id="API-unregister-netdev">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>unregister_netdev</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>unregister_netdev</refname>
 <refpurpose>
     remove device from the kernel
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>unregister_netdev </function></funcdef>
   <paramdef>struct net_device * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     device
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This function shuts down a device interface and removes it
   from the kernel tables.
   </para><para>

   This is just a wrapper for unregister_netdevice that takes
   the rtnl semaphore.  In general you want to use this and not
   unregister_netdevice.
</para>
</refsect1>
</refentry>

<refentry id="API-dev-change-net-namespace">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>dev_change_net_namespace</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>dev_change_net_namespace</refname>
 <refpurpose>
     move device to different nethost namespace
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>dev_change_net_namespace </function></funcdef>
   <paramdef>struct net_device * <parameter>dev</parameter></paramdef>
   <paramdef>struct net * <parameter>net</parameter></paramdef>
   <paramdef>const char * <parameter>pat</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>net</parameter></term>
   <listitem>
    <para>
     network namespace
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>pat</parameter></term>
   <listitem>
    <para>
     If not NULL name pattern to try if the current device name
     is already taken in the destination network namespace.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This function shuts down a device interface and moves it
   to a new network namespace. On success 0 is returned, on
   a failure a netagive errno code is returned.
   </para><para>

   Callers must hold the rtnl semaphore.
</para>
</refsect1>
</refentry>

<refentry id="API-netdev-increment-features">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>netdev_increment_features</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>netdev_increment_features</refname>
 <refpurpose>
     increment feature set by one
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>netdev_features_t <function>netdev_increment_features </function></funcdef>
   <paramdef>netdev_features_t <parameter>all</parameter></paramdef>
   <paramdef>netdev_features_t <parameter>one</parameter></paramdef>
   <paramdef>netdev_features_t <parameter>mask</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>all</parameter></term>
   <listitem>
    <para>
     current feature set
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>one</parameter></term>
   <listitem>
    <para>
     new feature set
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>mask</parameter></term>
   <listitem>
    <para>
     mask feature set
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Computes a new feature set after adding a device with feature set
   <parameter>one</parameter> to the master device with current feature set <parameter>all</parameter>.  Will not
   enable anything that is off in <parameter>mask</parameter>. Returns the new feature set.
</para>
</refsect1>
</refentry>

<!-- net/ethernet/eth.c -->
<refentry id="API-eth-header">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>eth_header</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>eth_header</refname>
 <refpurpose>
  create the Ethernet header
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>eth_header </function></funcdef>
   <paramdef>struct sk_buff * <parameter>skb</parameter></paramdef>
   <paramdef>struct net_device * <parameter>dev</parameter></paramdef>
   <paramdef>unsigned short <parameter>type</parameter></paramdef>
   <paramdef>const void * <parameter>daddr</parameter></paramdef>
   <paramdef>const void * <parameter>saddr</parameter></paramdef>
   <paramdef>unsigned int <parameter>len</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>skb</parameter></term>
   <listitem>
    <para>
     buffer to alter
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     source device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>type</parameter></term>
   <listitem>
    <para>
     Ethernet type field
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>daddr</parameter></term>
   <listitem>
    <para>
     destination address (NULL leave destination address)
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>saddr</parameter></term>
   <listitem>
    <para>
     source address (NULL use device source address)
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>len</parameter></term>
   <listitem>
    <para>
     packet length (&lt;= skb-&gt;len)
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   </para><para>

   Set the protocol type. For a packet of type ETH_P_802_3/2 we put the length
   in here instead.
</para>
</refsect1>
</refentry>

<refentry id="API-eth-rebuild-header">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>eth_rebuild_header</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>eth_rebuild_header</refname>
 <refpurpose>
     rebuild the Ethernet MAC header.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>eth_rebuild_header </function></funcdef>
   <paramdef>struct sk_buff * <parameter>skb</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>skb</parameter></term>
   <listitem>
    <para>
     socket buffer to update
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This is called after an ARP or IPV6 ndisc it's resolution on this
   sk_buff. We now let protocol (ARP) fill in the other fields.
   </para><para>

   This routine CANNOT use cached dst-&gt;neigh!
   Really, it is used only when dst-&gt;neigh is wrong.
</para>
</refsect1>
</refentry>

<refentry id="API-eth-get-headlen">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>eth_get_headlen</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>eth_get_headlen</refname>
 <refpurpose>
     determine the the length of header for an ethernet frame
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>u32 <function>eth_get_headlen </function></funcdef>
   <paramdef>void * <parameter>data</parameter></paramdef>
   <paramdef>unsigned int <parameter>len</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>data</parameter></term>
   <listitem>
    <para>
     pointer to start of frame
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>len</parameter></term>
   <listitem>
    <para>
     total length of frame
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Make a best effort attempt to pull the length for all of the headers for
   a given frame in a linear buffer.
</para>
</refsect1>
</refentry>

<refentry id="API-eth-type-trans">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>eth_type_trans</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>eth_type_trans</refname>
 <refpurpose>
     determine the packet's protocol ID.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>__be16 <function>eth_type_trans </function></funcdef>
   <paramdef>struct sk_buff * <parameter>skb</parameter></paramdef>
   <paramdef>struct net_device * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>skb</parameter></term>
   <listitem>
    <para>
     received socket data
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     receiving network device
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   The rule here is that we
   assume 802.3 if the type field is short enough to be a length.
   This is normal practice and works for any 'now in use' protocol.
</para>
</refsect1>
</refentry>

<refentry id="API-eth-header-parse">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>eth_header_parse</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>eth_header_parse</refname>
 <refpurpose>
     extract hardware address from packet
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>eth_header_parse </function></funcdef>
   <paramdef>const struct sk_buff * <parameter>skb</parameter></paramdef>
   <paramdef>unsigned char * <parameter>haddr</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>skb</parameter></term>
   <listitem>
    <para>
     packet to extract header from
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>haddr</parameter></term>
   <listitem>
    <para>
     destination buffer
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-eth-header-cache">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>eth_header_cache</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>eth_header_cache</refname>
 <refpurpose>
     fill cache entry from neighbour
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>eth_header_cache </function></funcdef>
   <paramdef>const struct neighbour * <parameter>neigh</parameter></paramdef>
   <paramdef>struct hh_cache * <parameter>hh</parameter></paramdef>
   <paramdef>__be16 <parameter>type</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>neigh</parameter></term>
   <listitem>
    <para>
     source neighbour
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>hh</parameter></term>
   <listitem>
    <para>
     destination cache entry
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>type</parameter></term>
   <listitem>
    <para>
     Ethernet type field
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Create an Ethernet header template from the neighbour.
</para>
</refsect1>
</refentry>

<refentry id="API-eth-header-cache-update">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>eth_header_cache_update</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>eth_header_cache_update</refname>
 <refpurpose>
     update cache entry
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>eth_header_cache_update </function></funcdef>
   <paramdef>struct hh_cache * <parameter>hh</parameter></paramdef>
   <paramdef>const struct net_device * <parameter>dev</parameter></paramdef>
   <paramdef>const unsigned char * <parameter>haddr</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>hh</parameter></term>
   <listitem>
    <para>
     destination cache entry
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     network device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>haddr</parameter></term>
   <listitem>
    <para>
     new hardware address
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Called by Address Resolution module to notify changes in address.
</para>
</refsect1>
</refentry>

<refentry id="API-eth-prepare-mac-addr-change">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>eth_prepare_mac_addr_change</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>eth_prepare_mac_addr_change</refname>
 <refpurpose>
     prepare for mac change
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>eth_prepare_mac_addr_change </function></funcdef>
   <paramdef>struct net_device * <parameter>dev</parameter></paramdef>
   <paramdef>void * <parameter>p</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     network device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>p</parameter></term>
   <listitem>
    <para>
     socket address
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-eth-commit-mac-addr-change">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>eth_commit_mac_addr_change</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>eth_commit_mac_addr_change</refname>
 <refpurpose>
     commit mac change
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>eth_commit_mac_addr_change </function></funcdef>
   <paramdef>struct net_device * <parameter>dev</parameter></paramdef>
   <paramdef>void * <parameter>p</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     network device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>p</parameter></term>
   <listitem>
    <para>
     socket address
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-eth-mac-addr">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>eth_mac_addr</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>eth_mac_addr</refname>
 <refpurpose>
     set new Ethernet hardware address
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>eth_mac_addr </function></funcdef>
   <paramdef>struct net_device * <parameter>dev</parameter></paramdef>
   <paramdef>void * <parameter>p</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     network device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>p</parameter></term>
   <listitem>
    <para>
     socket address
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Change hardware address of device.
   </para><para>

   This doesn't change hardware matching, so needs to be overridden
   for most real devices.
</para>
</refsect1>
</refentry>

<refentry id="API-eth-change-mtu">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>eth_change_mtu</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>eth_change_mtu</refname>
 <refpurpose>
     set new MTU size
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>eth_change_mtu </function></funcdef>
   <paramdef>struct net_device * <parameter>dev</parameter></paramdef>
   <paramdef>int <parameter>new_mtu</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     network device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>new_mtu</parameter></term>
   <listitem>
    <para>
     new Maximum Transfer Unit
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Allow changing MTU size. Needs to be overridden for devices
   supporting jumbo frames.
</para>
</refsect1>
</refentry>

<refentry id="API-ether-setup">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ether_setup</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ether_setup</refname>
 <refpurpose>
     setup Ethernet network device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>ether_setup </function></funcdef>
   <paramdef>struct net_device * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     network device
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Fill in the fields of the device structure with Ethernet-generic values.
</para>
</refsect1>
</refentry>

<refentry id="API-alloc-etherdev-mqs">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>alloc_etherdev_mqs</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>alloc_etherdev_mqs</refname>
 <refpurpose>
     Allocates and sets up an Ethernet device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct net_device * <function>alloc_etherdev_mqs </function></funcdef>
   <paramdef>int <parameter>sizeof_priv</parameter></paramdef>
   <paramdef>unsigned int <parameter>txqs</parameter></paramdef>
   <paramdef>unsigned int <parameter>rxqs</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>sizeof_priv</parameter></term>
   <listitem>
    <para>
     Size of additional driver-private structure to be allocated
     for this Ethernet device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>txqs</parameter></term>
   <listitem>
    <para>
     The number of TX queues this device has.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>rxqs</parameter></term>
   <listitem>
    <para>
     The number of RX queues this device has.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Fill in the fields of the device structure with Ethernet-generic
   values. Basically does everything except registering the device.
   </para><para>

   Constructs a new net device, complete with a private data area of
   size (sizeof_priv).  A 32-byte (not bit) alignment is enforced for
   this private data area.
</para>
</refsect1>
</refentry>

<!-- net/sched/sch_generic.c -->
<refentry id="API-netif-carrier-on">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>netif_carrier_on</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>netif_carrier_on</refname>
 <refpurpose>
  set carrier
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>netif_carrier_on </function></funcdef>
   <paramdef>struct net_device * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     network device
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Device has detected that carrier.
</para>
</refsect1>
</refentry>

<refentry id="API-netif-carrier-off">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>netif_carrier_off</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>netif_carrier_off</refname>
 <refpurpose>
     clear carrier
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>netif_carrier_off </function></funcdef>
   <paramdef>struct net_device * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     network device
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Device has detected loss of carrier.
</para>
</refsect1>
</refentry>

<!-- include/linux/etherdevice.h -->
<refentry id="API-is-link-local-ether-addr">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>is_link_local_ether_addr</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>is_link_local_ether_addr</refname>
 <refpurpose>
  Determine if given Ethernet address is link-local
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>bool <function>is_link_local_ether_addr </function></funcdef>
   <paramdef>const u8 * <parameter>addr</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>addr</parameter></term>
   <listitem>
    <para>
     Pointer to a six-byte array containing the Ethernet address
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Return true if address is link local reserved addr (01:80:c2:00:00:0X) per
   IEEE 802.1Q 8.6.3 Frame filtering.
</para>
</refsect1>
<refsect1>
<title>Please note</title>
<para>
   addr must be aligned to u16.
</para>
</refsect1>
</refentry>

<refentry id="API-is-zero-ether-addr">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>is_zero_ether_addr</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>is_zero_ether_addr</refname>
 <refpurpose>
     Determine if give Ethernet address is all zeros.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>bool <function>is_zero_ether_addr </function></funcdef>
   <paramdef>const u8 * <parameter>addr</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>addr</parameter></term>
   <listitem>
    <para>
     Pointer to a six-byte array containing the Ethernet address
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Return true if the address is all zeroes.
</para>
</refsect1>
<refsect1>
<title>Please note</title>
<para>
   addr must be aligned to u16.
</para>
</refsect1>
</refentry>

<refentry id="API-is-multicast-ether-addr">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>is_multicast_ether_addr</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>is_multicast_ether_addr</refname>
 <refpurpose>
     Determine if the Ethernet address is a multicast.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>bool <function>is_multicast_ether_addr </function></funcdef>
   <paramdef>const u8 * <parameter>addr</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>addr</parameter></term>
   <listitem>
    <para>
     Pointer to a six-byte array containing the Ethernet address
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Return true if the address is a multicast address.
   By definition the broadcast address is also a multicast address.
</para>
</refsect1>
</refentry>

<refentry id="API-is-local-ether-addr">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>is_local_ether_addr</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>is_local_ether_addr</refname>
 <refpurpose>
     Determine if the Ethernet address is locally-assigned one (IEEE 802).
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>bool <function>is_local_ether_addr </function></funcdef>
   <paramdef>const u8 * <parameter>addr</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>addr</parameter></term>
   <listitem>
    <para>
     Pointer to a six-byte array containing the Ethernet address
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Return true if the address is a local address.
</para>
</refsect1>
</refentry>

<refentry id="API-is-broadcast-ether-addr">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>is_broadcast_ether_addr</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>is_broadcast_ether_addr</refname>
 <refpurpose>
     Determine if the Ethernet address is broadcast
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>bool <function>is_broadcast_ether_addr </function></funcdef>
   <paramdef>const u8 * <parameter>addr</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>addr</parameter></term>
   <listitem>
    <para>
     Pointer to a six-byte array containing the Ethernet address
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Return true if the address is the broadcast address.
</para>
</refsect1>
<refsect1>
<title>Please note</title>
<para>
   addr must be aligned to u16.
</para>
</refsect1>
</refentry>

<refentry id="API-is-unicast-ether-addr">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>is_unicast_ether_addr</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>is_unicast_ether_addr</refname>
 <refpurpose>
     Determine if the Ethernet address is unicast
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>bool <function>is_unicast_ether_addr </function></funcdef>
   <paramdef>const u8 * <parameter>addr</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>addr</parameter></term>
   <listitem>
    <para>
     Pointer to a six-byte array containing the Ethernet address
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Return true if the address is a unicast address.
</para>
</refsect1>
</refentry>

<refentry id="API-is-valid-ether-addr">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>is_valid_ether_addr</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>is_valid_ether_addr</refname>
 <refpurpose>
     Determine if the given Ethernet address is valid
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>bool <function>is_valid_ether_addr </function></funcdef>
   <paramdef>const u8 * <parameter>addr</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>addr</parameter></term>
   <listitem>
    <para>
     Pointer to a six-byte array containing the Ethernet address
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Check that the Ethernet address (MAC) is not 00:00:00:00:00:00, is not
   a multicast address, and is not FF:FF:FF:FF:FF:FF.
   </para><para>

   Return true if the address is valid.
</para>
</refsect1>
<refsect1>
<title>Please note</title>
<para>
   addr must be aligned to u16.
</para>
</refsect1>
</refentry>

<refentry id="API-eth-random-addr">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>eth_random_addr</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>eth_random_addr</refname>
 <refpurpose>
     Generate software assigned random Ethernet address
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>eth_random_addr </function></funcdef>
   <paramdef>u8 * <parameter>addr</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>addr</parameter></term>
   <listitem>
    <para>
     Pointer to a six-byte array containing the Ethernet address
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Generate a random Ethernet address (MAC) that is not multicast
   and has the local assigned bit set.
</para>
</refsect1>
</refentry>

<refentry id="API-eth-broadcast-addr">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>eth_broadcast_addr</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>eth_broadcast_addr</refname>
 <refpurpose>
     Assign broadcast address
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>eth_broadcast_addr </function></funcdef>
   <paramdef>u8 * <parameter>addr</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>addr</parameter></term>
   <listitem>
    <para>
     Pointer to a six-byte array containing the Ethernet address
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Assign the broadcast address to the given address array.
</para>
</refsect1>
</refentry>

<refentry id="API-eth-zero-addr">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>eth_zero_addr</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>eth_zero_addr</refname>
 <refpurpose>
     Assign zero address
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>eth_zero_addr </function></funcdef>
   <paramdef>u8 * <parameter>addr</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>addr</parameter></term>
   <listitem>
    <para>
     Pointer to a six-byte array containing the Ethernet address
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Assign the zero address to the given address array.
</para>
</refsect1>
</refentry>

<refentry id="API-eth-hw-addr-random">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>eth_hw_addr_random</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>eth_hw_addr_random</refname>
 <refpurpose>
     Generate software assigned random Ethernet and set device flag
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>eth_hw_addr_random </function></funcdef>
   <paramdef>struct net_device * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     pointer to net_device structure
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Generate a random Ethernet address (MAC) to be used by a net device
   and set addr_assign_type so the state can be read by sysfs and be
   used by userspace.
</para>
</refsect1>
</refentry>

<refentry id="API-ether-addr-copy">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ether_addr_copy</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ether_addr_copy</refname>
 <refpurpose>
     Copy an Ethernet address
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>ether_addr_copy </function></funcdef>
   <paramdef>u8 * <parameter>dst</parameter></paramdef>
   <paramdef>const u8 * <parameter>src</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dst</parameter></term>
   <listitem>
    <para>
     Pointer to a six-byte array Ethernet address destination
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>src</parameter></term>
   <listitem>
    <para>
     Pointer to a six-byte array Ethernet address source
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Please note</title>
<para>
   dst &amp; src must both be aligned to u16.
</para>
</refsect1>
</refentry>

<refentry id="API-eth-hw-addr-inherit">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>eth_hw_addr_inherit</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>eth_hw_addr_inherit</refname>
 <refpurpose>
     Copy dev_addr from another net_device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>eth_hw_addr_inherit </function></funcdef>
   <paramdef>struct net_device * <parameter>dst</parameter></paramdef>
   <paramdef>struct net_device * <parameter>src</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dst</parameter></term>
   <listitem>
    <para>
     pointer to net_device to copy dev_addr to
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>src</parameter></term>
   <listitem>
    <para>
     pointer to net_device to copy dev_addr from
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Copy the Ethernet address from one net_device to another along with
   the address attributes (addr_assign_type).
</para>
</refsect1>
</refentry>

<refentry id="API-ether-addr-equal">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ether_addr_equal</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ether_addr_equal</refname>
 <refpurpose>
     Compare two Ethernet addresses
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>bool <function>ether_addr_equal </function></funcdef>
   <paramdef>const u8 * <parameter>addr1</parameter></paramdef>
   <paramdef>const u8 * <parameter>addr2</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>addr1</parameter></term>
   <listitem>
    <para>
     Pointer to a six-byte array containing the Ethernet address
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>addr2</parameter></term>
   <listitem>
    <para>
     Pointer other six-byte array containing the Ethernet address
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Compare two Ethernet addresses, returns true if equal
</para>
</refsect1>
<refsect1>
<title>Please note</title>
<para>
   addr1 &amp; addr2 must both be aligned to u16.
</para>
</refsect1>
</refentry>

<refentry id="API-ether-addr-equal-64bits">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ether_addr_equal_64bits</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ether_addr_equal_64bits</refname>
 <refpurpose>
     Compare two Ethernet addresses
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>bool <function>ether_addr_equal_64bits </function></funcdef>
   <paramdef>const u8 <parameter>addr1[6+2]</parameter></paramdef>
   <paramdef>const u8 <parameter>addr2[6+2]</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>addr1[6+2]</parameter></term>
   <listitem>
    <para>
     Pointer to an array of 8 bytes
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>addr2[6+2]</parameter></term>
   <listitem>
    <para>
     Pointer to an other array of 8 bytes
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Compare two Ethernet addresses, returns true if equal, false otherwise.
   </para><para>

   The function doesn't need any conditional branches and possibly uses
   word memory accesses on CPU allowing cheap unaligned memory reads.
   arrays = { byte1, byte2, byte3, byte4, byte5, byte6, pad1, pad2 }
   </para><para>

   Please note that alignment of addr1 &amp; addr2 are only guaranteed to be 16 bits.
</para>
</refsect1>
</refentry>

<refentry id="API-ether-addr-equal-unaligned">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ether_addr_equal_unaligned</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ether_addr_equal_unaligned</refname>
 <refpurpose>
     Compare two not u16 aligned Ethernet addresses
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>bool <function>ether_addr_equal_unaligned </function></funcdef>
   <paramdef>const u8 * <parameter>addr1</parameter></paramdef>
   <paramdef>const u8 * <parameter>addr2</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>addr1</parameter></term>
   <listitem>
    <para>
     Pointer to a six-byte array containing the Ethernet address
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>addr2</parameter></term>
   <listitem>
    <para>
     Pointer other six-byte array containing the Ethernet address
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Compare two Ethernet addresses, returns true if equal
</para>
</refsect1>
<refsect1>
<title>Please note</title>
<para>
   Use only when any Ethernet address may not be u16 aligned.
</para>
</refsect1>
</refentry>

<refentry id="API-is-etherdev-addr">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>is_etherdev_addr</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>is_etherdev_addr</refname>
 <refpurpose>
     Tell if given Ethernet address belongs to the device.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>bool <function>is_etherdev_addr </function></funcdef>
   <paramdef>const struct net_device * <parameter>dev</parameter></paramdef>
   <paramdef>const u8 <parameter>addr[6 + 2]</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     Pointer to a device structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>addr[6 + 2]</parameter></term>
   <listitem>
    <para>
     Pointer to a six-byte array containing the Ethernet address
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Compare passed address with all addresses of the device. Return true if the
   address if one of the device addresses.
   </para><para>

   Note that this function calls <function>ether_addr_equal_64bits</function> so take care of
   the right padding.
</para>
</refsect1>
</refentry>

<refentry id="API-compare-ether-header">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>compare_ether_header</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>compare_ether_header</refname>
 <refpurpose>
     Compare two Ethernet headers
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>unsigned long <function>compare_ether_header </function></funcdef>
   <paramdef>const void * <parameter>a</parameter></paramdef>
   <paramdef>const void * <parameter>b</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>a</parameter></term>
   <listitem>
    <para>
     Pointer to Ethernet header
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>b</parameter></term>
   <listitem>
    <para>
     Pointer to Ethernet header
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Compare two Ethernet headers, returns 0 if equal.
   This assumes that the network header (i.e., IP header) is 4-byte
   aligned OR the platform can handle unaligned access.  This is the
   case for all packets coming into netif_receive_skb or similar
   entry points.
</para>
</refsect1>
</refentry>

<!-- include/linux/netdevice.h -->
<refentry id="API-napi-schedule-prep">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>napi_schedule_prep</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>napi_schedule_prep</refname>
 <refpurpose>
  check if napi can be scheduled
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>bool <function>napi_schedule_prep </function></funcdef>
   <paramdef>struct napi_struct * <parameter>n</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>n</parameter></term>
   <listitem>
    <para>
     napi context
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Test if NAPI routine is already running, and if not mark
   it as running.  This is used as a condition variable
   insure only one NAPI poll instance runs.  We also make
   sure there is no pending NAPI disable.
</para>
</refsect1>
</refentry>

<refentry id="API-napi-schedule">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>napi_schedule</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>napi_schedule</refname>
 <refpurpose>
     schedule NAPI poll
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>napi_schedule </function></funcdef>
   <paramdef>struct napi_struct * <parameter>n</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>n</parameter></term>
   <listitem>
    <para>
     napi context
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Schedule NAPI poll routine to be called if it is not already
   running.
</para>
</refsect1>
</refentry>

<refentry id="API-napi-disable">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>napi_disable</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>napi_disable</refname>
 <refpurpose>
     prevent NAPI from scheduling
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>napi_disable </function></funcdef>
   <paramdef>struct napi_struct * <parameter>n</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>n</parameter></term>
   <listitem>
    <para>
     napi context
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Stop NAPI from being scheduled on this context.
   Waits till any outstanding processing completes.
</para>
</refsect1>
</refentry>

<refentry id="API-napi-enable">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>napi_enable</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>napi_enable</refname>
 <refpurpose>
     enable NAPI scheduling
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>napi_enable </function></funcdef>
   <paramdef>struct napi_struct * <parameter>n</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>n</parameter></term>
   <listitem>
    <para>
     napi context
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Resume NAPI from being scheduled on this context.
   Must be paired with napi_disable.
</para>
</refsect1>
</refentry>

<refentry id="API-napi-synchronize">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>napi_synchronize</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>napi_synchronize</refname>
 <refpurpose>
     wait until NAPI is not running
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>napi_synchronize </function></funcdef>
   <paramdef>const struct napi_struct * <parameter>n</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>n</parameter></term>
   <listitem>
    <para>
     napi context
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Wait until NAPI is done being scheduled on this context.
   Waits till any outstanding processing completes but
   does not disable future activations.
</para>
</refsect1>
</refentry>

<refentry id="API-enum-netdev-priv-flags">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>enum netdev_priv_flags</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>enum netdev_priv_flags</refname>
 <refpurpose>
     <structname>struct net_device</structname> priv_flags
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
enum netdev_priv_flags {
  IFF_802_1Q_VLAN,
  IFF_EBRIDGE,
  IFF_SLAVE_INACTIVE,
  IFF_MASTER_8023AD,
  IFF_MASTER_ALB,
  IFF_BONDING,
  IFF_SLAVE_NEEDARP,
  IFF_ISATAP,
  IFF_MASTER_ARPMON,
  IFF_WAN_HDLC,
  IFF_XMIT_DST_RELEASE,
  IFF_DONT_BRIDGE,
  IFF_DISABLE_NETPOLL,
  IFF_MACVLAN_PORT,
  IFF_BRIDGE_PORT,
  IFF_OVS_DATAPATH,
  IFF_TX_SKB_SHARING,
  IFF_UNICAST_FLT,
  IFF_TEAM_PORT,
  IFF_SUPP_NOFCS,
  IFF_LIVE_ADDR_CHANGE,
  IFF_MACVLAN,
  IFF_XMIT_DST_RELEASE_PERM
};  </programlisting>
</refsynopsisdiv>
<refsect1>
 <title>Constants</title>
  <variablelist>
    <varlistentry>      <term>IFF_802_1Q_VLAN</term>
      <listitem><para>
   802.1Q VLAN device
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>IFF_EBRIDGE</term>
      <listitem><para>
   Ethernet bridging device
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>IFF_SLAVE_INACTIVE</term>
      <listitem><para>
   bonding slave not the curr. active
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>IFF_MASTER_8023AD</term>
      <listitem><para>
   bonding master, 802.3ad
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>IFF_MASTER_ALB</term>
      <listitem><para>
   bonding master, balance-alb
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>IFF_BONDING</term>
      <listitem><para>
   bonding master or slave
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>IFF_SLAVE_NEEDARP</term>
      <listitem><para>
   need ARPs for validation
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>IFF_ISATAP</term>
      <listitem><para>
   ISATAP interface (RFC4214)
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>IFF_MASTER_ARPMON</term>
      <listitem><para>
   bonding master, ARP mon in use
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>IFF_WAN_HDLC</term>
      <listitem><para>
   WAN HDLC device
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>IFF_XMIT_DST_RELEASE</term>
      <listitem><para>
   <function>dev_hard_start_xmit</function> is allowed to
   release skb-&gt;dst
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>IFF_DONT_BRIDGE</term>
      <listitem><para>
   disallow bridging this ether dev
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>IFF_DISABLE_NETPOLL</term>
      <listitem><para>
   disable netpoll at run-time
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>IFF_MACVLAN_PORT</term>
      <listitem><para>
   device used as macvlan port
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>IFF_BRIDGE_PORT</term>
      <listitem><para>
   device used as bridge port
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>IFF_OVS_DATAPATH</term>
      <listitem><para>
   device used as Open vSwitch datapath port
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>IFF_TX_SKB_SHARING</term>
      <listitem><para>
   The interface supports sharing skbs on transmit
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>IFF_UNICAST_FLT</term>
      <listitem><para>
   Supports unicast filtering
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>IFF_TEAM_PORT</term>
      <listitem><para>
   device used as team port
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>IFF_SUPP_NOFCS</term>
      <listitem><para>
   device supports sending custom FCS
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>IFF_LIVE_ADDR_CHANGE</term>
      <listitem><para>
   device supports hardware address
   change when it's running
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>IFF_MACVLAN</term>
      <listitem><para>
   Macvlan device
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>IFF_XMIT_DST_RELEASE_PERM</term>
      <listitem><para>
   -- undescribed --
      </para></listitem>
    </varlistentry>
  </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   </para><para>

   These are the <structname>struct net_device</structname>, they are only set internally
   by drivers and used in the kernel. These flags are invisible to
   userspace, this means that the order of these flags can change
   during any kernel release.
   </para><para>

   You should have a pretty good reason to be extending these flags.
</para>
</refsect1>
</refentry>

<refentry id="API-struct-net-device">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct net_device</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct net_device</refname>
 <refpurpose>
     The DEVICE structure. Actually, this whole structure is a big mistake. It mixes I/O data with strictly <quote>high-level</quote> data, and it has to know about almost every data structure used in the INET module.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct net_device {
  char name[IFNAMSIZ];
  struct hlist_node name_hlist;
  char * ifalias;
  unsigned long mem_end;
  unsigned long mem_start;
  unsigned long base_addr;
  int irq;
  unsigned long state;
  struct list_head dev_list;
  struct list_head napi_list;
  struct list_head unreg_list;
  struct list_head close_list;
  struct {unnamed_struct};
  struct garp_port __rcu * garp_port;
  struct mrp_port __rcu * mrp_port;
  struct device dev;
  const struct attribute_group * sysfs_groups[4];
  const struct attribute_group * sysfs_rx_queue_group;
  const struct rtnl_link_ops * rtnl_link_ops;
#define GSO_MAX_SIZE		65536
  unsigned int gso_max_size;
#define GSO_MAX_SEGS		65535
  u16 gso_max_segs;
  u16 gso_min_segs;
#ifdef CONFIG_DCB
  const struct dcbnl_rtnl_ops * dcbnl_ops;
#endif
  u8 num_tc;
  struct netdev_tc_txq tc_to_txq[TC_MAX_QUEUE];
  u8 prio_tc_map[TC_BITMASK + 1];
#if IS_ENABLED(CONFIG_FCOE)
  unsigned int fcoe_ddp_xid;
#endif
#if IS_ENABLED(CONFIG_CGROUP_NET_PRIO)
  struct netprio_map __rcu * priomap;
#endif
  struct phy_device * phydev;
  struct lock_class_key * qdisc_tx_busylock;
  int group;
  struct pm_qos_request pm_qos_req;
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>name[IFNAMSIZ]</term>
      <listitem><para>
   This is the first field of the <quote>visible</quote> part of this structure
   (i.e. as seen by users in the <quote>Space.c</quote> file).  It is the name
   of the interface.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>name_hlist</term>
      <listitem><para>
   Device name hash chain, please keep it close to name[]
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>ifalias</term>
      <listitem><para>
   SNMP alias
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>mem_end</term>
      <listitem><para>
   Shared memory end
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>mem_start</term>
      <listitem><para>
   Shared memory start
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>base_addr</term>
      <listitem><para>
   Device I/O address
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>irq</term>
      <listitem><para>
   Device IRQ number
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>state</term>
      <listitem><para>
   Generic network queuing layer state, see netdev_state_t
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>dev_list</term>
      <listitem><para>
   The global list of network devices
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>napi_list</term>
      <listitem><para>
   List entry, that is used for polling napi devices
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>unreg_list</term>
      <listitem><para>
   List entry, that is used, when we are unregistering the
   device, see the function unregister_netdev
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>close_list</term>
      <listitem><para>
   List entry, that is used, when we are closing the device
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>{unnamed_struct}</term>
      <listitem><para>
   anonymous
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>garp_port</term>
      <listitem><para>
   GARP
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>mrp_port</term>
      <listitem><para>
   MRP
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>dev</term>
      <listitem><para>
   Class/net/name entry
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>sysfs_groups[4]</term>
      <listitem><para>
   Space for optional device, statistics and wireless
   sysfs groups
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>sysfs_rx_queue_group</term>
      <listitem><para>
   Space for optional per-rx queue attributes
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>rtnl_link_ops</term>
      <listitem><para>
   Rtnl_link_ops
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>gso_max_size</term>
      <listitem><para>
   Maximum size of generic segmentation offload
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>gso_max_segs</term>
      <listitem><para>
   Maximum number of segments that can be passed to the
   NIC for GSO
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>gso_min_segs</term>
      <listitem><para>
   Minimum number of segments that can be passed to the
   NIC for GSO
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>dcbnl_ops</term>
      <listitem><para>
   Data Center Bridging netlink ops
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>num_tc</term>
      <listitem><para>
   Number of traffic classes in the net device
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>tc_to_txq[TC_MAX_QUEUE]</term>
      <listitem><para>
   XXX: need comments on this one
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>prio_tc_map[TC_BITMASK + 1]</term>
      <listitem><para>
   need comments on this one
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>fcoe_ddp_xid</term>
      <listitem><para>
   Max exchange id for FCoE LRO by ddp
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>priomap</term>
      <listitem><para>
   XXX: need comments on this one
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>phydev</term>
      <listitem><para>
   Physical device may attach itself
   for hardware timestamping
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>qdisc_tx_busylock</term>
      <listitem><para>
   XXX: need comments on this one
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>group</term>
      <listitem><para>
   The group, that the device belongs to
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>pm_qos_req</term>
      <listitem><para>
   Power Management QoS object
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
<refsect1>
<title>FIXME</title>
<para>
   cleanup struct net_device such that network protocol info
   moves out.
</para>
</refsect1>
</refentry>

<refentry id="API-netdev-priv">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>netdev_priv</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>netdev_priv</refname>
 <refpurpose>
     access network device private data
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void * <function>netdev_priv </function></funcdef>
   <paramdef>const struct net_device * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     network device
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Get network device private data
</para>
</refsect1>
</refentry>

<refentry id="API-netif-start-queue">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>netif_start_queue</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>netif_start_queue</refname>
 <refpurpose>
     allow transmit
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>netif_start_queue </function></funcdef>
   <paramdef>struct net_device * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     network device
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Allow upper layers to call the device hard_start_xmit routine.
</para>
</refsect1>
</refentry>

<refentry id="API-netif-wake-queue">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>netif_wake_queue</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>netif_wake_queue</refname>
 <refpurpose>
     restart transmit
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>netif_wake_queue </function></funcdef>
   <paramdef>struct net_device * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     network device
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Allow upper layers to call the device hard_start_xmit routine.
   Used for flow control when transmit resources are available.
</para>
</refsect1>
</refentry>

<refentry id="API-netif-stop-queue">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>netif_stop_queue</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>netif_stop_queue</refname>
 <refpurpose>
     stop transmitted packets
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>netif_stop_queue </function></funcdef>
   <paramdef>struct net_device * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     network device
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Stop upper layers calling the device hard_start_xmit routine.
   Used for flow control when transmit resources are unavailable.
</para>
</refsect1>
</refentry>

<refentry id="API-netif-queue-stopped">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>netif_queue_stopped</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>netif_queue_stopped</refname>
 <refpurpose>
     test if transmit queue is flowblocked
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>bool <function>netif_queue_stopped </function></funcdef>
   <paramdef>const struct net_device * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     network device
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Test if transmit queue on device is currently unable to send.
</para>
</refsect1>
</refentry>

<refentry id="API-netdev-txq-bql-enqueue-prefetchw">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>netdev_txq_bql_enqueue_prefetchw</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>netdev_txq_bql_enqueue_prefetchw</refname>
 <refpurpose>
     prefetch bql data for write
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>netdev_txq_bql_enqueue_prefetchw </function></funcdef>
   <paramdef>struct netdev_queue * <parameter>dev_queue</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev_queue</parameter></term>
   <listitem>
    <para>
     pointer to transmit queue
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   BQL enabled drivers might use this helper in their <function>ndo_start_xmit</function>,
   to give appropriate hint to the cpu.
</para>
</refsect1>
</refentry>

<refentry id="API-netdev-txq-bql-complete-prefetchw">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>netdev_txq_bql_complete_prefetchw</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>netdev_txq_bql_complete_prefetchw</refname>
 <refpurpose>
     prefetch bql data for write
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>netdev_txq_bql_complete_prefetchw </function></funcdef>
   <paramdef>struct netdev_queue * <parameter>dev_queue</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev_queue</parameter></term>
   <listitem>
    <para>
     pointer to transmit queue
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   BQL enabled drivers might use this helper in their TX completion path,
   to give appropriate hint to the cpu.
</para>
</refsect1>
</refentry>

<refentry id="API-netdev-sent-queue">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>netdev_sent_queue</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>netdev_sent_queue</refname>
 <refpurpose>
     report the number of bytes queued to hardware
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>netdev_sent_queue </function></funcdef>
   <paramdef>struct net_device * <parameter>dev</parameter></paramdef>
   <paramdef>unsigned int <parameter>bytes</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     network device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>bytes</parameter></term>
   <listitem>
    <para>
     number of bytes queued to the hardware device queue
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Report the number of bytes queued for sending/completion to the network
   device hardware queue. <parameter>bytes</parameter> should be a good approximation and should
   exactly match <function>netdev_completed_queue</function> <parameter>bytes</parameter>
</para>
</refsect1>
</refentry>

<refentry id="API-netdev-completed-queue">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>netdev_completed_queue</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>netdev_completed_queue</refname>
 <refpurpose>
     report bytes and packets completed by device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>netdev_completed_queue </function></funcdef>
   <paramdef>struct net_device * <parameter>dev</parameter></paramdef>
   <paramdef>unsigned int <parameter>pkts</parameter></paramdef>
   <paramdef>unsigned int <parameter>bytes</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     network device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>pkts</parameter></term>
   <listitem>
    <para>
     actual number of packets sent over the medium
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>bytes</parameter></term>
   <listitem>
    <para>
     actual number of bytes sent over the medium
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Report the number of bytes and packets transmitted by the network device
   hardware queue over the physical medium, <parameter>bytes</parameter> must exactly match the
   <parameter>bytes</parameter> amount passed to <function>netdev_sent_queue</function>
</para>
</refsect1>
</refentry>

<refentry id="API-netdev-reset-queue">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>netdev_reset_queue</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>netdev_reset_queue</refname>
 <refpurpose>
     reset the packets and bytes count of a network device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>netdev_reset_queue </function></funcdef>
   <paramdef>struct net_device * <parameter>dev_queue</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev_queue</parameter></term>
   <listitem>
    <para>
     network device
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Reset the bytes and packet count of a network device and clear the
   software flow control OFF bit for this network device
</para>
</refsect1>
</refentry>

<refentry id="API-netdev-cap-txqueue">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>netdev_cap_txqueue</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>netdev_cap_txqueue</refname>
 <refpurpose>
     check if selected tx queue exceeds device queues
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>u16 <function>netdev_cap_txqueue </function></funcdef>
   <paramdef>struct net_device * <parameter>dev</parameter></paramdef>
   <paramdef>u16 <parameter>queue_index</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     network device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>queue_index</parameter></term>
   <listitem>
    <para>
     given tx queue index
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Returns 0 if given tx queue index &gt;= number of device tx queues,
   otherwise returns the originally passed tx queue index.
</para>
</refsect1>
</refentry>

<refentry id="API-netif-running">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>netif_running</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>netif_running</refname>
 <refpurpose>
     test if up
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>bool <function>netif_running </function></funcdef>
   <paramdef>const struct net_device * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     network device
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Test if the device has been brought up.
</para>
</refsect1>
</refentry>

<refentry id="API-netif-start-subqueue">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>netif_start_subqueue</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>netif_start_subqueue</refname>
 <refpurpose>
     allow sending packets on subqueue
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>netif_start_subqueue </function></funcdef>
   <paramdef>struct net_device * <parameter>dev</parameter></paramdef>
   <paramdef>u16 <parameter>queue_index</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     network device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>queue_index</parameter></term>
   <listitem>
    <para>
     sub queue index
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Start individual transmit queue of a device with multiple transmit queues.
</para>
</refsect1>
</refentry>

<refentry id="API-netif-stop-subqueue">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>netif_stop_subqueue</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>netif_stop_subqueue</refname>
 <refpurpose>
     stop sending packets on subqueue
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>netif_stop_subqueue </function></funcdef>
   <paramdef>struct net_device * <parameter>dev</parameter></paramdef>
   <paramdef>u16 <parameter>queue_index</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     network device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>queue_index</parameter></term>
   <listitem>
    <para>
     sub queue index
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Stop individual transmit queue of a device with multiple transmit queues.
</para>
</refsect1>
</refentry>

<refentry id="API---netif-subqueue-stopped">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>__netif_subqueue_stopped</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>__netif_subqueue_stopped</refname>
 <refpurpose>
     test status of subqueue
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>bool <function>__netif_subqueue_stopped </function></funcdef>
   <paramdef>const struct net_device * <parameter>dev</parameter></paramdef>
   <paramdef>u16 <parameter>queue_index</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     network device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>queue_index</parameter></term>
   <listitem>
    <para>
     sub queue index
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Check individual transmit queue of a device with multiple transmit queues.
</para>
</refsect1>
</refentry>

<refentry id="API-netif-is-multiqueue">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>netif_is_multiqueue</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>netif_is_multiqueue</refname>
 <refpurpose>
     test if device has multiple transmit queues
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>bool <function>netif_is_multiqueue </function></funcdef>
   <paramdef>const struct net_device * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     network device
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Check if device has multiple transmit queues
</para>
</refsect1>
</refentry>

<refentry id="API-dev-put">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>dev_put</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>dev_put</refname>
 <refpurpose>
     release reference to device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>dev_put </function></funcdef>
   <paramdef>struct net_device * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     network device
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Release reference to device to allow it to be freed.
</para>
</refsect1>
</refentry>

<refentry id="API-dev-hold">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>dev_hold</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>dev_hold</refname>
 <refpurpose>
     get reference to device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>dev_hold </function></funcdef>
   <paramdef>struct net_device * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     network device
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Hold reference to device to keep it from being freed.
</para>
</refsect1>
</refentry>

<refentry id="API-netif-carrier-ok">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>netif_carrier_ok</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>netif_carrier_ok</refname>
 <refpurpose>
     test if carrier present
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>bool <function>netif_carrier_ok </function></funcdef>
   <paramdef>const struct net_device * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     network device
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Check if carrier is present on device
</para>
</refsect1>
</refentry>

<refentry id="API-netif-dormant-on">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>netif_dormant_on</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>netif_dormant_on</refname>
 <refpurpose>
     mark device as dormant.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>netif_dormant_on </function></funcdef>
   <paramdef>struct net_device * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     network device
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Mark device as dormant (as per RFC2863).
   </para><para>

   The dormant state indicates that the relevant interface is not
   actually in a condition to pass packets (i.e., it is not 'up') but is
   in a <quote>pending</quote> state, waiting for some external event.  For <quote>on-
   demand</quote> interfaces, this new state identifies the situation where the
   interface is waiting for events to place it in the up state.
</para>
</refsect1>
</refentry>

<refentry id="API-netif-dormant-off">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>netif_dormant_off</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>netif_dormant_off</refname>
 <refpurpose>
     set device as not dormant.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>netif_dormant_off </function></funcdef>
   <paramdef>struct net_device * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     network device
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Device is not in dormant state.
</para>
</refsect1>
</refentry>

<refentry id="API-netif-dormant">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>netif_dormant</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>netif_dormant</refname>
 <refpurpose>
     test if carrier present
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>bool <function>netif_dormant </function></funcdef>
   <paramdef>const struct net_device * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     network device
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Check if carrier is present on device
</para>
</refsect1>
</refentry>

<refentry id="API-netif-oper-up">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>netif_oper_up</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>netif_oper_up</refname>
 <refpurpose>
     test if device is operational
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>bool <function>netif_oper_up </function></funcdef>
   <paramdef>const struct net_device * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     network device
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Check if carrier is operational
</para>
</refsect1>
</refentry>

<refentry id="API-netif-device-present">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>netif_device_present</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>netif_device_present</refname>
 <refpurpose>
     is device available or removed
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>bool <function>netif_device_present </function></funcdef>
   <paramdef>struct net_device * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     network device
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Check if device has not been removed from system.
</para>
</refsect1>
</refentry>

<refentry id="API-netif-tx-lock">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>netif_tx_lock</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>netif_tx_lock</refname>
 <refpurpose>
     grab network device transmit lock
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>netif_tx_lock </function></funcdef>
   <paramdef>struct net_device * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     network device
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Get network device transmit lock
</para>
</refsect1>
</refentry>

<refentry id="API---dev-uc-sync">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>__dev_uc_sync</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>__dev_uc_sync</refname>
 <refpurpose>
     Synchonize device's unicast list
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>__dev_uc_sync </function></funcdef>
   <paramdef>struct net_device * <parameter>dev</parameter></paramdef>
   <paramdef>int (*<parameter>sync</parameter>)
     <funcparams>struct net_device *, 					    const unsigned char *</funcparams></paramdef>
   <paramdef>int (*<parameter>unsync</parameter>)
     <funcparams>struct net_device *, 					      const unsigned char *</funcparams></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     device to sync
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>sync</parameter></term>
   <listitem>
    <para>
     function to call if address should be added
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>unsync</parameter></term>
   <listitem>
    <para>
     function to call if address should be removed
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Add newly added addresses to the interface, and release
   addresses that have been deleted.
</para>
</refsect1>
</refentry>

<refentry id="API---dev-uc-unsync">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>__dev_uc_unsync</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>__dev_uc_unsync</refname>
 <refpurpose>
     Remove synchronized addresses from device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>__dev_uc_unsync </function></funcdef>
   <paramdef>struct net_device * <parameter>dev</parameter></paramdef>
   <paramdef>int (*<parameter>unsync</parameter>)
     <funcparams>struct net_device *, 						 const unsigned char *</funcparams></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     device to sync
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>unsync</parameter></term>
   <listitem>
    <para>
     function to call if address should be removed
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Remove all addresses that were added to the device by <function>dev_uc_sync</function>.
</para>
</refsect1>
</refentry>

<refentry id="API---dev-mc-sync">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>__dev_mc_sync</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>__dev_mc_sync</refname>
 <refpurpose>
     Synchonize device's multicast list
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>__dev_mc_sync </function></funcdef>
   <paramdef>struct net_device * <parameter>dev</parameter></paramdef>
   <paramdef>int (*<parameter>sync</parameter>)
     <funcparams>struct net_device *, 					    const unsigned char *</funcparams></paramdef>
   <paramdef>int (*<parameter>unsync</parameter>)
     <funcparams>struct net_device *, 					      const unsigned char *</funcparams></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     device to sync
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>sync</parameter></term>
   <listitem>
    <para>
     function to call if address should be added
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>unsync</parameter></term>
   <listitem>
    <para>
     function to call if address should be removed
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Add newly added addresses to the interface, and release
   addresses that have been deleted.
</para>
</refsect1>
</refentry>

<refentry id="API---dev-mc-unsync">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>__dev_mc_unsync</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>__dev_mc_unsync</refname>
 <refpurpose>
     Remove synchronized addresses from device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>__dev_mc_unsync </function></funcdef>
   <paramdef>struct net_device * <parameter>dev</parameter></paramdef>
   <paramdef>int (*<parameter>unsync</parameter>)
     <funcparams>struct net_device *, 						 const unsigned char *</funcparams></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     device to sync
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>unsync</parameter></term>
   <listitem>
    <para>
     function to call if address should be removed
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Remove all addresses that were added to the device by <function>dev_mc_sync</function>.
</para>
</refsect1>
</refentry>

     </sect1>
     <sect1><title>PHY Support</title>
<!-- drivers/net/phy/phy.c -->
<refentry id="API-phy-print-status">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>phy_print_status</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>phy_print_status</refname>
 <refpurpose>
  Convenience function to print out the current phy status
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>phy_print_status </function></funcdef>
   <paramdef>struct phy_device * <parameter>phydev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>phydev</parameter></term>
   <listitem>
    <para>
     the phy_device struct
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-phy-ethtool-sset">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>phy_ethtool_sset</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>phy_ethtool_sset</refname>
 <refpurpose>
     generic ethtool sset function, handles all the details
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>phy_ethtool_sset </function></funcdef>
   <paramdef>struct phy_device * <parameter>phydev</parameter></paramdef>
   <paramdef>struct ethtool_cmd * <parameter>cmd</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>phydev</parameter></term>
   <listitem>
    <para>
     target phy_device struct
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>cmd</parameter></term>
   <listitem>
    <para>
     ethtool_cmd
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>A few notes about parameter checking</title>
<para>
   - We don't set port or transceiver, so we don't care what they
   were set to.
   - <function>phy_start_aneg</function> will make sure forced settings are sane, and
   choose the next best ones from the ones selected, so we don't
   care if ethtool tries to give us bad values.
</para>
</refsect1>
</refentry>

<refentry id="API-phy-mii-ioctl">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>phy_mii_ioctl</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>phy_mii_ioctl</refname>
 <refpurpose>
     generic PHY MII ioctl interface
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>phy_mii_ioctl </function></funcdef>
   <paramdef>struct phy_device * <parameter>phydev</parameter></paramdef>
   <paramdef>struct ifreq * <parameter>ifr</parameter></paramdef>
   <paramdef>int <parameter>cmd</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>phydev</parameter></term>
   <listitem>
    <para>
     the phy_device struct
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>ifr</parameter></term>
   <listitem>
    <para>
     <structname>struct ifreq</structname> for socket ioctl's
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>cmd</parameter></term>
   <listitem>
    <para>
     ioctl cmd to execute
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Note that this function is currently incompatible with the
   PHYCONTROL layer.  It changes registers without regard to
   current state.  Use at own risk.
</para>
</refsect1>
</refentry>

<refentry id="API-phy-start-aneg">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>phy_start_aneg</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>phy_start_aneg</refname>
 <refpurpose>
     start auto-negotiation for this PHY device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>phy_start_aneg </function></funcdef>
   <paramdef>struct phy_device * <parameter>phydev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>phydev</parameter></term>
   <listitem>
    <para>
     the phy_device struct
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Sanitizes the settings (if we're not autonegotiating
   them), and then calls the driver's config_aneg function.
   If the PHYCONTROL Layer is operating, we change the state to
   reflect the beginning of Auto-negotiation or forcing.
</para>
</refsect1>
</refentry>

<refentry id="API-phy-start-interrupts">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>phy_start_interrupts</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>phy_start_interrupts</refname>
 <refpurpose>
     request and enable interrupts for a PHY device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>phy_start_interrupts </function></funcdef>
   <paramdef>struct phy_device * <parameter>phydev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>phydev</parameter></term>
   <listitem>
    <para>
     target phy_device struct
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Request the interrupt for the given PHY.
   If this fails, then we set irq to PHY_POLL.
   Otherwise, we enable the interrupts in the PHY.
   This should only be called with a valid IRQ number.
   Returns 0 on success or &lt; 0 on error.
</para>
</refsect1>
</refentry>

<refentry id="API-phy-stop-interrupts">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>phy_stop_interrupts</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>phy_stop_interrupts</refname>
 <refpurpose>
     disable interrupts from a PHY device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>phy_stop_interrupts </function></funcdef>
   <paramdef>struct phy_device * <parameter>phydev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>phydev</parameter></term>
   <listitem>
    <para>
     target phy_device struct
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-phy-stop">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>phy_stop</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>phy_stop</refname>
 <refpurpose>
     Bring down the PHY link, and stop checking the status
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>phy_stop </function></funcdef>
   <paramdef>struct phy_device * <parameter>phydev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>phydev</parameter></term>
   <listitem>
    <para>
     target phy_device struct
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-phy-start">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>phy_start</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>phy_start</refname>
 <refpurpose>
     start or restart a PHY device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>phy_start </function></funcdef>
   <paramdef>struct phy_device * <parameter>phydev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>phydev</parameter></term>
   <listitem>
    <para>
     target phy_device struct
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Indicates the attached device's readiness to
   handle PHY-related work.  Used during startup to start the
   PHY, and after a call to <function>phy_stop</function> to resume operation.
   Also used to indicate the MDIO bus has cleared an error
   condition.
</para>
</refsect1>
</refentry>

<refentry id="API-phy-read-mmd-indirect">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>phy_read_mmd_indirect</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>phy_read_mmd_indirect</refname>
 <refpurpose>
     reads data from the MMD registers
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>phy_read_mmd_indirect </function></funcdef>
   <paramdef>struct phy_device * <parameter>phydev</parameter></paramdef>
   <paramdef>int <parameter>prtad</parameter></paramdef>
   <paramdef>int <parameter>devad</parameter></paramdef>
   <paramdef>int <parameter>addr</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>phydev</parameter></term>
   <listitem>
    <para>
     The PHY device bus
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>prtad</parameter></term>
   <listitem>
    <para>
     MMD Address
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>devad</parameter></term>
   <listitem>
    <para>
     MMD DEVAD
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>addr</parameter></term>
   <listitem>
    <para>
     PHY address on the MII bus
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   it reads data from the MMD registers (clause 22 to access to
   clause 45) of the specified phy address.
</para>
</refsect1>
<refsect1>
<title>To read these register we have</title>
<para>
   1) Write reg 13 // DEVAD
   2) Write reg 14 // MMD Address
   3) Write reg 13 // MMD Data Command for MMD DEVAD
   3) Read  reg 14 // Read MMD data
</para>
</refsect1>
</refentry>

<refentry id="API-phy-write-mmd-indirect">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>phy_write_mmd_indirect</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>phy_write_mmd_indirect</refname>
 <refpurpose>
     writes data to the MMD registers
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>phy_write_mmd_indirect </function></funcdef>
   <paramdef>struct phy_device * <parameter>phydev</parameter></paramdef>
   <paramdef>int <parameter>prtad</parameter></paramdef>
   <paramdef>int <parameter>devad</parameter></paramdef>
   <paramdef>int <parameter>addr</parameter></paramdef>
   <paramdef>u32 <parameter>data</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>phydev</parameter></term>
   <listitem>
    <para>
     The PHY device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>prtad</parameter></term>
   <listitem>
    <para>
     MMD Address
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>devad</parameter></term>
   <listitem>
    <para>
     MMD DEVAD
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>addr</parameter></term>
   <listitem>
    <para>
     PHY address on the MII bus
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>data</parameter></term>
   <listitem>
    <para>
     data to write in the MMD register
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Write data from the MMD registers of the specified
   phy address.
</para>
</refsect1>
<refsect1>
<title>To write these register we have</title>
<para>
   1) Write reg 13 // DEVAD
   2) Write reg 14 // MMD Address
   3) Write reg 13 // MMD Data Command for MMD DEVAD
   3) Write reg 14 // Write MMD data
</para>
</refsect1>
</refentry>

<refentry id="API-phy-init-eee">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>phy_init_eee</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>phy_init_eee</refname>
 <refpurpose>
     init and check the EEE feature
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>phy_init_eee </function></funcdef>
   <paramdef>struct phy_device * <parameter>phydev</parameter></paramdef>
   <paramdef>bool <parameter>clk_stop_enable</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>phydev</parameter></term>
   <listitem>
    <para>
     target phy_device struct
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>clk_stop_enable</parameter></term>
   <listitem>
    <para>
     PHY may stop the clock during LPI
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   it checks if the Energy-Efficient Ethernet (EEE)
   is supported by looking at the MMD registers 3.20 and 7.60/61
   and it programs the MMD register 3.0 setting the <quote>Clock stop enable</quote>
   bit if required.
</para>
</refsect1>
</refentry>

<refentry id="API-phy-get-eee-err">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>phy_get_eee_err</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>phy_get_eee_err</refname>
 <refpurpose>
     report the EEE wake error count
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>phy_get_eee_err </function></funcdef>
   <paramdef>struct phy_device * <parameter>phydev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>phydev</parameter></term>
   <listitem>
    <para>
     target phy_device struct
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   it is to report the number of time where the PHY
   failed to complete its normal wake sequence.
</para>
</refsect1>
</refentry>

<refentry id="API-phy-ethtool-get-eee">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>phy_ethtool_get_eee</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>phy_ethtool_get_eee</refname>
 <refpurpose>
     get EEE supported and status
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>phy_ethtool_get_eee </function></funcdef>
   <paramdef>struct phy_device * <parameter>phydev</parameter></paramdef>
   <paramdef>struct ethtool_eee * <parameter>data</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>phydev</parameter></term>
   <listitem>
    <para>
     target phy_device struct
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>data</parameter></term>
   <listitem>
    <para>
     ethtool_eee data
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   it reportes the Supported/Advertisement/LP Advertisement
   capabilities.
</para>
</refsect1>
</refentry>

<refentry id="API-phy-ethtool-set-eee">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>phy_ethtool_set_eee</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>phy_ethtool_set_eee</refname>
 <refpurpose>
     set EEE supported and status
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>phy_ethtool_set_eee </function></funcdef>
   <paramdef>struct phy_device * <parameter>phydev</parameter></paramdef>
   <paramdef>struct ethtool_eee * <parameter>data</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>phydev</parameter></term>
   <listitem>
    <para>
     target phy_device struct
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>data</parameter></term>
   <listitem>
    <para>
     ethtool_eee data
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   it is to program the Advertisement EEE register.
</para>
</refsect1>
</refentry>

<!-- drivers/net/phy/phy.c -->
<refentry id="API-phy-clear-interrupt">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>phy_clear_interrupt</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>phy_clear_interrupt</refname>
 <refpurpose>
  Ack the phy device's interrupt
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>phy_clear_interrupt </function></funcdef>
   <paramdef>struct phy_device * <parameter>phydev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>phydev</parameter></term>
   <listitem>
    <para>
     the phy_device struct
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   If the <parameter>phydev</parameter> driver has an ack_interrupt function, call it to
   ack and clear the phy device's interrupt.
   </para><para>

   Returns 0 on success or &lt; 0 on error.
</para>
</refsect1>
</refentry>

<refentry id="API-phy-config-interrupt">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>phy_config_interrupt</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>phy_config_interrupt</refname>
 <refpurpose>
     configure the PHY device for the requested interrupts
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>phy_config_interrupt </function></funcdef>
   <paramdef>struct phy_device * <parameter>phydev</parameter></paramdef>
   <paramdef>u32 <parameter>interrupts</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>phydev</parameter></term>
   <listitem>
    <para>
     the phy_device struct
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>interrupts</parameter></term>
   <listitem>
    <para>
     interrupt flags to configure for this <parameter>phydev</parameter>
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Returns 0 on success or &lt; 0 on error.
</para>
</refsect1>
</refentry>

<refentry id="API-phy-aneg-done">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>phy_aneg_done</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>phy_aneg_done</refname>
 <refpurpose>
     return auto-negotiation status
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>phy_aneg_done </function></funcdef>
   <paramdef>struct phy_device * <parameter>phydev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>phydev</parameter></term>
   <listitem>
    <para>
     target phy_device struct
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Return the auto-negotiation status from this <parameter>phydev</parameter>
   Returns &gt; 0 on success or &lt; 0 on error. 0 means that auto-negotiation
   is still pending.
</para>
</refsect1>
</refentry>

<refentry id="API-phy-find-setting">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>phy_find_setting</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>phy_find_setting</refname>
 <refpurpose>
     find a PHY settings array entry that matches speed &amp; duplex
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>unsigned int <function>phy_find_setting </function></funcdef>
   <paramdef>int <parameter>speed</parameter></paramdef>
   <paramdef>int <parameter>duplex</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>speed</parameter></term>
   <listitem>
    <para>
     speed to match
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>duplex</parameter></term>
   <listitem>
    <para>
     duplex to match
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Searches the settings array for the setting which
   matches the desired speed and duplex, and returns the index
   of that setting.  Returns the index of the last setting if
   none of the others match.
</para>
</refsect1>
</refentry>

<refentry id="API-phy-find-valid">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>phy_find_valid</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>phy_find_valid</refname>
 <refpurpose>
     find a PHY setting that matches the requested features mask
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>unsigned int <function>phy_find_valid </function></funcdef>
   <paramdef>unsigned int <parameter>idx</parameter></paramdef>
   <paramdef>u32 <parameter>features</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>idx</parameter></term>
   <listitem>
    <para>
     The first index in settings[] to search
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>features</parameter></term>
   <listitem>
    <para>
     A mask of the valid settings
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Returns the index of the first valid setting less
   than or equal to the one pointed to by idx, as determined by
   the mask in features.  Returns the index of the last setting
   if nothing else matches.
</para>
</refsect1>
</refentry>

<refentry id="API-phy-check-valid">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>phy_check_valid</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>phy_check_valid</refname>
 <refpurpose>
     check if there is a valid PHY setting which matches speed, duplex, and feature mask
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>bool <function>phy_check_valid </function></funcdef>
   <paramdef>int <parameter>speed</parameter></paramdef>
   <paramdef>int <parameter>duplex</parameter></paramdef>
   <paramdef>u32 <parameter>features</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>speed</parameter></term>
   <listitem>
    <para>
     speed to match
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>duplex</parameter></term>
   <listitem>
    <para>
     duplex to match
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>features</parameter></term>
   <listitem>
    <para>
     A mask of the valid settings
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Returns true if there is a valid setting, false otherwise.
</para>
</refsect1>
</refentry>

<refentry id="API-phy-sanitize-settings">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>phy_sanitize_settings</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>phy_sanitize_settings</refname>
 <refpurpose>
     make sure the PHY is set to supported speed and duplex
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>phy_sanitize_settings </function></funcdef>
   <paramdef>struct phy_device * <parameter>phydev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>phydev</parameter></term>
   <listitem>
    <para>
     the target phy_device struct
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Make sure the PHY is set to supported speeds and
   duplexes.  Drop down by one in this order:  1000/FULL,
   1000/HALF, 100/FULL, 100/HALF, 10/FULL, 10/HALF.
</para>
</refsect1>
</refentry>

<refentry id="API-phy-start-machine">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>phy_start_machine</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>phy_start_machine</refname>
 <refpurpose>
     start PHY state machine tracking
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>phy_start_machine </function></funcdef>
   <paramdef>struct phy_device * <parameter>phydev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>phydev</parameter></term>
   <listitem>
    <para>
     the phy_device struct
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   The PHY infrastructure can run a state machine
   which tracks whether the PHY is starting up, negotiating,
   etc.  This function starts the timer which tracks the state
   of the PHY.  If you want to maintain your own state machine,
   do not call this function.
</para>
</refsect1>
</refentry>

<refentry id="API-phy-stop-machine">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>phy_stop_machine</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>phy_stop_machine</refname>
 <refpurpose>
     stop the PHY state machine tracking
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>phy_stop_machine </function></funcdef>
   <paramdef>struct phy_device * <parameter>phydev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>phydev</parameter></term>
   <listitem>
    <para>
     target phy_device struct
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Stops the state machine timer, sets the state to UP
   (unless it wasn't up yet). This function must be called BEFORE
   phy_detach.
</para>
</refsect1>
</refentry>

<refentry id="API-phy-error">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>phy_error</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>phy_error</refname>
 <refpurpose>
     enter HALTED state for this PHY device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>phy_error </function></funcdef>
   <paramdef>struct phy_device * <parameter>phydev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>phydev</parameter></term>
   <listitem>
    <para>
     target phy_device struct
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Moves the PHY to the HALTED state in response to a read
   or write error, and tells the controller the link is down.
   Must not be called from interrupt context, or while the
   phydev-&gt;lock is held.
</para>
</refsect1>
</refentry>

<refentry id="API-phy-interrupt">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>phy_interrupt</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>phy_interrupt</refname>
 <refpurpose>
     PHY interrupt handler
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>irqreturn_t <function>phy_interrupt </function></funcdef>
   <paramdef>int <parameter>irq</parameter></paramdef>
   <paramdef>void * <parameter>phy_dat</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>irq</parameter></term>
   <listitem>
    <para>
     interrupt line
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>phy_dat</parameter></term>
   <listitem>
    <para>
     phy_device pointer
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   When a PHY interrupt occurs, the handler disables
   interrupts, and schedules a work task to clear the interrupt.
</para>
</refsect1>
</refentry>

<refentry id="API-phy-enable-interrupts">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>phy_enable_interrupts</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>phy_enable_interrupts</refname>
 <refpurpose>
     Enable the interrupts from the PHY side
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>phy_enable_interrupts </function></funcdef>
   <paramdef>struct phy_device * <parameter>phydev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>phydev</parameter></term>
   <listitem>
    <para>
     target phy_device struct
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-phy-disable-interrupts">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>phy_disable_interrupts</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>phy_disable_interrupts</refname>
 <refpurpose>
     Disable the PHY interrupts from the PHY side
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>phy_disable_interrupts </function></funcdef>
   <paramdef>struct phy_device * <parameter>phydev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>phydev</parameter></term>
   <listitem>
    <para>
     target phy_device struct
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-phy-change">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>phy_change</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>phy_change</refname>
 <refpurpose>
     Scheduled by the phy_interrupt/timer to handle PHY changes
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>phy_change </function></funcdef>
   <paramdef>struct work_struct * <parameter>work</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>work</parameter></term>
   <listitem>
    <para>
     work_struct that describes the work to be done
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-phy-state-machine">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>phy_state_machine</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>phy_state_machine</refname>
 <refpurpose>
     Handle the state machine
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>phy_state_machine </function></funcdef>
   <paramdef>struct work_struct * <parameter>work</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>work</parameter></term>
   <listitem>
    <para>
     work_struct that describes the work to be done
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<!-- drivers/net/phy/phy_device.c -->
<refentry id="API-phy-register-fixup">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>phy_register_fixup</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>phy_register_fixup</refname>
 <refpurpose>
  creates a new phy_fixup and adds it to the list
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>phy_register_fixup </function></funcdef>
   <paramdef>const char * <parameter>bus_id</parameter></paramdef>
   <paramdef>u32 <parameter>phy_uid</parameter></paramdef>
   <paramdef>u32 <parameter>phy_uid_mask</parameter></paramdef>
   <paramdef>int (*<parameter>run</parameter>)
     <funcparams>struct phy_device *</funcparams></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>bus_id</parameter></term>
   <listitem>
    <para>
     A string which matches phydev-&gt;dev.bus_id (or PHY_ANY_ID)
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>phy_uid</parameter></term>
   <listitem>
    <para>
     Used to match against phydev-&gt;phy_id (the UID of the PHY)
     It can also be PHY_ANY_UID
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>phy_uid_mask</parameter></term>
   <listitem>
    <para>
     Applied to phydev-&gt;phy_id and fixup-&gt;phy_uid before
     comparison
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>run</parameter></term>
   <listitem>
    <para>
     The actual code to be run when a matching PHY is found
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-get-phy-device">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>get_phy_device</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>get_phy_device</refname>
 <refpurpose>
     reads the specified PHY device and returns its <parameter>phy_device</parameter> struct
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct phy_device * <function>get_phy_device </function></funcdef>
   <paramdef>struct mii_bus * <parameter>bus</parameter></paramdef>
   <paramdef>int <parameter>addr</parameter></paramdef>
   <paramdef>bool <parameter>is_c45</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>bus</parameter></term>
   <listitem>
    <para>
     the target MII bus
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>addr</parameter></term>
   <listitem>
    <para>
     PHY address on the MII bus
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>is_c45</parameter></term>
   <listitem>
    <para>
     If true the PHY uses the 802.3 clause 45 protocol
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Reads the ID registers of the PHY at <parameter>addr</parameter> on the
   <parameter>bus</parameter>, then allocates and returns the phy_device to represent it.
</para>
</refsect1>
</refentry>

<refentry id="API-phy-device-register">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>phy_device_register</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>phy_device_register</refname>
 <refpurpose>
     Register the phy device on the MDIO bus
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>phy_device_register </function></funcdef>
   <paramdef>struct phy_device * <parameter>phydev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>phydev</parameter></term>
   <listitem>
    <para>
     phy_device structure to be added to the MDIO bus
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-phy-find-first">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>phy_find_first</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>phy_find_first</refname>
 <refpurpose>
     finds the first PHY device on the bus
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct phy_device * <function>phy_find_first </function></funcdef>
   <paramdef>struct mii_bus * <parameter>bus</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>bus</parameter></term>
   <listitem>
    <para>
     the target MII bus
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-phy-connect-direct">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>phy_connect_direct</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>phy_connect_direct</refname>
 <refpurpose>
     connect an ethernet device to a specific phy_device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>phy_connect_direct </function></funcdef>
   <paramdef>struct net_device * <parameter>dev</parameter></paramdef>
   <paramdef>struct phy_device * <parameter>phydev</parameter></paramdef>
   <paramdef>void (*<parameter>handler</parameter>)
     <funcparams>struct net_device *</funcparams></paramdef>
   <paramdef>phy_interface_t <parameter>interface</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     the network device to connect
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>phydev</parameter></term>
   <listitem>
    <para>
     the pointer to the phy device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>handler</parameter></term>
   <listitem>
    <para>
     callback function for state change notifications
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>interface</parameter></term>
   <listitem>
    <para>
     PHY device's interface
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-phy-connect">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>phy_connect</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>phy_connect</refname>
 <refpurpose>
     connect an ethernet device to a PHY device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct phy_device * <function>phy_connect </function></funcdef>
   <paramdef>struct net_device * <parameter>dev</parameter></paramdef>
   <paramdef>const char * <parameter>bus_id</parameter></paramdef>
   <paramdef>void (*<parameter>handler</parameter>)
     <funcparams>struct net_device *</funcparams></paramdef>
   <paramdef>phy_interface_t <parameter>interface</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     the network device to connect
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>bus_id</parameter></term>
   <listitem>
    <para>
     the id string of the PHY device to connect
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>handler</parameter></term>
   <listitem>
    <para>
     callback function for state change notifications
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>interface</parameter></term>
   <listitem>
    <para>
     PHY device's interface
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Convenience function for connecting ethernet
   devices to PHY devices.  The default behavior is for
   the PHY infrastructure to handle everything, and only notify
   the connected driver when the link status changes.  If you
   don't want, or can't use the provided functionality, you may
   choose to call only the subset of functions which provide
   the desired functionality.
</para>
</refsect1>
</refentry>

<refentry id="API-phy-disconnect">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>phy_disconnect</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>phy_disconnect</refname>
 <refpurpose>
     disable interrupts, stop state machine, and detach a PHY device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>phy_disconnect </function></funcdef>
   <paramdef>struct phy_device * <parameter>phydev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>phydev</parameter></term>
   <listitem>
    <para>
     target phy_device struct
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-phy-attach-direct">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>phy_attach_direct</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>phy_attach_direct</refname>
 <refpurpose>
     attach a network device to a given PHY device pointer
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>phy_attach_direct </function></funcdef>
   <paramdef>struct net_device * <parameter>dev</parameter></paramdef>
   <paramdef>struct phy_device * <parameter>phydev</parameter></paramdef>
   <paramdef>u32 <parameter>flags</parameter></paramdef>
   <paramdef>phy_interface_t <parameter>interface</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     network device to attach
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>phydev</parameter></term>
   <listitem>
    <para>
     Pointer to phy_device to attach
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>flags</parameter></term>
   <listitem>
    <para>
     PHY device's dev_flags
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>interface</parameter></term>
   <listitem>
    <para>
     PHY device's interface
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Called by drivers to attach to a particular PHY
   device. The phy_device is found, and properly hooked up
   to the phy_driver.  If no driver is attached, then a
   generic driver is used.  The phy_device is given a ptr to
   the attaching device, and given a callback for link status
   change.  The phy_device is returned to the attaching driver.
</para>
</refsect1>
</refentry>

<refentry id="API-phy-attach">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>phy_attach</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>phy_attach</refname>
 <refpurpose>
     attach a network device to a particular PHY device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct phy_device * <function>phy_attach </function></funcdef>
   <paramdef>struct net_device * <parameter>dev</parameter></paramdef>
   <paramdef>const char * <parameter>bus_id</parameter></paramdef>
   <paramdef>phy_interface_t <parameter>interface</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     network device to attach
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>bus_id</parameter></term>
   <listitem>
    <para>
     Bus ID of PHY device to attach
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>interface</parameter></term>
   <listitem>
    <para>
     PHY device's interface
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Same as <function>phy_attach_direct</function> except that a PHY bus_id
   string is passed instead of a pointer to a struct phy_device.
</para>
</refsect1>
</refentry>

<refentry id="API-phy-detach">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>phy_detach</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>phy_detach</refname>
 <refpurpose>
     detach a PHY device from its network device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>phy_detach </function></funcdef>
   <paramdef>struct phy_device * <parameter>phydev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>phydev</parameter></term>
   <listitem>
    <para>
     target phy_device struct
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-genphy-setup-forced">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>genphy_setup_forced</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>genphy_setup_forced</refname>
 <refpurpose>
     configures/forces speed/duplex from <parameter>phydev</parameter>
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>genphy_setup_forced </function></funcdef>
   <paramdef>struct phy_device * <parameter>phydev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>phydev</parameter></term>
   <listitem>
    <para>
     target phy_device struct
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Configures MII_BMCR to force speed/duplex
   to the values in phydev. Assumes that the values are valid.
   Please see <function>phy_sanitize_settings</function>.
</para>
</refsect1>
</refentry>

<refentry id="API-genphy-restart-aneg">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>genphy_restart_aneg</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>genphy_restart_aneg</refname>
 <refpurpose>
     Enable and Restart Autonegotiation
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>genphy_restart_aneg </function></funcdef>
   <paramdef>struct phy_device * <parameter>phydev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>phydev</parameter></term>
   <listitem>
    <para>
     target phy_device struct
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-genphy-config-aneg">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>genphy_config_aneg</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>genphy_config_aneg</refname>
 <refpurpose>
     restart auto-negotiation or write BMCR
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>genphy_config_aneg </function></funcdef>
   <paramdef>struct phy_device * <parameter>phydev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>phydev</parameter></term>
   <listitem>
    <para>
     target phy_device struct
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   If auto-negotiation is enabled, we configure the
   advertising, and then restart auto-negotiation.  If it is not
   enabled, then we write the BMCR.
</para>
</refsect1>
</refentry>

<refentry id="API-genphy-aneg-done">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>genphy_aneg_done</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>genphy_aneg_done</refname>
 <refpurpose>
     return auto-negotiation status
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>genphy_aneg_done </function></funcdef>
   <paramdef>struct phy_device * <parameter>phydev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>phydev</parameter></term>
   <listitem>
    <para>
     target phy_device struct
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Reads the status register and returns 0 either if
   auto-negotiation is incomplete, or if there was an error.
   Returns BMSR_ANEGCOMPLETE if auto-negotiation is done.
</para>
</refsect1>
</refentry>

<refentry id="API-genphy-update-link">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>genphy_update_link</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>genphy_update_link</refname>
 <refpurpose>
     update link status in <parameter>phydev</parameter>
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>genphy_update_link </function></funcdef>
   <paramdef>struct phy_device * <parameter>phydev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>phydev</parameter></term>
   <listitem>
    <para>
     target phy_device struct
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Update the value in phydev-&gt;link to reflect the
   current link value.  In order to do this, we need to read
   the status register twice, keeping the second value.
</para>
</refsect1>
</refentry>

<refentry id="API-genphy-read-status">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>genphy_read_status</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>genphy_read_status</refname>
 <refpurpose>
     check the link status and update current link state
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>genphy_read_status </function></funcdef>
   <paramdef>struct phy_device * <parameter>phydev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>phydev</parameter></term>
   <listitem>
    <para>
     target phy_device struct
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Check the link, then figure out the current state
   by comparing what we advertise with what the link partner
   advertises.  Start by checking the gigabit possibilities,
   then move on to 10/100.
</para>
</refsect1>
</refentry>

<refentry id="API-genphy-soft-reset">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>genphy_soft_reset</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>genphy_soft_reset</refname>
 <refpurpose>
     software reset the PHY via BMCR_RESET bit
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>genphy_soft_reset </function></funcdef>
   <paramdef>struct phy_device * <parameter>phydev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>phydev</parameter></term>
   <listitem>
    <para>
     target phy_device struct
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Perform a software PHY reset using the standard
   BMCR_RESET bit and poll for the reset bit to be cleared.
</para>
</refsect1>
<refsect1>
<title>Returns</title>
<para>
   0 on success, &lt; 0 on failure
</para>
</refsect1>
</refentry>

<refentry id="API-phy-driver-register">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>phy_driver_register</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>phy_driver_register</refname>
 <refpurpose>
     register a phy_driver with the PHY layer
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>phy_driver_register </function></funcdef>
   <paramdef>struct phy_driver * <parameter>new_driver</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>new_driver</parameter></term>
   <listitem>
    <para>
     new phy_driver to register
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<!-- drivers/net/phy/phy_device.c -->
<refentry id="API-get-phy-c45-ids">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>get_phy_c45_ids</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>get_phy_c45_ids</refname>
 <refpurpose>
  reads the specified addr for its 802.3-c45 IDs.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>get_phy_c45_ids </function></funcdef>
   <paramdef>struct mii_bus * <parameter>bus</parameter></paramdef>
   <paramdef>int <parameter>addr</parameter></paramdef>
   <paramdef>u32 * <parameter>phy_id</parameter></paramdef>
   <paramdef>struct phy_c45_device_ids * <parameter>c45_ids</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>bus</parameter></term>
   <listitem>
    <para>
     the target MII bus
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>addr</parameter></term>
   <listitem>
    <para>
     PHY address on the MII bus
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>phy_id</parameter></term>
   <listitem>
    <para>
     where to store the ID retrieved.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>c45_ids</parameter></term>
   <listitem>
    <para>
     where to store the c45 ID information.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   If the PHY devices-in-package appears to be valid, it and the
   corresponding identifiers are stored in <parameter>c45_ids</parameter>, zero is stored
   in <parameter>phy_id</parameter>.  Otherwise 0xffffffff is stored in <parameter>phy_id</parameter>.  Returns
   zero on success.
</para>
</refsect1>
</refentry>

<refentry id="API-get-phy-id">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>get_phy_id</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>get_phy_id</refname>
 <refpurpose>
     reads the specified addr for its ID.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>get_phy_id </function></funcdef>
   <paramdef>struct mii_bus * <parameter>bus</parameter></paramdef>
   <paramdef>int <parameter>addr</parameter></paramdef>
   <paramdef>u32 * <parameter>phy_id</parameter></paramdef>
   <paramdef>bool <parameter>is_c45</parameter></paramdef>
   <paramdef>struct phy_c45_device_ids * <parameter>c45_ids</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>bus</parameter></term>
   <listitem>
    <para>
     the target MII bus
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>addr</parameter></term>
   <listitem>
    <para>
     PHY address on the MII bus
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>phy_id</parameter></term>
   <listitem>
    <para>
     where to store the ID retrieved.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>is_c45</parameter></term>
   <listitem>
    <para>
     If true the PHY uses the 802.3 clause 45 protocol
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>c45_ids</parameter></term>
   <listitem>
    <para>
     where to store the c45 ID information.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   In the case of a 802.3-c22 PHY, reads the ID registers
   of the PHY at <parameter>addr</parameter> on the <parameter>bus</parameter>, stores it in <parameter>phy_id</parameter> and returns
   zero on success.
   </para><para>

   In the case of a 802.3-c45 PHY, <function>get_phy_c45_ids</function> is invoked, and
   its return value is in turn returned.
</para>
</refsect1>
</refentry>

<refentry id="API-phy-prepare-link">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>phy_prepare_link</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>phy_prepare_link</refname>
 <refpurpose>
     prepares the PHY layer to monitor link status
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>phy_prepare_link </function></funcdef>
   <paramdef>struct phy_device * <parameter>phydev</parameter></paramdef>
   <paramdef>void (*<parameter>handler</parameter>)
     <funcparams>struct net_device *</funcparams></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>phydev</parameter></term>
   <listitem>
    <para>
     target phy_device struct
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>handler</parameter></term>
   <listitem>
    <para>
     callback function for link status change notifications
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Tells the PHY infrastructure to handle the
   gory details on monitoring link status (whether through
   polling or an interrupt), and to call back to the
   connected device driver when the link status changes.
   If you want to monitor your own link state, don't call
   this function.
</para>
</refsect1>
</refentry>

<refentry id="API-phy-poll-reset">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>phy_poll_reset</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>phy_poll_reset</refname>
 <refpurpose>
     Safely wait until a PHY reset has properly completed
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>phy_poll_reset </function></funcdef>
   <paramdef>struct phy_device * <parameter>phydev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>phydev</parameter></term>
   <listitem>
    <para>
     The PHY device to poll
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   According to IEEE 802.3, Section 2, Subsection 22.2.4.1.1, as
   published in 2008, a PHY reset may take up to 0.5 seconds.  The MII BMCR
   register must be polled until the BMCR_RESET bit clears.
   </para><para>

   Furthermore, any attempts to write to PHY registers may have no effect
   or even generate MDIO bus errors until this is complete.
   </para><para>

   Some PHYs (such as the Marvell 88E1111) don't entirely conform to the
   standard and do not fully reset after the BMCR_RESET bit is set, and may
   even *REQUIRE* a soft-reset to properly restart autonegotiation.  In an
   effort to support such broken PHYs, this function is separate from the
   standard <function>phy_init_hw</function> which will zero all the other bits in the BMCR
   and reapply all driver-specific and board-specific fixups.
</para>
</refsect1>
</refentry>

<refentry id="API-genphy-config-advert">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>genphy_config_advert</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>genphy_config_advert</refname>
 <refpurpose>
     sanitize and advertise auto-negotiation parameters
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>genphy_config_advert </function></funcdef>
   <paramdef>struct phy_device * <parameter>phydev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>phydev</parameter></term>
   <listitem>
    <para>
     target phy_device struct
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Writes MII_ADVERTISE with the appropriate values,
   after sanitizing the values to make sure we only advertise
   what is supported.  Returns &lt; 0 on error, 0 if the PHY's advertisement
   hasn't changed, and &gt; 0 if it has changed.
</para>
</refsect1>
</refentry>

<refentry id="API-phy-probe">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>phy_probe</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>phy_probe</refname>
 <refpurpose>
     probe and init a PHY device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>phy_probe </function></funcdef>
   <paramdef>struct device * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     device to probe and init
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Take care of setting up the phy_device structure,
   set the state to READY (the driver's init function should
   set it to STARTING if needed).
</para>
</refsect1>
</refentry>

<!-- drivers/net/phy/mdio_bus.c -->
<refentry id="API-mdiobus-alloc-size">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>mdiobus_alloc_size</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>mdiobus_alloc_size</refname>
 <refpurpose>
  allocate a mii_bus structure
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct mii_bus * <function>mdiobus_alloc_size </function></funcdef>
   <paramdef>size_t <parameter>size</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>size</parameter></term>
   <listitem>
    <para>
     extra amount of memory to allocate for private storage.
     If non-zero, then bus-&gt;priv is points to that memory.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   called by a bus driver to allocate an mii_bus
   structure to fill in.
</para>
</refsect1>
</refentry>

<refentry id="API-devm-mdiobus-alloc-size">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>devm_mdiobus_alloc_size</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>devm_mdiobus_alloc_size</refname>
 <refpurpose>
     Resource-managed <function>mdiobus_alloc_size</function>
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct mii_bus * <function>devm_mdiobus_alloc_size </function></funcdef>
   <paramdef>struct device * <parameter>dev</parameter></paramdef>
   <paramdef>int <parameter>sizeof_priv</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     Device to allocate mii_bus for
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>sizeof_priv</parameter></term>
   <listitem>
    <para>
     Space to allocate for private structure.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Managed mdiobus_alloc_size. mii_bus allocated with this function is
   automatically freed on driver detach.
   </para><para>

   If an mii_bus allocated with this function needs to be freed separately,
   <function>devm_mdiobus_free</function> must be used.
</para>
</refsect1>
<refsect1>
<title>RETURNS</title>
<para>
   Pointer to allocated mii_bus on success, NULL on failure.
</para>
</refsect1>
</refentry>

<refentry id="API-devm-mdiobus-free">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>devm_mdiobus_free</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>devm_mdiobus_free</refname>
 <refpurpose>
     Resource-managed <function>mdiobus_free</function>
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>devm_mdiobus_free </function></funcdef>
   <paramdef>struct device * <parameter>dev</parameter></paramdef>
   <paramdef>struct mii_bus * <parameter>bus</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     Device this mii_bus belongs to
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>bus</parameter></term>
   <listitem>
    <para>
     the mii_bus associated with the device
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Free mii_bus allocated with <function>devm_mdiobus_alloc_size</function>.
</para>
</refsect1>
</refentry>

<refentry id="API-of-mdio-find-bus">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>of_mdio_find_bus</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>of_mdio_find_bus</refname>
 <refpurpose>
     Given an mii_bus node, find the mii_bus.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct mii_bus * <function>of_mdio_find_bus </function></funcdef>
   <paramdef>struct device_node * <parameter>mdio_bus_np</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>mdio_bus_np</parameter></term>
   <listitem>
    <para>
     Pointer to the mii_bus.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Returns a pointer to the mii_bus, or NULL if none found.
   </para><para>

   Because the association of a device_node and mii_bus is made via
   <function>of_mdiobus_register</function>, the mii_bus cannot be found before it is
   registered with <function>of_mdiobus_register</function>.
</para>
</refsect1>
</refentry>

<refentry id="API-mdiobus-register">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>mdiobus_register</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>mdiobus_register</refname>
 <refpurpose>
     bring up all the PHYs on a given bus and attach them to bus
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>mdiobus_register </function></funcdef>
   <paramdef>struct mii_bus * <parameter>bus</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>bus</parameter></term>
   <listitem>
    <para>
     target mii_bus
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Called by a bus driver to bring up all the PHYs
   on a given bus, and attach them to the bus.
   </para><para>

   Returns 0 on success or &lt; 0 on error.
</para>
</refsect1>
</refentry>

<refentry id="API-mdiobus-free">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>mdiobus_free</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>mdiobus_free</refname>
 <refpurpose>
     free a struct mii_bus
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>mdiobus_free </function></funcdef>
   <paramdef>struct mii_bus * <parameter>bus</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>bus</parameter></term>
   <listitem>
    <para>
     mii_bus to free
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This function releases the reference to the underlying device
   object in the mii_bus.  If this is the last reference, the mii_bus
   will be freed.
</para>
</refsect1>
</refentry>

<refentry id="API-mdiobus-read">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>mdiobus_read</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>mdiobus_read</refname>
 <refpurpose>
     Convenience function for reading a given MII mgmt register
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>mdiobus_read </function></funcdef>
   <paramdef>struct mii_bus * <parameter>bus</parameter></paramdef>
   <paramdef>int <parameter>addr</parameter></paramdef>
   <paramdef>u32 <parameter>regnum</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>bus</parameter></term>
   <listitem>
    <para>
     the mii_bus struct
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>addr</parameter></term>
   <listitem>
    <para>
     the phy address
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>regnum</parameter></term>
   <listitem>
    <para>
     register number to read
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>NOTE</title>
<para>
   MUST NOT be called from interrupt context,
   because the bus read/write functions may wait for an interrupt
   to conclude the operation.
</para>
</refsect1>
</refentry>

<refentry id="API-mdiobus-write">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>mdiobus_write</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>mdiobus_write</refname>
 <refpurpose>
     Convenience function for writing a given MII mgmt register
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>mdiobus_write </function></funcdef>
   <paramdef>struct mii_bus * <parameter>bus</parameter></paramdef>
   <paramdef>int <parameter>addr</parameter></paramdef>
   <paramdef>u32 <parameter>regnum</parameter></paramdef>
   <paramdef>u16 <parameter>val</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>bus</parameter></term>
   <listitem>
    <para>
     the mii_bus struct
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>addr</parameter></term>
   <listitem>
    <para>
     the phy address
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>regnum</parameter></term>
   <listitem>
    <para>
     register number to write
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>val</parameter></term>
   <listitem>
    <para>
     value to write to <parameter>regnum</parameter>
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>NOTE</title>
<para>
   MUST NOT be called from interrupt context,
   because the bus read/write functions may wait for an interrupt
   to conclude the operation.
</para>
</refsect1>
</refentry>

<!-- drivers/net/phy/mdio_bus.c -->
<refentry id="API-mdiobus-release">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>mdiobus_release</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>mdiobus_release</refname>
 <refpurpose>
  mii_bus device release callback
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>mdiobus_release </function></funcdef>
   <paramdef>struct device * <parameter>d</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>d</parameter></term>
   <listitem>
    <para>
     the target struct device that contains the mii_bus
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   called when the last reference to an mii_bus is
   dropped, to free the underlying memory.
</para>
</refsect1>
</refentry>

<refentry id="API-mdio-bus-match">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>mdio_bus_match</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>mdio_bus_match</refname>
 <refpurpose>
     determine if given PHY driver supports the given PHY device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>mdio_bus_match </function></funcdef>
   <paramdef>struct device * <parameter>dev</parameter></paramdef>
   <paramdef>struct device_driver * <parameter>drv</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     target PHY device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>drv</parameter></term>
   <listitem>
    <para>
     given PHY driver
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Given a PHY device, and a PHY driver, return 1 if
   the driver supports the device.  Otherwise, return 0.
</para>
</refsect1>
</refentry>

     </sect1>
<!-- FIXME: Removed for now since no structured comments in source
     <sect1><title>Wireless</title>
X!Enet/core/wireless.c
     </sect1>
-->
  </chapter>

</book>
