<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN"
	"http://www.oasis-open.org/docbook/xml/4.1.2/docbookx.dtd" []>

<book id="drmDevelopersGuide">
  <bookinfo>
    <title>Linux DRM Developer's Guide</title>

    <authorgroup>
      <author>
	<firstname>Jesse</firstname>
	<surname>Barnes</surname>
	<contrib>Initial version</contrib>
	<affiliation>
	  <orgname>Intel Corporation</orgname>
	  <address>
	    <email>jesse.barnes@intel.com</email>
	  </address>
	</affiliation>
      </author>
      <author>
	<firstname>Laurent</firstname>
	<surname>Pinchart</surname>
	<contrib>Driver internals</contrib>
	<affiliation>
	  <orgname>Ideas on board SPRL</orgname>
	  <address>
	    <email>laurent.pinchart@ideasonboard.com</email>
	  </address>
	</affiliation>
      </author>
      <author>
	<firstname>Daniel</firstname>
	<surname>Vetter</surname>
	<contrib>Contributions all over the place</contrib>
	<affiliation>
	  <orgname>Intel Corporation</orgname>
	  <address>
	    <email>daniel.vetter@ffwll.ch</email>
	  </address>
	</affiliation>
      </author>
    </authorgroup>

    <copyright>
      <year>2008-2009</year>
      <year>2013-2014</year>
      <holder>Intel Corporation</holder>
    </copyright>
    <copyright>
      <year>2012</year>
      <holder>Laurent Pinchart</holder>
    </copyright>

    <legalnotice>
      <para>
	The contents of this file may be used under the terms of the GNU
	General Public License version 2 (the "GPL") as distributed in
	the kernel source COPYING file.
      </para>
    </legalnotice>

    <revhistory>
      <!-- Put document revisions here, newest first. -->
      <revision>
	<revnumber>1.0</revnumber>
	<date>2012-07-13</date>
	<authorinitials>LP</authorinitials>
	<revremark>Added extensive documentation about driver internals.
	</revremark>
      </revision>
    </revhistory>
  </bookinfo>

<toc></toc>

<part id="drmCore">
  <title>DRM Core</title>
  <partintro>
    <para>
      This first part of the DRM Developer's Guide documents core DRM code,
      helper libraries for writing drivers and generic userspace interfaces
      exposed by DRM drivers.
    </para>
  </partintro>

  <chapter id="drmIntroduction">
    <title>Introduction</title>
    <para>
      The Linux DRM layer contains code intended to support the needs
      of complex graphics devices, usually containing programmable
      pipelines well suited to 3D graphics acceleration.  Graphics
      drivers in the kernel may make use of DRM functions to make
      tasks like memory management, interrupt handling and DMA easier,
      and provide a uniform interface to applications.
    </para>
    <para>
      A note on versions: this guide covers features found in the DRM
      tree, including the TTM memory manager, output configuration and
      mode setting, and the new vblank internals, in addition to all
      the regular features found in current kernels.
    </para>
    <para>
      [Insert diagram of typical DRM stack here]
    </para>
  </chapter>

  <!-- Internals -->

  <chapter id="drmInternals">
    <title>DRM Internals</title>
    <para>
      This chapter documents DRM internals relevant to driver authors
      and developers working to add support for the latest features to
      existing drivers.
    </para>
    <para>
      First, we go over some typical driver initialization
      requirements, like setting up command buffers, creating an
      initial output configuration, and initializing core services.
      Subsequent sections cover core internals in more detail,
      providing implementation notes and examples.
    </para>
    <para>
      The DRM layer provides several services to graphics drivers,
      many of them driven by the application interfaces it provides
      through libdrm, the library that wraps most of the DRM ioctls.
      These include vblank event handling, memory
      management, output management, framebuffer management, command
      submission &amp; fencing, suspend/resume support, and DMA
      services.
    </para>

  <!-- Internals: driver init -->

  <sect1>
    <title>Driver Initialization</title>
    <para>
      At the core of every DRM driver is a <structname>drm_driver</structname>
      structure. Drivers typically statically initialize a drm_driver structure,
      and then pass it to one of the <function>drm_*_init()</function> functions
      to register it with the DRM subsystem.
    </para>
    <para>
      Newer drivers that no longer require a <structname>drm_bus</structname>
      structure can alternatively use the low-level device initialization and
      registration functions such as <function>drm_dev_alloc()</function> and
      <function>drm_dev_register()</function> directly.
    </para>
    <para>
      The <structname>drm_driver</structname> structure contains static
      information that describes the driver and features it supports, and
      pointers to methods that the DRM core will call to implement the DRM API.
      We will first go through the <structname>drm_driver</structname> static
      information fields, and will then describe individual operations in
      details as they get used in later sections.
    </para>
    <sect2>
      <title>Driver Information</title>
      <sect3>
        <title>Driver Features</title>
        <para>
          Drivers inform the DRM core about their requirements and supported
          features by setting appropriate flags in the
          <structfield>driver_features</structfield> field. Since those flags
          influence the DRM core behaviour since registration time, most of them
          must be set to registering the <structname>drm_driver</structname>
          instance.
        </para>
        <synopsis>u32 driver_features;</synopsis>
        <variablelist>
          <title>Driver Feature Flags</title>
          <varlistentry>
            <term>DRIVER_USE_AGP</term>
            <listitem><para>
              Driver uses AGP interface, the DRM core will manage AGP resources.
            </para></listitem>
          </varlistentry>
          <varlistentry>
            <term>DRIVER_REQUIRE_AGP</term>
            <listitem><para>
              Driver needs AGP interface to function. AGP initialization failure
              will become a fatal error.
            </para></listitem>
          </varlistentry>
          <varlistentry>
            <term>DRIVER_PCI_DMA</term>
            <listitem><para>
              Driver is capable of PCI DMA, mapping of PCI DMA buffers to
              userspace will be enabled. Deprecated.
            </para></listitem>
          </varlistentry>
          <varlistentry>
            <term>DRIVER_SG</term>
            <listitem><para>
              Driver can perform scatter/gather DMA, allocation and mapping of
              scatter/gather buffers will be enabled. Deprecated.
            </para></listitem>
          </varlistentry>
          <varlistentry>
            <term>DRIVER_HAVE_DMA</term>
            <listitem><para>
              Driver supports DMA, the userspace DMA API will be supported.
              Deprecated.
            </para></listitem>
          </varlistentry>
          <varlistentry>
            <term>DRIVER_HAVE_IRQ</term><term>DRIVER_IRQ_SHARED</term>
            <listitem><para>
              DRIVER_HAVE_IRQ indicates whether the driver has an IRQ handler
              managed by the DRM Core. The core will support simple IRQ handler
              installation when the flag is set. The installation process is
              described in <xref linkend="drm-irq-registration"/>.</para>
              <para>DRIVER_IRQ_SHARED indicates whether the device &amp; handler
              support shared IRQs (note that this is required of PCI  drivers).
            </para></listitem>
          </varlistentry>
          <varlistentry>
            <term>DRIVER_GEM</term>
            <listitem><para>
              Driver use the GEM memory manager.
            </para></listitem>
          </varlistentry>
          <varlistentry>
            <term>DRIVER_MODESET</term>
            <listitem><para>
              Driver supports mode setting interfaces (KMS).
            </para></listitem>
          </varlistentry>
          <varlistentry>
            <term>DRIVER_PRIME</term>
            <listitem><para>
              Driver implements DRM PRIME buffer sharing.
            </para></listitem>
          </varlistentry>
          <varlistentry>
            <term>DRIVER_RENDER</term>
            <listitem><para>
              Driver supports dedicated render nodes.
            </para></listitem>
          </varlistentry>
        </variablelist>
      </sect3>
      <sect3>
        <title>Major, Minor and Patchlevel</title>
        <synopsis>int major;
int minor;
int patchlevel;</synopsis>
        <para>
          The DRM core identifies driver versions by a major, minor and patch
          level triplet. The information is printed to the kernel log at
          initialization time and passed to userspace through the
          DRM_IOCTL_VERSION ioctl.
        </para>
        <para>
          The major and minor numbers are also used to verify the requested driver
          API version passed to DRM_IOCTL_SET_VERSION. When the driver API changes
          between minor versions, applications can call DRM_IOCTL_SET_VERSION to
          select a specific version of the API. If the requested major isn't equal
          to the driver major, or the requested minor is larger than the driver
          minor, the DRM_IOCTL_SET_VERSION call will return an error. Otherwise
          the driver's set_version() method will be called with the requested
          version.
        </para>
      </sect3>
      <sect3>
        <title>Name, Description and Date</title>
        <synopsis>char *name;
char *desc;
char *date;</synopsis>
        <para>
          The driver name is printed to the kernel log at initialization time,
          used for IRQ registration and passed to userspace through
          DRM_IOCTL_VERSION.
        </para>
        <para>
          The driver description is a purely informative string passed to
          userspace through the DRM_IOCTL_VERSION ioctl and otherwise unused by
          the kernel.
        </para>
        <para>
          The driver date, formatted as YYYYMMDD, is meant to identify the date of
          the latest modification to the driver. However, as most drivers fail to
          update it, its value is mostly useless. The DRM core prints it to the
          kernel log at initialization time and passes it to userspace through the
          DRM_IOCTL_VERSION ioctl.
        </para>
      </sect3>
    </sect2>
    <sect2>
      <title>Device Registration</title>
      <para>
        A number of functions are provided to help with device registration.
        The functions deal with PCI and platform devices, respectively.
      </para>
<!-- drivers/gpu/drm/drm_pci.c -->
<refentry id="API-drm-pci-alloc">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_pci_alloc</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_pci_alloc</refname>
 <refpurpose>
  Allocate a PCI consistent memory block, for DMA.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>drm_dma_handle_t * <function>drm_pci_alloc </function></funcdef>
   <paramdef>struct drm_device * <parameter>dev</parameter></paramdef>
   <paramdef>size_t <parameter>size</parameter></paramdef>
   <paramdef>size_t <parameter>align</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     DRM device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>size</parameter></term>
   <listitem>
    <para>
     size of block to allocate
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>align</parameter></term>
   <listitem>
    <para>
     alignment of block
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Return</title>
<para>
   A handle to the allocated memory block on success or NULL on
   failure.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-pci-free">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_pci_free</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_pci_free</refname>
 <refpurpose>
     Free a PCI consistent memory block
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>drm_pci_free </function></funcdef>
   <paramdef>struct drm_device * <parameter>dev</parameter></paramdef>
   <paramdef>drm_dma_handle_t * <parameter>dmah</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     DRM device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>dmah</parameter></term>
   <listitem>
    <para>
     handle to memory block
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-drm-get-pci-dev">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_get_pci_dev</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_get_pci_dev</refname>
 <refpurpose>
     Register a PCI device with the DRM subsystem
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>drm_get_pci_dev </function></funcdef>
   <paramdef>struct pci_dev * <parameter>pdev</parameter></paramdef>
   <paramdef>const struct pci_device_id * <parameter>ent</parameter></paramdef>
   <paramdef>struct drm_driver * <parameter>driver</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>pdev</parameter></term>
   <listitem>
    <para>
     PCI device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>ent</parameter></term>
   <listitem>
    <para>
     entry from the PCI ID table that matches <parameter>pdev</parameter>
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>driver</parameter></term>
   <listitem>
    <para>
     DRM device driver
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Attempt to gets inter module <quote>drm</quote> information. If we are first
   then register the character device and inter module information.
   Try and register, if we fail to register, backout previous work.
</para>
</refsect1>
<refsect1>
<title>Return</title>
<para>
   0 on success or a negative error code on failure.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-pci-init">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_pci_init</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_pci_init</refname>
 <refpurpose>
     Register matching PCI devices with the DRM subsystem
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>drm_pci_init </function></funcdef>
   <paramdef>struct drm_driver * <parameter>driver</parameter></paramdef>
   <paramdef>struct pci_driver * <parameter>pdriver</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>driver</parameter></term>
   <listitem>
    <para>
     DRM device driver
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>pdriver</parameter></term>
   <listitem>
    <para>
     PCI device driver
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Initializes a drm_device structures, registering the stubs and initializing
   the AGP device.
</para>
</refsect1>
<refsect1>
<title>Return</title>
<para>
   0 on success or a negative error code on failure.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-pci-exit">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_pci_exit</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_pci_exit</refname>
 <refpurpose>
     Unregister matching PCI devices from the DRM subsystem
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>drm_pci_exit </function></funcdef>
   <paramdef>struct drm_driver * <parameter>driver</parameter></paramdef>
   <paramdef>struct pci_driver * <parameter>pdriver</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>driver</parameter></term>
   <listitem>
    <para>
     DRM device driver
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>pdriver</parameter></term>
   <listitem>
    <para>
     PCI device driver
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Unregisters one or more devices matched by a PCI driver from the DRM
   subsystem.
</para>
</refsect1>
</refentry>

<!-- drivers/gpu/drm/drm_platform.c -->
<refentry id="API-drm-platform-init">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_platform_init</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_platform_init</refname>
 <refpurpose>
  Register a platform device with the DRM subsystem
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>drm_platform_init </function></funcdef>
   <paramdef>struct drm_driver * <parameter>driver</parameter></paramdef>
   <paramdef>struct platform_device * <parameter>platform_device</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>driver</parameter></term>
   <listitem>
    <para>
     DRM device driver
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>platform_device</parameter></term>
   <listitem>
    <para>
     platform device to register
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Registers the specified DRM device driver and platform device with the DRM
   subsystem, initializing a drm_device structure and calling the driver's
   .<function>load</function> function.
</para>
</refsect1>
<refsect1>
<title>Return</title>
<para>
   0 on success or a negative error code on failure.
</para>
</refsect1>
</refentry>

      <para>
        New drivers that no longer rely on the services provided by the
        <structname>drm_bus</structname> structure can call the low-level
        device registration functions directly. The
        <function>drm_dev_alloc()</function> function can be used to allocate
        and initialize a new <structname>drm_device</structname> structure.
        Drivers will typically want to perform some additional setup on this
        structure, such as allocating driver-specific data and storing a
        pointer to it in the DRM device's <structfield>dev_private</structfield>
        field. Drivers should also set the device's unique name using the
        <function>drm_dev_set_unique()</function> function. After it has been
        set up a device can be registered with the DRM subsystem by calling
        <function>drm_dev_register()</function>. This will cause the device to
        be exposed to userspace and will call the driver's
        <structfield>.load()</structfield> implementation. When a device is
        removed, the DRM device can safely be unregistered and freed by calling
        <function>drm_dev_unregister()</function> followed by a call to
        <function>drm_dev_unref()</function>.
      </para>
<!-- drivers/gpu/drm/drm_drv.c -->
<refentry id="API-drm-put-dev">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_put_dev</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_put_dev</refname>
 <refpurpose>
  Unregister and release a DRM device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>drm_put_dev </function></funcdef>
   <paramdef>struct drm_device * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     DRM device
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Called at module unload time or when a PCI device is unplugged.
   </para><para>

   Use of this function is discouraged. It will eventually go away completely.
   Please use <function>drm_dev_unregister</function> and <function>drm_dev_unref</function> explicitly instead.
   </para><para>

   Cleans up all DRM device, calling <function>drm_lastclose</function>.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-dev-alloc">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_dev_alloc</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_dev_alloc</refname>
 <refpurpose>
     Allocate new DRM device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct drm_device * <function>drm_dev_alloc </function></funcdef>
   <paramdef>struct drm_driver * <parameter>driver</parameter></paramdef>
   <paramdef>struct device * <parameter>parent</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>driver</parameter></term>
   <listitem>
    <para>
     DRM driver to allocate device for
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>parent</parameter></term>
   <listitem>
    <para>
     Parent device object
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Allocate and initialize a new DRM device. No device registration is done.
   Call <function>drm_dev_register</function> to advertice the device to user space and register it
   with other core subsystems.
   </para><para>

   The initial ref-count of the object is 1. Use <function>drm_dev_ref</function> and
   <function>drm_dev_unref</function> to take and drop further ref-counts.
</para>
</refsect1>
<refsect1>
<title>RETURNS</title>
<para>
   Pointer to new DRM device, or NULL if out of memory.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-dev-ref">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_dev_ref</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_dev_ref</refname>
 <refpurpose>
     Take reference of a DRM device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>drm_dev_ref </function></funcdef>
   <paramdef>struct drm_device * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     device to take reference of or NULL
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This increases the ref-count of <parameter>dev</parameter> by one. You *must* already own a
   reference when calling this. Use <function>drm_dev_unref</function> to drop this reference
   again.
   </para><para>

   This function never fails. However, this function does not provide *any*
   guarantee whether the device is alive or running. It only provides a
   reference to the object and the memory associated with it.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-dev-unref">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_dev_unref</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_dev_unref</refname>
 <refpurpose>
     Drop reference of a DRM device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>drm_dev_unref </function></funcdef>
   <paramdef>struct drm_device * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     device to drop reference of or NULL
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This decreases the ref-count of <parameter>dev</parameter> by one. The device is destroyed if the
   ref-count drops to zero.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-dev-register">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_dev_register</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_dev_register</refname>
 <refpurpose>
     Register DRM device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>drm_dev_register </function></funcdef>
   <paramdef>struct drm_device * <parameter>dev</parameter></paramdef>
   <paramdef>unsigned long <parameter>flags</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     Device to register
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>flags</parameter></term>
   <listitem>
    <para>
     Flags passed to the driver's .<function>load</function> function
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Register the DRM device <parameter>dev</parameter> with the system, advertise device to user-space
   and start normal device operation. <parameter>dev</parameter> must be allocated via <function>drm_dev_alloc</function>
   previously.
   </para><para>

   Never call this twice on any device!
</para>
</refsect1>
<refsect1>
<title>RETURNS</title>
<para>
   0 on success, negative error code on failure.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-dev-unregister">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_dev_unregister</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_dev_unregister</refname>
 <refpurpose>
     Unregister DRM device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>drm_dev_unregister </function></funcdef>
   <paramdef>struct drm_device * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     Device to unregister
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Unregister the DRM device from the system. This does the reverse of
   <function>drm_dev_register</function> but does not deallocate the device. The caller must call
   <function>drm_dev_unref</function> to drop their final reference.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-dev-set-unique">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_dev_set_unique</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_dev_set_unique</refname>
 <refpurpose>
     Set the unique name of a DRM device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>drm_dev_set_unique </function></funcdef>
   <paramdef>struct drm_device * <parameter>dev</parameter></paramdef>
   <paramdef>const char * <parameter>fmt</parameter></paramdef>
   <paramdef> <parameter>...</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     device of which to set the unique name
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>fmt</parameter></term>
   <listitem>
    <para>
     format string for unique name
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>...</parameter></term>
   <listitem>
    <para>
     variable arguments
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Sets the unique name of a DRM device using the specified format string and
   a variable list of arguments. Drivers can use this at driver probe time if
   the unique name of the devices they drive is static.
</para>
</refsect1>
<refsect1>
<title>Return</title>
<para>
   0 on success or a negative error code on failure.
</para>
</refsect1>
</refentry>

    </sect2>
    <sect2>
      <title>Driver Load</title>
      <para>
        The <methodname>load</methodname> method is the driver and device
        initialization entry point. The method is responsible for allocating and
	initializing driver private data, performing resource allocation and
	mapping (e.g. acquiring
        clocks, mapping registers or allocating command buffers), initializing
        the memory manager (<xref linkend="drm-memory-management"/>), installing
        the IRQ handler (<xref linkend="drm-irq-registration"/>), setting up
        vertical blanking handling (<xref linkend="drm-vertical-blank"/>), mode
	setting (<xref linkend="drm-mode-setting"/>) and initial output
	configuration (<xref linkend="drm-kms-init"/>).
      </para>
      <note><para>
        If compatibility is a concern (e.g. with drivers converted over from
        User Mode Setting to Kernel Mode Setting), care must be taken to prevent
        device initialization and control that is incompatible with currently
        active userspace drivers. For instance, if user level mode setting
        drivers are in use, it would be problematic to perform output discovery
        &amp; configuration at load time. Likewise, if user-level drivers
        unaware of memory management are in use, memory management and command
        buffer setup may need to be omitted. These requirements are
        driver-specific, and care needs to be taken to keep both old and new
        applications and libraries working.
      </para></note>
      <synopsis>int (*load) (struct drm_device *, unsigned long flags);</synopsis>
      <para>
        The method takes two arguments, a pointer to the newly created
	<structname>drm_device</structname> and flags. The flags are used to
	pass the <structfield>driver_data</structfield> field of the device id
	corresponding to the device passed to <function>drm_*_init()</function>.
	Only PCI devices currently use this, USB and platform DRM drivers have
	their <methodname>load</methodname> method called with flags to 0.
      </para>
      <sect3>
        <title>Driver Private Data</title>
        <para>
          The driver private hangs off the main
          <structname>drm_device</structname> structure and can be used for
          tracking various device-specific bits of information, like register
          offsets, command buffer status, register state for suspend/resume, etc.
          At load time, a driver may simply allocate one and set
          <structname>drm_device</structname>.<structfield>dev_priv</structfield>
          appropriately; it should be freed and
          <structname>drm_device</structname>.<structfield>dev_priv</structfield>
          set to NULL when the driver is unloaded.
        </para>
      </sect3>
      <sect3 id="drm-irq-registration">
        <title>IRQ Registration</title>
        <para>
          The DRM core tries to facilitate IRQ handler registration and
          unregistration by providing <function>drm_irq_install</function> and
          <function>drm_irq_uninstall</function> functions. Those functions only
          support a single interrupt per device, devices that use more than one
          IRQs need to be handled manually.
        </para>
        <sect4>
          <title>Managed IRQ Registration</title>
          <para>
            <function>drm_irq_install</function> starts by calling the
            <methodname>irq_preinstall</methodname> driver operation. The operation
            is optional and must make sure that the interrupt will not get fired by
            clearing all pending interrupt flags or disabling the interrupt.
          </para>
          <para>
            The passed-in IRQ will then be requested by a call to
            <function>request_irq</function>. If the DRIVER_IRQ_SHARED driver
            feature flag is set, a shared (IRQF_SHARED) IRQ handler will be
            requested.
          </para>
          <para>
            The IRQ handler function must be provided as the mandatory irq_handler
            driver operation. It will get passed directly to
            <function>request_irq</function> and thus has the same prototype as all
            IRQ handlers. It will get called with a pointer to the DRM device as the
            second argument.
          </para>
          <para>
            Finally the function calls the optional
            <methodname>irq_postinstall</methodname> driver operation. The operation
            usually enables interrupts (excluding the vblank interrupt, which is
            enabled separately), but drivers may choose to enable/disable interrupts
            at a different time.
          </para>
          <para>
            <function>drm_irq_uninstall</function> is similarly used to uninstall an
            IRQ handler. It starts by waking up all processes waiting on a vblank
            interrupt to make sure they don't hang, and then calls the optional
            <methodname>irq_uninstall</methodname> driver operation. The operation
            must disable all hardware interrupts. Finally the function frees the IRQ
            by calling <function>free_irq</function>.
          </para>
        </sect4>
        <sect4>
          <title>Manual IRQ Registration</title>
          <para>
            Drivers that require multiple interrupt handlers can't use the managed
            IRQ registration functions. In that case IRQs must be registered and
            unregistered manually (usually with the <function>request_irq</function>
            and <function>free_irq</function> functions, or their devm_* equivalent).
          </para>
          <para>
            When manually registering IRQs, drivers must not set the DRIVER_HAVE_IRQ
            driver feature flag, and must not provide the
	    <methodname>irq_handler</methodname> driver operation. They must set the
	    <structname>drm_device</structname> <structfield>irq_enabled</structfield>
	    field to 1 upon registration of the IRQs, and clear it to 0 after
	    unregistering the IRQs.
          </para>
        </sect4>
      </sect3>
      <sect3>
        <title>Memory Manager Initialization</title>
        <para>
          Every DRM driver requires a memory manager which must be initialized at
          load time. DRM currently contains two memory managers, the Translation
          Table Manager (TTM) and the Graphics Execution Manager (GEM).
          This document describes the use of the GEM memory manager only. See
          <xref linkend="drm-memory-management"/> for details.
        </para>
      </sect3>
      <sect3>
        <title>Miscellaneous Device Configuration</title>
        <para>
          Another task that may be necessary for PCI devices during configuration
          is mapping the video BIOS. On many devices, the VBIOS describes device
          configuration, LCD panel timings (if any), and contains flags indicating
          device state. Mapping the BIOS can be done using the pci_map_rom() call,
          a convenience function that takes care of mapping the actual ROM,
          whether it has been shadowed into memory (typically at address 0xc0000)
          or exists on the PCI device in the ROM BAR. Note that after the ROM has
          been mapped and any necessary information has been extracted, it should
          be unmapped; on many devices, the ROM address decoder is shared with
          other BARs, so leaving it mapped could cause undesired behaviour like
          hangs or memory corruption.
  <!--!Fdrivers/pci/rom.c pci_map_rom-->
        </para>
      </sect3>
    </sect2>
  </sect1>

  <!-- Internals: memory management -->

  <sect1 id="drm-memory-management">
    <title>Memory management</title>
    <para>
      Modern Linux systems require large amount of graphics memory to store
      frame buffers, textures, vertices and other graphics-related data. Given
      the very dynamic nature of many of that data, managing graphics memory
      efficiently is thus crucial for the graphics stack and plays a central
      role in the DRM infrastructure.
    </para>
    <para>
      The DRM core includes two memory managers, namely Translation Table Maps
      (TTM) and Graphics Execution Manager (GEM). TTM was the first DRM memory
      manager to be developed and tried to be a one-size-fits-them all
      solution. It provides a single userspace API to accommodate the need of
      all hardware, supporting both Unified Memory Architecture (UMA) devices
      and devices with dedicated video RAM (i.e. most discrete video cards).
      This resulted in a large, complex piece of code that turned out to be
      hard to use for driver development.
    </para>
    <para>
      GEM started as an Intel-sponsored project in reaction to TTM's
      complexity. Its design philosophy is completely different: instead of
      providing a solution to every graphics memory-related problems, GEM
      identified common code between drivers and created a support library to
      share it. GEM has simpler initialization and execution requirements than
      TTM, but has no video RAM management capabilities and is thus limited to
      UMA devices.
    </para>
    <sect2>
      <title>The Translation Table Manager (TTM)</title>
      <para>
	TTM design background and information belongs here.
      </para>
      <sect3>
	<title>TTM initialization</title>
        <warning><para>This section is outdated.</para></warning>
        <para>
          Drivers wishing to support TTM must fill out a drm_bo_driver
          structure. The structure contains several fields with function
          pointers for initializing the TTM, allocating and freeing memory,
          waiting for command completion and fence synchronization, and memory
          migration. See the radeon_ttm.c file for an example of usage.
	</para>
	<para>
	  The ttm_global_reference structure is made up of several fields:
	</para>
	<programlisting>
	  struct ttm_global_reference {
	  	enum ttm_global_types global_type;
	  	size_t size;
	  	void *object;
	  	int (*init) (struct ttm_global_reference *);
	  	void (*release) (struct ttm_global_reference *);
	  };
	</programlisting>
	<para>
	  There should be one global reference structure for your memory
	  manager as a whole, and there will be others for each object
	  created by the memory manager at runtime.  Your global TTM should
	  have a type of TTM_GLOBAL_TTM_MEM.  The size field for the global
	  object should be sizeof(struct ttm_mem_global), and the init and
	  release hooks should point at your driver-specific init and
	  release routines, which probably eventually call
	  ttm_mem_global_init and ttm_mem_global_release, respectively.
	</para>
	<para>
	  Once your global TTM accounting structure is set up and initialized
	  by calling ttm_global_item_ref() on it,
	  you need to create a buffer object TTM to
	  provide a pool for buffer object allocation by clients and the
	  kernel itself.  The type of this object should be TTM_GLOBAL_TTM_BO,
	  and its size should be sizeof(struct ttm_bo_global).  Again,
	  driver-specific init and release functions may be provided,
	  likely eventually calling ttm_bo_global_init() and
	  ttm_bo_global_release(), respectively.  Also, like the previous
	  object, ttm_global_item_ref() is used to create an initial reference
	  count for the TTM, which will call your initialization function.
	</para>
      </sect3>
    </sect2>
    <sect2 id="drm-gem">
      <title>The Graphics Execution Manager (GEM)</title>
      <para>
        The GEM design approach has resulted in a memory manager that doesn't
        provide full coverage of all (or even all common) use cases in its
        userspace or kernel API. GEM exposes a set of standard memory-related
        operations to userspace and a set of helper functions to drivers, and let
        drivers implement hardware-specific operations with their own private API.
      </para>
      <para>
        The GEM userspace API is described in the
        <ulink url="http://lwn.net/Articles/283798/"><citetitle>GEM - the Graphics
        Execution Manager</citetitle></ulink> article on LWN. While slightly
        outdated, the document provides a good overview of the GEM API principles.
        Buffer allocation and read and write operations, described as part of the
        common GEM API, are currently implemented using driver-specific ioctls.
      </para>
      <para>
        GEM is data-agnostic. It manages abstract buffer objects without knowing
        what individual buffers contain. APIs that require knowledge of buffer
        contents or purpose, such as buffer allocation or synchronization
        primitives, are thus outside of the scope of GEM and must be implemented
        using driver-specific ioctls.
      </para>
      <para>
	On a fundamental level, GEM involves several operations:
	<itemizedlist>
	  <listitem>Memory allocation and freeing</listitem>
	  <listitem>Command execution</listitem>
	  <listitem>Aperture management at command execution time</listitem>
	</itemizedlist>
	Buffer object allocation is relatively straightforward and largely
        provided by Linux's shmem layer, which provides memory to back each
        object.
      </para>
      <para>
        Device-specific operations, such as command execution, pinning, buffer
	read &amp; write, mapping, and domain ownership transfers are left to
        driver-specific ioctls.
      </para>
      <sect3>
        <title>GEM Initialization</title>
        <para>
          Drivers that use GEM must set the DRIVER_GEM bit in the struct
          <structname>drm_driver</structname>
          <structfield>driver_features</structfield> field. The DRM core will
          then automatically initialize the GEM core before calling the
          <methodname>load</methodname> operation. Behind the scene, this will
          create a DRM Memory Manager object which provides an address space
          pool for object allocation.
        </para>
        <para>
          In a KMS configuration, drivers need to allocate and initialize a
          command ring buffer following core GEM initialization if required by
          the hardware. UMA devices usually have what is called a "stolen"
          memory region, which provides space for the initial framebuffer and
          large, contiguous memory regions required by the device. This space is
          typically not managed by GEM, and must be initialized separately into
          its own DRM MM object.
        </para>
      </sect3>
      <sect3>
        <title>GEM Objects Creation</title>
        <para>
          GEM splits creation of GEM objects and allocation of the memory that
          backs them in two distinct operations.
        </para>
        <para>
          GEM objects are represented by an instance of struct
          <structname>drm_gem_object</structname>. Drivers usually need to extend
          GEM objects with private information and thus create a driver-specific
          GEM object structure type that embeds an instance of struct
          <structname>drm_gem_object</structname>.
        </para>
        <para>
          To create a GEM object, a driver allocates memory for an instance of its
          specific GEM object type and initializes the embedded struct
          <structname>drm_gem_object</structname> with a call to
          <function>drm_gem_object_init</function>. The function takes a pointer to
          the DRM device, a pointer to the GEM object and the buffer object size
          in bytes.
        </para>
        <para>
          GEM uses shmem to allocate anonymous pageable memory.
          <function>drm_gem_object_init</function> will create an shmfs file of
          the requested size and store it into the struct
          <structname>drm_gem_object</structname> <structfield>filp</structfield>
          field. The memory is used as either main storage for the object when the
          graphics hardware uses system memory directly or as a backing store
          otherwise.
        </para>
        <para>
          Drivers are responsible for the actual physical pages allocation by
          calling <function>shmem_read_mapping_page_gfp</function> for each page.
          Note that they can decide to allocate pages when initializing the GEM
          object, or to delay allocation until the memory is needed (for instance
          when a page fault occurs as a result of a userspace memory access or
          when the driver needs to start a DMA transfer involving the memory).
        </para>
        <para>
          Anonymous pageable memory allocation is not always desired, for instance
          when the hardware requires physically contiguous system memory as is
          often the case in embedded devices. Drivers can create GEM objects with
          no shmfs backing (called private GEM objects) by initializing them with
          a call to <function>drm_gem_private_object_init</function> instead of
          <function>drm_gem_object_init</function>. Storage for private GEM
          objects must be managed by drivers.
        </para>
        <para>
          Drivers that do not need to extend GEM objects with private information
          can call the <function>drm_gem_object_alloc</function> function to
          allocate and initialize a struct <structname>drm_gem_object</structname>
          instance. The GEM core will call the optional driver
          <methodname>gem_init_object</methodname> operation after initializing
          the GEM object with <function>drm_gem_object_init</function>.
          <synopsis>int (*gem_init_object) (struct drm_gem_object *obj);</synopsis>
        </para>
        <para>
          No alloc-and-init function exists for private GEM objects.
        </para>
      </sect3>
      <sect3>
        <title>GEM Objects Lifetime</title>
        <para>
          All GEM objects are reference-counted by the GEM core. References can be
          acquired and release by <function>calling drm_gem_object_reference</function>
          and <function>drm_gem_object_unreference</function> respectively. The
          caller must hold the <structname>drm_device</structname>
          <structfield>struct_mutex</structfield> lock. As a convenience, GEM
          provides the <function>drm_gem_object_reference_unlocked</function> and
          <function>drm_gem_object_unreference_unlocked</function> functions that
          can be called without holding the lock.
        </para>
        <para>
          When the last reference to a GEM object is released the GEM core calls
          the <structname>drm_driver</structname>
          <methodname>gem_free_object</methodname> operation. That operation is
          mandatory for GEM-enabled drivers and must free the GEM object and all
          associated resources.
        </para>
        <para>
          <synopsis>void (*gem_free_object) (struct drm_gem_object *obj);</synopsis>
          Drivers are responsible for freeing all GEM object resources, including
          the resources created by the GEM core. If an mmap offset has been
          created for the object (in which case
          <structname>drm_gem_object</structname>::<structfield>map_list</structfield>::<structfield>map</structfield>
          is not NULL) it must be freed by a call to
          <function>drm_gem_free_mmap_offset</function>. The shmfs backing store
          must be released by calling <function>drm_gem_object_release</function>
          (that function can safely be called if no shmfs backing store has been
          created).
        </para>
      </sect3>
      <sect3>
        <title>GEM Objects Naming</title>
        <para>
          Communication between userspace and the kernel refers to GEM objects
          using local handles, global names or, more recently, file descriptors.
          All of those are 32-bit integer values; the usual Linux kernel limits
          apply to the file descriptors.
        </para>
        <para>
          GEM handles are local to a DRM file. Applications get a handle to a GEM
          object through a driver-specific ioctl, and can use that handle to refer
          to the GEM object in other standard or driver-specific ioctls. Closing a
          DRM file handle frees all its GEM handles and dereferences the
          associated GEM objects.
        </para>
        <para>
          To create a handle for a GEM object drivers call
          <function>drm_gem_handle_create</function>. The function takes a pointer
          to the DRM file and the GEM object and returns a locally unique handle.
          When the handle is no longer needed drivers delete it with a call to
          <function>drm_gem_handle_delete</function>. Finally the GEM object
          associated with a handle can be retrieved by a call to
          <function>drm_gem_object_lookup</function>.
        </para>
        <para>
          Handles don't take ownership of GEM objects, they only take a reference
          to the object that will be dropped when the handle is destroyed. To
          avoid leaking GEM objects, drivers must make sure they drop the
          reference(s) they own (such as the initial reference taken at object
          creation time) as appropriate, without any special consideration for the
          handle. For example, in the particular case of combined GEM object and
          handle creation in the implementation of the
          <methodname>dumb_create</methodname> operation, drivers must drop the
          initial reference to the GEM object before returning the handle.
        </para>
        <para>
          GEM names are similar in purpose to handles but are not local to DRM
          files. They can be passed between processes to reference a GEM object
          globally. Names can't be used directly to refer to objects in the DRM
          API, applications must convert handles to names and names to handles
          using the DRM_IOCTL_GEM_FLINK and DRM_IOCTL_GEM_OPEN ioctls
          respectively. The conversion is handled by the DRM core without any
          driver-specific support.
        </para>
	<para>
	  GEM also supports buffer sharing with dma-buf file descriptors through
	  PRIME. GEM-based drivers must use the provided helpers functions to
	  implement the exporting and importing correctly. See <xref linkend="drm-prime-support" />.
	  Since sharing file descriptors is inherently more secure than the
	  easily guessable and global GEM names it is the preferred buffer
	  sharing mechanism. Sharing buffers through GEM names is only supported
	  for legacy userspace. Furthermore PRIME also allows cross-device
	  buffer sharing since it is based on dma-bufs.
	</para>
      </sect3>
      <sect3 id="drm-gem-objects-mapping">
        <title>GEM Objects Mapping</title>
        <para>
          Because mapping operations are fairly heavyweight GEM favours
          read/write-like access to buffers, implemented through driver-specific
          ioctls, over mapping buffers to userspace. However, when random access
          to the buffer is needed (to perform software rendering for instance),
          direct access to the object can be more efficient.
        </para>
        <para>
          The mmap system call can't be used directly to map GEM objects, as they
          don't have their own file handle. Two alternative methods currently
          co-exist to map GEM objects to userspace. The first method uses a
          driver-specific ioctl to perform the mapping operation, calling
          <function>do_mmap</function> under the hood. This is often considered
          dubious, seems to be discouraged for new GEM-enabled drivers, and will
          thus not be described here.
        </para>
        <para>
          The second method uses the mmap system call on the DRM file handle.
          <synopsis>void *mmap(void *addr, size_t length, int prot, int flags, int fd,
             off_t offset);</synopsis>
          DRM identifies the GEM object to be mapped by a fake offset passed
          through the mmap offset argument. Prior to being mapped, a GEM object
          must thus be associated with a fake offset. To do so, drivers must call
          <function>drm_gem_create_mmap_offset</function> on the object. The
          function allocates a fake offset range from a pool and stores the
          offset divided by PAGE_SIZE in
          <literal>obj-&gt;map_list.hash.key</literal>. Care must be taken not to
          call <function>drm_gem_create_mmap_offset</function> if a fake offset
          has already been allocated for the object. This can be tested by
          <literal>obj-&gt;map_list.map</literal> being non-NULL.
        </para>
        <para>
          Once allocated, the fake offset value
          (<literal>obj-&gt;map_list.hash.key &lt;&lt; PAGE_SHIFT</literal>)
          must be passed to the application in a driver-specific way and can then
          be used as the mmap offset argument.
        </para>
        <para>
          The GEM core provides a helper method <function>drm_gem_mmap</function>
          to handle object mapping. The method can be set directly as the mmap
          file operation handler. It will look up the GEM object based on the
          offset value and set the VMA operations to the
          <structname>drm_driver</structname> <structfield>gem_vm_ops</structfield>
          field. Note that <function>drm_gem_mmap</function> doesn't map memory to
          userspace, but relies on the driver-provided fault handler to map pages
          individually.
        </para>
        <para>
          To use <function>drm_gem_mmap</function>, drivers must fill the struct
          <structname>drm_driver</structname> <structfield>gem_vm_ops</structfield>
          field with a pointer to VM operations.
        </para>
        <para>
          <synopsis>struct vm_operations_struct *gem_vm_ops

  struct vm_operations_struct {
          void (*open)(struct vm_area_struct * area);
          void (*close)(struct vm_area_struct * area);
          int (*fault)(struct vm_area_struct *vma, struct vm_fault *vmf);
  };</synopsis>
        </para>
        <para>
          The <methodname>open</methodname> and <methodname>close</methodname>
          operations must update the GEM object reference count. Drivers can use
          the <function>drm_gem_vm_open</function> and
          <function>drm_gem_vm_close</function> helper functions directly as open
          and close handlers.
        </para>
        <para>
          The fault operation handler is responsible for mapping individual pages
          to userspace when a page fault occurs. Depending on the memory
          allocation scheme, drivers can allocate pages at fault time, or can
          decide to allocate memory for the GEM object at the time the object is
          created.
        </para>
        <para>
          Drivers that want to map the GEM object upfront instead of handling page
          faults can implement their own mmap file operation handler.
        </para>
      </sect3>
      <sect3>
        <title>Memory Coherency</title>
        <para>
          When mapped to the device or used in a command buffer, backing pages
          for an object are flushed to memory and marked write combined so as to
          be coherent with the GPU. Likewise, if the CPU accesses an object
          after the GPU has finished rendering to the object, then the object
          must be made coherent with the CPU's view of memory, usually involving
          GPU cache flushing of various kinds. This core CPU&lt;-&gt;GPU
          coherency management is provided by a device-specific ioctl, which
          evaluates an object's current domain and performs any necessary
          flushing or synchronization to put the object into the desired
          coherency domain (note that the object may be busy, i.e. an active
          render target; in that case, setting the domain blocks the client and
          waits for rendering to complete before performing any necessary
          flushing operations).
        </para>
      </sect3>
      <sect3>
        <title>Command Execution</title>
        <para>
	  Perhaps the most important GEM function for GPU devices is providing a
          command execution interface to clients. Client programs construct
          command buffers containing references to previously allocated memory
          objects, and then submit them to GEM. At that point, GEM takes care to
          bind all the objects into the GTT, execute the buffer, and provide
          necessary synchronization between clients accessing the same buffers.
          This often involves evicting some objects from the GTT and re-binding
          others (a fairly expensive operation), and providing relocation
          support which hides fixed GTT offsets from clients. Clients must take
          care not to submit command buffers that reference more objects than
          can fit in the GTT; otherwise, GEM will reject them and no rendering
          will occur. Similarly, if several objects in the buffer require fence
          registers to be allocated for correct rendering (e.g. 2D blits on
          pre-965 chips), care must be taken not to require more fence registers
          than are available to the client. Such resource management should be
          abstracted from the client in libdrm.
        </para>
      </sect3>
      <sect3>
        <title>GEM Function Reference</title>
<!-- drivers/gpu/drm/drm_gem.c -->
<refentry id="API-drm-gem-object-init">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_gem_object_init</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_gem_object_init</refname>
 <refpurpose>
  initialize an allocated shmem-backed GEM object
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>drm_gem_object_init </function></funcdef>
   <paramdef>struct drm_device * <parameter>dev</parameter></paramdef>
   <paramdef>struct drm_gem_object * <parameter>obj</parameter></paramdef>
   <paramdef>size_t <parameter>size</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     drm_device the object should be initialized for
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>obj</parameter></term>
   <listitem>
    <para>
     drm_gem_object to initialize
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>size</parameter></term>
   <listitem>
    <para>
     object size
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Initialize an already allocated GEM object of the specified size with
   shmfs backing store.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-gem-private-object-init">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_gem_private_object_init</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_gem_private_object_init</refname>
 <refpurpose>
     initialize an allocated private GEM object
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>drm_gem_private_object_init </function></funcdef>
   <paramdef>struct drm_device * <parameter>dev</parameter></paramdef>
   <paramdef>struct drm_gem_object * <parameter>obj</parameter></paramdef>
   <paramdef>size_t <parameter>size</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     drm_device the object should be initialized for
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>obj</parameter></term>
   <listitem>
    <para>
     drm_gem_object to initialize
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>size</parameter></term>
   <listitem>
    <para>
     object size
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Initialize an already allocated GEM object of the specified size with
   no GEM provided backing store. Instead the caller is responsible for
   backing the object and handling it.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-gem-handle-delete">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_gem_handle_delete</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_gem_handle_delete</refname>
 <refpurpose>
     deletes the given file-private handle
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>drm_gem_handle_delete </function></funcdef>
   <paramdef>struct drm_file * <parameter>filp</parameter></paramdef>
   <paramdef>u32 <parameter>handle</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>filp</parameter></term>
   <listitem>
    <para>
     drm file-private structure to use for the handle look up
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>handle</parameter></term>
   <listitem>
    <para>
     userspace handle to delete
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Removes the GEM handle from the <parameter>filp</parameter> lookup table and if this is the last
   handle also cleans up linked resources like GEM names.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-gem-dumb-destroy">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_gem_dumb_destroy</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_gem_dumb_destroy</refname>
 <refpurpose>
     dumb fb callback helper for gem based drivers
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>drm_gem_dumb_destroy </function></funcdef>
   <paramdef>struct drm_file * <parameter>file</parameter></paramdef>
   <paramdef>struct drm_device * <parameter>dev</parameter></paramdef>
   <paramdef>uint32_t <parameter>handle</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>file</parameter></term>
   <listitem>
    <para>
     drm file-private structure to remove the dumb handle from
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     corresponding drm_device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>handle</parameter></term>
   <listitem>
    <para>
     the dumb handle to remove
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This implements the -&gt;dumb_destroy kms driver callback for drivers which use
   gem to manage their backing storage.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-gem-handle-create">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_gem_handle_create</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_gem_handle_create</refname>
 <refpurpose>
     create a gem handle for an object
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>drm_gem_handle_create </function></funcdef>
   <paramdef>struct drm_file * <parameter>file_priv</parameter></paramdef>
   <paramdef>struct drm_gem_object * <parameter>obj</parameter></paramdef>
   <paramdef>u32 * <parameter>handlep</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>file_priv</parameter></term>
   <listitem>
    <para>
     drm file-private structure to register the handle for
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>obj</parameter></term>
   <listitem>
    <para>
     object to register
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>handlep</parameter></term>
   <listitem>
    <para>
     pionter to return the created handle to the caller
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Create a handle for this object. This adds a handle reference
   to the object, which includes a regular reference count. Callers
   will likely want to dereference the object afterwards.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-gem-free-mmap-offset">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_gem_free_mmap_offset</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_gem_free_mmap_offset</refname>
 <refpurpose>
     release a fake mmap offset for an object
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>drm_gem_free_mmap_offset </function></funcdef>
   <paramdef>struct drm_gem_object * <parameter>obj</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>obj</parameter></term>
   <listitem>
    <para>
     obj in question
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This routine frees fake offsets allocated by <function>drm_gem_create_mmap_offset</function>.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-gem-create-mmap-offset-size">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_gem_create_mmap_offset_size</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_gem_create_mmap_offset_size</refname>
 <refpurpose>
     create a fake mmap offset for an object
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>drm_gem_create_mmap_offset_size </function></funcdef>
   <paramdef>struct drm_gem_object * <parameter>obj</parameter></paramdef>
   <paramdef>size_t <parameter>size</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>obj</parameter></term>
   <listitem>
    <para>
     obj in question
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>size</parameter></term>
   <listitem>
    <para>
     the virtual size
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   GEM memory mapping works by handing back to userspace a fake mmap offset
   it can use in a subsequent mmap(2) call.  The DRM core code then looks
   up the object based on the offset and sets up the various memory mapping
   structures.
   </para><para>

   This routine allocates and attaches a fake offset for <parameter>obj</parameter>, in cases where
   the virtual size differs from the physical size (ie. obj-&gt;size).  Otherwise
   just use <function>drm_gem_create_mmap_offset</function>.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-gem-create-mmap-offset">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_gem_create_mmap_offset</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_gem_create_mmap_offset</refname>
 <refpurpose>
     create a fake mmap offset for an object
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>drm_gem_create_mmap_offset </function></funcdef>
   <paramdef>struct drm_gem_object * <parameter>obj</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>obj</parameter></term>
   <listitem>
    <para>
     obj in question
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   GEM memory mapping works by handing back to userspace a fake mmap offset
   it can use in a subsequent mmap(2) call.  The DRM core code then looks
   up the object based on the offset and sets up the various memory mapping
   structures.
   </para><para>

   This routine allocates and attaches a fake offset for <parameter>obj</parameter>.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-gem-get-pages">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_gem_get_pages</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_gem_get_pages</refname>
 <refpurpose>
     helper to allocate backing pages for a GEM object from shmem
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct page ** <function>drm_gem_get_pages </function></funcdef>
   <paramdef>struct drm_gem_object * <parameter>obj</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>obj</parameter></term>
   <listitem>
    <para>
     obj in question
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This reads the page-array of the shmem-backing storage of the given gem
   object. An array of pages is returned. If a page is not allocated or
   swapped-out, this will allocate/swap-in the required pages. Note that the
   whole object is covered by the page-array and pinned in memory.
   </para><para>

   Use <function>drm_gem_put_pages</function> to release the array and unpin all pages.
   </para><para>

   This uses the GFP-mask set on the shmem-mapping (see <function>mapping_set_gfp_mask</function>).
   If you require other GFP-masks, you have to do those allocations yourself.
   </para><para>

   Note that you are not allowed to change gfp-zones during runtime. That is,
   <function>shmem_read_mapping_page_gfp</function> must be called with the same gfp_zone(gfp) as
   set during initialization. If you have special zone constraints, set them
   after <function>drm_gem_init_object</function> via <function>mapping_set_gfp_mask</function>. shmem-core takes care
   to keep pages in the required zone during swap-in.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-gem-put-pages">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_gem_put_pages</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_gem_put_pages</refname>
 <refpurpose>
     helper to free backing pages for a GEM object
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>drm_gem_put_pages </function></funcdef>
   <paramdef>struct drm_gem_object * <parameter>obj</parameter></paramdef>
   <paramdef>struct page ** <parameter>pages</parameter></paramdef>
   <paramdef>bool <parameter>dirty</parameter></paramdef>
   <paramdef>bool <parameter>accessed</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>obj</parameter></term>
   <listitem>
    <para>
     obj in question
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>pages</parameter></term>
   <listitem>
    <para>
     pages to free
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>dirty</parameter></term>
   <listitem>
    <para>
     if true, pages will be marked as dirty
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>accessed</parameter></term>
   <listitem>
    <para>
     if true, the pages will be marked as accessed
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-drm-gem-object-free">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_gem_object_free</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_gem_object_free</refname>
 <refpurpose>
     free a GEM object
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>drm_gem_object_free </function></funcdef>
   <paramdef>struct kref * <parameter>kref</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>kref</parameter></term>
   <listitem>
    <para>
     kref of the object to free
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Called after the last reference to the object has been lost.
   Must be called holding struct_ mutex
   </para><para>

   Frees the object
</para>
</refsect1>
</refentry>

<refentry id="API-drm-gem-mmap-obj">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_gem_mmap_obj</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_gem_mmap_obj</refname>
 <refpurpose>
     memory map a GEM object
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>drm_gem_mmap_obj </function></funcdef>
   <paramdef>struct drm_gem_object * <parameter>obj</parameter></paramdef>
   <paramdef>unsigned long <parameter>obj_size</parameter></paramdef>
   <paramdef>struct vm_area_struct * <parameter>vma</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>obj</parameter></term>
   <listitem>
    <para>
     the GEM object to map
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>obj_size</parameter></term>
   <listitem>
    <para>
     the object size to be mapped, in bytes
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>vma</parameter></term>
   <listitem>
    <para>
     VMA for the area to be mapped
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Set up the VMA to prepare mapping of the GEM object using the gem_vm_ops
   provided by the driver. Depending on their requirements, drivers can either
   provide a fault handler in their gem_vm_ops (in which case any accesses to
   the object will be trapped, to perform migration, GTT binding, surface
   register allocation, or performance monitoring), or mmap the buffer memory
   synchronously after calling drm_gem_mmap_obj.
   </para><para>

   This function is mainly intended to implement the DMABUF mmap operation, when
   the GEM object is not looked up based on its fake offset. To implement the
   DRM mmap operation, drivers should use the <function>drm_gem_mmap</function> function.
   </para><para>

   <function>drm_gem_mmap_obj</function> assumes the user is granted access to the buffer while
   <function>drm_gem_mmap</function> prevents unprivileged users from mapping random objects. So
   callers must verify access restrictions before calling this helper.
</para>
</refsect1>
<refsect1>
<title>NOTE</title>
<para>
   This function has to be protected with dev-&gt;struct_mutex
   </para><para>

   Return 0 or success or -EINVAL if the object size is smaller than the VMA
   size, or if no gem_vm_ops are provided.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-gem-mmap">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_gem_mmap</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_gem_mmap</refname>
 <refpurpose>
     memory map routine for GEM objects
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>drm_gem_mmap </function></funcdef>
   <paramdef>struct file * <parameter>filp</parameter></paramdef>
   <paramdef>struct vm_area_struct * <parameter>vma</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>filp</parameter></term>
   <listitem>
    <para>
     DRM file pointer
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>vma</parameter></term>
   <listitem>
    <para>
     VMA for the area to be mapped
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   If a driver supports GEM object mapping, mmap calls on the DRM file
   descriptor will end up here.
   </para><para>

   Look up the GEM object based on the offset passed in (vma-&gt;vm_pgoff will
   contain the fake offset we created when the GTT map ioctl was called on
   the object) and map it with a call to <function>drm_gem_mmap_obj</function>.
   </para><para>

   If the caller is not granted access to the buffer object, the mmap will fail
   with EACCES. Please see the vma manager for more information.
</para>
</refsect1>
</refentry>

      </sect3>
      </sect2>
      <sect2>
	<title>VMA Offset Manager</title>
<para>
   </para><para>
   The vma-manager is responsible to map arbitrary driver-dependent memory
   regions into the linear user address-space. It provides offsets to the
   caller which can then be used on the address_space of the drm-device. It
   takes care to not overlap regions, size them appropriately and to not
   confuse mm-core by inconsistent fake vm_pgoff fields.
   Drivers shouldn't use this for object placement in VMEM. This manager should
   only be used to manage mappings into linear user-space VMs.
   </para><para>
   We use drm_mm as backend to manage object allocations. But it is highly
   optimized for alloc/free calls, not lookups. Hence, we use an rb-tree to
   speed up offset lookups.
   </para><para>
   You must not use multiple offset managers on a single address_space.
   Otherwise, mm-core will be unable to tear down memory mappings as the VM will
   no longer be linear. Please use VM_NONLINEAR in that case and implement your
   own offset managers.
   </para><para>
   This offset manager works on page-based addresses. That is, every argument
   and return code (with the exception of <function>drm_vma_node_offset_addr</function>) is given
   in number of pages, not number of bytes. That means, object sizes and offsets
   must always be page-aligned (as usual).
   If you want to get a valid byte-based user-space address for a given offset,
   please see <function>drm_vma_node_offset_addr</function>.
   </para><para>
   Additionally to offset management, the vma offset manager also handles access
   management. For every open-file context that is allowed to access a given
   node, you must call <function>drm_vma_node_allow</function>. Otherwise, an <function>mmap</function> call on this
   open-file with the offset of the node will fail with -EACCES. To revoke
   access again, use <function>drm_vma_node_revoke</function>. However, the caller is responsible
   for destroying already existing mappings, if required.
</para>

<!-- drivers/gpu/drm/drm_vma_manager.c -->
<refentry id="API-drm-vma-offset-manager-init">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_vma_offset_manager_init</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_vma_offset_manager_init</refname>
 <refpurpose>
  Initialize new offset-manager
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>drm_vma_offset_manager_init </function></funcdef>
   <paramdef>struct drm_vma_offset_manager * <parameter>mgr</parameter></paramdef>
   <paramdef>unsigned long <parameter>page_offset</parameter></paramdef>
   <paramdef>unsigned long <parameter>size</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>mgr</parameter></term>
   <listitem>
    <para>
     Manager object
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>page_offset</parameter></term>
   <listitem>
    <para>
     Offset of available memory area (page-based)
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>size</parameter></term>
   <listitem>
    <para>
     Size of available address space range (page-based)
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Initialize a new offset-manager. The offset and area size available for the
   manager are given as <parameter>page_offset</parameter> and <parameter>size</parameter>. Both are interpreted as
   page-numbers, not bytes.
   </para><para>

   Adding/removing nodes from the manager is locked internally and protected
   against concurrent access. However, node allocation and destruction is left
   for the caller. While calling into the vma-manager, a given node must
   always be guaranteed to be referenced.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-vma-offset-manager-destroy">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_vma_offset_manager_destroy</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_vma_offset_manager_destroy</refname>
 <refpurpose>
     Destroy offset manager
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>drm_vma_offset_manager_destroy </function></funcdef>
   <paramdef>struct drm_vma_offset_manager * <parameter>mgr</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>mgr</parameter></term>
   <listitem>
    <para>
     Manager object
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Destroy an object manager which was previously created via
   <function>drm_vma_offset_manager_init</function>. The caller must remove all allocated nodes
   before destroying the manager. Otherwise, drm_mm will refuse to free the
   requested resources.
   </para><para>

   The manager must not be accessed after this function is called.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-vma-offset-lookup">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_vma_offset_lookup</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_vma_offset_lookup</refname>
 <refpurpose>
     Find node in offset space
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct drm_vma_offset_node * <function>drm_vma_offset_lookup </function></funcdef>
   <paramdef>struct drm_vma_offset_manager * <parameter>mgr</parameter></paramdef>
   <paramdef>unsigned long <parameter>start</parameter></paramdef>
   <paramdef>unsigned long <parameter>pages</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>mgr</parameter></term>
   <listitem>
    <para>
     Manager object
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>start</parameter></term>
   <listitem>
    <para>
     Start address for object (page-based)
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>pages</parameter></term>
   <listitem>
    <para>
     Size of object (page-based)
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Find a node given a start address and object size. This returns the _best_
   match for the given node. That is, <parameter>start</parameter> may point somewhere into a valid
   region and the given node will be returned, as long as the node spans the
   whole requested area (given the size in number of pages as <parameter>pages</parameter>).
</para>
</refsect1>
<refsect1>
<title>RETURNS</title>
<para>
   Returns NULL if no suitable node can be found. Otherwise, the best match
   is returned. It's the caller's responsibility to make sure the node doesn't
   get destroyed before the caller can access it.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-vma-offset-lookup-locked">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_vma_offset_lookup_locked</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_vma_offset_lookup_locked</refname>
 <refpurpose>
     Find node in offset space
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct drm_vma_offset_node * <function>drm_vma_offset_lookup_locked </function></funcdef>
   <paramdef>struct drm_vma_offset_manager * <parameter>mgr</parameter></paramdef>
   <paramdef>unsigned long <parameter>start</parameter></paramdef>
   <paramdef>unsigned long <parameter>pages</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>mgr</parameter></term>
   <listitem>
    <para>
     Manager object
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>start</parameter></term>
   <listitem>
    <para>
     Start address for object (page-based)
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>pages</parameter></term>
   <listitem>
    <para>
     Size of object (page-based)
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Same as <function>drm_vma_offset_lookup</function> but requires the caller to lock offset lookup
   manually. See <function>drm_vma_offset_lock_lookup</function> for an example.
</para>
</refsect1>
<refsect1>
<title>RETURNS</title>
<para>
   Returns NULL if no suitable node can be found. Otherwise, the best match
   is returned.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-vma-offset-add">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_vma_offset_add</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_vma_offset_add</refname>
 <refpurpose>
     Add offset node to manager
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>drm_vma_offset_add </function></funcdef>
   <paramdef>struct drm_vma_offset_manager * <parameter>mgr</parameter></paramdef>
   <paramdef>struct drm_vma_offset_node * <parameter>node</parameter></paramdef>
   <paramdef>unsigned long <parameter>pages</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>mgr</parameter></term>
   <listitem>
    <para>
     Manager object
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>node</parameter></term>
   <listitem>
    <para>
     Node to be added
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>pages</parameter></term>
   <listitem>
    <para>
     Allocation size visible to user-space (in number of pages)
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Add a node to the offset-manager. If the node was already added, this does
   nothing and return 0. <parameter>pages</parameter> is the size of the object given in number of
   pages.
   After this call succeeds, you can access the offset of the node until it
   is removed again.
   </para><para>

   If this call fails, it is safe to retry the operation or call
   <function>drm_vma_offset_remove</function>, anyway. However, no cleanup is required in that
   case.
   </para><para>

   <parameter>pages</parameter> is not required to be the same size as the underlying memory object
   that you want to map. It only limits the size that user-space can map into
   their address space.
</para>
</refsect1>
<refsect1>
<title>RETURNS</title>
<para>
   0 on success, negative error code on failure.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-vma-offset-remove">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_vma_offset_remove</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_vma_offset_remove</refname>
 <refpurpose>
     Remove offset node from manager
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>drm_vma_offset_remove </function></funcdef>
   <paramdef>struct drm_vma_offset_manager * <parameter>mgr</parameter></paramdef>
   <paramdef>struct drm_vma_offset_node * <parameter>node</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>mgr</parameter></term>
   <listitem>
    <para>
     Manager object
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>node</parameter></term>
   <listitem>
    <para>
     Node to be removed
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Remove a node from the offset manager. If the node wasn't added before, this
   does nothing. After this call returns, the offset and size will be 0 until a
   new offset is allocated via <function>drm_vma_offset_add</function> again. Helper functions like
   <function>drm_vma_node_start</function> and <function>drm_vma_node_offset_addr</function> will return 0 if no
   offset is allocated.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-vma-node-allow">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_vma_node_allow</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_vma_node_allow</refname>
 <refpurpose>
     Add open-file to list of allowed users
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>drm_vma_node_allow </function></funcdef>
   <paramdef>struct drm_vma_offset_node * <parameter>node</parameter></paramdef>
   <paramdef>struct file * <parameter>filp</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>node</parameter></term>
   <listitem>
    <para>
     Node to modify
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>filp</parameter></term>
   <listitem>
    <para>
     Open file to add
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Add <parameter>filp</parameter> to the list of allowed open-files for this node. If <parameter>filp</parameter> is
   already on this list, the ref-count is incremented.
   </para><para>

   The list of allowed-users is preserved across <function>drm_vma_offset_add</function> and
   <function>drm_vma_offset_remove</function> calls. You may even call it if the node is currently
   not added to any offset-manager.
   </para><para>

   You must remove all open-files the same number of times as you added them
   before destroying the node. Otherwise, you will leak memory.
   </para><para>

   This is locked against concurrent access internally.
</para>
</refsect1>
<refsect1>
<title>RETURNS</title>
<para>
   0 on success, negative error code on internal failure (out-of-mem)
</para>
</refsect1>
</refentry>

<refentry id="API-drm-vma-node-revoke">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_vma_node_revoke</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_vma_node_revoke</refname>
 <refpurpose>
     Remove open-file from list of allowed users
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>drm_vma_node_revoke </function></funcdef>
   <paramdef>struct drm_vma_offset_node * <parameter>node</parameter></paramdef>
   <paramdef>struct file * <parameter>filp</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>node</parameter></term>
   <listitem>
    <para>
     Node to modify
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>filp</parameter></term>
   <listitem>
    <para>
     Open file to remove
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Decrement the ref-count of <parameter>filp</parameter> in the list of allowed open-files on <parameter>node</parameter>.
   If the ref-count drops to zero, remove <parameter>filp</parameter> from the list. You must call
   this once for every <function>drm_vma_node_allow</function> on <parameter>filp</parameter>.
   </para><para>

   This is locked against concurrent access internally.
   </para><para>

   If <parameter>filp</parameter> is not on the list, nothing is done.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-vma-node-is-allowed">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_vma_node_is_allowed</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_vma_node_is_allowed</refname>
 <refpurpose>
     Check whether an open-file is granted access
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>bool <function>drm_vma_node_is_allowed </function></funcdef>
   <paramdef>struct drm_vma_offset_node * <parameter>node</parameter></paramdef>
   <paramdef>struct file * <parameter>filp</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>node</parameter></term>
   <listitem>
    <para>
     Node to check
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>filp</parameter></term>
   <listitem>
    <para>
     Open-file to check for
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Search the list in <parameter>node</parameter> whether <parameter>filp</parameter> is currently on the list of allowed
   open-files (see <function>drm_vma_node_allow</function>).
   </para><para>

   This is locked against concurrent access internally.
</para>
</refsect1>
<refsect1>
<title>RETURNS</title>
<para>
   true iff <parameter>filp</parameter> is on the list
</para>
</refsect1>
</refentry>

<!-- include/drm/drm_vma_manager.h -->
<refentry id="API-drm-vma-offset-exact-lookup">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_vma_offset_exact_lookup</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_vma_offset_exact_lookup</refname>
 <refpurpose>
  Look up node by exact address
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct drm_vma_offset_node * <function>drm_vma_offset_exact_lookup </function></funcdef>
   <paramdef>struct drm_vma_offset_manager * <parameter>mgr</parameter></paramdef>
   <paramdef>unsigned long <parameter>start</parameter></paramdef>
   <paramdef>unsigned long <parameter>pages</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>mgr</parameter></term>
   <listitem>
    <para>
     Manager object
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>start</parameter></term>
   <listitem>
    <para>
     Start address (page-based, not byte-based)
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>pages</parameter></term>
   <listitem>
    <para>
     Size of object (page-based)
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Same as <function>drm_vma_offset_lookup</function> but does not allow any offset into the node.
   It only returns the exact object with the given start address.
</para>
</refsect1>
<refsect1>
<title>RETURNS</title>
<para>
   Node at exact start address <parameter>start</parameter>.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-vma-offset-lock-lookup">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_vma_offset_lock_lookup</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_vma_offset_lock_lookup</refname>
 <refpurpose>
     Lock lookup for extended private use
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>drm_vma_offset_lock_lookup </function></funcdef>
   <paramdef>struct drm_vma_offset_manager * <parameter>mgr</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>mgr</parameter></term>
   <listitem>
    <para>
     Manager object
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Lock VMA manager for extended lookups. Only *<function>_locked</function> VMA function calls
   are allowed while holding this lock. All other contexts are blocked from VMA
   until the lock is released via <function>drm_vma_offset_unlock_lookup</function>.
   </para><para>

   Use this if you need to take a reference to the objects returned by
   <function>drm_vma_offset_lookup_locked</function> before releasing this lock again.
   </para><para>

   This lock must not be used for anything else than extended lookups. You must
   not call any other VMA helpers while holding this lock.
</para>
</refsect1>
<refsect1>
<title>Note</title>
<para>
   You're in atomic-context while holding this lock!
</para>
</refsect1>
<refsect1>
<title>Example</title>
<informalexample><programlisting>
     drm_vma_offset_lock_lookup(mgr);
     node = drm_vma_offset_lookup_locked(mgr);
     if (node)
         kref_get_unless_zero(container_of(node, sth, entr));
     drm_vma_offset_unlock_lookup(mgr);
</programlisting></informalexample>
</refsect1>
</refentry>

<refentry id="API-drm-vma-offset-unlock-lookup">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_vma_offset_unlock_lookup</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_vma_offset_unlock_lookup</refname>
 <refpurpose>
     Unlock lookup for extended private use
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>drm_vma_offset_unlock_lookup </function></funcdef>
   <paramdef>struct drm_vma_offset_manager * <parameter>mgr</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>mgr</parameter></term>
   <listitem>
    <para>
     Manager object
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Release lookup-lock. See <function>drm_vma_offset_lock_lookup</function> for more information.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-vma-node-reset">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_vma_node_reset</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_vma_node_reset</refname>
 <refpurpose>
     Initialize or reset node object
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>drm_vma_node_reset </function></funcdef>
   <paramdef>struct drm_vma_offset_node * <parameter>node</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>node</parameter></term>
   <listitem>
    <para>
     Node to initialize or reset
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Reset a node to its initial state. This must be called before using it with
   any VMA offset manager.
   </para><para>

   This must not be called on an already allocated node, or you will leak
   memory.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-vma-node-start">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_vma_node_start</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_vma_node_start</refname>
 <refpurpose>
     Return start address for page-based addressing
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>unsigned long <function>drm_vma_node_start </function></funcdef>
   <paramdef>struct drm_vma_offset_node * <parameter>node</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>node</parameter></term>
   <listitem>
    <para>
     Node to inspect
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Return the start address of the given node. This can be used as offset into
   the linear VM space that is provided by the VMA offset manager. Note that
   this can only be used for page-based addressing. If you need a proper offset
   for user-space mappings, you must apply <quote>&lt;&lt; PAGE_SHIFT</quote> or use the
   <function>drm_vma_node_offset_addr</function> helper instead.
</para>
</refsect1>
<refsect1>
<title>RETURNS</title>
<para>
   Start address of <parameter>node</parameter> for page-based addressing. 0 if the node does not
   have an offset allocated.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-vma-node-size">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_vma_node_size</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_vma_node_size</refname>
 <refpurpose>
     Return size (page-based)
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>unsigned long <function>drm_vma_node_size </function></funcdef>
   <paramdef>struct drm_vma_offset_node * <parameter>node</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>node</parameter></term>
   <listitem>
    <para>
     Node to inspect
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Return the size as number of pages for the given node. This is the same size
   that was passed to <function>drm_vma_offset_add</function>. If no offset is allocated for the
   node, this is 0.
</para>
</refsect1>
<refsect1>
<title>RETURNS</title>
<para>
   Size of <parameter>node</parameter> as number of pages. 0 if the node does not have an offset
   allocated.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-vma-node-has-offset">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_vma_node_has_offset</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_vma_node_has_offset</refname>
 <refpurpose>
     Check whether node is added to offset manager
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>bool <function>drm_vma_node_has_offset </function></funcdef>
   <paramdef>struct drm_vma_offset_node * <parameter>node</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>node</parameter></term>
   <listitem>
    <para>
     Node to be checked
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>RETURNS</title>
<para>
   true iff the node was previously allocated an offset and added to
   an vma offset manager.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-vma-node-offset-addr">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_vma_node_offset_addr</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_vma_node_offset_addr</refname>
 <refpurpose>
     Return sanitized offset for user-space mmaps
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>__u64 <function>drm_vma_node_offset_addr </function></funcdef>
   <paramdef>struct drm_vma_offset_node * <parameter>node</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>node</parameter></term>
   <listitem>
    <para>
     Linked offset node
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Same as <function>drm_vma_node_start</function> but returns the address as a valid offset that
   can be used for user-space mappings during <function>mmap</function>.
   This must not be called on unlinked nodes.
</para>
</refsect1>
<refsect1>
<title>RETURNS</title>
<para>
   Offset of <parameter>node</parameter> for byte-based addressing. 0 if the node does not have an
   object allocated.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-vma-node-unmap">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_vma_node_unmap</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_vma_node_unmap</refname>
 <refpurpose>
     Unmap offset node
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>drm_vma_node_unmap </function></funcdef>
   <paramdef>struct drm_vma_offset_node * <parameter>node</parameter></paramdef>
   <paramdef>struct address_space * <parameter>file_mapping</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>node</parameter></term>
   <listitem>
    <para>
     Offset node
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>file_mapping</parameter></term>
   <listitem>
    <para>
     Address space to unmap <parameter>node</parameter> from
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Unmap all userspace mappings for a given offset node. The mappings must be
   associated with the <parameter>file_mapping</parameter> address-space. If no offset exists
   nothing is done.
   </para><para>

   This call is unlocked. The caller must guarantee that <function>drm_vma_offset_remove</function>
   is not called on this node concurrently.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-vma-node-verify-access">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_vma_node_verify_access</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_vma_node_verify_access</refname>
 <refpurpose>
     Access verification helper for TTM
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>drm_vma_node_verify_access </function></funcdef>
   <paramdef>struct drm_vma_offset_node * <parameter>node</parameter></paramdef>
   <paramdef>struct file * <parameter>filp</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>node</parameter></term>
   <listitem>
    <para>
     Offset node
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>filp</parameter></term>
   <listitem>
    <para>
     Open-file
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This checks whether <parameter>filp</parameter> is granted access to <parameter>node</parameter>. It is the same as
   <function>drm_vma_node_is_allowed</function> but suitable as drop-in helper for TTM
   <function>verify_access</function> callbacks.
</para>
</refsect1>
<refsect1>
<title>RETURNS</title>
<para>
   0 if access is granted, -EACCES otherwise.
</para>
</refsect1>
</refentry>

      </sect2>
      <sect2 id="drm-prime-support">
	<title>PRIME Buffer Sharing</title>
	<para>
	  PRIME is the cross device buffer sharing framework in drm, originally
	  created for the OPTIMUS range of multi-gpu platforms. To userspace
	  PRIME buffers are dma-buf based file descriptors.
	</para>
	<sect3>
	  <title>Overview and Driver Interface</title>
	  <para>
	    Similar to GEM global names, PRIME file descriptors are
	    also used to share buffer objects across processes. They offer
	    additional security: as file descriptors must be explicitly sent over
	    UNIX domain sockets to be shared between applications, they can't be
	    guessed like the globally unique GEM names.
	  </para>
	  <para>
	    Drivers that support the PRIME
	    API must set the DRIVER_PRIME bit in the struct
	    <structname>drm_driver</structname>
	    <structfield>driver_features</structfield> field, and implement the
	    <methodname>prime_handle_to_fd</methodname> and
	    <methodname>prime_fd_to_handle</methodname> operations.
	  </para>
	  <para>
	    <synopsis>int (*prime_handle_to_fd)(struct drm_device *dev,
			  struct drm_file *file_priv, uint32_t handle,
			  uint32_t flags, int *prime_fd);
int (*prime_fd_to_handle)(struct drm_device *dev,
			  struct drm_file *file_priv, int prime_fd,
			  uint32_t *handle);</synopsis>
	    Those two operations convert a handle to a PRIME file descriptor and
	    vice versa. Drivers must use the kernel dma-buf buffer sharing framework
	    to manage the PRIME file descriptors. Similar to the mode setting
	    API PRIME is agnostic to the underlying buffer object manager, as
	    long as handles are 32bit unsigned integers.
	  </para>
	  <para>
	    While non-GEM drivers must implement the operations themselves, GEM
	    drivers must use the <function>drm_gem_prime_handle_to_fd</function>
	    and <function>drm_gem_prime_fd_to_handle</function> helper functions.
	    Those helpers rely on the driver
	    <methodname>gem_prime_export</methodname> and
	    <methodname>gem_prime_import</methodname> operations to create a dma-buf
	    instance from a GEM object (dma-buf exporter role) and to create a GEM
	    object from a dma-buf instance (dma-buf importer role).
	  </para>
	  <para>
	    <synopsis>struct dma_buf * (*gem_prime_export)(struct drm_device *dev,
				     struct drm_gem_object *obj,
				     int flags);
struct drm_gem_object * (*gem_prime_import)(struct drm_device *dev,
					    struct dma_buf *dma_buf);</synopsis>
	    These two operations are mandatory for GEM drivers that support
	    PRIME.
	  </para>
	</sect3>
        <sect3>
          <title>PRIME Helper Functions</title>
<para>
   </para><para>
   Drivers can implement <parameter>gem_prime_export</parameter> and <parameter>gem_prime_import</parameter> in terms of
   simpler APIs by using the helper functions <parameter>drm_gem_prime_export</parameter> and
   <parameter>drm_gem_prime_import</parameter>.  These functions implement dma-buf support in terms of
   five lower-level driver callbacks:
   </para><para>
   Export callbacks:
   </para><para>
   - <parameter>gem_prime_pin</parameter> (optional): prepare a GEM object for exporting
   </para><para>
   - <parameter>gem_prime_get_sg_table</parameter>: provide a scatter/gather table of pinned pages
   </para><para>
   - <parameter>gem_prime_vmap</parameter>: vmap a buffer exported by your driver
   </para><para>
   - <parameter>gem_prime_vunmap</parameter>: vunmap a buffer exported by your driver
   </para><para>
   Import callback:
   </para><para>
   - <parameter>gem_prime_import_sg_table</parameter> (import): produce a GEM object from another
   driver's scatter/gather table
</para>

        </sect3>
      </sect2>
      <sect2>
	<title>PRIME Function References</title>
<!-- drivers/gpu/drm/drm_prime.c -->
<refentry id="API-drm-gem-dmabuf-release">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_gem_dmabuf_release</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_gem_dmabuf_release</refname>
 <refpurpose>
  dma_buf release implementation for GEM
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>drm_gem_dmabuf_release </function></funcdef>
   <paramdef>struct dma_buf * <parameter>dma_buf</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dma_buf</parameter></term>
   <listitem>
    <para>
     buffer to be released
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Generic release function for dma_bufs exported as PRIME buffers. GEM drivers
   must use this in their dma_buf ops structure as the release callback.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-gem-prime-export">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_gem_prime_export</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_gem_prime_export</refname>
 <refpurpose>
     helper library implemention of the export callback
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct dma_buf * <function>drm_gem_prime_export </function></funcdef>
   <paramdef>struct drm_device * <parameter>dev</parameter></paramdef>
   <paramdef>struct drm_gem_object * <parameter>obj</parameter></paramdef>
   <paramdef>int <parameter>flags</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     drm_device to export from
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>obj</parameter></term>
   <listitem>
    <para>
     GEM object to export
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>flags</parameter></term>
   <listitem>
    <para>
     flags like DRM_CLOEXEC
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This is the implementation of the gem_prime_export functions for GEM drivers
   using the PRIME helpers.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-gem-prime-handle-to-fd">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_gem_prime_handle_to_fd</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_gem_prime_handle_to_fd</refname>
 <refpurpose>
     PRIME export function for GEM drivers
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>drm_gem_prime_handle_to_fd </function></funcdef>
   <paramdef>struct drm_device * <parameter>dev</parameter></paramdef>
   <paramdef>struct drm_file * <parameter>file_priv</parameter></paramdef>
   <paramdef>uint32_t <parameter>handle</parameter></paramdef>
   <paramdef>uint32_t <parameter>flags</parameter></paramdef>
   <paramdef>int * <parameter>prime_fd</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     dev to export the buffer from
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>file_priv</parameter></term>
   <listitem>
    <para>
     drm file-private structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>handle</parameter></term>
   <listitem>
    <para>
     buffer handle to export
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>flags</parameter></term>
   <listitem>
    <para>
     flags like DRM_CLOEXEC
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>prime_fd</parameter></term>
   <listitem>
    <para>
     pointer to storage for the fd id of the create dma-buf
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This is the PRIME export function which must be used mandatorily by GEM
   drivers to ensure correct lifetime management of the underlying GEM object.
   The actual exporting from GEM object to a dma-buf is done through the
   gem_prime_export driver callback.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-gem-prime-import">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_gem_prime_import</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_gem_prime_import</refname>
 <refpurpose>
     helper library implemention of the import callback
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct drm_gem_object * <function>drm_gem_prime_import </function></funcdef>
   <paramdef>struct drm_device * <parameter>dev</parameter></paramdef>
   <paramdef>struct dma_buf * <parameter>dma_buf</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     drm_device to import into
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>dma_buf</parameter></term>
   <listitem>
    <para>
     dma-buf object to import
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This is the implementation of the gem_prime_import functions for GEM drivers
   using the PRIME helpers.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-gem-prime-fd-to-handle">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_gem_prime_fd_to_handle</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_gem_prime_fd_to_handle</refname>
 <refpurpose>
     PRIME import function for GEM drivers
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>drm_gem_prime_fd_to_handle </function></funcdef>
   <paramdef>struct drm_device * <parameter>dev</parameter></paramdef>
   <paramdef>struct drm_file * <parameter>file_priv</parameter></paramdef>
   <paramdef>int <parameter>prime_fd</parameter></paramdef>
   <paramdef>uint32_t * <parameter>handle</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     dev to export the buffer from
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>file_priv</parameter></term>
   <listitem>
    <para>
     drm file-private structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>prime_fd</parameter></term>
   <listitem>
    <para>
     fd id of the dma-buf which should be imported
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>handle</parameter></term>
   <listitem>
    <para>
     pointer to storage for the handle of the imported buffer object
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This is the PRIME import function which must be used mandatorily by GEM
   drivers to ensure correct lifetime management of the underlying GEM object.
   The actual importing of GEM object from the dma-buf is done through the
   gem_import_export driver callback.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-prime-pages-to-sg">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_prime_pages_to_sg</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_prime_pages_to_sg</refname>
 <refpurpose>
     converts a page array into an sg list
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct sg_table * <function>drm_prime_pages_to_sg </function></funcdef>
   <paramdef>struct page ** <parameter>pages</parameter></paramdef>
   <paramdef>int <parameter>nr_pages</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>pages</parameter></term>
   <listitem>
    <para>
     pointer to the array of page pointers to convert
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>nr_pages</parameter></term>
   <listitem>
    <para>
     length of the page vector
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This helper creates an sg table object from a set of pages
   the driver is responsible for mapping the pages into the
   importers address space for use with dma_buf itself.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-prime-sg-to-page-addr-arrays">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_prime_sg_to_page_addr_arrays</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_prime_sg_to_page_addr_arrays</refname>
 <refpurpose>
     convert an sg table into a page array
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>drm_prime_sg_to_page_addr_arrays </function></funcdef>
   <paramdef>struct sg_table * <parameter>sgt</parameter></paramdef>
   <paramdef>struct page ** <parameter>pages</parameter></paramdef>
   <paramdef>dma_addr_t * <parameter>addrs</parameter></paramdef>
   <paramdef>int <parameter>max_pages</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>sgt</parameter></term>
   <listitem>
    <para>
     scatter-gather table to convert
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>pages</parameter></term>
   <listitem>
    <para>
     array of page pointers to store the page array in
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>addrs</parameter></term>
   <listitem>
    <para>
     optional array to store the dma bus address of each page
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>max_pages</parameter></term>
   <listitem>
    <para>
     size of both the passed-in arrays
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Exports an sg table into an array of pages and addresses. This is currently
   required by the TTM driver in order to do correct fault handling.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-prime-gem-destroy">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_prime_gem_destroy</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_prime_gem_destroy</refname>
 <refpurpose>
     helper to clean up a PRIME-imported GEM object
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>drm_prime_gem_destroy </function></funcdef>
   <paramdef>struct drm_gem_object * <parameter>obj</parameter></paramdef>
   <paramdef>struct sg_table * <parameter>sg</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>obj</parameter></term>
   <listitem>
    <para>
     GEM object which was created from a dma-buf
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>sg</parameter></term>
   <listitem>
    <para>
     the sg-table which was pinned at import time
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This is the cleanup functions which GEM drivers need to call when they use
   <parameter>drm_gem_prime_import</parameter> to import dma-bufs.
</para>
</refsect1>
</refentry>

      </sect2>
      <sect2>
	<title>DRM MM Range Allocator</title>
	<sect3>
	  <title>Overview</title>
<para>
   </para><para>
   drm_mm provides a simple range allocator. The drivers are free to use the
   resource allocator from the linux core if it suits them, the upside of drm_mm
   is that it's in the DRM core. Which means that it's easier to extend for
   some of the crazier special purpose needs of gpus.
   </para><para>
   The main data struct is <structname>drm_mm</structname>, allocations are tracked in <structname>drm_mm_node</structname>.
   Drivers are free to embed either of them into their own suitable
   datastructures. drm_mm itself will not do any allocations of its own, so if
   drivers choose not to embed nodes they need to still allocate them
   themselves.
   </para><para>
   The range allocator also supports reservation of preallocated blocks. This is
   useful for taking over initial mode setting configurations from the firmware,
   where an object needs to be created which exactly matches the firmware's
   scanout target. As long as the range is still free it can be inserted anytime
   after the allocator is initialized, which helps with avoiding looped
   depencies in the driver load sequence.
   </para><para>
   drm_mm maintains a stack of most recently freed holes, which of all
   simplistic datastructures seems to be a fairly decent approach to clustering
   allocations and avoiding too much fragmentation. This means free space
   searches are O(num_holes). Given that all the fancy features drm_mm supports
   something better would be fairly complex and since gfx thrashing is a fairly
   steep cliff not a real concern. Removing a node again is O(1).
   </para><para>
   drm_mm supports a few features: Alignment and range restrictions can be
   supplied. Further more every <structname>drm_mm_node</structname> has a color value (which is just an
   opaqua unsigned long) which in conjunction with a driver callback can be used
   to implement sophisticated placement restrictions. The i915 DRM driver uses
   this to implement guard pages between incompatible caching domains in the
   graphics TT.
   </para><para>
   Two behaviors are supported for searching and allocating: bottom-up and top-down.
   The default is bottom-up. Top-down allocation can be used if the memory area
   has different restrictions, or just to reduce fragmentation.
   </para><para>
   Finally iteration helpers to walk all nodes and all holes are provided as are
   some basic allocator dumpers for debugging.
</para>

	</sect3>
	<sect3>
	  <title>LRU Scan/Eviction Support</title>
<para>
   </para><para>
   Very often GPUs need to have continuous allocations for a given object. When
   evicting objects to make space for a new one it is therefore not most
   efficient when we simply start to select all objects from the tail of an LRU
   until there's a suitable hole: Especially for big objects or nodes that
   otherwise have special allocation constraints there's a good chance we evict
   lots of (smaller) objects unecessarily.
   </para><para>
   The DRM range allocator supports this use-case through the scanning
   interfaces. First a scan operation needs to be initialized with
   <function>drm_mm_init_scan</function> or <function>drm_mm_init_scan_with_range</function>. The the driver adds
   objects to the roaster (probably by walking an LRU list, but this can be
   freely implemented) until a suitable hole is found or there's no further
   evitable object.
   </para><para>
   The the driver must walk through all objects again in exactly the reverse
   order to restore the allocator state. Note that while the allocator is used
   in the scan mode no other operation is allowed.
   </para><para>
   Finally the driver evicts all objects selected in the scan. Adding and
   removing an object is O(1), and since freeing a node is also O(1) the overall
   complexity is O(scanned_objects). So like the free stack which needs to be
   walked before a scan operation even begins this is linear in the number of
   objects. It doesn't seem to hurt badly.
</para>

	</sect3>
      </sect2>
      <sect2>
	<title>DRM MM Range Allocator Function References</title>
<!-- drivers/gpu/drm/drm_mm.c -->
<refentry id="API-drm-mm-reserve-node">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_mm_reserve_node</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_mm_reserve_node</refname>
 <refpurpose>
  insert an pre-initialized node
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>drm_mm_reserve_node </function></funcdef>
   <paramdef>struct drm_mm * <parameter>mm</parameter></paramdef>
   <paramdef>struct drm_mm_node * <parameter>node</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>mm</parameter></term>
   <listitem>
    <para>
     drm_mm allocator to insert <parameter>node</parameter> into
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>node</parameter></term>
   <listitem>
    <para>
     drm_mm_node to insert
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This functions inserts an already set-up drm_mm_node into the allocator,
   meaning that start, size and color must be set by the caller. This is useful
   to initialize the allocator with preallocated objects which must be set-up
   before the range allocator can be set-up, e.g. when taking over a firmware
   framebuffer.
</para>
</refsect1>
<refsect1>
<title>Returns</title>
<para>
   0 on success, -ENOSPC if there's no hole where <parameter>node</parameter> is.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-mm-insert-node-generic">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_mm_insert_node_generic</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_mm_insert_node_generic</refname>
 <refpurpose>
     search for space and insert <parameter>node</parameter>
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>drm_mm_insert_node_generic </function></funcdef>
   <paramdef>struct drm_mm * <parameter>mm</parameter></paramdef>
   <paramdef>struct drm_mm_node * <parameter>node</parameter></paramdef>
   <paramdef>unsigned long <parameter>size</parameter></paramdef>
   <paramdef>unsigned <parameter>alignment</parameter></paramdef>
   <paramdef>unsigned long <parameter>color</parameter></paramdef>
   <paramdef>enum drm_mm_search_flags <parameter>sflags</parameter></paramdef>
   <paramdef>enum drm_mm_allocator_flags <parameter>aflags</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>mm</parameter></term>
   <listitem>
    <para>
     drm_mm to allocate from
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>node</parameter></term>
   <listitem>
    <para>
     preallocate node to insert
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>size</parameter></term>
   <listitem>
    <para>
     size of the allocation
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>alignment</parameter></term>
   <listitem>
    <para>
     alignment of the allocation
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>color</parameter></term>
   <listitem>
    <para>
     opaque tag value to use for this node
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>sflags</parameter></term>
   <listitem>
    <para>
     flags to fine-tune the allocation search
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>aflags</parameter></term>
   <listitem>
    <para>
     flags to fine-tune the allocation behavior
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   The preallocated node must be cleared to 0.
</para>
</refsect1>
<refsect1>
<title>Returns</title>
<para>
   0 on success, -ENOSPC if there's no suitable hole.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-mm-insert-node-in-range-generic">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_mm_insert_node_in_range_generic</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_mm_insert_node_in_range_generic</refname>
 <refpurpose>
     ranged search for space and insert <parameter>node</parameter>
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>drm_mm_insert_node_in_range_generic </function></funcdef>
   <paramdef>struct drm_mm * <parameter>mm</parameter></paramdef>
   <paramdef>struct drm_mm_node * <parameter>node</parameter></paramdef>
   <paramdef>unsigned long <parameter>size</parameter></paramdef>
   <paramdef>unsigned <parameter>alignment</parameter></paramdef>
   <paramdef>unsigned long <parameter>color</parameter></paramdef>
   <paramdef>unsigned long <parameter>start</parameter></paramdef>
   <paramdef>unsigned long <parameter>end</parameter></paramdef>
   <paramdef>enum drm_mm_search_flags <parameter>sflags</parameter></paramdef>
   <paramdef>enum drm_mm_allocator_flags <parameter>aflags</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>mm</parameter></term>
   <listitem>
    <para>
     drm_mm to allocate from
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>node</parameter></term>
   <listitem>
    <para>
     preallocate node to insert
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>size</parameter></term>
   <listitem>
    <para>
     size of the allocation
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>alignment</parameter></term>
   <listitem>
    <para>
     alignment of the allocation
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>color</parameter></term>
   <listitem>
    <para>
     opaque tag value to use for this node
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>start</parameter></term>
   <listitem>
    <para>
     start of the allowed range for this node
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>end</parameter></term>
   <listitem>
    <para>
     end of the allowed range for this node
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>sflags</parameter></term>
   <listitem>
    <para>
     flags to fine-tune the allocation search
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>aflags</parameter></term>
   <listitem>
    <para>
     flags to fine-tune the allocation behavior
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   The preallocated node must be cleared to 0.
</para>
</refsect1>
<refsect1>
<title>Returns</title>
<para>
   0 on success, -ENOSPC if there's no suitable hole.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-mm-remove-node">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_mm_remove_node</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_mm_remove_node</refname>
 <refpurpose>
     Remove a memory node from the allocator.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>drm_mm_remove_node </function></funcdef>
   <paramdef>struct drm_mm_node * <parameter>node</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>node</parameter></term>
   <listitem>
    <para>
     drm_mm_node to remove
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This just removes a node from its drm_mm allocator. The node does not need to
   be cleared again before it can be re-inserted into this or any other drm_mm
   allocator. It is a bug to call this function on a un-allocated node.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-mm-replace-node">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_mm_replace_node</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_mm_replace_node</refname>
 <refpurpose>
     move an allocation from <parameter>old</parameter> to <parameter>new</parameter>
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>drm_mm_replace_node </function></funcdef>
   <paramdef>struct drm_mm_node * <parameter>old</parameter></paramdef>
   <paramdef>struct drm_mm_node * <parameter>new</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>old</parameter></term>
   <listitem>
    <para>
     drm_mm_node to remove from the allocator
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>new</parameter></term>
   <listitem>
    <para>
     drm_mm_node which should inherit <parameter>old</parameter>'s allocation
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This is useful for when drivers embed the drm_mm_node structure and hence
   can't move allocations by reassigning pointers. It's a combination of remove
   and insert with the guarantee that the allocation start will match.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-mm-init-scan">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_mm_init_scan</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_mm_init_scan</refname>
 <refpurpose>
     initialize lru scanning
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>drm_mm_init_scan </function></funcdef>
   <paramdef>struct drm_mm * <parameter>mm</parameter></paramdef>
   <paramdef>unsigned long <parameter>size</parameter></paramdef>
   <paramdef>unsigned <parameter>alignment</parameter></paramdef>
   <paramdef>unsigned long <parameter>color</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>mm</parameter></term>
   <listitem>
    <para>
     drm_mm to scan
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>size</parameter></term>
   <listitem>
    <para>
     size of the allocation
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>alignment</parameter></term>
   <listitem>
    <para>
     alignment of the allocation
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>color</parameter></term>
   <listitem>
    <para>
     opaque tag value to use for the allocation
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This simply sets up the scanning routines with the parameters for the desired
   hole. Note that there's no need to specify allocation flags, since they only
   change the place a node is allocated from within a suitable hole.
</para>
</refsect1>
<refsect1>
<title>Warning</title>
<para>
   As long as the scan list is non-empty, no other operations than
   adding/removing nodes to/from the scan list are allowed.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-mm-init-scan-with-range">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_mm_init_scan_with_range</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_mm_init_scan_with_range</refname>
 <refpurpose>
     initialize range-restricted lru scanning
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>drm_mm_init_scan_with_range </function></funcdef>
   <paramdef>struct drm_mm * <parameter>mm</parameter></paramdef>
   <paramdef>unsigned long <parameter>size</parameter></paramdef>
   <paramdef>unsigned <parameter>alignment</parameter></paramdef>
   <paramdef>unsigned long <parameter>color</parameter></paramdef>
   <paramdef>unsigned long <parameter>start</parameter></paramdef>
   <paramdef>unsigned long <parameter>end</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>mm</parameter></term>
   <listitem>
    <para>
     drm_mm to scan
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>size</parameter></term>
   <listitem>
    <para>
     size of the allocation
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>alignment</parameter></term>
   <listitem>
    <para>
     alignment of the allocation
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>color</parameter></term>
   <listitem>
    <para>
     opaque tag value to use for the allocation
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>start</parameter></term>
   <listitem>
    <para>
     start of the allowed range for the allocation
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>end</parameter></term>
   <listitem>
    <para>
     end of the allowed range for the allocation
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This simply sets up the scanning routines with the parameters for the desired
   hole. Note that there's no need to specify allocation flags, since they only
   change the place a node is allocated from within a suitable hole.
</para>
</refsect1>
<refsect1>
<title>Warning</title>
<para>
   As long as the scan list is non-empty, no other operations than
   adding/removing nodes to/from the scan list are allowed.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-mm-scan-add-block">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_mm_scan_add_block</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_mm_scan_add_block</refname>
 <refpurpose>
     add a node to the scan list
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>bool <function>drm_mm_scan_add_block </function></funcdef>
   <paramdef>struct drm_mm_node * <parameter>node</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>node</parameter></term>
   <listitem>
    <para>
     drm_mm_node to add
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Add a node to the scan list that might be freed to make space for the desired
   hole.
</para>
</refsect1>
<refsect1>
<title>Returns</title>
<para>
   True if a hole has been found, false otherwise.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-mm-scan-remove-block">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_mm_scan_remove_block</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_mm_scan_remove_block</refname>
 <refpurpose>
     remove a node from the scan list
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>bool <function>drm_mm_scan_remove_block </function></funcdef>
   <paramdef>struct drm_mm_node * <parameter>node</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>node</parameter></term>
   <listitem>
    <para>
     drm_mm_node to remove
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Nodes _must_ be removed in the exact same order from the scan list as they
   have been added, otherwise the internal state of the memory manager will be
   corrupted.
   </para><para>

   When the scan list is empty, the selected memory nodes can be freed. An
   immediately following drm_mm_search_free with !DRM_MM_SEARCH_BEST will then
   return the just freed block (because its at the top of the free_stack list).
</para>
</refsect1>
<refsect1>
<title>Returns</title>
<para>
   True if this block should be evicted, false otherwise. Will always
   return false when no hole has been found.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-mm-clean">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_mm_clean</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_mm_clean</refname>
 <refpurpose>
     checks whether an allocator is clean
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>bool <function>drm_mm_clean </function></funcdef>
   <paramdef>struct drm_mm * <parameter>mm</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>mm</parameter></term>
   <listitem>
    <para>
     drm_mm allocator to check
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Returns</title>
<para>
   True if the allocator is completely free, false if there's still a node
   allocated in it.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-mm-init">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_mm_init</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_mm_init</refname>
 <refpurpose>
     initialize a drm-mm allocator
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>drm_mm_init </function></funcdef>
   <paramdef>struct drm_mm * <parameter>mm</parameter></paramdef>
   <paramdef>unsigned long <parameter>start</parameter></paramdef>
   <paramdef>unsigned long <parameter>size</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>mm</parameter></term>
   <listitem>
    <para>
     the drm_mm structure to initialize
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>start</parameter></term>
   <listitem>
    <para>
     start of the range managed by <parameter>mm</parameter>
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>size</parameter></term>
   <listitem>
    <para>
     end of the range managed by <parameter>mm</parameter>
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Note that <parameter>mm</parameter> must be cleared to 0 before calling this function.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-mm-takedown">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_mm_takedown</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_mm_takedown</refname>
 <refpurpose>
     clean up a drm_mm allocator
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>drm_mm_takedown </function></funcdef>
   <paramdef>struct drm_mm * <parameter>mm</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>mm</parameter></term>
   <listitem>
    <para>
     drm_mm allocator to clean up
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Note that it is a bug to call this function on an allocator which is not
   clean.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-mm-debug-table">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_mm_debug_table</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_mm_debug_table</refname>
 <refpurpose>
     dump allocator state to dmesg
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>drm_mm_debug_table </function></funcdef>
   <paramdef>struct drm_mm * <parameter>mm</parameter></paramdef>
   <paramdef>const char * <parameter>prefix</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>mm</parameter></term>
   <listitem>
    <para>
     drm_mm allocator to dump
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>prefix</parameter></term>
   <listitem>
    <para>
     prefix to use for dumping to dmesg
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-drm-mm-dump-table">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_mm_dump_table</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_mm_dump_table</refname>
 <refpurpose>
     dump allocator state to a seq_file
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>drm_mm_dump_table </function></funcdef>
   <paramdef>struct seq_file * <parameter>m</parameter></paramdef>
   <paramdef>struct drm_mm * <parameter>mm</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>m</parameter></term>
   <listitem>
    <para>
     seq_file to dump to
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>mm</parameter></term>
   <listitem>
    <para>
     drm_mm allocator to dump
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<!-- include/drm/drm_mm.h -->
<refentry id="API-drm-mm-node-allocated">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_mm_node_allocated</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_mm_node_allocated</refname>
 <refpurpose>
  checks whether a node is allocated
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>bool <function>drm_mm_node_allocated </function></funcdef>
   <paramdef>struct drm_mm_node * <parameter>node</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>node</parameter></term>
   <listitem>
    <para>
     drm_mm_node to check
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Drivers should use this helpers for proper encapusulation of drm_mm
   internals.
</para>
</refsect1>
<refsect1>
<title>Returns</title>
<para>
   True if the <parameter>node</parameter> is allocated.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-mm-initialized">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_mm_initialized</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_mm_initialized</refname>
 <refpurpose>
     checks whether an allocator is initialized
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>bool <function>drm_mm_initialized </function></funcdef>
   <paramdef>struct drm_mm * <parameter>mm</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>mm</parameter></term>
   <listitem>
    <para>
     drm_mm to check
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Drivers should use this helpers for proper encapusulation of drm_mm
   internals.
</para>
</refsect1>
<refsect1>
<title>Returns</title>
<para>
   True if the <parameter>mm</parameter> is initialized.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-mm-hole-node-start">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_mm_hole_node_start</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_mm_hole_node_start</refname>
 <refpurpose>
     computes the start of the hole following <parameter>node</parameter>
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>unsigned long <function>drm_mm_hole_node_start </function></funcdef>
   <paramdef>struct drm_mm_node * <parameter>hole_node</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>hole_node</parameter></term>
   <listitem>
    <para>
     drm_mm_node which implicitly tracks the following hole
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This is useful for driver-sepific debug dumpers. Otherwise drivers should not
   inspect holes themselves. Drivers must check first whether a hole indeed
   follows by looking at node-&gt;hole_follows.
</para>
</refsect1>
<refsect1>
<title>Returns</title>
<para>
   Start of the subsequent hole.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-mm-hole-node-end">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_mm_hole_node_end</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_mm_hole_node_end</refname>
 <refpurpose>
     computes the end of the hole following <parameter>node</parameter>
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>unsigned long <function>drm_mm_hole_node_end </function></funcdef>
   <paramdef>struct drm_mm_node * <parameter>hole_node</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>hole_node</parameter></term>
   <listitem>
    <para>
     drm_mm_node which implicitly tracks the following hole
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This is useful for driver-sepific debug dumpers. Otherwise drivers should not
   inspect holes themselves. Drivers must check first whether a hole indeed
   follows by looking at node-&gt;hole_follows.
</para>
</refsect1>
<refsect1>
<title>Returns</title>
<para>
   End of the subsequent hole.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-mm-for-each-node">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_mm_for_each_node</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_mm_for_each_node</refname>
 <refpurpose>
     iterator to walk over all allocated nodes
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef> <function>drm_mm_for_each_node </function></funcdef>
   <paramdef> <parameter>entry</parameter></paramdef>
   <paramdef> <parameter>mm</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>entry</parameter></term>
   <listitem>
    <para>
     drm_mm_node structure to assign to in each iteration step
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>mm</parameter></term>
   <listitem>
    <para>
     drm_mm allocator to walk
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This iterator walks over all nodes in the range allocator. It is implemented
   with list_for_each, so not save against removal of elements.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-mm-for-each-hole">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_mm_for_each_hole</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_mm_for_each_hole</refname>
 <refpurpose>
     iterator to walk over all holes
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef> <function>drm_mm_for_each_hole </function></funcdef>
   <paramdef> <parameter>entry</parameter></paramdef>
   <paramdef> <parameter>mm</parameter></paramdef>
   <paramdef> <parameter>hole_start</parameter></paramdef>
   <paramdef> <parameter>hole_end</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>entry</parameter></term>
   <listitem>
    <para>
     drm_mm_node used internally to track progress
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>mm</parameter></term>
   <listitem>
    <para>
     drm_mm allocator to walk
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>hole_start</parameter></term>
   <listitem>
    <para>
     ulong variable to assign the hole start to on each iteration
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>hole_end</parameter></term>
   <listitem>
    <para>
     ulong variable to assign the hole end to on each iteration
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This iterator walks over all holes in the range allocator. It is implemented
   with list_for_each, so not save against removal of elements. <parameter>entry</parameter> is used
   internally and will not reflect a real drm_mm_node for the very first hole.
   Hence users of this iterator may not access it.
</para>
</refsect1>
<refsect1>
<title>Implementation Note</title>
<para>
   We need to inline list_for_each_entry in order to be able to set hole_start
   and hole_end on each iteration while keeping the macro sane.
   </para><para>

   The __drm_mm_for_each_hole version is similar, but with added support for
   going backwards.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-mm-insert-node">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_mm_insert_node</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_mm_insert_node</refname>
 <refpurpose>
     search for space and insert <parameter>node</parameter>
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>drm_mm_insert_node </function></funcdef>
   <paramdef>struct drm_mm * <parameter>mm</parameter></paramdef>
   <paramdef>struct drm_mm_node * <parameter>node</parameter></paramdef>
   <paramdef>unsigned long <parameter>size</parameter></paramdef>
   <paramdef>unsigned <parameter>alignment</parameter></paramdef>
   <paramdef>enum drm_mm_search_flags <parameter>flags</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>mm</parameter></term>
   <listitem>
    <para>
     drm_mm to allocate from
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>node</parameter></term>
   <listitem>
    <para>
     preallocate node to insert
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>size</parameter></term>
   <listitem>
    <para>
     size of the allocation
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>alignment</parameter></term>
   <listitem>
    <para>
     alignment of the allocation
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>flags</parameter></term>
   <listitem>
    <para>
     flags to fine-tune the allocation
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This is a simplified version of <function>drm_mm_insert_node_generic</function> with <parameter>color</parameter> set
   to 0.
   </para><para>

   The preallocated node must be cleared to 0.
</para>
</refsect1>
<refsect1>
<title>Returns</title>
<para>
   0 on success, -ENOSPC if there's no suitable hole.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-mm-insert-node-in-range">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_mm_insert_node_in_range</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_mm_insert_node_in_range</refname>
 <refpurpose>
     ranged search for space and insert <parameter>node</parameter>
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>drm_mm_insert_node_in_range </function></funcdef>
   <paramdef>struct drm_mm * <parameter>mm</parameter></paramdef>
   <paramdef>struct drm_mm_node * <parameter>node</parameter></paramdef>
   <paramdef>unsigned long <parameter>size</parameter></paramdef>
   <paramdef>unsigned <parameter>alignment</parameter></paramdef>
   <paramdef>unsigned long <parameter>start</parameter></paramdef>
   <paramdef>unsigned long <parameter>end</parameter></paramdef>
   <paramdef>enum drm_mm_search_flags <parameter>flags</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>mm</parameter></term>
   <listitem>
    <para>
     drm_mm to allocate from
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>node</parameter></term>
   <listitem>
    <para>
     preallocate node to insert
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>size</parameter></term>
   <listitem>
    <para>
     size of the allocation
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>alignment</parameter></term>
   <listitem>
    <para>
     alignment of the allocation
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>start</parameter></term>
   <listitem>
    <para>
     start of the allowed range for this node
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>end</parameter></term>
   <listitem>
    <para>
     end of the allowed range for this node
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>flags</parameter></term>
   <listitem>
    <para>
     flags to fine-tune the allocation
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This is a simplified version of <function>drm_mm_insert_node_in_range_generic</function> with
   <parameter>color</parameter> set to 0.
   </para><para>

   The preallocated node must be cleared to 0.
</para>
</refsect1>
<refsect1>
<title>Returns</title>
<para>
   0 on success, -ENOSPC if there's no suitable hole.
</para>
</refsect1>
</refentry>

      </sect2>
  </sect1>

  <!-- Internals: mode setting -->

  <sect1 id="drm-mode-setting">
    <title>Mode Setting</title>
    <para>
      Drivers must initialize the mode setting core by calling
      <function>drm_mode_config_init</function> on the DRM device. The function
      initializes the <structname>drm_device</structname>
      <structfield>mode_config</structfield> field and never fails. Once done,
      mode configuration must be setup by initializing the following fields.
    </para>
    <itemizedlist>
      <listitem>
        <synopsis>int min_width, min_height;
int max_width, max_height;</synopsis>
        <para>
	  Minimum and maximum width and height of the frame buffers in pixel
	  units.
	</para>
      </listitem>
      <listitem>
        <synopsis>struct drm_mode_config_funcs *funcs;</synopsis>
	<para>Mode setting functions.</para>
      </listitem>
    </itemizedlist>
    <sect2>
      <title>Display Modes Function Reference</title>
<!-- include/drm/drm_modes.h -->
<refentry id="API-drm-mode-is-stereo">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_mode_is_stereo</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_mode_is_stereo</refname>
 <refpurpose>
  check for stereo mode flags
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>bool <function>drm_mode_is_stereo </function></funcdef>
   <paramdef>const struct drm_display_mode * <parameter>mode</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>mode</parameter></term>
   <listitem>
    <para>
     drm_display_mode to check
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Returns</title>
<para>
   True if the mode is one of the stereo modes (like side-by-side), false if
   not.
</para>
</refsect1>
</refentry>

<!-- drivers/gpu/drm/drm_modes.c -->
<refentry id="API-drm-mode-debug-printmodeline">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_mode_debug_printmodeline</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_mode_debug_printmodeline</refname>
 <refpurpose>
  print a mode to dmesg
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>drm_mode_debug_printmodeline </function></funcdef>
   <paramdef>const struct drm_display_mode * <parameter>mode</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>mode</parameter></term>
   <listitem>
    <para>
     mode to print
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Describe <parameter>mode</parameter> using DRM_DEBUG.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-mode-create">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_mode_create</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_mode_create</refname>
 <refpurpose>
     create a new display mode
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct drm_display_mode * <function>drm_mode_create </function></funcdef>
   <paramdef>struct drm_device * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     DRM device
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Create a new, cleared drm_display_mode with kzalloc, allocate an ID for it
   and return it.
</para>
</refsect1>
<refsect1>
<title>Returns</title>
<para>
   Pointer to new mode on success, NULL on error.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-mode-destroy">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_mode_destroy</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_mode_destroy</refname>
 <refpurpose>
     remove a mode
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>drm_mode_destroy </function></funcdef>
   <paramdef>struct drm_device * <parameter>dev</parameter></paramdef>
   <paramdef>struct drm_display_mode * <parameter>mode</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     DRM device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>mode</parameter></term>
   <listitem>
    <para>
     mode to remove
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Release <parameter>mode</parameter>'s unique ID, then free it <parameter>mode</parameter> structure itself using kfree.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-mode-probed-add">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_mode_probed_add</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_mode_probed_add</refname>
 <refpurpose>
     add a mode to a connector's probed_mode list
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>drm_mode_probed_add </function></funcdef>
   <paramdef>struct drm_connector * <parameter>connector</parameter></paramdef>
   <paramdef>struct drm_display_mode * <parameter>mode</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>connector</parameter></term>
   <listitem>
    <para>
     connector the new mode
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>mode</parameter></term>
   <listitem>
    <para>
     mode data
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Add <parameter>mode</parameter> to <parameter>connector</parameter>'s probed_mode list for later use. This list should
   then in a second step get filtered and all the modes actually supported by
   the hardware moved to the <parameter>connector</parameter>'s modes list.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-cvt-mode">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_cvt_mode</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_cvt_mode</refname>
 <refpurpose>
     create a modeline based on the CVT algorithm
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct drm_display_mode * <function>drm_cvt_mode </function></funcdef>
   <paramdef>struct drm_device * <parameter>dev</parameter></paramdef>
   <paramdef>int <parameter>hdisplay</parameter></paramdef>
   <paramdef>int <parameter>vdisplay</parameter></paramdef>
   <paramdef>int <parameter>vrefresh</parameter></paramdef>
   <paramdef>bool <parameter>reduced</parameter></paramdef>
   <paramdef>bool <parameter>interlaced</parameter></paramdef>
   <paramdef>bool <parameter>margins</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     drm device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>hdisplay</parameter></term>
   <listitem>
    <para>
     hdisplay size
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>vdisplay</parameter></term>
   <listitem>
    <para>
     vdisplay size
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>vrefresh</parameter></term>
   <listitem>
    <para>
     vrefresh rate
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>reduced</parameter></term>
   <listitem>
    <para>
     whether to use reduced blanking
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>interlaced</parameter></term>
   <listitem>
    <para>
     whether to compute an interlaced mode
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>margins</parameter></term>
   <listitem>
    <para>
     whether to add margins (borders)
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This function is called to generate the modeline based on CVT algorithm
   according to the hdisplay, vdisplay, vrefresh.
   It is based from the VESA(TM) Coordinated Video Timing Generator by
   Graham Loveridge April 9, 2003 available at
</para>
</refsect1>
<refsect1>
<title>http</title>
<para>
   //www.elo.utfsm.cl/~elo212/docs/CVTd6r1.xls 
   </para><para>

   And it is copied from xf86CVTmode in xserver/hw/xfree86/modes/xf86cvt.c.
   What I have done is to translate it by using integer calculation.
</para>
</refsect1>
<refsect1>
<title>Returns</title>
<para>
   The modeline based on the CVT algorithm stored in a drm_display_mode object.
   The display mode object is allocated with <function>drm_mode_create</function>. Returns NULL
   when no mode could be allocated.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-gtf-mode-complex">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_gtf_mode_complex</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_gtf_mode_complex</refname>
 <refpurpose>
     create the modeline based on the full GTF algorithm
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct drm_display_mode * <function>drm_gtf_mode_complex </function></funcdef>
   <paramdef>struct drm_device * <parameter>dev</parameter></paramdef>
   <paramdef>int <parameter>hdisplay</parameter></paramdef>
   <paramdef>int <parameter>vdisplay</parameter></paramdef>
   <paramdef>int <parameter>vrefresh</parameter></paramdef>
   <paramdef>bool <parameter>interlaced</parameter></paramdef>
   <paramdef>int <parameter>margins</parameter></paramdef>
   <paramdef>int <parameter>GTF_M</parameter></paramdef>
   <paramdef>int <parameter>GTF_2C</parameter></paramdef>
   <paramdef>int <parameter>GTF_K</parameter></paramdef>
   <paramdef>int <parameter>GTF_2J</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     drm device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>hdisplay</parameter></term>
   <listitem>
    <para>
     hdisplay size
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>vdisplay</parameter></term>
   <listitem>
    <para>
     vdisplay size
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>vrefresh</parameter></term>
   <listitem>
    <para>
     vrefresh rate.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>interlaced</parameter></term>
   <listitem>
    <para>
     whether to compute an interlaced mode
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>margins</parameter></term>
   <listitem>
    <para>
     desired margin (borders) size
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>GTF_M</parameter></term>
   <listitem>
    <para>
     extended GTF formula parameters
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>GTF_2C</parameter></term>
   <listitem>
    <para>
     extended GTF formula parameters
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>GTF_K</parameter></term>
   <listitem>
    <para>
     extended GTF formula parameters
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>GTF_2J</parameter></term>
   <listitem>
    <para>
     extended GTF formula parameters
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   GTF feature blocks specify C and J in multiples of 0.5, so we pass them
   in here multiplied by two.  For a C of 40, pass in 80.
</para>
</refsect1>
<refsect1>
<title>Returns</title>
<para>
   The modeline based on the full GTF algorithm stored in a drm_display_mode object.
   The display mode object is allocated with <function>drm_mode_create</function>. Returns NULL
   when no mode could be allocated.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-gtf-mode">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_gtf_mode</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_gtf_mode</refname>
 <refpurpose>
     create the modeline based on the GTF algorithm
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct drm_display_mode * <function>drm_gtf_mode </function></funcdef>
   <paramdef>struct drm_device * <parameter>dev</parameter></paramdef>
   <paramdef>int <parameter>hdisplay</parameter></paramdef>
   <paramdef>int <parameter>vdisplay</parameter></paramdef>
   <paramdef>int <parameter>vrefresh</parameter></paramdef>
   <paramdef>bool <parameter>interlaced</parameter></paramdef>
   <paramdef>int <parameter>margins</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     drm device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>hdisplay</parameter></term>
   <listitem>
    <para>
     hdisplay size
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>vdisplay</parameter></term>
   <listitem>
    <para>
     vdisplay size
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>vrefresh</parameter></term>
   <listitem>
    <para>
     vrefresh rate.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>interlaced</parameter></term>
   <listitem>
    <para>
     whether to compute an interlaced mode
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>margins</parameter></term>
   <listitem>
    <para>
     desired margin (borders) size
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   return the modeline based on GTF algorithm
   </para><para>

   This function is to create the modeline based on the GTF algorithm.
</para>
</refsect1>
<refsect1>
<title>Generalized Timing Formula is derived from</title>
<para>
   GTF Spreadsheet by Andy Morrish (1/5/97)
</para>
</refsect1>
<refsect1>
<title>available at http</title>
<para>
   //www.vesa.org
   </para><para>

   And it is copied from the file of xserver/hw/xfree86/modes/xf86gtf.c.
   What I have done is to translate it by using integer calculation.
   I also refer to the function of fb_get_mode in the file of
   drivers/video/fbmon.c
</para>
</refsect1>
<refsect1>
<title>Standard GTF parameters</title>
<para>
   M = 600
   C = 40
   K = 128
   J = 20
</para>
</refsect1>
<refsect1>
<title>Returns</title>
<para>
   The modeline based on the GTF algorithm stored in a drm_display_mode object.
   The display mode object is allocated with <function>drm_mode_create</function>. Returns NULL
   when no mode could be allocated.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-display-mode-from-videomode">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_display_mode_from_videomode</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_display_mode_from_videomode</refname>
 <refpurpose>
     fill in <parameter>dmode</parameter> using <parameter>vm</parameter>,
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>drm_display_mode_from_videomode </function></funcdef>
   <paramdef>const struct videomode * <parameter>vm</parameter></paramdef>
   <paramdef>struct drm_display_mode * <parameter>dmode</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>vm</parameter></term>
   <listitem>
    <para>
     videomode structure to use as source
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>dmode</parameter></term>
   <listitem>
    <para>
     drm_display_mode structure to use as destination
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Fills out <parameter>dmode</parameter> using the display mode specified in <parameter>vm</parameter>.
</para>
</refsect1>
</refentry>

<refentry id="API-of-get-drm-display-mode">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>of_get_drm_display_mode</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>of_get_drm_display_mode</refname>
 <refpurpose>
     get a drm_display_mode from devicetree
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>of_get_drm_display_mode </function></funcdef>
   <paramdef>struct device_node * <parameter>np</parameter></paramdef>
   <paramdef>struct drm_display_mode * <parameter>dmode</parameter></paramdef>
   <paramdef>int <parameter>index</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>np</parameter></term>
   <listitem>
    <para>
     device_node with the timing specification
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>dmode</parameter></term>
   <listitem>
    <para>
     will be set to the return value
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>index</parameter></term>
   <listitem>
    <para>
     index into the list of display timings in devicetree
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This function is expensive and should only be used, if only one mode is to be
   read from DT. To get multiple modes start with of_get_display_timings and
   work with that instead.
</para>
</refsect1>
<refsect1>
<title>Returns</title>
<para>
   0 on success, a negative errno code when no of videomode node was found.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-mode-set-name">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_mode_set_name</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_mode_set_name</refname>
 <refpurpose>
     set the name on a mode
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>drm_mode_set_name </function></funcdef>
   <paramdef>struct drm_display_mode * <parameter>mode</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>mode</parameter></term>
   <listitem>
    <para>
     name will be set in this mode
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Set the name of <parameter>mode</parameter> to a standard format which is &lt;hdisplay&gt;x&lt;vdisplay&gt;
   with an optional 'i' suffix for interlaced modes.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-mode-vrefresh">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_mode_vrefresh</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_mode_vrefresh</refname>
 <refpurpose>
     get the vrefresh of a mode
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>drm_mode_vrefresh </function></funcdef>
   <paramdef>const struct drm_display_mode * <parameter>mode</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>mode</parameter></term>
   <listitem>
    <para>
     mode
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Returns</title>
<para>
   <parameter>modes</parameter>'s vrefresh rate in Hz, rounded to the nearest integer. Calculates the
   value first if it is not yet set.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-mode-set-crtcinfo">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_mode_set_crtcinfo</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_mode_set_crtcinfo</refname>
 <refpurpose>
     set CRTC modesetting timing parameters
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>drm_mode_set_crtcinfo </function></funcdef>
   <paramdef>struct drm_display_mode * <parameter>p</parameter></paramdef>
   <paramdef>int <parameter>adjust_flags</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>p</parameter></term>
   <listitem>
    <para>
     mode
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>adjust_flags</parameter></term>
   <listitem>
    <para>
     a combination of adjustment flags
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Setup the CRTC modesetting timing parameters for <parameter>p</parameter>, adjusting if necessary.
   </para><para>

   - The CRTC_INTERLACE_HALVE_V flag can be used to halve vertical timings of
   interlaced modes.
   - The CRTC_STEREO_DOUBLE flag can be used to compute the timings for
   buffers containing two eyes (only adjust the timings when needed, eg. for
   <quote>frame packing</quote> or <quote>side by side full</quote>).
</para>
</refsect1>
</refentry>

<refentry id="API-drm-mode-copy">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_mode_copy</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_mode_copy</refname>
 <refpurpose>
     copy the mode
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>drm_mode_copy </function></funcdef>
   <paramdef>struct drm_display_mode * <parameter>dst</parameter></paramdef>
   <paramdef>const struct drm_display_mode * <parameter>src</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dst</parameter></term>
   <listitem>
    <para>
     mode to overwrite
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>src</parameter></term>
   <listitem>
    <para>
     mode to copy
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Copy an existing mode into another mode, preserving the object id and
   list head of the destination mode.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-mode-duplicate">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_mode_duplicate</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_mode_duplicate</refname>
 <refpurpose>
     allocate and duplicate an existing mode
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct drm_display_mode * <function>drm_mode_duplicate </function></funcdef>
   <paramdef>struct drm_device * <parameter>dev</parameter></paramdef>
   <paramdef>const struct drm_display_mode * <parameter>mode</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     drm_device to allocate the duplicated mode for
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>mode</parameter></term>
   <listitem>
    <para>
     mode to duplicate
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Just allocate a new mode, copy the existing mode into it, and return
   a pointer to it.  Used to create new instances of established modes.
</para>
</refsect1>
<refsect1>
<title>Returns</title>
<para>
   Pointer to duplicated mode on success, NULL on error.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-mode-equal">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_mode_equal</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_mode_equal</refname>
 <refpurpose>
     test modes for equality
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>bool <function>drm_mode_equal </function></funcdef>
   <paramdef>const struct drm_display_mode * <parameter>mode1</parameter></paramdef>
   <paramdef>const struct drm_display_mode * <parameter>mode2</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>mode1</parameter></term>
   <listitem>
    <para>
     first mode
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>mode2</parameter></term>
   <listitem>
    <para>
     second mode
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Check to see if <parameter>mode1</parameter> and <parameter>mode2</parameter> are equivalent.
</para>
</refsect1>
<refsect1>
<title>Returns</title>
<para>
   True if the modes are equal, false otherwise.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-mode-equal-no-clocks-no-stereo">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_mode_equal_no_clocks_no_stereo</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_mode_equal_no_clocks_no_stereo</refname>
 <refpurpose>
     test modes for equality
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>bool <function>drm_mode_equal_no_clocks_no_stereo </function></funcdef>
   <paramdef>const struct drm_display_mode * <parameter>mode1</parameter></paramdef>
   <paramdef>const struct drm_display_mode * <parameter>mode2</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>mode1</parameter></term>
   <listitem>
    <para>
     first mode
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>mode2</parameter></term>
   <listitem>
    <para>
     second mode
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Check to see if <parameter>mode1</parameter> and <parameter>mode2</parameter> are equivalent, but
   don't check the pixel clocks nor the stereo layout.
</para>
</refsect1>
<refsect1>
<title>Returns</title>
<para>
   True if the modes are equal, false otherwise.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-mode-validate-size">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_mode_validate_size</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_mode_validate_size</refname>
 <refpurpose>
     make sure modes adhere to size constraints
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>drm_mode_validate_size </function></funcdef>
   <paramdef>struct drm_device * <parameter>dev</parameter></paramdef>
   <paramdef>struct list_head * <parameter>mode_list</parameter></paramdef>
   <paramdef>int <parameter>maxX</parameter></paramdef>
   <paramdef>int <parameter>maxY</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     DRM device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>mode_list</parameter></term>
   <listitem>
    <para>
     list of modes to check
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>maxX</parameter></term>
   <listitem>
    <para>
     maximum width
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>maxY</parameter></term>
   <listitem>
    <para>
     maximum height
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This function is a helper which can be used to validate modes against size
   limitations of the DRM device/connector. If a mode is too big its status
   memeber is updated with the appropriate validation failure code. The list
   itself is not changed.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-mode-prune-invalid">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_mode_prune_invalid</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_mode_prune_invalid</refname>
 <refpurpose>
     remove invalid modes from mode list
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>drm_mode_prune_invalid </function></funcdef>
   <paramdef>struct drm_device * <parameter>dev</parameter></paramdef>
   <paramdef>struct list_head * <parameter>mode_list</parameter></paramdef>
   <paramdef>bool <parameter>verbose</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     DRM device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>mode_list</parameter></term>
   <listitem>
    <para>
     list of modes to check
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>verbose</parameter></term>
   <listitem>
    <para>
     be verbose about it
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This helper function can be used to prune a display mode list after
   validation has been completed. All modes who's status is not MODE_OK will be
   removed from the list, and if <parameter>verbose</parameter> the status code and mode name is also
   printed to dmesg.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-mode-sort">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_mode_sort</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_mode_sort</refname>
 <refpurpose>
     sort mode list
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>drm_mode_sort </function></funcdef>
   <paramdef>struct list_head * <parameter>mode_list</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>mode_list</parameter></term>
   <listitem>
    <para>
     list of drm_display_mode structures to sort
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Sort <parameter>mode_list</parameter> by favorability, moving good modes to the head of the list.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-mode-connector-list-update">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_mode_connector_list_update</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_mode_connector_list_update</refname>
 <refpurpose>
     update the mode list for the connector
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>drm_mode_connector_list_update </function></funcdef>
   <paramdef>struct drm_connector * <parameter>connector</parameter></paramdef>
   <paramdef>bool <parameter>merge_type_bits</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>connector</parameter></term>
   <listitem>
    <para>
     the connector to update
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>merge_type_bits</parameter></term>
   <listitem>
    <para>
     whether to merge or overright type bits.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This moves the modes from the <parameter>connector</parameter> probed_modes list
   to the actual mode list. It compares the probed mode against the current
   list and only adds different/new modes.
   </para><para>

   This is just a helper functions doesn't validate any modes itself and also
   doesn't prune any invalid modes. Callers need to do that themselves.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-mode-parse-command-line-for-connector">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_mode_parse_command_line_for_connector</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_mode_parse_command_line_for_connector</refname>
 <refpurpose>
     parse command line modeline for connector
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>bool <function>drm_mode_parse_command_line_for_connector </function></funcdef>
   <paramdef>const char * <parameter>mode_option</parameter></paramdef>
   <paramdef>struct drm_connector * <parameter>connector</parameter></paramdef>
   <paramdef>struct drm_cmdline_mode * <parameter>mode</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>mode_option</parameter></term>
   <listitem>
    <para>
     optional per connector mode option
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>connector</parameter></term>
   <listitem>
    <para>
     connector to parse modeline for
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>mode</parameter></term>
   <listitem>
    <para>
     preallocated drm_cmdline_mode structure to fill out
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This parses <parameter>mode_option</parameter> command line modeline for modes and options to
   configure the connector. If <parameter>mode_option</parameter> is NULL the default command line
   modeline in fb_mode_option will be parsed instead.
   </para><para>

   This uses the same parameters as the fb modedb.c, except for an extra
   force-enable, force-enable-digital and force-disable bit at the end:
   </para><para>

   &lt;xres&gt;x&lt;yres&gt;[M][R][-&lt;bpp&gt;][@&lt;refresh&gt;][i][m][eDd]
   </para><para>

   The intermediate drm_cmdline_mode structure is required to store additional
   options from the command line modline like the force-enabel/disable flag.
</para>
</refsect1>
<refsect1>
<title>Returns</title>
<para>
   True if a valid modeline has been parsed, false otherwise.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-mode-create-from-cmdline-mode">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_mode_create_from_cmdline_mode</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_mode_create_from_cmdline_mode</refname>
 <refpurpose>
     convert a command line modeline into a DRM display mode
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct drm_display_mode * <function>drm_mode_create_from_cmdline_mode </function></funcdef>
   <paramdef>struct drm_device * <parameter>dev</parameter></paramdef>
   <paramdef>struct drm_cmdline_mode * <parameter>cmd</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     DRM device to create the new mode for
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>cmd</parameter></term>
   <listitem>
    <para>
     input command line modeline
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Returns</title>
<para>
   Pointer to converted mode on success, NULL on error.
</para>
</refsect1>
</refentry>

    </sect2>
    <sect2>
      <title>Frame Buffer Creation</title>
      <synopsis>struct drm_framebuffer *(*fb_create)(struct drm_device *dev,
				     struct drm_file *file_priv,
				     struct drm_mode_fb_cmd2 *mode_cmd);</synopsis>
      <para>
        Frame buffers are abstract memory objects that provide a source of
        pixels to scanout to a CRTC. Applications explicitly request the
        creation of frame buffers through the DRM_IOCTL_MODE_ADDFB(2) ioctls and
        receive an opaque handle that can be passed to the KMS CRTC control,
        plane configuration and page flip functions.
      </para>
      <para>
        Frame buffers rely on the underneath memory manager for low-level memory
        operations. When creating a frame buffer applications pass a memory
        handle (or a list of memory handles for multi-planar formats) through
	the <parameter>drm_mode_fb_cmd2</parameter> argument. For drivers using
	GEM as their userspace buffer management interface this would be a GEM
	handle.  Drivers are however free to use their own backing storage object
	handles, e.g. vmwgfx directly exposes special TTM handles to userspace
	and so expects TTM handles in the create ioctl and not GEM handles.
      </para>
      <para>
        Drivers must first validate the requested frame buffer parameters passed
        through the mode_cmd argument. In particular this is where invalid
        sizes, pixel formats or pitches can be caught.
      </para>
      <para>
        If the parameters are deemed valid, drivers then create, initialize and
        return an instance of struct <structname>drm_framebuffer</structname>.
        If desired the instance can be embedded in a larger driver-specific
	structure. Drivers must fill its <structfield>width</structfield>,
	<structfield>height</structfield>, <structfield>pitches</structfield>,
        <structfield>offsets</structfield>, <structfield>depth</structfield>,
        <structfield>bits_per_pixel</structfield> and
        <structfield>pixel_format</structfield> fields from the values passed
        through the <parameter>drm_mode_fb_cmd2</parameter> argument. They
        should call the <function>drm_helper_mode_fill_fb_struct</function>
        helper function to do so.
      </para>

      <para>
	The initialization of the new framebuffer instance is finalized with a
	call to <function>drm_framebuffer_init</function> which takes a pointer
	to DRM frame buffer operations (struct
	<structname>drm_framebuffer_funcs</structname>). Note that this function
	publishes the framebuffer and so from this point on it can be accessed
	concurrently from other threads. Hence it must be the last step in the
	driver's framebuffer initialization sequence. Frame buffer operations
	are
        <itemizedlist>
          <listitem>
            <synopsis>int (*create_handle)(struct drm_framebuffer *fb,
		     struct drm_file *file_priv, unsigned int *handle);</synopsis>
            <para>
              Create a handle to the frame buffer underlying memory object. If
              the frame buffer uses a multi-plane format, the handle will
              reference the memory object associated with the first plane.
            </para>
            <para>
              Drivers call <function>drm_gem_handle_create</function> to create
              the handle.
            </para>
          </listitem>
          <listitem>
            <synopsis>void (*destroy)(struct drm_framebuffer *framebuffer);</synopsis>
            <para>
              Destroy the frame buffer object and frees all associated
              resources. Drivers must call
              <function>drm_framebuffer_cleanup</function> to free resources
              allocated by the DRM core for the frame buffer object, and must
              make sure to unreference all memory objects associated with the
              frame buffer. Handles created by the
              <methodname>create_handle</methodname> operation are released by
              the DRM core.
            </para>
          </listitem>
          <listitem>
            <synopsis>int (*dirty)(struct drm_framebuffer *framebuffer,
	     struct drm_file *file_priv, unsigned flags, unsigned color,
	     struct drm_clip_rect *clips, unsigned num_clips);</synopsis>
            <para>
              This optional operation notifies the driver that a region of the
              frame buffer has changed in response to a DRM_IOCTL_MODE_DIRTYFB
              ioctl call.
            </para>
          </listitem>
        </itemizedlist>
      </para>
      <para>
	The lifetime of a drm framebuffer is controlled with a reference count,
	drivers can grab additional references with
	<function>drm_framebuffer_reference</function>and drop them
	again with <function>drm_framebuffer_unreference</function>. For
	driver-private framebuffers for which the last reference is never
	dropped (e.g. for the fbdev framebuffer when the struct
	<structname>drm_framebuffer</structname> is embedded into the fbdev
	helper struct) drivers can manually clean up a framebuffer at module
	unload time with
	<function>drm_framebuffer_unregister_private</function>.
      </para>
    </sect2>
    <sect2>
      <title>Dumb Buffer Objects</title>
      <para>
	The KMS API doesn't standardize backing storage object creation and
	leaves it to driver-specific ioctls. Furthermore actually creating a
	buffer object even for GEM-based drivers is done through a
	driver-specific ioctl - GEM only has a common userspace interface for
	sharing and destroying objects. While not an issue for full-fledged
	graphics stacks that include device-specific userspace components (in
	libdrm for instance), this limit makes DRM-based early boot graphics
	unnecessarily complex.
      </para>
      <para>
        Dumb objects partly alleviate the problem by providing a standard
        API to create dumb buffers suitable for scanout, which can then be used
        to create KMS frame buffers.
      </para>
      <para>
        To support dumb objects drivers must implement the
        <methodname>dumb_create</methodname>,
        <methodname>dumb_destroy</methodname> and
        <methodname>dumb_map_offset</methodname> operations.
      </para>
      <itemizedlist>
        <listitem>
          <synopsis>int (*dumb_create)(struct drm_file *file_priv, struct drm_device *dev,
                   struct drm_mode_create_dumb *args);</synopsis>
          <para>
            The <methodname>dumb_create</methodname> operation creates a driver
	    object (GEM or TTM handle) suitable for scanout based on the
	    width, height and depth from the struct
	    <structname>drm_mode_create_dumb</structname> argument. It fills the
	    argument's <structfield>handle</structfield>,
	    <structfield>pitch</structfield> and <structfield>size</structfield>
	    fields with a handle for the newly created object and its line
            pitch and size in bytes.
          </para>
        </listitem>
        <listitem>
          <synopsis>int (*dumb_destroy)(struct drm_file *file_priv, struct drm_device *dev,
                    uint32_t handle);</synopsis>
          <para>
            The <methodname>dumb_destroy</methodname> operation destroys a dumb
            object created by <methodname>dumb_create</methodname>.
          </para>
        </listitem>
        <listitem>
          <synopsis>int (*dumb_map_offset)(struct drm_file *file_priv, struct drm_device *dev,
                       uint32_t handle, uint64_t *offset);</synopsis>
          <para>
            The <methodname>dumb_map_offset</methodname> operation associates an
            mmap fake offset with the object given by the handle and returns
            it. Drivers must use the
            <function>drm_gem_create_mmap_offset</function> function to
            associate the fake offset as described in
            <xref linkend="drm-gem-objects-mapping"/>.
          </para>
        </listitem>
      </itemizedlist>
      <para>
        Note that dumb objects may not be used for gpu acceleration, as has been
	attempted on some ARM embedded platforms. Such drivers really must have
	a hardware-specific ioctl to allocate suitable buffer objects.
      </para>
    </sect2>
    <sect2>
      <title>Output Polling</title>
      <synopsis>void (*output_poll_changed)(struct drm_device *dev);</synopsis>
      <para>
        This operation notifies the driver that the status of one or more
        connectors has changed. Drivers that use the fb helper can just call the
        <function>drm_fb_helper_hotplug_event</function> function to handle this
        operation.
      </para>
    </sect2>
    <sect2>
      <title>Locking</title>
      <para>
        Beside some lookup structures with their own locking (which is hidden
	behind the interface functions) most of the modeset state is protected
	by the <code>dev-&lt;mode_config.lock</code> mutex and additionally
	per-crtc locks to allow cursor updates, pageflips and similar operations
	to occur concurrently with background tasks like output detection.
	Operations which cross domains like a full modeset always grab all
	locks. Drivers there need to protect resources shared between crtcs with
	additional locking. They also need to be careful to always grab the
	relevant crtc locks if a modset functions touches crtc state, e.g. for
	load detection (which does only grab the <code>mode_config.lock</code>
	to allow concurrent screen updates on live crtcs).
      </para>
    </sect2>
  </sect1>

  <!-- Internals: kms initialization and cleanup -->

  <sect1 id="drm-kms-init">
    <title>KMS Initialization and Cleanup</title>
    <para>
      A KMS device is abstracted and exposed as a set of planes, CRTCs, encoders
      and connectors. KMS drivers must thus create and initialize all those
      objects at load time after initializing mode setting.
    </para>
    <sect2>
      <title>CRTCs (struct <structname>drm_crtc</structname>)</title>
      <para>
        A CRTC is an abstraction representing a part of the chip that contains a
	pointer to a scanout buffer. Therefore, the number of CRTCs available
	determines how many independent scanout buffers can be active at any
	given time. The CRTC structure contains several fields to support this:
	a pointer to some video memory (abstracted as a frame buffer object), a
	display mode, and an (x, y) offset into the video memory to support
	panning or configurations where one piece of video memory spans multiple
	CRTCs.
      </para>
      <sect3>
        <title>CRTC Initialization</title>
        <para>
          A KMS device must create and register at least one struct
          <structname>drm_crtc</structname> instance. The instance is allocated
          and zeroed by the driver, possibly as part of a larger structure, and
          registered with a call to <function>drm_crtc_init</function> with a
          pointer to CRTC functions.
        </para>
      </sect3>
      <sect3 id="drm-kms-crtcops">
        <title>CRTC Operations</title>
        <sect4>
          <title>Set Configuration</title>
          <synopsis>int (*set_config)(struct drm_mode_set *set);</synopsis>
          <para>
            Apply a new CRTC configuration to the device. The configuration
            specifies a CRTC, a frame buffer to scan out from, a (x,y) position in
            the frame buffer, a display mode and an array of connectors to drive
            with the CRTC if possible.
          </para>
          <para>
            If the frame buffer specified in the configuration is NULL, the driver
            must detach all encoders connected to the CRTC and all connectors
            attached to those encoders and disable them.
          </para>
          <para>
            This operation is called with the mode config lock held.
          </para>
          <note><para>
	    Note that the drm core has no notion of restoring the mode setting
	    state after resume, since all resume handling is in the full
	    responsibility of the driver. The common mode setting helper library
	    though provides a helper which can be used for this:
	    <function>drm_helper_resume_force_mode</function>.
          </para></note>
        </sect4>
        <sect4>
          <title>Page Flipping</title>
          <synopsis>int (*page_flip)(struct drm_crtc *crtc, struct drm_framebuffer *fb,
                   struct drm_pending_vblank_event *event);</synopsis>
          <para>
            Schedule a page flip to the given frame buffer for the CRTC. This
            operation is called with the mode config mutex held.
          </para>
          <para>
            Page flipping is a synchronization mechanism that replaces the frame
            buffer being scanned out by the CRTC with a new frame buffer during
            vertical blanking, avoiding tearing. When an application requests a page
            flip the DRM core verifies that the new frame buffer is large enough to
            be scanned out by  the CRTC in the currently configured mode and then
            calls the CRTC <methodname>page_flip</methodname> operation with a
            pointer to the new frame buffer.
          </para>
          <para>
            The <methodname>page_flip</methodname> operation schedules a page flip.
            Once any pending rendering targeting the new frame buffer has
            completed, the CRTC will be reprogrammed to display that frame buffer
            after the next vertical refresh. The operation must return immediately
            without waiting for rendering or page flip to complete and must block
            any new rendering to the frame buffer until the page flip completes.
          </para>
          <para>
            If a page flip can be successfully scheduled the driver must set the
            <code>drm_crtc-&lt;fb</code> field to the new framebuffer pointed to
            by <code>fb</code>. This is important so that the reference counting
            on framebuffers stays balanced.
          </para>
          <para>
            If a page flip is already pending, the
            <methodname>page_flip</methodname> operation must return
            -<errorname>EBUSY</errorname>.
          </para>
          <para>
            To synchronize page flip to vertical blanking the driver will likely
            need to enable vertical blanking interrupts. It should call
            <function>drm_vblank_get</function> for that purpose, and call
            <function>drm_vblank_put</function> after the page flip completes.
          </para>
          <para>
            If the application has requested to be notified when page flip completes
            the <methodname>page_flip</methodname> operation will be called with a
            non-NULL <parameter>event</parameter> argument pointing to a
            <structname>drm_pending_vblank_event</structname> instance. Upon page
            flip completion the driver must call <methodname>drm_send_vblank_event</methodname>
            to fill in the event and send to wake up any waiting processes.
            This can be performed with
            <programlisting><![CDATA[
            spin_lock_irqsave(&dev->event_lock, flags);
            ...
            drm_send_vblank_event(dev, pipe, event);
            spin_unlock_irqrestore(&dev->event_lock, flags);
            ]]></programlisting>
          </para>
          <note><para>
            FIXME: Could drivers that don't need to wait for rendering to complete
            just add the event to <literal>dev-&gt;vblank_event_list</literal> and
            let the DRM core handle everything, as for "normal" vertical blanking
            events?
          </para></note>
          <para>
            While waiting for the page flip to complete, the
            <literal>event-&gt;base.link</literal> list head can be used freely by
            the driver to store the pending event in a driver-specific list.
          </para>
          <para>
            If the file handle is closed before the event is signaled, drivers must
            take care to destroy the event in their
            <methodname>preclose</methodname> operation (and, if needed, call
            <function>drm_vblank_put</function>).
          </para>
        </sect4>
        <sect4>
          <title>Miscellaneous</title>
          <itemizedlist>
            <listitem>
              <synopsis>void (*set_property)(struct drm_crtc *crtc,
                     struct drm_property *property, uint64_t value);</synopsis>
              <para>
                Set the value of the given CRTC property to
                <parameter>value</parameter>. See <xref linkend="drm-kms-properties"/>
                for more information about properties.
              </para>
            </listitem>
            <listitem>
              <synopsis>void (*gamma_set)(struct drm_crtc *crtc, u16 *r, u16 *g, u16 *b,
                        uint32_t start, uint32_t size);</synopsis>
              <para>
                Apply a gamma table to the device. The operation is optional.
              </para>
            </listitem>
            <listitem>
              <synopsis>void (*destroy)(struct drm_crtc *crtc);</synopsis>
              <para>
                Destroy the CRTC when not needed anymore. See
                <xref linkend="drm-kms-init"/>.
              </para>
            </listitem>
          </itemizedlist>
        </sect4>
      </sect3>
    </sect2>
    <sect2>
      <title>Planes (struct <structname>drm_plane</structname>)</title>
      <para>
        A plane represents an image source that can be blended with or overlayed
	on top of a CRTC during the scanout process. Planes are associated with
	a frame buffer to crop a portion of the image memory (source) and
	optionally scale it to a destination size. The result is then blended
	with or overlayed on top of a CRTC.
      </para>
      <para>
      The DRM core recognizes three types of planes:
      <itemizedlist>
        <listitem>
        DRM_PLANE_TYPE_PRIMARY represents a "main" plane for a CRTC.  Primary
        planes are the planes operated upon by by CRTC modesetting and flipping
        operations described in <xref linkend="drm-kms-crtcops"/>.
        </listitem>
        <listitem>
        DRM_PLANE_TYPE_CURSOR represents a "cursor" plane for a CRTC.  Cursor
        planes are the planes operated upon by the DRM_IOCTL_MODE_CURSOR and
        DRM_IOCTL_MODE_CURSOR2 ioctls.
        </listitem>
        <listitem>
        DRM_PLANE_TYPE_OVERLAY represents all non-primary, non-cursor planes.
        Some drivers refer to these types of planes as "sprites" internally.
        </listitem>
      </itemizedlist>
      For compatibility with legacy userspace, only overlay planes are made
      available to userspace by default.  Userspace clients may set the
      DRM_CLIENT_CAP_UNIVERSAL_PLANES client capability bit to indicate that
      they wish to receive a universal plane list containing all plane types.
      </para>
      <sect3>
        <title>Plane Initialization</title>
        <para>
          To create a plane, a KMS drivers allocates and
          zeroes an instances of struct <structname>drm_plane</structname>
          (possibly as part of a larger structure) and registers it with a call
          to <function>drm_universal_plane_init</function>. The function takes a bitmask
          of the CRTCs that can be associated with the plane, a pointer to the
          plane functions, a list of format supported formats, and the type of
          plane (primary, cursor, or overlay) being initialized.
        </para>
        <para>
          Cursor and overlay planes are optional.  All drivers should provide
          one primary plane per CRTC (although this requirement may change in
          the future); drivers that do not wish to provide special handling for
          primary planes may make use of the helper functions described in
          <xref linkend="drm-kms-planehelpers"/> to create and register a
          primary plane with standard capabilities.
        </para>
      </sect3>
      <sect3>
        <title>Plane Operations</title>
        <itemizedlist>
          <listitem>
            <synopsis>int (*update_plane)(struct drm_plane *plane, struct drm_crtc *crtc,
                        struct drm_framebuffer *fb, int crtc_x, int crtc_y,
                        unsigned int crtc_w, unsigned int crtc_h,
                        uint32_t src_x, uint32_t src_y,
                        uint32_t src_w, uint32_t src_h);</synopsis>
            <para>
              Enable and configure the plane to use the given CRTC and frame buffer.
            </para>
            <para>
              The source rectangle in frame buffer memory coordinates is given by
              the <parameter>src_x</parameter>, <parameter>src_y</parameter>,
              <parameter>src_w</parameter> and <parameter>src_h</parameter>
              parameters (as 16.16 fixed point values). Devices that don't support
              subpixel plane coordinates can ignore the fractional part.
            </para>
            <para>
              The destination rectangle in CRTC coordinates is given by the
              <parameter>crtc_x</parameter>, <parameter>crtc_y</parameter>,
              <parameter>crtc_w</parameter> and <parameter>crtc_h</parameter>
              parameters (as integer values). Devices scale the source rectangle to
              the destination rectangle. If scaling is not supported, and the source
              rectangle size doesn't match the destination rectangle size, the
              driver must return a -<errorname>EINVAL</errorname> error.
            </para>
          </listitem>
          <listitem>
            <synopsis>int (*disable_plane)(struct drm_plane *plane);</synopsis>
            <para>
              Disable the plane. The DRM core calls this method in response to a
              DRM_IOCTL_MODE_SETPLANE ioctl call with the frame buffer ID set to 0.
              Disabled planes must not be processed by the CRTC.
            </para>
          </listitem>
          <listitem>
            <synopsis>void (*destroy)(struct drm_plane *plane);</synopsis>
            <para>
              Destroy the plane when not needed anymore. See
              <xref linkend="drm-kms-init"/>.
            </para>
          </listitem>
        </itemizedlist>
      </sect3>
    </sect2>
    <sect2>
      <title>Encoders (struct <structname>drm_encoder</structname>)</title>
      <para>
        An encoder takes pixel data from a CRTC and converts it to a format
	suitable for any attached connectors. On some devices, it may be
	possible to have a CRTC send data to more than one encoder. In that
	case, both encoders would receive data from the same scanout buffer,
	resulting in a "cloned" display configuration across the connectors
	attached to each encoder.
      </para>
      <sect3>
        <title>Encoder Initialization</title>
        <para>
          As for CRTCs, a KMS driver must create, initialize and register at
          least one struct <structname>drm_encoder</structname> instance. The
          instance is allocated and zeroed by the driver, possibly as part of a
          larger structure.
        </para>
        <para>
          Drivers must initialize the struct <structname>drm_encoder</structname>
          <structfield>possible_crtcs</structfield> and
          <structfield>possible_clones</structfield> fields before registering the
          encoder. Both fields are bitmasks of respectively the CRTCs that the
          encoder can be connected to, and sibling encoders candidate for cloning.
        </para>
        <para>
          After being initialized, the encoder must be registered with a call to
          <function>drm_encoder_init</function>. The function takes a pointer to
          the encoder functions and an encoder type. Supported types are
          <itemizedlist>
            <listitem>
              DRM_MODE_ENCODER_DAC for VGA and analog on DVI-I/DVI-A
              </listitem>
            <listitem>
              DRM_MODE_ENCODER_TMDS for DVI, HDMI and (embedded) DisplayPort
            </listitem>
            <listitem>
              DRM_MODE_ENCODER_LVDS for display panels
            </listitem>
            <listitem>
              DRM_MODE_ENCODER_TVDAC for TV output (Composite, S-Video, Component,
              SCART)
            </listitem>
            <listitem>
              DRM_MODE_ENCODER_VIRTUAL for virtual machine displays
            </listitem>
          </itemizedlist>
        </para>
        <para>
          Encoders must be attached to a CRTC to be used. DRM drivers leave
          encoders unattached at initialization time. Applications (or the fbdev
          compatibility layer when implemented) are responsible for attaching the
          encoders they want to use to a CRTC.
        </para>
      </sect3>
      <sect3>
        <title>Encoder Operations</title>
        <itemizedlist>
          <listitem>
            <synopsis>void (*destroy)(struct drm_encoder *encoder);</synopsis>
            <para>
              Called to destroy the encoder when not needed anymore. See
              <xref linkend="drm-kms-init"/>.
            </para>
          </listitem>
          <listitem>
            <synopsis>void (*set_property)(struct drm_plane *plane,
                     struct drm_property *property, uint64_t value);</synopsis>
            <para>
              Set the value of the given plane property to
              <parameter>value</parameter>. See <xref linkend="drm-kms-properties"/>
              for more information about properties.
            </para>
          </listitem>
        </itemizedlist>
      </sect3>
    </sect2>
    <sect2>
      <title>Connectors (struct <structname>drm_connector</structname>)</title>
      <para>
        A connector is the final destination for pixel data on a device, and
	usually connects directly to an external display device like a monitor
	or laptop panel. A connector can only be attached to one encoder at a
	time. The connector is also the structure where information about the
	attached display is kept, so it contains fields for display data, EDID
	data, DPMS &amp; connection status, and information about modes
	supported on the attached displays.
      </para>
      <sect3>
        <title>Connector Initialization</title>
        <para>
          Finally a KMS driver must create, initialize, register and attach at
          least one struct <structname>drm_connector</structname> instance. The
          instance is created as other KMS objects and initialized by setting the
          following fields.
        </para>
        <variablelist>
          <varlistentry>
            <term><structfield>interlace_allowed</structfield></term>
            <listitem><para>
              Whether the connector can handle interlaced modes.
            </para></listitem>
          </varlistentry>
          <varlistentry>
            <term><structfield>doublescan_allowed</structfield></term>
            <listitem><para>
              Whether the connector can handle doublescan.
            </para></listitem>
          </varlistentry>
          <varlistentry>
            <term><structfield>display_info
            </structfield></term>
            <listitem><para>
              Display information is filled from EDID information when a display
              is detected. For non hot-pluggable displays such as flat panels in
              embedded systems, the driver should initialize the
              <structfield>display_info</structfield>.<structfield>width_mm</structfield>
              and
              <structfield>display_info</structfield>.<structfield>height_mm</structfield>
              fields with the physical size of the display.
            </para></listitem>
          </varlistentry>
          <varlistentry>
            <term id="drm-kms-connector-polled"><structfield>polled</structfield></term>
            <listitem><para>
              Connector polling mode, a combination of
              <variablelist>
                <varlistentry>
                  <term>DRM_CONNECTOR_POLL_HPD</term>
                  <listitem><para>
                    The connector generates hotplug events and doesn't need to be
                    periodically polled. The CONNECT and DISCONNECT flags must not
                    be set together with the HPD flag.
                  </para></listitem>
                </varlistentry>
                <varlistentry>
                  <term>DRM_CONNECTOR_POLL_CONNECT</term>
                  <listitem><para>
                    Periodically poll the connector for connection.
                  </para></listitem>
                </varlistentry>
                <varlistentry>
                  <term>DRM_CONNECTOR_POLL_DISCONNECT</term>
                  <listitem><para>
                    Periodically poll the connector for disconnection.
                  </para></listitem>
                </varlistentry>
              </variablelist>
              Set to 0 for connectors that don't support connection status
              discovery.
            </para></listitem>
          </varlistentry>
        </variablelist>
        <para>
          The connector is then registered with a call to
          <function>drm_connector_init</function> with a pointer to the connector
          functions and a connector type, and exposed through sysfs with a call to
          <function>drm_connector_register</function>.
        </para>
        <para>
          Supported connector types are
          <itemizedlist>
            <listitem>DRM_MODE_CONNECTOR_VGA</listitem>
            <listitem>DRM_MODE_CONNECTOR_DVII</listitem>
            <listitem>DRM_MODE_CONNECTOR_DVID</listitem>
            <listitem>DRM_MODE_CONNECTOR_DVIA</listitem>
            <listitem>DRM_MODE_CONNECTOR_Composite</listitem>
            <listitem>DRM_MODE_CONNECTOR_SVIDEO</listitem>
            <listitem>DRM_MODE_CONNECTOR_LVDS</listitem>
            <listitem>DRM_MODE_CONNECTOR_Component</listitem>
            <listitem>DRM_MODE_CONNECTOR_9PinDIN</listitem>
            <listitem>DRM_MODE_CONNECTOR_DisplayPort</listitem>
            <listitem>DRM_MODE_CONNECTOR_HDMIA</listitem>
            <listitem>DRM_MODE_CONNECTOR_HDMIB</listitem>
            <listitem>DRM_MODE_CONNECTOR_TV</listitem>
            <listitem>DRM_MODE_CONNECTOR_eDP</listitem>
            <listitem>DRM_MODE_CONNECTOR_VIRTUAL</listitem>
          </itemizedlist>
        </para>
        <para>
          Connectors must be attached to an encoder to be used. For devices that
          map connectors to encoders 1:1, the connector should be attached at
          initialization time with a call to
          <function>drm_mode_connector_attach_encoder</function>. The driver must
          also set the <structname>drm_connector</structname>
          <structfield>encoder</structfield> field to point to the attached
          encoder.
        </para>
        <para>
          Finally, drivers must initialize the connectors state change detection
          with a call to <function>drm_kms_helper_poll_init</function>. If at
          least one connector is pollable but can't generate hotplug interrupts
          (indicated by the DRM_CONNECTOR_POLL_CONNECT and
          DRM_CONNECTOR_POLL_DISCONNECT connector flags), a delayed work will
          automatically be queued to periodically poll for changes. Connectors
          that can generate hotplug interrupts must be marked with the
          DRM_CONNECTOR_POLL_HPD flag instead, and their interrupt handler must
          call <function>drm_helper_hpd_irq_event</function>. The function will
          queue a delayed work to check the state of all connectors, but no
          periodic polling will be done.
        </para>
      </sect3>
      <sect3>
        <title>Connector Operations</title>
        <note><para>
          Unless otherwise state, all operations are mandatory.
        </para></note>
        <sect4>
          <title>DPMS</title>
          <synopsis>void (*dpms)(struct drm_connector *connector, int mode);</synopsis>
          <para>
            The DPMS operation sets the power state of a connector. The mode
            argument is one of
            <itemizedlist>
              <listitem><para>DRM_MODE_DPMS_ON</para></listitem>
              <listitem><para>DRM_MODE_DPMS_STANDBY</para></listitem>
              <listitem><para>DRM_MODE_DPMS_SUSPEND</para></listitem>
              <listitem><para>DRM_MODE_DPMS_OFF</para></listitem>
            </itemizedlist>
          </para>
          <para>
            In all but DPMS_ON mode the encoder to which the connector is attached
            should put the display in low-power mode by driving its signals
            appropriately. If more than one connector is attached to the encoder
            care should be taken not to change the power state of other displays as
            a side effect. Low-power mode should be propagated to the encoders and
            CRTCs when all related connectors are put in low-power mode.
          </para>
        </sect4>
        <sect4>
          <title>Modes</title>
          <synopsis>int (*fill_modes)(struct drm_connector *connector, uint32_t max_width,
                      uint32_t max_height);</synopsis>
          <para>
            Fill the mode list with all supported modes for the connector. If the
            <parameter>max_width</parameter> and <parameter>max_height</parameter>
            arguments are non-zero, the implementation must ignore all modes wider
            than <parameter>max_width</parameter> or higher than
            <parameter>max_height</parameter>.
          </para>
          <para>
            The connector must also fill in this operation its
            <structfield>display_info</structfield>
            <structfield>width_mm</structfield> and
            <structfield>height_mm</structfield> fields with the connected display
            physical size in millimeters. The fields should be set to 0 if the value
            isn't known or is not applicable (for instance for projector devices).
          </para>
        </sect4>
        <sect4>
          <title>Connection Status</title>
          <para>
            The connection status is updated through polling or hotplug events when
            supported (see <xref linkend="drm-kms-connector-polled"/>). The status
            value is reported to userspace through ioctls and must not be used
            inside the driver, as it only gets initialized by a call to
            <function>drm_mode_getconnector</function> from userspace.
          </para>
          <synopsis>enum drm_connector_status (*detect)(struct drm_connector *connector,
                                        bool force);</synopsis>
          <para>
            Check to see if anything is attached to the connector. The
            <parameter>force</parameter> parameter is set to false whilst polling or
            to true when checking the connector due to user request.
            <parameter>force</parameter> can be used by the driver to avoid
            expensive, destructive operations during automated probing.
          </para>
          <para>
            Return connector_status_connected if something is connected to the
            connector, connector_status_disconnected if nothing is connected and
            connector_status_unknown if the connection state isn't known.
          </para>
          <para>
            Drivers should only return connector_status_connected if the connection
            status has really been probed as connected. Connectors that can't detect
            the connection status, or failed connection status probes, should return
            connector_status_unknown.
          </para>
        </sect4>
        <sect4>
          <title>Miscellaneous</title>
          <itemizedlist>
            <listitem>
              <synopsis>void (*set_property)(struct drm_connector *connector,
                     struct drm_property *property, uint64_t value);</synopsis>
              <para>
                Set the value of the given connector property to
                <parameter>value</parameter>. See <xref linkend="drm-kms-properties"/>
                for more information about properties.
              </para>
            </listitem>
            <listitem>
              <synopsis>void (*destroy)(struct drm_connector *connector);</synopsis>
              <para>
                Destroy the connector when not needed anymore. See
                <xref linkend="drm-kms-init"/>.
              </para>
            </listitem>
          </itemizedlist>
        </sect4>
      </sect3>
    </sect2>
    <sect2>
      <title>Cleanup</title>
      <para>
        The DRM core manages its objects' lifetime. When an object is not needed
	anymore the core calls its destroy function, which must clean up and
	free every resource allocated for the object. Every
	<function>drm_*_init</function> call must be matched with a
	corresponding <function>drm_*_cleanup</function> call to cleanup CRTCs
	(<function>drm_crtc_cleanup</function>), planes
	(<function>drm_plane_cleanup</function>), encoders
	(<function>drm_encoder_cleanup</function>) and connectors
	(<function>drm_connector_cleanup</function>). Furthermore, connectors
	that have been added to sysfs must be removed by a call to
	<function>drm_connector_unregister</function> before calling
	<function>drm_connector_cleanup</function>.
      </para>
      <para>
        Connectors state change detection must be cleanup up with a call to
	<function>drm_kms_helper_poll_fini</function>.
      </para>
    </sect2>
    <sect2>
      <title>Output discovery and initialization example</title>
      <programlisting><![CDATA[
void intel_crt_init(struct drm_device *dev)
{
	struct drm_connector *connector;
	struct intel_output *intel_output;

	intel_output = kzalloc(sizeof(struct intel_output), GFP_KERNEL);
	if (!intel_output)
		return;

	connector = &intel_output->base;
	drm_connector_init(dev, &intel_output->base,
			   &intel_crt_connector_funcs, DRM_MODE_CONNECTOR_VGA);

	drm_encoder_init(dev, &intel_output->enc, &intel_crt_enc_funcs,
			 DRM_MODE_ENCODER_DAC);

	drm_mode_connector_attach_encoder(&intel_output->base,
					  &intel_output->enc);

	/* Set up the DDC bus. */
	intel_output->ddc_bus = intel_i2c_create(dev, GPIOA, "CRTDDC_A");
	if (!intel_output->ddc_bus) {
		dev_printk(KERN_ERR, &dev->pdev->dev, "DDC bus registration "
			   "failed.\n");
		return;
	}

	intel_output->type = INTEL_OUTPUT_ANALOG;
	connector->interlace_allowed = 0;
	connector->doublescan_allowed = 0;

	drm_encoder_helper_add(&intel_output->enc, &intel_crt_helper_funcs);
	drm_connector_helper_add(connector, &intel_crt_connector_helper_funcs);

	drm_connector_register(connector);
}]]></programlisting>
      <para>
        In the example above (taken from the i915 driver), a CRTC, connector and
        encoder combination is created. A device-specific i2c bus is also
        created for fetching EDID data and performing monitor detection. Once
        the process is complete, the new connector is registered with sysfs to
        make its properties available to applications.
      </para>
    </sect2>
    <sect2>
      <title>KMS API Functions</title>
<!-- drivers/gpu/drm/drm_crtc.c -->
<refentry id="API-drm-get-connector-status-name">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_get_connector_status_name</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_get_connector_status_name</refname>
 <refpurpose>
  return a string for connector status
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>const char * <function>drm_get_connector_status_name </function></funcdef>
   <paramdef>enum drm_connector_status <parameter>status</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>status</parameter></term>
   <listitem>
    <para>
     connector status to compute name of
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   In contrast to the other drm_get_*_name functions this one here returns a
   const pointer and hence is threadsafe.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-get-subpixel-order-name">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_get_subpixel_order_name</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_get_subpixel_order_name</refname>
 <refpurpose>
     return a string for a given subpixel enum
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>const char * <function>drm_get_subpixel_order_name </function></funcdef>
   <paramdef>enum subpixel_order <parameter>order</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>order</parameter></term>
   <listitem>
    <para>
     enum of subpixel_order
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Note you could abuse this and return something out of bounds, but that
   would be a caller error.  No unscrubbed user data should make it here.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-get-format-name">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_get_format_name</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_get_format_name</refname>
 <refpurpose>
     return a string for drm fourcc format
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>const char * <function>drm_get_format_name </function></funcdef>
   <paramdef>uint32_t <parameter>format</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>format</parameter></term>
   <listitem>
    <para>
     format to compute name of
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Note that the buffer used by this function is globally shared and owned by
   the function itself.
</para>
</refsect1>
<refsect1>
<title>FIXME</title>
<para>
   This isn't really multithreading safe.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-mode-object-find">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_mode_object_find</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_mode_object_find</refname>
 <refpurpose>
     look up a drm object with static lifetime
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct drm_mode_object * <function>drm_mode_object_find </function></funcdef>
   <paramdef>struct drm_device * <parameter>dev</parameter></paramdef>
   <paramdef>uint32_t <parameter>id</parameter></paramdef>
   <paramdef>uint32_t <parameter>type</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     drm device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>id</parameter></term>
   <listitem>
    <para>
     id of the mode object
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>type</parameter></term>
   <listitem>
    <para>
     type of the mode object
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Note that framebuffers cannot be looked up with this functions - since those
   are reference counted, they need special treatment.  Even with
   DRM_MODE_OBJECT_ANY (although that will simply return NULL
   rather than <function>WARN_ON</function>).
</para>
</refsect1>
</refentry>

<refentry id="API-drm-framebuffer-init">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_framebuffer_init</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_framebuffer_init</refname>
 <refpurpose>
     initialize a framebuffer
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>drm_framebuffer_init </function></funcdef>
   <paramdef>struct drm_device * <parameter>dev</parameter></paramdef>
   <paramdef>struct drm_framebuffer * <parameter>fb</parameter></paramdef>
   <paramdef>const struct drm_framebuffer_funcs * <parameter>funcs</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     DRM device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>fb</parameter></term>
   <listitem>
    <para>
     framebuffer to be initialized
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>funcs</parameter></term>
   <listitem>
    <para>
     ... with these functions
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Allocates an ID for the framebuffer's parent mode object, sets its mode
   functions &amp; device file and adds it to the master fd list.
</para>
</refsect1>
<refsect1>
<title>IMPORTANT</title>
<para>
   This functions publishes the fb and makes it available for concurrent access
   by other users. Which means by this point the fb _must_ be fully set up -
   since all the fb attributes are invariant over its lifetime, no further
   locking but only correct reference counting is required.
</para>
</refsect1>
<refsect1>
<title>Returns</title>
<para>
   Zero on success, error code on failure.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-framebuffer-lookup">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_framebuffer_lookup</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_framebuffer_lookup</refname>
 <refpurpose>
     look up a drm framebuffer and grab a reference
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct drm_framebuffer * <function>drm_framebuffer_lookup </function></funcdef>
   <paramdef>struct drm_device * <parameter>dev</parameter></paramdef>
   <paramdef>uint32_t <parameter>id</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     drm device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>id</parameter></term>
   <listitem>
    <para>
     id of the fb object
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   If successful, this grabs an additional reference to the framebuffer -
   callers need to make sure to eventually unreference the returned framebuffer
   again, using <parameter>drm_framebuffer_unreference</parameter>.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-framebuffer-unreference">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_framebuffer_unreference</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_framebuffer_unreference</refname>
 <refpurpose>
     unref a framebuffer
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>drm_framebuffer_unreference </function></funcdef>
   <paramdef>struct drm_framebuffer * <parameter>fb</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>fb</parameter></term>
   <listitem>
    <para>
     framebuffer to unref
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This functions decrements the fb's refcount and frees it if it drops to zero.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-framebuffer-reference">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_framebuffer_reference</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_framebuffer_reference</refname>
 <refpurpose>
     incr the fb refcnt
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>drm_framebuffer_reference </function></funcdef>
   <paramdef>struct drm_framebuffer * <parameter>fb</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>fb</parameter></term>
   <listitem>
    <para>
     framebuffer
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This functions increments the fb's refcount.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-framebuffer-unregister-private">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_framebuffer_unregister_private</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_framebuffer_unregister_private</refname>
 <refpurpose>
     unregister a private fb from the lookup idr
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>drm_framebuffer_unregister_private </function></funcdef>
   <paramdef>struct drm_framebuffer * <parameter>fb</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>fb</parameter></term>
   <listitem>
    <para>
     fb to unregister
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Drivers need to call this when cleaning up driver-private framebuffers, e.g.
   those used for fbdev. Note that the caller must hold a reference of it's own,
   i.e. the object may not be destroyed through this call (since it'll lead to a
   locking inversion).
</para>
</refsect1>
</refentry>

<refentry id="API-drm-framebuffer-cleanup">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_framebuffer_cleanup</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_framebuffer_cleanup</refname>
 <refpurpose>
     remove a framebuffer object
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>drm_framebuffer_cleanup </function></funcdef>
   <paramdef>struct drm_framebuffer * <parameter>fb</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>fb</parameter></term>
   <listitem>
    <para>
     framebuffer to remove
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Cleanup framebuffer. This function is intended to be used from the drivers
   -&gt;destroy callback. It can also be used to clean up driver private
   framebuffers embedded into a larger structure.
   </para><para>

   Note that this function does not remove the fb from active usuage - if it is
   still used anywhere, hilarity can ensue since userspace could call getfb on
   the id and get back -EINVAL. Obviously no concern at driver unload time.
   </para><para>

   Also, the framebuffer will not be removed from the lookup idr - for
   user-created framebuffers this will happen in in the rmfb ioctl. For
   driver-private objects (e.g. for fbdev) drivers need to explicitly call
   drm_framebuffer_unregister_private.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-framebuffer-remove">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_framebuffer_remove</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_framebuffer_remove</refname>
 <refpurpose>
     remove and unreference a framebuffer object
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>drm_framebuffer_remove </function></funcdef>
   <paramdef>struct drm_framebuffer * <parameter>fb</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>fb</parameter></term>
   <listitem>
    <para>
     framebuffer to remove
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Scans all the CRTCs and planes in <parameter>dev</parameter>'s mode_config.  If they're
   using <parameter>fb</parameter>, removes it, setting it to NULL. Then drops the reference to the
   passed-in framebuffer. Might take the modeset locks.
   </para><para>

   Note that this function optimizes the cleanup away if the caller holds the
   last reference to the framebuffer. It is also guaranteed to not take the
   modeset locks in this case.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-crtc-init-with-planes">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_crtc_init_with_planes</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_crtc_init_with_planes</refname>
 <refpurpose>
     Initialise a new CRTC object with specified primary and cursor planes.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>drm_crtc_init_with_planes </function></funcdef>
   <paramdef>struct drm_device * <parameter>dev</parameter></paramdef>
   <paramdef>struct drm_crtc * <parameter>crtc</parameter></paramdef>
   <paramdef>struct drm_plane * <parameter>primary</parameter></paramdef>
   <paramdef>struct drm_plane * <parameter>cursor</parameter></paramdef>
   <paramdef>const struct drm_crtc_funcs * <parameter>funcs</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     DRM device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>crtc</parameter></term>
   <listitem>
    <para>
     CRTC object to init
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>primary</parameter></term>
   <listitem>
    <para>
     Primary plane for CRTC
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>cursor</parameter></term>
   <listitem>
    <para>
     Cursor plane for CRTC
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>funcs</parameter></term>
   <listitem>
    <para>
     callbacks for the new CRTC
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Inits a new object created as base part of a driver crtc object.
</para>
</refsect1>
<refsect1>
<title>Returns</title>
<para>
   Zero on success, error code on failure.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-crtc-cleanup">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_crtc_cleanup</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_crtc_cleanup</refname>
 <refpurpose>
     Clean up the core crtc usage
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>drm_crtc_cleanup </function></funcdef>
   <paramdef>struct drm_crtc * <parameter>crtc</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>crtc</parameter></term>
   <listitem>
    <para>
     CRTC to cleanup
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This function cleans up <parameter>crtc</parameter> and removes it from the DRM mode setting
   core. Note that the function does *not* free the crtc structure itself,
   this is the responsibility of the caller.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-crtc-index">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_crtc_index</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_crtc_index</refname>
 <refpurpose>
     find the index of a registered CRTC
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>unsigned int <function>drm_crtc_index </function></funcdef>
   <paramdef>struct drm_crtc * <parameter>crtc</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>crtc</parameter></term>
   <listitem>
    <para>
     CRTC to find index for
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Given a registered CRTC, return the index of that CRTC within a DRM
   device's list of CRTCs.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-connector-init">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_connector_init</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_connector_init</refname>
 <refpurpose>
     Init a preallocated connector
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>drm_connector_init </function></funcdef>
   <paramdef>struct drm_device * <parameter>dev</parameter></paramdef>
   <paramdef>struct drm_connector * <parameter>connector</parameter></paramdef>
   <paramdef>const struct drm_connector_funcs * <parameter>funcs</parameter></paramdef>
   <paramdef>int <parameter>connector_type</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     DRM device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>connector</parameter></term>
   <listitem>
    <para>
     the connector to init
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>funcs</parameter></term>
   <listitem>
    <para>
     callbacks for this connector
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>connector_type</parameter></term>
   <listitem>
    <para>
     user visible type of the connector
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Initialises a preallocated connector. Connectors should be
   subclassed as part of driver connector objects.
</para>
</refsect1>
<refsect1>
<title>Returns</title>
<para>
   Zero on success, error code on failure.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-connector-cleanup">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_connector_cleanup</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_connector_cleanup</refname>
 <refpurpose>
     cleans up an initialised connector
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>drm_connector_cleanup </function></funcdef>
   <paramdef>struct drm_connector * <parameter>connector</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>connector</parameter></term>
   <listitem>
    <para>
     connector to cleanup
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Cleans up the connector but doesn't free the object.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-connector-index">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_connector_index</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_connector_index</refname>
 <refpurpose>
     find the index of a registered connector
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>unsigned int <function>drm_connector_index </function></funcdef>
   <paramdef>struct drm_connector * <parameter>connector</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>connector</parameter></term>
   <listitem>
    <para>
     connector to find index for
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Given a registered connector, return the index of that connector within a DRM
   device's list of connectors.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-connector-register">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_connector_register</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_connector_register</refname>
 <refpurpose>
     register a connector
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>drm_connector_register </function></funcdef>
   <paramdef>struct drm_connector * <parameter>connector</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>connector</parameter></term>
   <listitem>
    <para>
     the connector to register
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Register userspace interfaces for a connector
</para>
</refsect1>
<refsect1>
<title>Returns</title>
<para>
   Zero on success, error code on failure.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-connector-unregister">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_connector_unregister</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_connector_unregister</refname>
 <refpurpose>
     unregister a connector
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>drm_connector_unregister </function></funcdef>
   <paramdef>struct drm_connector * <parameter>connector</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>connector</parameter></term>
   <listitem>
    <para>
     the connector to unregister
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Unregister userspace interfaces for a connector
</para>
</refsect1>
</refentry>

<refentry id="API-drm-connector-unplug-all">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_connector_unplug_all</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_connector_unplug_all</refname>
 <refpurpose>
     unregister connector userspace interfaces
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>drm_connector_unplug_all </function></funcdef>
   <paramdef>struct drm_device * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     drm device
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This function unregisters all connector userspace interfaces in sysfs. Should
   be call when the device is disconnected, e.g. from an usb driver's
   -&gt;disconnect callback.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-bridge-init">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_bridge_init</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_bridge_init</refname>
 <refpurpose>
     initialize a drm transcoder/bridge
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>drm_bridge_init </function></funcdef>
   <paramdef>struct drm_device * <parameter>dev</parameter></paramdef>
   <paramdef>struct drm_bridge * <parameter>bridge</parameter></paramdef>
   <paramdef>const struct drm_bridge_funcs * <parameter>funcs</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     drm device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>bridge</parameter></term>
   <listitem>
    <para>
     transcoder/bridge to set up
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>funcs</parameter></term>
   <listitem>
    <para>
     bridge function table
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Initialises a preallocated bridge. Bridges should be
   subclassed as part of driver connector objects.
</para>
</refsect1>
<refsect1>
<title>Returns</title>
<para>
   Zero on success, error code on failure.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-bridge-cleanup">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_bridge_cleanup</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_bridge_cleanup</refname>
 <refpurpose>
     cleans up an initialised bridge
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>drm_bridge_cleanup </function></funcdef>
   <paramdef>struct drm_bridge * <parameter>bridge</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>bridge</parameter></term>
   <listitem>
    <para>
     bridge to cleanup
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Cleans up the bridge but doesn't free the object.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-encoder-init">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_encoder_init</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_encoder_init</refname>
 <refpurpose>
     Init a preallocated encoder
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>drm_encoder_init </function></funcdef>
   <paramdef>struct drm_device * <parameter>dev</parameter></paramdef>
   <paramdef>struct drm_encoder * <parameter>encoder</parameter></paramdef>
   <paramdef>const struct drm_encoder_funcs * <parameter>funcs</parameter></paramdef>
   <paramdef>int <parameter>encoder_type</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     drm device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>encoder</parameter></term>
   <listitem>
    <para>
     the encoder to init
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>funcs</parameter></term>
   <listitem>
    <para>
     callbacks for this encoder
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>encoder_type</parameter></term>
   <listitem>
    <para>
     user visible type of the encoder
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Initialises a preallocated encoder. Encoder should be
   subclassed as part of driver encoder objects.
</para>
</refsect1>
<refsect1>
<title>Returns</title>
<para>
   Zero on success, error code on failure.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-encoder-cleanup">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_encoder_cleanup</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_encoder_cleanup</refname>
 <refpurpose>
     cleans up an initialised encoder
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>drm_encoder_cleanup </function></funcdef>
   <paramdef>struct drm_encoder * <parameter>encoder</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>encoder</parameter></term>
   <listitem>
    <para>
     encoder to cleanup
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Cleans up the encoder but doesn't free the object.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-universal-plane-init">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_universal_plane_init</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_universal_plane_init</refname>
 <refpurpose>
     Initialize a new universal plane object
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>drm_universal_plane_init </function></funcdef>
   <paramdef>struct drm_device * <parameter>dev</parameter></paramdef>
   <paramdef>struct drm_plane * <parameter>plane</parameter></paramdef>
   <paramdef>unsigned long <parameter>possible_crtcs</parameter></paramdef>
   <paramdef>const struct drm_plane_funcs * <parameter>funcs</parameter></paramdef>
   <paramdef>const uint32_t * <parameter>formats</parameter></paramdef>
   <paramdef>uint32_t <parameter>format_count</parameter></paramdef>
   <paramdef>enum drm_plane_type <parameter>type</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     DRM device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>plane</parameter></term>
   <listitem>
    <para>
     plane object to init
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>possible_crtcs</parameter></term>
   <listitem>
    <para>
     bitmask of possible CRTCs
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>funcs</parameter></term>
   <listitem>
    <para>
     callbacks for the new plane
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>formats</parameter></term>
   <listitem>
    <para>
     array of supported formats (<constant>DRM_FORMAT_</constant>*)
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>format_count</parameter></term>
   <listitem>
    <para>
     number of elements in <parameter>formats</parameter>
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>type</parameter></term>
   <listitem>
    <para>
     type of plane (overlay, primary, cursor)
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Initializes a plane object of type <parameter>type</parameter>.
</para>
</refsect1>
<refsect1>
<title>Returns</title>
<para>
   Zero on success, error code on failure.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-plane-init">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_plane_init</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_plane_init</refname>
 <refpurpose>
     Initialize a legacy plane
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>drm_plane_init </function></funcdef>
   <paramdef>struct drm_device * <parameter>dev</parameter></paramdef>
   <paramdef>struct drm_plane * <parameter>plane</parameter></paramdef>
   <paramdef>unsigned long <parameter>possible_crtcs</parameter></paramdef>
   <paramdef>const struct drm_plane_funcs * <parameter>funcs</parameter></paramdef>
   <paramdef>const uint32_t * <parameter>formats</parameter></paramdef>
   <paramdef>uint32_t <parameter>format_count</parameter></paramdef>
   <paramdef>bool <parameter>is_primary</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     DRM device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>plane</parameter></term>
   <listitem>
    <para>
     plane object to init
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>possible_crtcs</parameter></term>
   <listitem>
    <para>
     bitmask of possible CRTCs
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>funcs</parameter></term>
   <listitem>
    <para>
     callbacks for the new plane
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>formats</parameter></term>
   <listitem>
    <para>
     array of supported formats (<constant>DRM_FORMAT_</constant>*)
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>format_count</parameter></term>
   <listitem>
    <para>
     number of elements in <parameter>formats</parameter>
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>is_primary</parameter></term>
   <listitem>
    <para>
     plane type (primary vs overlay)
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Legacy API to initialize a DRM plane.
   </para><para>

   New drivers should call <function>drm_universal_plane_init</function> instead.
</para>
</refsect1>
<refsect1>
<title>Returns</title>
<para>
   Zero on success, error code on failure.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-plane-cleanup">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_plane_cleanup</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_plane_cleanup</refname>
 <refpurpose>
     Clean up the core plane usage
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>drm_plane_cleanup </function></funcdef>
   <paramdef>struct drm_plane * <parameter>plane</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>plane</parameter></term>
   <listitem>
    <para>
     plane to cleanup
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This function cleans up <parameter>plane</parameter> and removes it from the DRM mode setting
   core. Note that the function does *not* free the plane structure itself,
   this is the responsibility of the caller.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-plane-index">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_plane_index</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_plane_index</refname>
 <refpurpose>
     find the index of a registered plane
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>unsigned int <function>drm_plane_index </function></funcdef>
   <paramdef>struct drm_plane * <parameter>plane</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>plane</parameter></term>
   <listitem>
    <para>
     plane to find index for
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Given a registered plane, return the index of that CRTC within a DRM
   device's list of planes.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-plane-force-disable">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_plane_force_disable</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_plane_force_disable</refname>
 <refpurpose>
     Forcibly disable a plane
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>drm_plane_force_disable </function></funcdef>
   <paramdef>struct drm_plane * <parameter>plane</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>plane</parameter></term>
   <listitem>
    <para>
     plane to disable
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Forces the plane to be disabled.
   </para><para>

   Used when the plane's current framebuffer is destroyed,
   and when restoring fbdev mode.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-mode-create-dvi-i-properties">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_mode_create_dvi_i_properties</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_mode_create_dvi_i_properties</refname>
 <refpurpose>
     create DVI-I specific connector properties
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>drm_mode_create_dvi_i_properties </function></funcdef>
   <paramdef>struct drm_device * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     DRM device
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Called by a driver the first time a DVI-I connector is made.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-mode-create-tv-properties">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_mode_create_tv_properties</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_mode_create_tv_properties</refname>
 <refpurpose>
     create TV specific connector properties
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>drm_mode_create_tv_properties </function></funcdef>
   <paramdef>struct drm_device * <parameter>dev</parameter></paramdef>
   <paramdef>int <parameter>num_modes</parameter></paramdef>
   <paramdef>char * <parameter>modes[]</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     DRM device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>num_modes</parameter></term>
   <listitem>
    <para>
     number of different TV formats (modes) supported
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>modes[]</parameter></term>
   <listitem>
    <para>
     array of pointers to strings containing name of each format
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Called by a driver's TV initialization routine, this function creates
   the TV specific connector properties for a given device.  Caller is
   responsible for allocating a list of format names and passing them to
   this routine.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-mode-create-scaling-mode-property">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_mode_create_scaling_mode_property</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_mode_create_scaling_mode_property</refname>
 <refpurpose>
     create scaling mode property
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>drm_mode_create_scaling_mode_property </function></funcdef>
   <paramdef>struct drm_device * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     DRM device
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Called by a driver the first time it's needed, must be attached to desired
   connectors.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-mode-create-aspect-ratio-property">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_mode_create_aspect_ratio_property</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_mode_create_aspect_ratio_property</refname>
 <refpurpose>
     create aspect ratio property
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>drm_mode_create_aspect_ratio_property </function></funcdef>
   <paramdef>struct drm_device * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     DRM device
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Called by a driver the first time it's needed, must be attached to desired
   connectors.
</para>
</refsect1>
<refsect1>
<title>Returns</title>
<para>
   Zero on success, errno on failure.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-mode-create-dirty-info-property">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_mode_create_dirty_info_property</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_mode_create_dirty_info_property</refname>
 <refpurpose>
     create dirty property
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>drm_mode_create_dirty_info_property </function></funcdef>
   <paramdef>struct drm_device * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     DRM device
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Called by a driver the first time it's needed, must be attached to desired
   connectors.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-mode-set-config-internal">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_mode_set_config_internal</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_mode_set_config_internal</refname>
 <refpurpose>
     helper to call -&gt;set_config
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>drm_mode_set_config_internal </function></funcdef>
   <paramdef>struct drm_mode_set * <parameter>set</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>set</parameter></term>
   <listitem>
    <para>
     modeset config to set
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This is a little helper to wrap internal calls to the -&gt;set_config driver
   interface. The only thing it adds is correct refcounting dance.
</para>
</refsect1>
<refsect1>
<title>Returns</title>
<para>
   Zero on success, errno on failure.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-crtc-check-viewport">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_crtc_check_viewport</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_crtc_check_viewport</refname>
 <refpurpose>
     Checks that a framebuffer is big enough for the CRTC viewport
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>drm_crtc_check_viewport </function></funcdef>
   <paramdef>const struct drm_crtc * <parameter>crtc</parameter></paramdef>
   <paramdef>int <parameter>x</parameter></paramdef>
   <paramdef>int <parameter>y</parameter></paramdef>
   <paramdef>const struct drm_display_mode * <parameter>mode</parameter></paramdef>
   <paramdef>const struct drm_framebuffer * <parameter>fb</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>crtc</parameter></term>
   <listitem>
    <para>
     CRTC that framebuffer will be displayed on
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>x</parameter></term>
   <listitem>
    <para>
     x panning
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>y</parameter></term>
   <listitem>
    <para>
     y panning
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>mode</parameter></term>
   <listitem>
    <para>
     mode that framebuffer will be displayed under
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>fb</parameter></term>
   <listitem>
    <para>
     framebuffer to check size of
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-drm-mode-legacy-fb-format">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_mode_legacy_fb_format</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_mode_legacy_fb_format</refname>
 <refpurpose>
     compute drm fourcc code from legacy description
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>uint32_t <function>drm_mode_legacy_fb_format </function></funcdef>
   <paramdef>uint32_t <parameter>bpp</parameter></paramdef>
   <paramdef>uint32_t <parameter>depth</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>bpp</parameter></term>
   <listitem>
    <para>
     bits per pixels
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>depth</parameter></term>
   <listitem>
    <para>
     bit depth per pixel
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Computes a drm fourcc pixel format code for the given <parameter>bpp</parameter>/<parameter>depth</parameter> values.
   Useful in fbdev emulation code, since that deals in those values.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-property-create">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_property_create</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_property_create</refname>
 <refpurpose>
     create a new property type
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct drm_property * <function>drm_property_create </function></funcdef>
   <paramdef>struct drm_device * <parameter>dev</parameter></paramdef>
   <paramdef>int <parameter>flags</parameter></paramdef>
   <paramdef>const char * <parameter>name</parameter></paramdef>
   <paramdef>int <parameter>num_values</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     drm device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>flags</parameter></term>
   <listitem>
    <para>
     flags specifying the property type
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>name</parameter></term>
   <listitem>
    <para>
     name of the property
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>num_values</parameter></term>
   <listitem>
    <para>
     number of pre-defined values
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This creates a new generic drm property which can then be attached to a drm
   object with drm_object_attach_property. The returned property object must be
   freed with drm_property_destroy.
</para>
</refsect1>
<refsect1>
<title>Returns</title>
<para>
   A pointer to the newly created property on success, NULL on failure.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-property-create-enum">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_property_create_enum</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_property_create_enum</refname>
 <refpurpose>
     create a new enumeration property type
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct drm_property * <function>drm_property_create_enum </function></funcdef>
   <paramdef>struct drm_device * <parameter>dev</parameter></paramdef>
   <paramdef>int <parameter>flags</parameter></paramdef>
   <paramdef>const char * <parameter>name</parameter></paramdef>
   <paramdef>const struct drm_prop_enum_list * <parameter>props</parameter></paramdef>
   <paramdef>int <parameter>num_values</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     drm device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>flags</parameter></term>
   <listitem>
    <para>
     flags specifying the property type
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>name</parameter></term>
   <listitem>
    <para>
     name of the property
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>props</parameter></term>
   <listitem>
    <para>
     enumeration lists with property values
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>num_values</parameter></term>
   <listitem>
    <para>
     number of pre-defined values
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This creates a new generic drm property which can then be attached to a drm
   object with drm_object_attach_property. The returned property object must be
   freed with drm_property_destroy.
   </para><para>

   Userspace is only allowed to set one of the predefined values for enumeration
   properties.
</para>
</refsect1>
<refsect1>
<title>Returns</title>
<para>
   A pointer to the newly created property on success, NULL on failure.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-property-create-bitmask">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_property_create_bitmask</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_property_create_bitmask</refname>
 <refpurpose>
     create a new bitmask property type
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct drm_property * <function>drm_property_create_bitmask </function></funcdef>
   <paramdef>struct drm_device * <parameter>dev</parameter></paramdef>
   <paramdef>int <parameter>flags</parameter></paramdef>
   <paramdef>const char * <parameter>name</parameter></paramdef>
   <paramdef>const struct drm_prop_enum_list * <parameter>props</parameter></paramdef>
   <paramdef>int <parameter>num_props</parameter></paramdef>
   <paramdef>uint64_t <parameter>supported_bits</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     drm device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>flags</parameter></term>
   <listitem>
    <para>
     flags specifying the property type
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>name</parameter></term>
   <listitem>
    <para>
     name of the property
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>props</parameter></term>
   <listitem>
    <para>
     enumeration lists with property bitflags
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>num_props</parameter></term>
   <listitem>
    <para>
     size of the <parameter>props</parameter> array
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>supported_bits</parameter></term>
   <listitem>
    <para>
     bitmask of all supported enumeration values
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This creates a new bitmask drm property which can then be attached to a drm
   object with drm_object_attach_property. The returned property object must be
   freed with drm_property_destroy.
   </para><para>

   Compared to plain enumeration properties userspace is allowed to set any
   or'ed together combination of the predefined property bitflag values
</para>
</refsect1>
<refsect1>
<title>Returns</title>
<para>
   A pointer to the newly created property on success, NULL on failure.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-property-create-range">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_property_create_range</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_property_create_range</refname>
 <refpurpose>
     create a new ranged property type
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct drm_property * <function>drm_property_create_range </function></funcdef>
   <paramdef>struct drm_device * <parameter>dev</parameter></paramdef>
   <paramdef>int <parameter>flags</parameter></paramdef>
   <paramdef>const char * <parameter>name</parameter></paramdef>
   <paramdef>uint64_t <parameter>min</parameter></paramdef>
   <paramdef>uint64_t <parameter>max</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     drm device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>flags</parameter></term>
   <listitem>
    <para>
     flags specifying the property type
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>name</parameter></term>
   <listitem>
    <para>
     name of the property
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>min</parameter></term>
   <listitem>
    <para>
     minimum value of the property
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>max</parameter></term>
   <listitem>
    <para>
     maximum value of the property
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This creates a new generic drm property which can then be attached to a drm
   object with drm_object_attach_property. The returned property object must be
   freed with drm_property_destroy.
   </para><para>

   Userspace is allowed to set any interger value in the (min, max) range
   inclusive.
</para>
</refsect1>
<refsect1>
<title>Returns</title>
<para>
   A pointer to the newly created property on success, NULL on failure.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-property-add-enum">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_property_add_enum</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_property_add_enum</refname>
 <refpurpose>
     add a possible value to an enumeration property
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>drm_property_add_enum </function></funcdef>
   <paramdef>struct drm_property * <parameter>property</parameter></paramdef>
   <paramdef>int <parameter>index</parameter></paramdef>
   <paramdef>uint64_t <parameter>value</parameter></paramdef>
   <paramdef>const char * <parameter>name</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>property</parameter></term>
   <listitem>
    <para>
     enumeration property to change
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>index</parameter></term>
   <listitem>
    <para>
     index of the new enumeration
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>value</parameter></term>
   <listitem>
    <para>
     value of the new enumeration
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>name</parameter></term>
   <listitem>
    <para>
     symbolic name of the new enumeration
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This functions adds enumerations to a property.
   </para><para>

   It's use is deprecated, drivers should use one of the more specific helpers
   to directly create the property with all enumerations already attached.
</para>
</refsect1>
<refsect1>
<title>Returns</title>
<para>
   Zero on success, error code on failure.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-property-destroy">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_property_destroy</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_property_destroy</refname>
 <refpurpose>
     destroy a drm property
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>drm_property_destroy </function></funcdef>
   <paramdef>struct drm_device * <parameter>dev</parameter></paramdef>
   <paramdef>struct drm_property * <parameter>property</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     drm device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>property</parameter></term>
   <listitem>
    <para>
     property to destry
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This function frees a property including any attached resources like
   enumeration values.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-object-attach-property">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_object_attach_property</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_object_attach_property</refname>
 <refpurpose>
     attach a property to a modeset object
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>drm_object_attach_property </function></funcdef>
   <paramdef>struct drm_mode_object * <parameter>obj</parameter></paramdef>
   <paramdef>struct drm_property * <parameter>property</parameter></paramdef>
   <paramdef>uint64_t <parameter>init_val</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>obj</parameter></term>
   <listitem>
    <para>
     drm modeset object
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>property</parameter></term>
   <listitem>
    <para>
     property to attach
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>init_val</parameter></term>
   <listitem>
    <para>
     initial value of the property
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This attaches the given property to the modeset object with the given initial
   value. Currently this function cannot fail since the properties are stored in
   a statically sized array.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-object-property-set-value">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_object_property_set_value</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_object_property_set_value</refname>
 <refpurpose>
     set the value of a property
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>drm_object_property_set_value </function></funcdef>
   <paramdef>struct drm_mode_object * <parameter>obj</parameter></paramdef>
   <paramdef>struct drm_property * <parameter>property</parameter></paramdef>
   <paramdef>uint64_t <parameter>val</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>obj</parameter></term>
   <listitem>
    <para>
     drm mode object to set property value for
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>property</parameter></term>
   <listitem>
    <para>
     property to set
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>val</parameter></term>
   <listitem>
    <para>
     value the property should be set to
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This functions sets a given property on a given object. This function only
   changes the software state of the property, it does not call into the
   driver's -&gt;set_property callback.
</para>
</refsect1>
<refsect1>
<title>Returns</title>
<para>
   Zero on success, error code on failure.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-object-property-get-value">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_object_property_get_value</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_object_property_get_value</refname>
 <refpurpose>
     retrieve the value of a property
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>drm_object_property_get_value </function></funcdef>
   <paramdef>struct drm_mode_object * <parameter>obj</parameter></paramdef>
   <paramdef>struct drm_property * <parameter>property</parameter></paramdef>
   <paramdef>uint64_t * <parameter>val</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>obj</parameter></term>
   <listitem>
    <para>
     drm mode object to get property value from
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>property</parameter></term>
   <listitem>
    <para>
     property to retrieve
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>val</parameter></term>
   <listitem>
    <para>
     storage for the property value
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This function retrieves the softare state of the given property for the given
   property. Since there is no driver callback to retrieve the current property
   value this might be out of sync with the hardware, depending upon the driver
   and property.
</para>
</refsect1>
<refsect1>
<title>Returns</title>
<para>
   Zero on success, error code on failure.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-mode-connector-update-edid-property">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_mode_connector_update_edid_property</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_mode_connector_update_edid_property</refname>
 <refpurpose>
     update the edid property of a connector
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>drm_mode_connector_update_edid_property </function></funcdef>
   <paramdef>struct drm_connector * <parameter>connector</parameter></paramdef>
   <paramdef>struct edid * <parameter>edid</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>connector</parameter></term>
   <listitem>
    <para>
     drm connector
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>edid</parameter></term>
   <listitem>
    <para>
     new value of the edid property
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This function creates a new blob modeset object and assigns its id to the
   connector's edid property.
</para>
</refsect1>
<refsect1>
<title>Returns</title>
<para>
   Zero on success, errno on failure.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-mode-plane-set-obj-prop">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_mode_plane_set_obj_prop</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_mode_plane_set_obj_prop</refname>
 <refpurpose>
     set the value of a property
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>drm_mode_plane_set_obj_prop </function></funcdef>
   <paramdef>struct drm_plane * <parameter>plane</parameter></paramdef>
   <paramdef>struct drm_property * <parameter>property</parameter></paramdef>
   <paramdef>uint64_t <parameter>value</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>plane</parameter></term>
   <listitem>
    <para>
     drm plane object to set property value for
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>property</parameter></term>
   <listitem>
    <para>
     property to set
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>value</parameter></term>
   <listitem>
    <para>
     value the property should be set to
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This functions sets a given property on a given plane object. This function
   calls the driver's -&gt;set_property callback and changes the software state of
   the property if the callback succeeds.
</para>
</refsect1>
<refsect1>
<title>Returns</title>
<para>
   Zero on success, error code on failure.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-mode-connector-attach-encoder">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_mode_connector_attach_encoder</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_mode_connector_attach_encoder</refname>
 <refpurpose>
     attach a connector to an encoder
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>drm_mode_connector_attach_encoder </function></funcdef>
   <paramdef>struct drm_connector * <parameter>connector</parameter></paramdef>
   <paramdef>struct drm_encoder * <parameter>encoder</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>connector</parameter></term>
   <listitem>
    <para>
     connector to attach
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>encoder</parameter></term>
   <listitem>
    <para>
     encoder to attach <parameter>connector</parameter> to
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This function links up a connector to an encoder. Note that the routing
   restrictions between encoders and crtcs are exposed to userspace through the
   possible_clones and possible_crtcs bitmasks.
</para>
</refsect1>
<refsect1>
<title>Returns</title>
<para>
   Zero on success, errno on failure.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-mode-crtc-set-gamma-size">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_mode_crtc_set_gamma_size</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_mode_crtc_set_gamma_size</refname>
 <refpurpose>
     set the gamma table size
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>drm_mode_crtc_set_gamma_size </function></funcdef>
   <paramdef>struct drm_crtc * <parameter>crtc</parameter></paramdef>
   <paramdef>int <parameter>gamma_size</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>crtc</parameter></term>
   <listitem>
    <para>
     CRTC to set the gamma table size for
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>gamma_size</parameter></term>
   <listitem>
    <para>
     size of the gamma table
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Drivers which support gamma tables should set this to the supported gamma
   table size when initializing the CRTC. Currently the drm core only supports a
   fixed gamma table size.
</para>
</refsect1>
<refsect1>
<title>Returns</title>
<para>
   Zero on success, errno on failure.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-mode-config-reset">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_mode_config_reset</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_mode_config_reset</refname>
 <refpurpose>
     call -&gt;reset callbacks
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>drm_mode_config_reset </function></funcdef>
   <paramdef>struct drm_device * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     drm device
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This functions calls all the crtc's, encoder's and connector's -&gt;reset
   callback. Drivers can use this in e.g. their driver load or resume code to
   reset hardware and software state.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-fb-get-bpp-depth">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_fb_get_bpp_depth</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_fb_get_bpp_depth</refname>
 <refpurpose>
     get the bpp/depth values for format
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>drm_fb_get_bpp_depth </function></funcdef>
   <paramdef>uint32_t <parameter>format</parameter></paramdef>
   <paramdef>unsigned int * <parameter>depth</parameter></paramdef>
   <paramdef>int * <parameter>bpp</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>format</parameter></term>
   <listitem>
    <para>
     pixel format (DRM_FORMAT_*)
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>depth</parameter></term>
   <listitem>
    <para>
     storage for the depth value
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>bpp</parameter></term>
   <listitem>
    <para>
     storage for the bpp value
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This only supports RGB formats here for compat with code that doesn't use
   pixel formats directly yet.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-format-num-planes">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_format_num_planes</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_format_num_planes</refname>
 <refpurpose>
     get the number of planes for format
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>drm_format_num_planes </function></funcdef>
   <paramdef>uint32_t <parameter>format</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>format</parameter></term>
   <listitem>
    <para>
     pixel format (DRM_FORMAT_*)
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Returns</title>
<para>
   The number of planes used by the specified pixel format.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-format-plane-cpp">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_format_plane_cpp</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_format_plane_cpp</refname>
 <refpurpose>
     determine the bytes per pixel value
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>drm_format_plane_cpp </function></funcdef>
   <paramdef>uint32_t <parameter>format</parameter></paramdef>
   <paramdef>int <parameter>plane</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>format</parameter></term>
   <listitem>
    <para>
     pixel format (DRM_FORMAT_*)
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>plane</parameter></term>
   <listitem>
    <para>
     plane index
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Returns</title>
<para>
   The bytes per pixel value for the specified plane.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-format-horz-chroma-subsampling">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_format_horz_chroma_subsampling</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_format_horz_chroma_subsampling</refname>
 <refpurpose>
     get the horizontal chroma subsampling factor
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>drm_format_horz_chroma_subsampling </function></funcdef>
   <paramdef>uint32_t <parameter>format</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>format</parameter></term>
   <listitem>
    <para>
     pixel format (DRM_FORMAT_*)
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Returns</title>
<para>
   The horizontal chroma subsampling factor for the
   specified pixel format.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-format-vert-chroma-subsampling">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_format_vert_chroma_subsampling</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_format_vert_chroma_subsampling</refname>
 <refpurpose>
     get the vertical chroma subsampling factor
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>drm_format_vert_chroma_subsampling </function></funcdef>
   <paramdef>uint32_t <parameter>format</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>format</parameter></term>
   <listitem>
    <para>
     pixel format (DRM_FORMAT_*)
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Returns</title>
<para>
   The vertical chroma subsampling factor for the
   specified pixel format.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-rotation-simplify">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_rotation_simplify</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_rotation_simplify</refname>
 <refpurpose>
     Try to simplify the rotation
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>unsigned int <function>drm_rotation_simplify </function></funcdef>
   <paramdef>unsigned int <parameter>rotation</parameter></paramdef>
   <paramdef>unsigned int <parameter>supported_rotations</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>rotation</parameter></term>
   <listitem>
    <para>
     Rotation to be simplified
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>supported_rotations</parameter></term>
   <listitem>
    <para>
     Supported rotations
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Attempt to simplify the rotation to a form that is supported.
   Eg. if the hardware supports everything except DRM_REFLECT_X
</para>
</refsect1>
<refsect1>
<title>one could call this function like this</title>
<para>
   </para><para>

   drm_rotation_simplify(rotation, BIT(DRM_ROTATE_0) |
   BIT(DRM_ROTATE_90) | BIT(DRM_ROTATE_180) |
   BIT(DRM_ROTATE_270) | BIT(DRM_REFLECT_Y));
   </para><para>

   to eliminate the DRM_ROTATE_X flag. Depending on what kind of
   transforms the hardware supports, this function may not
   be able to produce a supported transform, so the caller should
   check the result afterwards.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-mode-config-init">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_mode_config_init</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_mode_config_init</refname>
 <refpurpose>
     initialize DRM mode_configuration structure
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>drm_mode_config_init </function></funcdef>
   <paramdef>struct drm_device * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     DRM device
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Initialize <parameter>dev</parameter>'s mode_config structure, used for tracking the graphics
   configuration of <parameter>dev</parameter>.
   </para><para>

   Since this initializes the modeset locks, no locking is possible. Which is no
   problem, since this should happen single threaded at init time. It is the
   driver's problem to ensure this guarantee.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-mode-config-cleanup">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_mode_config_cleanup</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_mode_config_cleanup</refname>
 <refpurpose>
     free up DRM mode_config info
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>drm_mode_config_cleanup </function></funcdef>
   <paramdef>struct drm_device * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     DRM device
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Free up all the connectors and CRTCs associated with this DRM device, then
   free up the framebuffers and associated buffer objects.
   </para><para>

   Note that since this /should/ happen single-threaded at driver/device
   teardown time, no locking is required. It's the driver's job to ensure that
   this guarantee actually holds true.
</para>
</refsect1>
<refsect1>
<title>FIXME</title>
<para>
   cleanup any dangling user buffer objects too
</para>
</refsect1>
</refentry>

    </sect2>
    <sect2>
      <title>KMS Locking</title>
<para>
   </para><para>
   As KMS moves toward more fine grained locking, and atomic ioctl where
   userspace can indirectly control locking order, it becomes necessary
   to use ww_mutex and acquire-contexts to avoid deadlocks.  But because
   the locking is more distributed around the driver code, we want a bit
   of extra utility/tracking out of our acquire-ctx.  This is provided
   by drm_modeset_lock / drm_modeset_acquire_ctx.
   </para><para>
   For basic principles of ww_mutex, see: Documentation/locking/ww-mutex-design.txt
   </para><para>
   The basic usage pattern is to:
   </para><para>
   drm_modeset_acquire_init(<structname>ctx</structname>)
   retry:
   foreach (lock in random_ordered_set_of_locks) {
   ret = drm_modeset_lock(lock, <structname>ctx</structname>)
   if (ret == -EDEADLK) {
   drm_modeset_backoff(<structname>ctx</structname>);
   goto retry;
   }
   }
   </para><para>
   ... do stuff ...
   </para><para>
   drm_modeset_drop_locks(<structname>ctx</structname>);
   drm_modeset_acquire_fini(<structname>ctx</structname>);
</para>

<!-- include/drm/drm_modeset_lock.h -->
<refentry id="API-struct-drm-modeset-acquire-ctx">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct drm_modeset_acquire_ctx</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct drm_modeset_acquire_ctx</refname>
 <refpurpose>
  locking context (see ww_acquire_ctx)
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct drm_modeset_acquire_ctx {
  struct ww_acquire_ctx ww_ctx;
  struct drm_modeset_lock * contended;
  struct list_head locked;
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>ww_ctx</term>
      <listitem><para>
base acquire ctx
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>contended</term>
      <listitem><para>
used internally for -EDEADLK handling
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>locked</term>
      <listitem><para>
list of held locks
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
<refsect1>
<title>Description</title>
<para>
   Each thread competing for a set of locks must use one acquire
   ctx.  And if any lock fxn returns -EDEADLK, it must backoff and
   retry.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-modeset-lock-init">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_modeset_lock_init</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_modeset_lock_init</refname>
 <refpurpose>
     initialize lock
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>drm_modeset_lock_init </function></funcdef>
   <paramdef>struct drm_modeset_lock * <parameter>lock</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>lock</parameter></term>
   <listitem>
    <para>
     lock to init
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-drm-modeset-lock-fini">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_modeset_lock_fini</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_modeset_lock_fini</refname>
 <refpurpose>
     cleanup lock
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>drm_modeset_lock_fini </function></funcdef>
   <paramdef>struct drm_modeset_lock * <parameter>lock</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>lock</parameter></term>
   <listitem>
    <para>
     lock to cleanup
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-drm-modeset-is-locked">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_modeset_is_locked</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_modeset_is_locked</refname>
 <refpurpose>
     equivalent to <function>mutex_is_locked</function>
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>bool <function>drm_modeset_is_locked </function></funcdef>
   <paramdef>struct drm_modeset_lock * <parameter>lock</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>lock</parameter></term>
   <listitem>
    <para>
     lock to check
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<!-- drivers/gpu/drm/drm_modeset_lock.c -->
<refentry id="API---drm-modeset-lock-all">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>__drm_modeset_lock_all</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>__drm_modeset_lock_all</refname>
 <refpurpose>
  internal helper to grab all modeset locks
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>__drm_modeset_lock_all </function></funcdef>
   <paramdef>struct drm_device * <parameter>dev</parameter></paramdef>
   <paramdef>bool <parameter>trylock</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     DRM device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>trylock</parameter></term>
   <listitem>
    <para>
     trylock mode for atomic contexts
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This is a special version of <function>drm_modeset_lock_all</function> which can also be used in
   atomic contexts. Then <parameter>trylock</parameter> must be set to true.
</para>
</refsect1>
<refsect1>
<title>Returns</title>
<para>
   0 on success or negative error code on failure.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-modeset-lock-all">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_modeset_lock_all</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_modeset_lock_all</refname>
 <refpurpose>
     take all modeset locks
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>drm_modeset_lock_all </function></funcdef>
   <paramdef>struct drm_device * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     drm device
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This function takes all modeset locks, suitable where a more fine-grained
   scheme isn't (yet) implemented. Locks must be dropped with
   drm_modeset_unlock_all.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-modeset-unlock-all">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_modeset_unlock_all</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_modeset_unlock_all</refname>
 <refpurpose>
     drop all modeset locks
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>drm_modeset_unlock_all </function></funcdef>
   <paramdef>struct drm_device * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     device
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This function drop all modeset locks taken by drm_modeset_lock_all.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-modeset-lock-crtc">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_modeset_lock_crtc</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_modeset_lock_crtc</refname>
 <refpurpose>
     lock crtc with hidden acquire ctx
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>drm_modeset_lock_crtc </function></funcdef>
   <paramdef>struct drm_crtc * <parameter>crtc</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>crtc</parameter></term>
   <listitem>
    <para>
     drm crtc
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This function locks the given crtc using a hidden acquire context. This is
   necessary so that drivers internally using the atomic interfaces can grab
   further locks with the lock acquire context.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-modeset-legacy-acquire-ctx">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_modeset_legacy_acquire_ctx</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_modeset_legacy_acquire_ctx</refname>
 <refpurpose>
     find acquire ctx for legacy ioctls
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct drm_modeset_acquire_ctx * <function>drm_modeset_legacy_acquire_ctx </function></funcdef>
   <paramdef>struct drm_crtc * <parameter>crtc</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>crtc</parameter></term>
   <listitem>
    <para>
     drm crtc
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Legacy ioctl operations like cursor updates or page flips only have per-crtc
   locking, and store the acquire ctx in the corresponding crtc. All other
   legacy operations take all locks and use a global acquire context. This
   function grabs the right one.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-modeset-unlock-crtc">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_modeset_unlock_crtc</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_modeset_unlock_crtc</refname>
 <refpurpose>
     drop crtc lock
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>drm_modeset_unlock_crtc </function></funcdef>
   <paramdef>struct drm_crtc * <parameter>crtc</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>crtc</parameter></term>
   <listitem>
    <para>
     drm crtc
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This drops the crtc lock acquire with <function>drm_modeset_lock_crtc</function> and all other
   locks acquired through the hidden context.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-warn-on-modeset-not-all-locked">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_warn_on_modeset_not_all_locked</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_warn_on_modeset_not_all_locked</refname>
 <refpurpose>
     check that all modeset locks are locked
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>drm_warn_on_modeset_not_all_locked </function></funcdef>
   <paramdef>struct drm_device * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     device
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Useful as a debug assert.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-modeset-acquire-init">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_modeset_acquire_init</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_modeset_acquire_init</refname>
 <refpurpose>
     initialize acquire context
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>drm_modeset_acquire_init </function></funcdef>
   <paramdef>struct drm_modeset_acquire_ctx * <parameter>ctx</parameter></paramdef>
   <paramdef>uint32_t <parameter>flags</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ctx</parameter></term>
   <listitem>
    <para>
     the acquire context
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>flags</parameter></term>
   <listitem>
    <para>
     for future
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-drm-modeset-acquire-fini">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_modeset_acquire_fini</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_modeset_acquire_fini</refname>
 <refpurpose>
     cleanup acquire context
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>drm_modeset_acquire_fini </function></funcdef>
   <paramdef>struct drm_modeset_acquire_ctx * <parameter>ctx</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ctx</parameter></term>
   <listitem>
    <para>
     the acquire context
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-drm-modeset-drop-locks">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_modeset_drop_locks</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_modeset_drop_locks</refname>
 <refpurpose>
     drop all locks
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>drm_modeset_drop_locks </function></funcdef>
   <paramdef>struct drm_modeset_acquire_ctx * <parameter>ctx</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ctx</parameter></term>
   <listitem>
    <para>
     the acquire context
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Drop all locks currently held against this acquire context.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-modeset-backoff">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_modeset_backoff</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_modeset_backoff</refname>
 <refpurpose>
     deadlock avoidance backoff
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>drm_modeset_backoff </function></funcdef>
   <paramdef>struct drm_modeset_acquire_ctx * <parameter>ctx</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ctx</parameter></term>
   <listitem>
    <para>
     the acquire context
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   If deadlock is detected (ie. <function>drm_modeset_lock</function> returns -EDEADLK),
   you must call this function to drop all currently held locks and
   block until the contended lock becomes available.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-modeset-backoff-interruptible">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_modeset_backoff_interruptible</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_modeset_backoff_interruptible</refname>
 <refpurpose>
     deadlock avoidance backoff
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>drm_modeset_backoff_interruptible </function></funcdef>
   <paramdef>struct drm_modeset_acquire_ctx * <parameter>ctx</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ctx</parameter></term>
   <listitem>
    <para>
     the acquire context
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Interruptible version of <function>drm_modeset_backoff</function>
</para>
</refsect1>
</refentry>

<refentry id="API-drm-modeset-lock">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_modeset_lock</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_modeset_lock</refname>
 <refpurpose>
     take modeset lock
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>drm_modeset_lock </function></funcdef>
   <paramdef>struct drm_modeset_lock * <parameter>lock</parameter></paramdef>
   <paramdef>struct drm_modeset_acquire_ctx * <parameter>ctx</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>lock</parameter></term>
   <listitem>
    <para>
     lock to take
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>ctx</parameter></term>
   <listitem>
    <para>
     acquire ctx
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   If ctx is not NULL, then its ww acquire context is used and the
   lock will be tracked by the context and can be released by calling
   <function>drm_modeset_drop_locks</function>.  If -EDEADLK is returned, this means a
   deadlock scenario has been detected and it is an error to attempt
   to take any more locks without first calling <function>drm_modeset_backoff</function>.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-modeset-lock-interruptible">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_modeset_lock_interruptible</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_modeset_lock_interruptible</refname>
 <refpurpose>
     take modeset lock
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>drm_modeset_lock_interruptible </function></funcdef>
   <paramdef>struct drm_modeset_lock * <parameter>lock</parameter></paramdef>
   <paramdef>struct drm_modeset_acquire_ctx * <parameter>ctx</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>lock</parameter></term>
   <listitem>
    <para>
     lock to take
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>ctx</parameter></term>
   <listitem>
    <para>
     acquire ctx
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Interruptible version of <function>drm_modeset_lock</function>
</para>
</refsect1>
</refentry>

<refentry id="API-drm-modeset-unlock">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_modeset_unlock</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_modeset_unlock</refname>
 <refpurpose>
     drop modeset lock
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>drm_modeset_unlock </function></funcdef>
   <paramdef>struct drm_modeset_lock * <parameter>lock</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>lock</parameter></term>
   <listitem>
    <para>
     lock to release
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

    </sect2>
  </sect1>

  <!-- Internals: kms helper functions -->

  <sect1>
    <title>Mode Setting Helper Functions</title>
    <para>
      The plane, CRTC, encoder and connector functions provided by the drivers
      implement the DRM API. They're called by the DRM core and ioctl handlers
      to handle device state changes and configuration request. As implementing
      those functions often requires logic not specific to drivers, mid-layer
      helper functions are available to avoid duplicating boilerplate code.
    </para>
    <para>
      The DRM core contains one mid-layer implementation. The mid-layer provides
      implementations of several plane, CRTC, encoder and connector functions
      (called from the top of the mid-layer) that pre-process requests and call
      lower-level functions provided by the driver (at the bottom of the
      mid-layer). For instance, the
      <function>drm_crtc_helper_set_config</function> function can be used to
      fill the struct <structname>drm_crtc_funcs</structname>
      <structfield>set_config</structfield> field. When called, it will split
      the <methodname>set_config</methodname> operation in smaller, simpler
      operations and call the driver to handle them.
    </para>
    <para>
      To use the mid-layer, drivers call <function>drm_crtc_helper_add</function>,
      <function>drm_encoder_helper_add</function> and
      <function>drm_connector_helper_add</function> functions to install their
      mid-layer bottom operations handlers, and fill the
      <structname>drm_crtc_funcs</structname>,
      <structname>drm_encoder_funcs</structname> and
      <structname>drm_connector_funcs</structname> structures with pointers to
      the mid-layer top API functions. Installing the mid-layer bottom operation
      handlers is best done right after registering the corresponding KMS object.
    </para>
    <para>
      The mid-layer is not split between CRTC, encoder and connector operations.
      To use it, a driver must provide bottom functions for all of the three KMS
      entities.
    </para>
    <sect2>
      <title>Helper Functions</title>
      <itemizedlist>
        <listitem>
          <synopsis>int drm_crtc_helper_set_config(struct drm_mode_set *set);</synopsis>
          <para>
            The <function>drm_crtc_helper_set_config</function> helper function
            is a CRTC <methodname>set_config</methodname> implementation. It
            first tries to locate the best encoder for each connector by calling
            the connector <methodname>best_encoder</methodname> helper
            operation.
          </para>
          <para>
            After locating the appropriate encoders, the helper function will
            call the <methodname>mode_fixup</methodname> encoder and CRTC helper
            operations to adjust the requested mode, or reject it completely in
            which case an error will be returned to the application. If the new
            configuration after mode adjustment is identical to the current
            configuration the helper function will return without performing any
            other operation.
          </para>
          <para>
            If the adjusted mode is identical to the current mode but changes to
            the frame buffer need to be applied, the
            <function>drm_crtc_helper_set_config</function> function will call
            the CRTC <methodname>mode_set_base</methodname> helper operation. If
            the adjusted mode differs from the current mode, or if the
            <methodname>mode_set_base</methodname> helper operation is not
            provided, the helper function performs a full mode set sequence by
            calling the <methodname>prepare</methodname>,
            <methodname>mode_set</methodname> and
            <methodname>commit</methodname> CRTC and encoder helper operations,
            in that order.
          </para>
        </listitem>
        <listitem>
          <synopsis>void drm_helper_connector_dpms(struct drm_connector *connector, int mode);</synopsis>
          <para>
            The <function>drm_helper_connector_dpms</function> helper function
            is a connector <methodname>dpms</methodname> implementation that
            tracks power state of connectors. To use the function, drivers must
            provide <methodname>dpms</methodname> helper operations for CRTCs
            and encoders to apply the DPMS state to the device.
          </para>
          <para>
            The mid-layer doesn't track the power state of CRTCs and encoders.
            The <methodname>dpms</methodname> helper operations can thus be
            called with a mode identical to the currently active mode.
          </para>
        </listitem>
        <listitem>
          <synopsis>int drm_helper_probe_single_connector_modes(struct drm_connector *connector,
                                            uint32_t maxX, uint32_t maxY);</synopsis>
          <para>
            The <function>drm_helper_probe_single_connector_modes</function> helper
            function is a connector <methodname>fill_modes</methodname>
            implementation that updates the connection status for the connector
            and then retrieves a list of modes by calling the connector
            <methodname>get_modes</methodname> helper operation.
          </para>
          <para>
            The function filters out modes larger than
            <parameter>max_width</parameter> and <parameter>max_height</parameter>
            if specified. It then calls the optional connector
            <methodname>mode_valid</methodname> helper operation for each mode in
            the probed list to check whether the mode is valid for the connector.
          </para>
        </listitem>
      </itemizedlist>
    </sect2>
    <sect2>
      <title>CRTC Helper Operations</title>
      <itemizedlist>
        <listitem id="drm-helper-crtc-mode-fixup">
          <synopsis>bool (*mode_fixup)(struct drm_crtc *crtc,
                       const struct drm_display_mode *mode,
                       struct drm_display_mode *adjusted_mode);</synopsis>
          <para>
            Let CRTCs adjust the requested mode or reject it completely. This
            operation returns true if the mode is accepted (possibly after being
            adjusted) or false if it is rejected.
          </para>
          <para>
            The <methodname>mode_fixup</methodname> operation should reject the
            mode if it can't reasonably use it. The definition of "reasonable"
            is currently fuzzy in this context. One possible behaviour would be
            to set the adjusted mode to the panel timings when a fixed-mode
            panel is used with hardware capable of scaling. Another behaviour
            would be to accept any input mode and adjust it to the closest mode
            supported by the hardware (FIXME: This needs to be clarified).
          </para>
        </listitem>
        <listitem>
          <synopsis>int (*mode_set_base)(struct drm_crtc *crtc, int x, int y,
                     struct drm_framebuffer *old_fb)</synopsis>
          <para>
            Move the CRTC on the current frame buffer (stored in
            <literal>crtc-&gt;fb</literal>) to position (x,y). Any of the frame
            buffer, x position or y position may have been modified.
          </para>
          <para>
            This helper operation is optional. If not provided, the
            <function>drm_crtc_helper_set_config</function> function will fall
            back to the <methodname>mode_set</methodname> helper operation.
          </para>
          <note><para>
            FIXME: Why are x and y passed as arguments, as they can be accessed
            through <literal>crtc-&gt;x</literal> and
            <literal>crtc-&gt;y</literal>?
          </para></note>
        </listitem>
        <listitem>
          <synopsis>void (*prepare)(struct drm_crtc *crtc);</synopsis>
          <para>
            Prepare the CRTC for mode setting. This operation is called after
            validating the requested mode. Drivers use it to perform
            device-specific operations required before setting the new mode.
          </para>
        </listitem>
        <listitem>
          <synopsis>int (*mode_set)(struct drm_crtc *crtc, struct drm_display_mode *mode,
                struct drm_display_mode *adjusted_mode, int x, int y,
                struct drm_framebuffer *old_fb);</synopsis>
          <para>
            Set a new mode, position and frame buffer. Depending on the device
            requirements, the mode can be stored internally by the driver and
            applied in the <methodname>commit</methodname> operation, or
            programmed to the hardware immediately.
          </para>
          <para>
            The <methodname>mode_set</methodname> operation returns 0 on success
	    or a negative error code if an error occurs.
          </para>
        </listitem>
        <listitem>
          <synopsis>void (*commit)(struct drm_crtc *crtc);</synopsis>
          <para>
            Commit a mode. This operation is called after setting the new mode.
            Upon return the device must use the new mode and be fully
            operational.
          </para>
        </listitem>
      </itemizedlist>
    </sect2>
    <sect2>
      <title>Encoder Helper Operations</title>
      <itemizedlist>
        <listitem>
          <synopsis>bool (*mode_fixup)(struct drm_encoder *encoder,
                       const struct drm_display_mode *mode,
                       struct drm_display_mode *adjusted_mode);</synopsis>
          <para>
            Let encoders adjust the requested mode or reject it completely. This
            operation returns true if the mode is accepted (possibly after being
            adjusted) or false if it is rejected. See the
            <link linkend="drm-helper-crtc-mode-fixup">mode_fixup CRTC helper
            operation</link> for an explanation of the allowed adjustments.
          </para>
        </listitem>
        <listitem>
          <synopsis>void (*prepare)(struct drm_encoder *encoder);</synopsis>
          <para>
            Prepare the encoder for mode setting. This operation is called after
            validating the requested mode. Drivers use it to perform
            device-specific operations required before setting the new mode.
          </para>
        </listitem>
        <listitem>
          <synopsis>void (*mode_set)(struct drm_encoder *encoder,
                 struct drm_display_mode *mode,
                 struct drm_display_mode *adjusted_mode);</synopsis>
          <para>
            Set a new mode. Depending on the device requirements, the mode can
            be stored internally by the driver and applied in the
            <methodname>commit</methodname> operation, or programmed to the
            hardware immediately.
          </para>
        </listitem>
        <listitem>
          <synopsis>void (*commit)(struct drm_encoder *encoder);</synopsis>
          <para>
            Commit a mode. This operation is called after setting the new mode.
            Upon return the device must use the new mode and be fully
            operational.
          </para>
        </listitem>
      </itemizedlist>
    </sect2>
    <sect2>
      <title>Connector Helper Operations</title>
      <itemizedlist>
        <listitem>
          <synopsis>struct drm_encoder *(*best_encoder)(struct drm_connector *connector);</synopsis>
          <para>
            Return a pointer to the best encoder for the connecter. Device that
            map connectors to encoders 1:1 simply return the pointer to the
            associated encoder. This operation is mandatory.
          </para>
        </listitem>
        <listitem>
          <synopsis>int (*get_modes)(struct drm_connector *connector);</synopsis>
          <para>
            Fill the connector's <structfield>probed_modes</structfield> list
            by parsing EDID data with <function>drm_add_edid_modes</function> or
            calling <function>drm_mode_probed_add</function> directly for every
            supported mode and return the number of modes it has detected. This
            operation is mandatory.
          </para>
          <para>
            When adding modes manually the driver creates each mode with a call to
            <function>drm_mode_create</function> and must fill the following fields.
            <itemizedlist>
              <listitem>
                <synopsis>__u32 type;</synopsis>
                <para>
                  Mode type bitmask, a combination of
                  <variablelist>
                    <varlistentry>
                      <term>DRM_MODE_TYPE_BUILTIN</term>
                      <listitem><para>not used?</para></listitem>
                    </varlistentry>
                    <varlistentry>
                      <term>DRM_MODE_TYPE_CLOCK_C</term>
                      <listitem><para>not used?</para></listitem>
                    </varlistentry>
                    <varlistentry>
                      <term>DRM_MODE_TYPE_CRTC_C</term>
                      <listitem><para>not used?</para></listitem>
                    </varlistentry>
                    <varlistentry>
                      <term>
        DRM_MODE_TYPE_PREFERRED - The preferred mode for the connector
                      </term>
                      <listitem>
                        <para>not used?</para>
                      </listitem>
                    </varlistentry>
                    <varlistentry>
                      <term>DRM_MODE_TYPE_DEFAULT</term>
                      <listitem><para>not used?</para></listitem>
                    </varlistentry>
                    <varlistentry>
                      <term>DRM_MODE_TYPE_USERDEF</term>
                      <listitem><para>not used?</para></listitem>
                    </varlistentry>
                    <varlistentry>
                      <term>DRM_MODE_TYPE_DRIVER</term>
                      <listitem>
                        <para>
                          The mode has been created by the driver (as opposed to
                          to user-created modes).
                        </para>
                      </listitem>
                    </varlistentry>
                  </variablelist>
                  Drivers must set the DRM_MODE_TYPE_DRIVER bit for all modes they
                  create, and set the DRM_MODE_TYPE_PREFERRED bit for the preferred
                  mode.
                </para>
              </listitem>
              <listitem>
                <synopsis>__u32 clock;</synopsis>
                <para>Pixel clock frequency in kHz unit</para>
              </listitem>
              <listitem>
                <synopsis>__u16 hdisplay, hsync_start, hsync_end, htotal;
    __u16 vdisplay, vsync_start, vsync_end, vtotal;</synopsis>
                <para>Horizontal and vertical timing information</para>
                <screen><![CDATA[
             Active                 Front           Sync           Back
             Region                 Porch                          Porch
    <-----------------------><----------------><-------------><-------------->

      //////////////////////|
     ////////////////////// |
    //////////////////////  |..................               ................
                                               _______________

    <----- [hv]display ----->
    <------------- [hv]sync_start ------------>
    <--------------------- [hv]sync_end --------------------->
    <-------------------------------- [hv]total ----------------------------->
]]></screen>
              </listitem>
              <listitem>
                <synopsis>__u16 hskew;
    __u16 vscan;</synopsis>
                <para>Unknown</para>
              </listitem>
              <listitem>
                <synopsis>__u32 flags;</synopsis>
                <para>
                  Mode flags, a combination of
                  <variablelist>
                    <varlistentry>
                      <term>DRM_MODE_FLAG_PHSYNC</term>
                      <listitem><para>
                        Horizontal sync is active high
                      </para></listitem>
                    </varlistentry>
                    <varlistentry>
                      <term>DRM_MODE_FLAG_NHSYNC</term>
                      <listitem><para>
                        Horizontal sync is active low
                      </para></listitem>
                    </varlistentry>
                    <varlistentry>
                      <term>DRM_MODE_FLAG_PVSYNC</term>
                      <listitem><para>
                        Vertical sync is active high
                      </para></listitem>
                    </varlistentry>
                    <varlistentry>
                      <term>DRM_MODE_FLAG_NVSYNC</term>
                      <listitem><para>
                        Vertical sync is active low
                      </para></listitem>
                    </varlistentry>
                    <varlistentry>
                      <term>DRM_MODE_FLAG_INTERLACE</term>
                      <listitem><para>
                        Mode is interlaced
                      </para></listitem>
                    </varlistentry>
                    <varlistentry>
                      <term>DRM_MODE_FLAG_DBLSCAN</term>
                      <listitem><para>
                        Mode uses doublescan
                      </para></listitem>
                    </varlistentry>
                    <varlistentry>
                      <term>DRM_MODE_FLAG_CSYNC</term>
                      <listitem><para>
                        Mode uses composite sync
                      </para></listitem>
                    </varlistentry>
                    <varlistentry>
                      <term>DRM_MODE_FLAG_PCSYNC</term>
                      <listitem><para>
                        Composite sync is active high
                      </para></listitem>
                    </varlistentry>
                    <varlistentry>
                      <term>DRM_MODE_FLAG_NCSYNC</term>
                      <listitem><para>
                        Composite sync is active low
                      </para></listitem>
                    </varlistentry>
                    <varlistentry>
                      <term>DRM_MODE_FLAG_HSKEW</term>
                      <listitem><para>
                        hskew provided (not used?)
                      </para></listitem>
                    </varlistentry>
                    <varlistentry>
                      <term>DRM_MODE_FLAG_BCAST</term>
                      <listitem><para>
                        not used?
                      </para></listitem>
                    </varlistentry>
                    <varlistentry>
                      <term>DRM_MODE_FLAG_PIXMUX</term>
                      <listitem><para>
                        not used?
                      </para></listitem>
                    </varlistentry>
                    <varlistentry>
                      <term>DRM_MODE_FLAG_DBLCLK</term>
                      <listitem><para>
                        not used?
                      </para></listitem>
                    </varlistentry>
                    <varlistentry>
                      <term>DRM_MODE_FLAG_CLKDIV2</term>
                      <listitem><para>
                        ?
                      </para></listitem>
                    </varlistentry>
                  </variablelist>
                </para>
                <para>
                  Note that modes marked with the INTERLACE or DBLSCAN flags will be
                  filtered out by
                  <function>drm_helper_probe_single_connector_modes</function> if
                  the connector's <structfield>interlace_allowed</structfield> or
                  <structfield>doublescan_allowed</structfield> field is set to 0.
                </para>
              </listitem>
              <listitem>
                <synopsis>char name[DRM_DISPLAY_MODE_LEN];</synopsis>
                <para>
                  Mode name. The driver must call
                  <function>drm_mode_set_name</function> to fill the mode name from
                  <structfield>hdisplay</structfield>,
                  <structfield>vdisplay</structfield> and interlace flag after
                  filling the corresponding fields.
                </para>
              </listitem>
            </itemizedlist>
          </para>
          <para>
            The <structfield>vrefresh</structfield> value is computed by
            <function>drm_helper_probe_single_connector_modes</function>.
          </para>
          <para>
            When parsing EDID data, <function>drm_add_edid_modes</function> fill the
            connector <structfield>display_info</structfield>
            <structfield>width_mm</structfield> and
            <structfield>height_mm</structfield> fields. When creating modes
            manually the <methodname>get_modes</methodname> helper operation must
            set the <structfield>display_info</structfield>
            <structfield>width_mm</structfield> and
            <structfield>height_mm</structfield> fields if they haven't been set
            already (for instance at initialization time when a fixed-size panel is
            attached to the connector). The mode <structfield>width_mm</structfield>
            and <structfield>height_mm</structfield> fields are only used internally
            during EDID parsing and should not be set when creating modes manually.
          </para>
        </listitem>
        <listitem>
          <synopsis>int (*mode_valid)(struct drm_connector *connector,
		  struct drm_display_mode *mode);</synopsis>
          <para>
            Verify whether a mode is valid for the connector. Return MODE_OK for
            supported modes and one of the enum drm_mode_status values (MODE_*)
            for unsupported modes. This operation is optional.
          </para>
          <para>
            As the mode rejection reason is currently not used beside for
            immediately removing the unsupported mode, an implementation can
            return MODE_BAD regardless of the exact reason why the mode is not
            valid.
          </para>
          <note><para>
            Note that the <methodname>mode_valid</methodname> helper operation is
            only called for modes detected by the device, and
            <emphasis>not</emphasis> for modes set by the user through the CRTC
            <methodname>set_config</methodname> operation.
          </para></note>
        </listitem>
      </itemizedlist>
    </sect2>
    <sect2>
      <title>Modeset Helper Functions Reference</title>
<!-- drivers/gpu/drm/drm_crtc_helper.c -->
<refentry id="API-drm-helper-move-panel-connectors-to-head">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_helper_move_panel_connectors_to_head</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_helper_move_panel_connectors_to_head</refname>
 <refpurpose>
  move panels to the front in the connector list
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>drm_helper_move_panel_connectors_to_head </function></funcdef>
   <paramdef>struct drm_device * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     drm device to operate on
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Some userspace presumes that the first connected connector is the main
   display, where it's supposed to display e.g. the login screen. For
   laptops, this should be the main panel. Use this function to sort all
   (eDP/LVDS) panels to the front of the connector list, instead of
   painstakingly trying to initialize them in the right order.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-helper-encoder-in-use">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_helper_encoder_in_use</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_helper_encoder_in_use</refname>
 <refpurpose>
     check if a given encoder is in use
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>bool <function>drm_helper_encoder_in_use </function></funcdef>
   <paramdef>struct drm_encoder * <parameter>encoder</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>encoder</parameter></term>
   <listitem>
    <para>
     encoder to check
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Checks whether <parameter>encoder</parameter> is with the current mode setting output configuration
   in use by any connector. This doesn't mean that it is actually enabled since
   the DPMS state is tracked separately.
</para>
</refsect1>
<refsect1>
<title>Returns</title>
<para>
   True if <parameter>encoder</parameter> is used, false otherwise.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-helper-crtc-in-use">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_helper_crtc_in_use</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_helper_crtc_in_use</refname>
 <refpurpose>
     check if a given CRTC is in a mode_config
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>bool <function>drm_helper_crtc_in_use </function></funcdef>
   <paramdef>struct drm_crtc * <parameter>crtc</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>crtc</parameter></term>
   <listitem>
    <para>
     CRTC to check
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Checks whether <parameter>crtc</parameter> is with the current mode setting output configuration
   in use by any connector. This doesn't mean that it is actually enabled since
   the DPMS state is tracked separately.
</para>
</refsect1>
<refsect1>
<title>Returns</title>
<para>
   True if <parameter>crtc</parameter> is used, false otherwise.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-helper-disable-unused-functions">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_helper_disable_unused_functions</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_helper_disable_unused_functions</refname>
 <refpurpose>
     disable unused objects
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>drm_helper_disable_unused_functions </function></funcdef>
   <paramdef>struct drm_device * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     DRM device
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This function walks through the entire mode setting configuration of <parameter>dev</parameter>. It
   will remove any crtc links of unused encoders and encoder links of
   disconnected connectors. Then it will disable all unused encoders and crtcs
   either by calling their disable callback if available or by calling their
   dpms callback with DRM_MODE_DPMS_OFF.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-crtc-helper-set-mode">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_crtc_helper_set_mode</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_crtc_helper_set_mode</refname>
 <refpurpose>
     internal helper to set a mode
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>bool <function>drm_crtc_helper_set_mode </function></funcdef>
   <paramdef>struct drm_crtc * <parameter>crtc</parameter></paramdef>
   <paramdef>struct drm_display_mode * <parameter>mode</parameter></paramdef>
   <paramdef>int <parameter>x</parameter></paramdef>
   <paramdef>int <parameter>y</parameter></paramdef>
   <paramdef>struct drm_framebuffer * <parameter>old_fb</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>crtc</parameter></term>
   <listitem>
    <para>
     CRTC to program
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>mode</parameter></term>
   <listitem>
    <para>
     mode to use
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>x</parameter></term>
   <listitem>
    <para>
     horizontal offset into the surface
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>y</parameter></term>
   <listitem>
    <para>
     vertical offset into the surface
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>old_fb</parameter></term>
   <listitem>
    <para>
     old framebuffer, for cleanup
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Try to set <parameter>mode</parameter> on <parameter>crtc</parameter>.  Give <parameter>crtc</parameter> and its associated connectors a chance
   to fixup or reject the mode prior to trying to set it. This is an internal
   helper that drivers could e.g. use to update properties that require the
   entire output pipe to be disabled and re-enabled in a new configuration. For
   example for changing whether audio is enabled on a hdmi link or for changing
   panel fitter or dither attributes. It is also called by the
   <function>drm_crtc_helper_set_config</function> helper function to drive the mode setting
   sequence.
</para>
</refsect1>
<refsect1>
<title>Returns</title>
<para>
   True if the mode was set successfully, false otherwise.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-crtc-helper-set-config">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_crtc_helper_set_config</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_crtc_helper_set_config</refname>
 <refpurpose>
     set a new config from userspace
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>drm_crtc_helper_set_config </function></funcdef>
   <paramdef>struct drm_mode_set * <parameter>set</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>set</parameter></term>
   <listitem>
    <para>
     mode set configuration
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Setup a new configuration, provided by the upper layers (either an ioctl call
   from userspace or internally e.g. from the fbdev support code) in <parameter>set</parameter>, and
   enable it. This is the main helper functions for drivers that implement
   kernel mode setting with the crtc helper functions and the assorted
   -&gt;<function>prepare</function>, -&gt;<function>modeset</function> and -&gt;<function>commit</function> helper callbacks.
</para>
</refsect1>
<refsect1>
<title>Returns</title>
<para>
   Returns 0 on success, negative errno numbers on failure.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-helper-connector-dpms">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_helper_connector_dpms</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_helper_connector_dpms</refname>
 <refpurpose>
     connector dpms helper implementation
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>drm_helper_connector_dpms </function></funcdef>
   <paramdef>struct drm_connector * <parameter>connector</parameter></paramdef>
   <paramdef>int <parameter>mode</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>connector</parameter></term>
   <listitem>
    <para>
     affected connector
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>mode</parameter></term>
   <listitem>
    <para>
     DPMS mode
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This is the main helper function provided by the crtc helper framework for
   implementing the DPMS connector attribute. It computes the new desired DPMS
   state for all encoders and crtcs in the output mesh and calls the -&gt;<function>dpms</function>
   callback provided by the driver appropriately.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-helper-mode-fill-fb-struct">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_helper_mode_fill_fb_struct</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_helper_mode_fill_fb_struct</refname>
 <refpurpose>
     fill out framebuffer metadata
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>drm_helper_mode_fill_fb_struct </function></funcdef>
   <paramdef>struct drm_framebuffer * <parameter>fb</parameter></paramdef>
   <paramdef>struct drm_mode_fb_cmd2 * <parameter>mode_cmd</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>fb</parameter></term>
   <listitem>
    <para>
     drm_framebuffer object to fill out
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>mode_cmd</parameter></term>
   <listitem>
    <para>
     metadata from the userspace fb creation request
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This helper can be used in a drivers fb_create callback to pre-fill the fb's
   metadata fields.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-helper-resume-force-mode">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_helper_resume_force_mode</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_helper_resume_force_mode</refname>
 <refpurpose>
     force-restore mode setting configuration
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>drm_helper_resume_force_mode </function></funcdef>
   <paramdef>struct drm_device * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     drm_device which should be restored
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Drivers which use the mode setting helpers can use this function to
   force-restore the mode setting configuration e.g. on resume or when something
   else might have trampled over the hw state (like some overzealous old BIOSen
   tended to do).
   </para><para>

   This helper doesn't provide a error return value since restoring the old
   config should never fail due to resource allocation issues since the driver
   has successfully set the restored configuration already. Hence this should
   boil down to the equivalent of a few dpms on calls, which also don't provide
   an error code.
   </para><para>

   Drivers where simply restoring an old configuration again might fail (e.g.
   due to slight differences in allocating shared resources when the
   configuration is restored in a different order than when userspace set it up)
   need to use their own restore logic.
</para>
</refsect1>
</refentry>

    </sect2>
    <sect2>
      <title>Output Probing Helper Functions Reference</title>
<para>
   </para><para>
   This library provides some helper code for output probing. It provides an
   implementation of the core connector-&gt;fill_modes interface with
   drm_helper_probe_single_connector_modes.
   </para><para>
   It also provides support for polling connectors with a work item and for
   generic hotplug interrupt handling where the driver doesn't or cannot keep
   track of a per-connector hpd interrupt.
   </para><para>
   This helper library can be used independently of the modeset helper library.
   Drivers can also overwrite different parts e.g. use their own hotplug
   handling code to avoid probing unrelated outputs.
</para>

<!-- drivers/gpu/drm/drm_probe_helper.c -->
<refentry id="API-drm-helper-probe-single-connector-modes">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_helper_probe_single_connector_modes</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_helper_probe_single_connector_modes</refname>
 <refpurpose>
  get complete set of display modes
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>drm_helper_probe_single_connector_modes </function></funcdef>
   <paramdef>struct drm_connector * <parameter>connector</parameter></paramdef>
   <paramdef>uint32_t <parameter>maxX</parameter></paramdef>
   <paramdef>uint32_t <parameter>maxY</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>connector</parameter></term>
   <listitem>
    <para>
     connector to probe
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>maxX</parameter></term>
   <listitem>
    <para>
     max width for modes
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>maxY</parameter></term>
   <listitem>
    <para>
     max height for modes
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Based on the helper callbacks implemented by <parameter>connector</parameter> try to detect all
   valid modes.  Modes will first be added to the connector's probed_modes list,
   then culled (based on validity and the <parameter>maxX</parameter>, <parameter>maxY</parameter> parameters) and put into
   the normal modes list.
   </para><para>

   Intended to be use as a generic implementation of the -&gt;<function>fill_modes</function>
   <parameter>connector</parameter> vfunc for drivers that use the crtc helpers for output mode
   filtering and detection.
</para>
</refsect1>
<refsect1>
<title>Returns</title>
<para>
   The number of modes found on <parameter>connector</parameter>.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-helper-probe-single-connector-modes-nomerge">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_helper_probe_single_connector_modes_nomerge</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_helper_probe_single_connector_modes_nomerge</refname>
 <refpurpose>
     get complete set of display modes
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>drm_helper_probe_single_connector_modes_nomerge </function></funcdef>
   <paramdef>struct drm_connector * <parameter>connector</parameter></paramdef>
   <paramdef>uint32_t <parameter>maxX</parameter></paramdef>
   <paramdef>uint32_t <parameter>maxY</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>connector</parameter></term>
   <listitem>
    <para>
     connector to probe
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>maxX</parameter></term>
   <listitem>
    <para>
     max width for modes
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>maxY</parameter></term>
   <listitem>
    <para>
     max height for modes
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This operates like drm_hehlper_probe_single_connector_modes except it
   replaces the mode bits instead of merging them for preferred modes.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-kms-helper-hotplug-event">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_kms_helper_hotplug_event</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_kms_helper_hotplug_event</refname>
 <refpurpose>
     fire off KMS hotplug events
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>drm_kms_helper_hotplug_event </function></funcdef>
   <paramdef>struct drm_device * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     drm_device whose connector state changed
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This function fires off the uevent for userspace and also calls the
   output_poll_changed function, which is most commonly used to inform the fbdev
   emulation code and allow it to update the fbcon output configuration.
   </para><para>

   Drivers should call this from their hotplug handling code when a change is
   detected. Note that this function does not do any output detection of its
   own, like <function>drm_helper_hpd_irq_event</function> does - this is assumed to be done by the
   driver already.
   </para><para>

   This function must be called from process context with no mode
   setting locks held.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-kms-helper-poll-disable">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_kms_helper_poll_disable</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_kms_helper_poll_disable</refname>
 <refpurpose>
     disable output polling
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>drm_kms_helper_poll_disable </function></funcdef>
   <paramdef>struct drm_device * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     drm_device
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This function disables the output polling work.
   </para><para>

   Drivers can call this helper from their device suspend implementation. It is
   not an error to call this even when output polling isn't enabled or arlready
   disabled.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-kms-helper-poll-enable">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_kms_helper_poll_enable</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_kms_helper_poll_enable</refname>
 <refpurpose>
     re-enable output polling.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>drm_kms_helper_poll_enable </function></funcdef>
   <paramdef>struct drm_device * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     drm_device
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This function re-enables the output polling work.
   </para><para>

   Drivers can call this helper from their device resume implementation. It is
   an error to call this when the output polling support has not yet been set
   up.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-kms-helper-poll-init">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_kms_helper_poll_init</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_kms_helper_poll_init</refname>
 <refpurpose>
     initialize and enable output polling
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>drm_kms_helper_poll_init </function></funcdef>
   <paramdef>struct drm_device * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     drm_device
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This function intializes and then also enables output polling support for
   <parameter>dev</parameter>. Drivers which do not have reliable hotplug support in hardware can use
   this helper infrastructure to regularly poll such connectors for changes in
   their connection state.
   </para><para>

   Drivers can control which connectors are polled by setting the
   DRM_CONNECTOR_POLL_CONNECT and DRM_CONNECTOR_POLL_DISCONNECT flags. On
   connectors where probing live outputs can result in visual distortion drivers
   should not set the DRM_CONNECTOR_POLL_DISCONNECT flag to avoid this.
   Connectors which have no flag or only DRM_CONNECTOR_POLL_HPD set are
   completely ignored by the polling logic.
   </para><para>

   Note that a connector can be both polled and probed from the hotplug handler,
   in case the hotplug interrupt is known to be unreliable.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-kms-helper-poll-fini">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_kms_helper_poll_fini</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_kms_helper_poll_fini</refname>
 <refpurpose>
     disable output polling and clean it up
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>drm_kms_helper_poll_fini </function></funcdef>
   <paramdef>struct drm_device * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     drm_device
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-drm-helper-hpd-irq-event">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_helper_hpd_irq_event</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_helper_hpd_irq_event</refname>
 <refpurpose>
     hotplug processing
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>bool <function>drm_helper_hpd_irq_event </function></funcdef>
   <paramdef>struct drm_device * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     drm_device
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Drivers can use this helper function to run a detect cycle on all connectors
   which have the DRM_CONNECTOR_POLL_HPD flag set in their <structname>polled</structname> member. All
   other connectors are ignored, which is useful to avoid reprobing fixed
   panels.
   </para><para>

   This helper function is useful for drivers which can't or don't track hotplug
   interrupts for each connector.
   </para><para>

   Drivers which support hotplug interrupts for each connector individually and
   which have a more fine-grained detect logic should bypass this code and
   directly call <function>drm_kms_helper_hotplug_event</function> in case the connector state
   changed.
   </para><para>

   This function must be called from process context with no mode
   setting locks held.
   </para><para>

   Note that a connector can be both polled and probed from the hotplug handler,
   in case the hotplug interrupt is known to be unreliable.
</para>
</refsect1>
</refentry>

    </sect2>
    <sect2>
      <title>fbdev Helper Functions Reference</title>
<para>
   </para><para>
   The fb helper functions are useful to provide an fbdev on top of a drm kernel
   mode setting driver. They can be used mostly independently from the crtc
   helper functions used by many drivers to implement the kernel mode setting
   interfaces.
   </para><para>
   Initialization is done as a four-step process with <function>drm_fb_helper_prepare</function>,
   <function>drm_fb_helper_init</function>, <function>drm_fb_helper_single_add_all_connectors</function> and
   <function>drm_fb_helper_initial_config</function>. Drivers with fancier requirements than the
   default behaviour can override the third step with their own code.
   Teardown is done with <function>drm_fb_helper_fini</function>.
   </para><para>
   At runtime drivers should restore the fbdev console by calling
   <function>drm_fb_helper_restore_fbdev_mode</function> from their -&gt;lastclose callback. They
   should also notify the fb helper code from updates to the output
   configuration by calling <function>drm_fb_helper_hotplug_event</function>. For easier
   integration with the output polling code in drm_crtc_helper.c the modeset
   code provides a -&gt;output_poll_changed callback.
   </para><para>
   All other functions exported by the fb helper library can be used to
   implement the fbdev driver interface by the driver.
   </para><para>
   It is possible, though perhaps somewhat tricky, to implement race-free
   hotplug detection using the fbdev helpers. The <function>drm_fb_helper_prepare</function>
   helper must be called first to initialize the minimum required to make
   hotplug detection work. Drivers also need to make sure to properly set up
   the dev-&gt;mode_config.funcs member. After calling <function>drm_kms_helper_poll_init</function>
   it is safe to enable interrupts and start processing hotplug events. At the
   same time, drivers should initialize all modeset objects such as CRTCs,
   encoders and connectors. To finish up the fbdev helper initialization, the
   <function>drm_fb_helper_init</function> function is called. To probe for all attached displays
   and set up an initial configuration using the detected hardware, drivers
   should call <function>drm_fb_helper_single_add_all_connectors</function> followed by
   <function>drm_fb_helper_initial_config</function>.
</para>

<!-- drivers/gpu/drm/drm_fb_helper.c -->
<refentry id="API-drm-fb-helper-single-add-all-connectors">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_fb_helper_single_add_all_connectors</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_fb_helper_single_add_all_connectors</refname>
 <refpurpose>
  add all connectors to fbdev emulation helper
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>drm_fb_helper_single_add_all_connectors </function></funcdef>
   <paramdef>struct drm_fb_helper * <parameter>fb_helper</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>fb_helper</parameter></term>
   <listitem>
    <para>
     fbdev initialized with drm_fb_helper_init
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This functions adds all the available connectors for use with the given
   fb_helper. This is a separate step to allow drivers to freely assign
   connectors to the fbdev, e.g. if some are reserved for special purposes or
   not adequate to be used for the fbcon.
   </para><para>

   Since this is part of the initial setup before the fbdev is published, no
   locking is required.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-fb-helper-debug-enter">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_fb_helper_debug_enter</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_fb_helper_debug_enter</refname>
 <refpurpose>
     implementation for -&gt;fb_debug_enter
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>drm_fb_helper_debug_enter </function></funcdef>
   <paramdef>struct fb_info * <parameter>info</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>info</parameter></term>
   <listitem>
    <para>
     fbdev registered by the helper
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-drm-fb-helper-debug-leave">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_fb_helper_debug_leave</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_fb_helper_debug_leave</refname>
 <refpurpose>
     implementation for -&gt;fb_debug_leave
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>drm_fb_helper_debug_leave </function></funcdef>
   <paramdef>struct fb_info * <parameter>info</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>info</parameter></term>
   <listitem>
    <para>
     fbdev registered by the helper
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-drm-fb-helper-restore-fbdev-mode-unlocked">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_fb_helper_restore_fbdev_mode_unlocked</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_fb_helper_restore_fbdev_mode_unlocked</refname>
 <refpurpose>
     restore fbdev configuration
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>bool <function>drm_fb_helper_restore_fbdev_mode_unlocked </function></funcdef>
   <paramdef>struct drm_fb_helper * <parameter>fb_helper</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>fb_helper</parameter></term>
   <listitem>
    <para>
     fbcon to restore
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This should be called from driver's drm -&gt;lastclose callback
   when implementing an fbcon on top of kms using this helper. This ensures that
   the user isn't greeted with a black screen when e.g. X dies.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-fb-helper-blank">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_fb_helper_blank</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_fb_helper_blank</refname>
 <refpurpose>
     implementation for -&gt;fb_blank
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>drm_fb_helper_blank </function></funcdef>
   <paramdef>int <parameter>blank</parameter></paramdef>
   <paramdef>struct fb_info * <parameter>info</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>blank</parameter></term>
   <listitem>
    <para>
     desired blanking state
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>info</parameter></term>
   <listitem>
    <para>
     fbdev registered by the helper
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-drm-fb-helper-prepare">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_fb_helper_prepare</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_fb_helper_prepare</refname>
 <refpurpose>
     setup a drm_fb_helper structure
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>drm_fb_helper_prepare </function></funcdef>
   <paramdef>struct drm_device * <parameter>dev</parameter></paramdef>
   <paramdef>struct drm_fb_helper * <parameter>helper</parameter></paramdef>
   <paramdef>const struct drm_fb_helper_funcs * <parameter>funcs</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     DRM device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>helper</parameter></term>
   <listitem>
    <para>
     driver-allocated fbdev helper structure to set up
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>funcs</parameter></term>
   <listitem>
    <para>
     pointer to structure of functions associate with this helper
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Sets up the bare minimum to make the framebuffer helper usable. This is
   useful to implement race-free initialization of the polling helpers.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-fb-helper-init">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_fb_helper_init</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_fb_helper_init</refname>
 <refpurpose>
     initialize a drm_fb_helper structure
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>drm_fb_helper_init </function></funcdef>
   <paramdef>struct drm_device * <parameter>dev</parameter></paramdef>
   <paramdef>struct drm_fb_helper * <parameter>fb_helper</parameter></paramdef>
   <paramdef>int <parameter>crtc_count</parameter></paramdef>
   <paramdef>int <parameter>max_conn_count</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     drm device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>fb_helper</parameter></term>
   <listitem>
    <para>
     driver-allocated fbdev helper structure to initialize
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>crtc_count</parameter></term>
   <listitem>
    <para>
     maximum number of crtcs to support in this fbdev emulation
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>max_conn_count</parameter></term>
   <listitem>
    <para>
     max connector count
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This allocates the structures for the fbdev helper with the given limits.
   Note that this won't yet touch the hardware (through the driver interfaces)
   nor register the fbdev. This is only done in <function>drm_fb_helper_initial_config</function>
   to allow driver writes more control over the exact init sequence.
   </para><para>

   Drivers must call <function>drm_fb_helper_prepare</function> before calling this function.
</para>
</refsect1>
<refsect1>
<title>RETURNS</title>
<para>
   Zero if everything went ok, nonzero otherwise.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-fb-helper-setcmap">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_fb_helper_setcmap</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_fb_helper_setcmap</refname>
 <refpurpose>
     implementation for -&gt;fb_setcmap
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>drm_fb_helper_setcmap </function></funcdef>
   <paramdef>struct fb_cmap * <parameter>cmap</parameter></paramdef>
   <paramdef>struct fb_info * <parameter>info</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>cmap</parameter></term>
   <listitem>
    <para>
     cmap to set
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>info</parameter></term>
   <listitem>
    <para>
     fbdev registered by the helper
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-drm-fb-helper-check-var">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_fb_helper_check_var</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_fb_helper_check_var</refname>
 <refpurpose>
     implementation for -&gt;fb_check_var
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>drm_fb_helper_check_var </function></funcdef>
   <paramdef>struct fb_var_screeninfo * <parameter>var</parameter></paramdef>
   <paramdef>struct fb_info * <parameter>info</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>var</parameter></term>
   <listitem>
    <para>
     screeninfo to check
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>info</parameter></term>
   <listitem>
    <para>
     fbdev registered by the helper
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-drm-fb-helper-set-par">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_fb_helper_set_par</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_fb_helper_set_par</refname>
 <refpurpose>
     implementation for -&gt;fb_set_par
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>drm_fb_helper_set_par </function></funcdef>
   <paramdef>struct fb_info * <parameter>info</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>info</parameter></term>
   <listitem>
    <para>
     fbdev registered by the helper
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This will let fbcon do the mode init and is called at initialization time by
   the fbdev core when registering the driver, and later on through the hotplug
   callback.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-fb-helper-pan-display">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_fb_helper_pan_display</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_fb_helper_pan_display</refname>
 <refpurpose>
     implementation for -&gt;fb_pan_display
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>drm_fb_helper_pan_display </function></funcdef>
   <paramdef>struct fb_var_screeninfo * <parameter>var</parameter></paramdef>
   <paramdef>struct fb_info * <parameter>info</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>var</parameter></term>
   <listitem>
    <para>
     updated screen information
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>info</parameter></term>
   <listitem>
    <para>
     fbdev registered by the helper
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-drm-fb-helper-fill-fix">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_fb_helper_fill_fix</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_fb_helper_fill_fix</refname>
 <refpurpose>
     initializes fixed fbdev information
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>drm_fb_helper_fill_fix </function></funcdef>
   <paramdef>struct fb_info * <parameter>info</parameter></paramdef>
   <paramdef>uint32_t <parameter>pitch</parameter></paramdef>
   <paramdef>uint32_t <parameter>depth</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>info</parameter></term>
   <listitem>
    <para>
     fbdev registered by the helper
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>pitch</parameter></term>
   <listitem>
    <para>
     desired pitch
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>depth</parameter></term>
   <listitem>
    <para>
     desired depth
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Helper to fill in the fixed fbdev information useful for a non-accelerated
   fbdev emulations. Drivers which support acceleration methods which impose
   additional constraints need to set up their own limits.
   </para><para>

   Drivers should call this (or their equivalent setup code) from their
   -&gt;fb_probe callback.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-fb-helper-fill-var">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_fb_helper_fill_var</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_fb_helper_fill_var</refname>
 <refpurpose>
     initalizes variable fbdev information
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>drm_fb_helper_fill_var </function></funcdef>
   <paramdef>struct fb_info * <parameter>info</parameter></paramdef>
   <paramdef>struct drm_fb_helper * <parameter>fb_helper</parameter></paramdef>
   <paramdef>uint32_t <parameter>fb_width</parameter></paramdef>
   <paramdef>uint32_t <parameter>fb_height</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>info</parameter></term>
   <listitem>
    <para>
     fbdev instance to set up
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>fb_helper</parameter></term>
   <listitem>
    <para>
     fb helper instance to use as template
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>fb_width</parameter></term>
   <listitem>
    <para>
     desired fb width
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>fb_height</parameter></term>
   <listitem>
    <para>
     desired fb height
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Sets up the variable fbdev metainformation from the given fb helper instance
   and the drm framebuffer allocated in fb_helper-&gt;fb.
   </para><para>

   Drivers should call this (or their equivalent setup code) from their
   -&gt;fb_probe callback after having allocated the fbdev backing
   storage framebuffer.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-fb-helper-initial-config">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_fb_helper_initial_config</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_fb_helper_initial_config</refname>
 <refpurpose>
     setup a sane initial connector configuration
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>drm_fb_helper_initial_config </function></funcdef>
   <paramdef>struct drm_fb_helper * <parameter>fb_helper</parameter></paramdef>
   <paramdef>int <parameter>bpp_sel</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>fb_helper</parameter></term>
   <listitem>
    <para>
     fb_helper device struct
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>bpp_sel</parameter></term>
   <listitem>
    <para>
     bpp value to use for the framebuffer configuration
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Scans the CRTCs and connectors and tries to put together an initial setup.
   At the moment, this is a cloned configuration across all heads with
   a new framebuffer object as the backing store.
   </para><para>

   Note that this also registers the fbdev and so allows userspace to call into
   the driver through the fbdev interfaces.
   </para><para>

   This function will call down into the -&gt;fb_probe callback to let
   the driver allocate and initialize the fbdev info structure and the drm
   framebuffer used to back the fbdev. <function>drm_fb_helper_fill_var</function> and
   <function>drm_fb_helper_fill_fix</function> are provided as helpers to setup simple default
   values for the fbdev info structure.
</para>
</refsect1>
<refsect1>
<title>RETURNS</title>
<para>
   Zero if everything went ok, nonzero otherwise.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-fb-helper-hotplug-event">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_fb_helper_hotplug_event</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_fb_helper_hotplug_event</refname>
 <refpurpose>
     respond to a hotplug notification by probing all the outputs attached to the fb
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>drm_fb_helper_hotplug_event </function></funcdef>
   <paramdef>struct drm_fb_helper * <parameter>fb_helper</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>fb_helper</parameter></term>
   <listitem>
    <para>
     the drm_fb_helper
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Scan the connectors attached to the fb_helper and try to put together a
   setup after *notification of a change in output configuration.
   </para><para>

   Called at runtime, takes the mode config locks to be able to check/change the
   modeset configuration. Must be run from process context (which usually means
   either the output polling work or a work item launched from the driver's
   hotplug interrupt).
   </para><para>

   Note that drivers may call this even before calling
   drm_fb_helper_initial_config but only aftert drm_fb_helper_init. This allows
   for a race-free fbcon setup and will make sure that the fbdev emulation will
   not miss any hotplug events.
</para>
</refsect1>
<refsect1>
<title>RETURNS</title>
<para>
   0 on success and a non-zero error code otherwise.
</para>
</refsect1>
</refentry>

<!-- include/drm/drm_fb_helper.h -->
<refentry id="API-struct-drm-fb-helper-funcs">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct drm_fb_helper_funcs</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct drm_fb_helper_funcs</refname>
 <refpurpose>
  driver callbacks for the fbdev emulation library
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct drm_fb_helper_funcs {
  void (* gamma_set) (struct drm_crtc *crtc, u16 red, u16 green,u16 blue, int regno);
  void (* gamma_get) (struct drm_crtc *crtc, u16 *red, u16 *green,u16 *blue, int regno);
  int (* fb_probe) (struct drm_fb_helper *helper,struct drm_fb_helper_surface_size *sizes);
  bool (* initial_config) (struct drm_fb_helper *fb_helper,struct drm_fb_helper_crtc **crtcs,struct drm_display_mode **modes,bool *enabled, int width, int height);
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>gamma_set</term>
      <listitem><para>
Set the given gamma lut register on the given crtc.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>gamma_get</term>
      <listitem><para>
Read the given gamma lut register on the given crtc, used to
save the current lut when force-restoring the fbdev for e.g.
kdbg.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>fb_probe</term>
      <listitem><para>
Driver callback to allocate and initialize the fbdev info
structure. Furthermore it also needs to allocate the drm
framebuffer used to back the fbdev.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>initial_config</term>
      <listitem><para>
Setup an initial fbdev display configuration
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
<refsect1>
<title>Description</title>
<para>
   Driver callbacks used by the fbdev emulation helper library.
</para>
</refsect1>
</refentry>

    </sect2>
    <sect2>
      <title>Display Port Helper Functions Reference</title>
<para>
   </para><para>
   These functions contain some common logic and helpers at various abstraction
   levels to deal with Display Port sink devices and related things like DP aux
   channel transfers, EDID reading over DP aux channels, decoding certain DPCD
   blocks, ...
</para>

<para>
   </para><para>
   The DisplayPort AUX channel is an abstraction to allow generic, driver-
   independent access to AUX functionality. Drivers can take advantage of
   this by filling in the fields of the drm_dp_aux structure.
   </para><para>
   Transactions are described using a hardware-independent drm_dp_aux_msg
   structure, which is passed into a driver's .<function>transfer</function> implementation.
   Both native and I2C-over-AUX transactions are supported.
</para>

<!-- include/drm/drm_dp_helper.h -->
<refentry id="API-struct-i2c-algo-dp-aux-data">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct i2c_algo_dp_aux_data</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct i2c_algo_dp_aux_data</refname>
 <refpurpose>
  driver interface structure for i2c over dp aux algorithm
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct i2c_algo_dp_aux_data {
  bool running;
  u16 address;
  int (* aux_ch) (struct i2c_adapter *adapter,int mode, uint8_t write_byte,uint8_t *read_byte);
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>running</term>
      <listitem><para>
set by the algo indicating whether an i2c is ongoing or whether
the i2c bus is quiescent
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>address</term>
      <listitem><para>
i2c target address for the currently ongoing transfer
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>aux_ch</term>
      <listitem><para>
driver callback to transfer a single byte of the i2c payload
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
</refentry>

<refentry id="API-struct-drm-dp-aux-msg">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct drm_dp_aux_msg</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct drm_dp_aux_msg</refname>
 <refpurpose>
     DisplayPort AUX channel transaction
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct drm_dp_aux_msg {
  unsigned int address;
  u8 request;
  u8 reply;
  void * buffer;
  size_t size;
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>address</term>
      <listitem><para>
   address of the (first) register to access
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>request</term>
      <listitem><para>
   contains the type of transaction (see DP_AUX_* macros)
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>reply</term>
      <listitem><para>
   upon completion, contains the reply type of the transaction
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>buffer</term>
      <listitem><para>
   pointer to a transmission or reception buffer
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>size</term>
      <listitem><para>
   size of <parameter>buffer</parameter>
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
</refentry>

<refentry id="API-struct-drm-dp-aux">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct drm_dp_aux</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct drm_dp_aux</refname>
 <refpurpose>
     DisplayPort AUX channel
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct drm_dp_aux {
  const char * name;
  struct i2c_adapter ddc;
  struct device * dev;
  struct mutex hw_mutex;
  ssize_t (* transfer) (struct drm_dp_aux *aux,struct drm_dp_aux_msg *msg);
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>name</term>
      <listitem><para>
   user-visible name of this AUX channel and the I2C-over-AUX adapter
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>ddc</term>
      <listitem><para>
   I2C adapter that can be used for I2C-over-AUX communication
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>dev</term>
      <listitem><para>
   pointer to struct device that is the parent for this AUX channel
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>hw_mutex</term>
      <listitem><para>
   internal mutex used for locking transfers
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>transfer</term>
      <listitem><para>
   transfers a message representing a single AUX transaction
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
<refsect1>
<title>Description</title>
<para>
   The .dev field should be set to a pointer to the device that implements
   the AUX channel.
   </para><para>

   The .name field may be used to specify the name of the I2C adapter. If set to
   NULL, <function>dev_name</function> of .dev will be used.
   </para><para>

   Drivers provide a hardware-specific implementation of how transactions
   are executed via the .<function>transfer</function> function. A pointer to a drm_dp_aux_msg
   structure describing the transaction is passed into this function. Upon
   success, the implementation should return the number of payload bytes
   that were transferred, or a negative error-code on failure. Helpers
   propagate errors from the .<function>transfer</function> function, with the exception of
   the -EBUSY error, which causes a transaction to be retried. On a short,
   helpers will return -EPROTO to make it simpler to check for failure.
   </para><para>

   An AUX channel can also be used to transport I2C messages to a sink. A
   typical application of that is to access an EDID that's present in the
   sink device. The .<function>transfer</function> function can also be used to execute such
   transactions. The <function>drm_dp_aux_register_i2c_bus</function> function registers an
   I2C adapter that can be passed to <function>drm_probe_ddc</function>. Upon removal, drivers
   should call <function>drm_dp_aux_unregister_i2c_bus</function> to remove the I2C adapter.
   </para><para>

   Note that the aux helper code assumes that the .<function>transfer</function> function
   only modifies the reply field of the drm_dp_aux_msg structure.  The
   retry logic and i2c helpers assume this is the case.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-dp-dpcd-readb">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_dp_dpcd_readb</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_dp_dpcd_readb</refname>
 <refpurpose>
     read a single byte from the DPCD
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>ssize_t <function>drm_dp_dpcd_readb </function></funcdef>
   <paramdef>struct drm_dp_aux * <parameter>aux</parameter></paramdef>
   <paramdef>unsigned int <parameter>offset</parameter></paramdef>
   <paramdef>u8 * <parameter>valuep</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>aux</parameter></term>
   <listitem>
    <para>
     DisplayPort AUX channel
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>offset</parameter></term>
   <listitem>
    <para>
     address of the register to read
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>valuep</parameter></term>
   <listitem>
    <para>
     location where the value of the register will be stored
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Returns the number of bytes transferred (1) on success, or a negative
   error code on failure.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-dp-dpcd-writeb">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_dp_dpcd_writeb</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_dp_dpcd_writeb</refname>
 <refpurpose>
     write a single byte to the DPCD
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>ssize_t <function>drm_dp_dpcd_writeb </function></funcdef>
   <paramdef>struct drm_dp_aux * <parameter>aux</parameter></paramdef>
   <paramdef>unsigned int <parameter>offset</parameter></paramdef>
   <paramdef>u8 <parameter>value</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>aux</parameter></term>
   <listitem>
    <para>
     DisplayPort AUX channel
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>offset</parameter></term>
   <listitem>
    <para>
     address of the register to write
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>value</parameter></term>
   <listitem>
    <para>
     value to write to the register
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Returns the number of bytes transferred (1) on success, or a negative
   error code on failure.
</para>
</refsect1>
</refentry>

<!-- drivers/gpu/drm/drm_dp_helper.c -->
<refentry id="API-i2c-dp-aux-add-bus">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>i2c_dp_aux_add_bus</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>i2c_dp_aux_add_bus</refname>
 <refpurpose>
  register an i2c adapter using the aux ch helper
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>i2c_dp_aux_add_bus </function></funcdef>
   <paramdef>struct i2c_adapter * <parameter>adapter</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>adapter</parameter></term>
   <listitem>
    <para>
     i2c adapter to register
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This registers an i2c adapter that uses dp aux channel as it's underlaying
   transport. The driver needs to fill out the <structname>i2c_algo_dp_aux_data</structname> structure
   and store it in the algo_data member of the <parameter>adapter</parameter> argument. This will be
   used by the i2c over dp aux algorithm to drive the hardware.
</para>
</refsect1>
<refsect1>
<title>RETURNS</title>
<para>
   0 on success, -ERRNO on failure.
</para>
</refsect1>
<refsect1>
<title>IMPORTANT</title>
<para>
   This interface is deprecated, please switch to the new dp aux helpers and
   <function>drm_dp_aux_register</function>.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-dp-dpcd-read">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_dp_dpcd_read</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_dp_dpcd_read</refname>
 <refpurpose>
     read a series of bytes from the DPCD
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>ssize_t <function>drm_dp_dpcd_read </function></funcdef>
   <paramdef>struct drm_dp_aux * <parameter>aux</parameter></paramdef>
   <paramdef>unsigned int <parameter>offset</parameter></paramdef>
   <paramdef>void * <parameter>buffer</parameter></paramdef>
   <paramdef>size_t <parameter>size</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>aux</parameter></term>
   <listitem>
    <para>
     DisplayPort AUX channel
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>offset</parameter></term>
   <listitem>
    <para>
     address of the (first) register to read
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>buffer</parameter></term>
   <listitem>
    <para>
     buffer to store the register values
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>size</parameter></term>
   <listitem>
    <para>
     number of bytes in <parameter>buffer</parameter>
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Returns the number of bytes transferred on success, or a negative error
   code on failure. -EIO is returned if the request was NAKed by the sink or
   if the retry count was exceeded. If not all bytes were transferred, this
   function returns -EPROTO. Errors from the underlying AUX channel transfer
   function, with the exception of -EBUSY (which causes the transaction to
   be retried), are propagated to the caller.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-dp-dpcd-write">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_dp_dpcd_write</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_dp_dpcd_write</refname>
 <refpurpose>
     write a series of bytes to the DPCD
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>ssize_t <function>drm_dp_dpcd_write </function></funcdef>
   <paramdef>struct drm_dp_aux * <parameter>aux</parameter></paramdef>
   <paramdef>unsigned int <parameter>offset</parameter></paramdef>
   <paramdef>void * <parameter>buffer</parameter></paramdef>
   <paramdef>size_t <parameter>size</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>aux</parameter></term>
   <listitem>
    <para>
     DisplayPort AUX channel
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>offset</parameter></term>
   <listitem>
    <para>
     address of the (first) register to write
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>buffer</parameter></term>
   <listitem>
    <para>
     buffer containing the values to write
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>size</parameter></term>
   <listitem>
    <para>
     number of bytes in <parameter>buffer</parameter>
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Returns the number of bytes transferred on success, or a negative error
   code on failure. -EIO is returned if the request was NAKed by the sink or
   if the retry count was exceeded. If not all bytes were transferred, this
   function returns -EPROTO. Errors from the underlying AUX channel transfer
   function, with the exception of -EBUSY (which causes the transaction to
   be retried), are propagated to the caller.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-dp-dpcd-read-link-status">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_dp_dpcd_read_link_status</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_dp_dpcd_read_link_status</refname>
 <refpurpose>
     read DPCD link status (bytes 0x202-0x207)
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>drm_dp_dpcd_read_link_status </function></funcdef>
   <paramdef>struct drm_dp_aux * <parameter>aux</parameter></paramdef>
   <paramdef>u8 <parameter>status[DP_LINK_STATUS_SIZE]</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>aux</parameter></term>
   <listitem>
    <para>
     DisplayPort AUX channel
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>status[DP_LINK_STATUS_SIZE]</parameter></term>
   <listitem>
    <para>
     buffer to store the link status in (must be at least 6 bytes)
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Returns the number of bytes transferred on success or a negative error
   code on failure.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-dp-link-probe">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_dp_link_probe</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_dp_link_probe</refname>
 <refpurpose>
     probe a DisplayPort link for capabilities
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>drm_dp_link_probe </function></funcdef>
   <paramdef>struct drm_dp_aux * <parameter>aux</parameter></paramdef>
   <paramdef>struct drm_dp_link * <parameter>link</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>aux</parameter></term>
   <listitem>
    <para>
     DisplayPort AUX channel
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>link</parameter></term>
   <listitem>
    <para>
     pointer to structure in which to return link capabilities
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   The structure filled in by this function can usually be passed directly
   into <function>drm_dp_link_power_up</function> and <function>drm_dp_link_configure</function> to power up and
   configure the link based on the link's capabilities.
   </para><para>

   Returns 0 on success or a negative error code on failure.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-dp-link-power-up">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_dp_link_power_up</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_dp_link_power_up</refname>
 <refpurpose>
     power up a DisplayPort link
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>drm_dp_link_power_up </function></funcdef>
   <paramdef>struct drm_dp_aux * <parameter>aux</parameter></paramdef>
   <paramdef>struct drm_dp_link * <parameter>link</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>aux</parameter></term>
   <listitem>
    <para>
     DisplayPort AUX channel
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>link</parameter></term>
   <listitem>
    <para>
     pointer to a structure containing the link configuration
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Returns 0 on success or a negative error code on failure.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-dp-link-configure">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_dp_link_configure</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_dp_link_configure</refname>
 <refpurpose>
     configure a DisplayPort link
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>drm_dp_link_configure </function></funcdef>
   <paramdef>struct drm_dp_aux * <parameter>aux</parameter></paramdef>
   <paramdef>struct drm_dp_link * <parameter>link</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>aux</parameter></term>
   <listitem>
    <para>
     DisplayPort AUX channel
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>link</parameter></term>
   <listitem>
    <para>
     pointer to a structure containing the link configuration
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Returns 0 on success or a negative error code on failure.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-dp-aux-register">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_dp_aux_register</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_dp_aux_register</refname>
 <refpurpose>
     initialise and register aux channel
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>drm_dp_aux_register </function></funcdef>
   <paramdef>struct drm_dp_aux * <parameter>aux</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>aux</parameter></term>
   <listitem>
    <para>
     DisplayPort AUX channel
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Returns 0 on success or a negative error code on failure.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-dp-aux-unregister">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_dp_aux_unregister</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_dp_aux_unregister</refname>
 <refpurpose>
     unregister an AUX adapter
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>drm_dp_aux_unregister </function></funcdef>
   <paramdef>struct drm_dp_aux * <parameter>aux</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>aux</parameter></term>
   <listitem>
    <para>
     DisplayPort AUX channel
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

    </sect2>
    <sect2>
      <title>Display Port MST Helper Functions Reference</title>
<para>
   </para><para>
   These functions contain parts of the DisplayPort 1.2a MultiStream Transport
   protocol. The helpers contain a topology manager and bandwidth manager.
   The helpers encapsulate the sending and received of sideband msgs.
</para>

<!-- include/drm/drm_dp_mst_helper.h -->
<refentry id="API-struct-drm-dp-vcpi">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct drm_dp_vcpi</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct drm_dp_vcpi</refname>
 <refpurpose>
  Virtual Channel Payload Identifer
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct drm_dp_vcpi {
  int vcpi;
  int pbn;
  int aligned_pbn;
  int num_slots;
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>vcpi</term>
      <listitem><para>
Virtual channel ID.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>pbn</term>
      <listitem><para>
Payload Bandwidth Number for this channel
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>aligned_pbn</term>
      <listitem><para>
PBN aligned with slot size
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>num_slots</term>
      <listitem><para>
number of slots for this PBN
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
</refentry>

<refentry id="API-struct-drm-dp-mst-port">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct drm_dp_mst_port</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct drm_dp_mst_port</refname>
 <refpurpose>
     MST port
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct drm_dp_mst_port {
  struct kref kref;
  u8 port_num;
  bool input;
  bool mcs;
  bool ddps;
  u8 pdt;
  bool ldps;
  u8 dpcd_rev;
  u8 num_sdp_streams;
  u8 num_sdp_stream_sinks;
  uint16_t available_pbn;
  struct list_head next;
  struct drm_dp_mst_branch * mstb;
  struct drm_dp_aux aux;
  struct drm_dp_mst_branch * parent;
  struct drm_dp_vcpi vcpi;
  struct drm_connector * connector;
  struct drm_dp_mst_topology_mgr * mgr;
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>kref</term>
      <listitem><para>
   reference count for this port.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>port_num</term>
      <listitem><para>
   port number
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>input</term>
      <listitem><para>
   if this port is an input port.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>mcs</term>
      <listitem><para>
   message capability status - DP 1.2 spec.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>ddps</term>
      <listitem><para>
   DisplayPort Device Plug Status - DP 1.2
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>pdt</term>
      <listitem><para>
   Peer Device Type
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>ldps</term>
      <listitem><para>
   Legacy Device Plug Status
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>dpcd_rev</term>
      <listitem><para>
   DPCD revision of device on this port
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>num_sdp_streams</term>
      <listitem><para>
   Number of simultaneous streams
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>num_sdp_stream_sinks</term>
      <listitem><para>
   Number of stream sinks
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>available_pbn</term>
      <listitem><para>
   Available bandwidth for this port.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>next</term>
      <listitem><para>
   link to next port on this branch device
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>mstb</term>
      <listitem><para>
   branch device attach below this port
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>aux</term>
      <listitem><para>
   i2c aux transport to talk to device connected to this port.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>parent</term>
      <listitem><para>
   branch device parent of this port
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>vcpi</term>
      <listitem><para>
   Virtual Channel Payload info for this port.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>connector</term>
      <listitem><para>
   DRM connector this port is connected to.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>mgr</term>
      <listitem><para>
   topology manager this port lives under.
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
<refsect1>
<title>Description</title>
<para>
   This structure represents an MST port endpoint on a device somewhere
   in the MST topology.
</para>
</refsect1>
</refentry>

<refentry id="API-struct-drm-dp-mst-branch">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct drm_dp_mst_branch</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct drm_dp_mst_branch</refname>
 <refpurpose>
     MST branch device.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct drm_dp_mst_branch {
  struct kref kref;
  u8 rad[8];
  u8 lct;
  int num_ports;
  int msg_slots;
  struct list_head ports;
  struct drm_dp_mst_port * port_parent;
  struct drm_dp_mst_topology_mgr * mgr;
  struct drm_dp_sideband_msg_tx * tx_slots[2];
  int last_seqno;
  bool link_address_sent;
  u8 guid[16];
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>kref</term>
      <listitem><para>
   reference count for this port.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>rad[8]</term>
      <listitem><para>
   Relative Address to talk to this branch device.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>lct</term>
      <listitem><para>
   Link count total to talk to this branch device.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>num_ports</term>
      <listitem><para>
   number of ports on the branch.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>msg_slots</term>
      <listitem><para>
   one bit per transmitted msg slot.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>ports</term>
      <listitem><para>
   linked list of ports on this branch.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>port_parent</term>
      <listitem><para>
   pointer to the port parent, NULL if toplevel.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>mgr</term>
      <listitem><para>
   topology manager for this branch device.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>tx_slots[2]</term>
      <listitem><para>
   transmission slots for this device.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>last_seqno</term>
      <listitem><para>
   last sequence number used to talk to this.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>link_address_sent</term>
      <listitem><para>
   if a link address message has been sent to this device yet.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>guid[16]</term>
      <listitem><para>
   guid for DP 1.2 branch device. port under this branch can be
   identified by port #.
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
<refsect1>
<title>Description</title>
<para>
   This structure represents an MST branch device, there is one
   primary branch device at the root, along with any other branches connected
   to downstream port of parent branches.
</para>
</refsect1>
</refentry>

<refentry id="API-struct-drm-dp-mst-topology-mgr">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct drm_dp_mst_topology_mgr</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct drm_dp_mst_topology_mgr</refname>
 <refpurpose>
     DisplayPort MST manager
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct drm_dp_mst_topology_mgr {
  struct device * dev;
  struct drm_dp_mst_topology_cbs * cbs;
  struct drm_dp_aux * aux;
  int max_payloads;
  int conn_base_id;
  struct drm_dp_sideband_msg_rx down_rep_recv;
  struct drm_dp_sideband_msg_rx up_req_recv;
  struct mutex lock;
  bool mst_state;
  struct drm_dp_mst_branch * mst_primary;
  u8 dpcd[DP_RECEIVER_CAP_SIZE];
  int pbn_div;
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>dev</term>
      <listitem><para>
   device pointer for adding i2c devices etc.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>cbs</term>
      <listitem><para>
   callbacks for connector addition and destruction.
   <parameter>max_dpcd_transaction_bytes</parameter> - maximum number of bytes to read/write in one go.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>aux</term>
      <listitem><para>
   aux channel for the DP connector.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>max_payloads</term>
      <listitem><para>
   maximum number of payloads the GPU can generate.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>conn_base_id</term>
      <listitem><para>
   DRM connector ID this mgr is connected to.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>down_rep_recv</term>
      <listitem><para>
   msg receiver state for down replies.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>up_req_recv</term>
      <listitem><para>
   msg receiver state for up requests.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>lock</term>
      <listitem><para>
   protects mst state, primary, dpcd.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>mst_state</term>
      <listitem><para>
   if this manager is enabled for an MST capable port.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>mst_primary</term>
      <listitem><para>
   pointer to the primary branch device.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>dpcd[DP_RECEIVER_CAP_SIZE]</term>
      <listitem><para>
   cache of DPCD for primary port.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>pbn_div</term>
      <listitem><para>
   PBN to slots divisor.
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
<refsect1>
<title>Description</title>
<para>
   This struct represents the toplevel displayport MST topology manager.
   There should be one instance of this for every MST capable DP connector
   on the GPU.
</para>
</refsect1>
</refentry>

<!-- drivers/gpu/drm/drm_dp_mst_topology.c -->
<refentry id="API-drm-dp-update-payload-part1">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_dp_update_payload_part1</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_dp_update_payload_part1</refname>
 <refpurpose>
  Execute payload update part 1
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>drm_dp_update_payload_part1 </function></funcdef>
   <paramdef>struct drm_dp_mst_topology_mgr * <parameter>mgr</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>mgr</parameter></term>
   <listitem>
    <para>
     manager to use.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This iterates over all proposed virtual channels, and tries to
   allocate space in the link for them. For 0-&gt;slots transitions,
   this step just writes the VCPI to the MST device. For slots-&gt;0
   transitions, this writes the updated VCPIs and removes the
   remote VC payloads.
   </para><para>

   after calling this the driver should generate ACT and payload
   packets.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-dp-update-payload-part2">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_dp_update_payload_part2</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_dp_update_payload_part2</refname>
 <refpurpose>
     Execute payload update part 2
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>drm_dp_update_payload_part2 </function></funcdef>
   <paramdef>struct drm_dp_mst_topology_mgr * <parameter>mgr</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>mgr</parameter></term>
   <listitem>
    <para>
     manager to use.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This iterates over all proposed virtual channels, and tries to
   allocate space in the link for them. For 0-&gt;slots transitions,
   this step writes the remote VC payload commands. For slots-&gt;0
   this just resets some internal state.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-dp-mst-topology-mgr-set-mst">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_dp_mst_topology_mgr_set_mst</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_dp_mst_topology_mgr_set_mst</refname>
 <refpurpose>
     Set the MST state for a topology manager
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>drm_dp_mst_topology_mgr_set_mst </function></funcdef>
   <paramdef>struct drm_dp_mst_topology_mgr * <parameter>mgr</parameter></paramdef>
   <paramdef>bool <parameter>mst_state</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>mgr</parameter></term>
   <listitem>
    <para>
     manager to set state for
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>mst_state</parameter></term>
   <listitem>
    <para>
     true to enable MST on this connector - false to disable.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This is called by the driver when it detects an MST capable device plugged
   into a DP MST capable port, or when a DP MST capable device is unplugged.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-dp-mst-topology-mgr-suspend">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_dp_mst_topology_mgr_suspend</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_dp_mst_topology_mgr_suspend</refname>
 <refpurpose>
     suspend the MST manager
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>drm_dp_mst_topology_mgr_suspend </function></funcdef>
   <paramdef>struct drm_dp_mst_topology_mgr * <parameter>mgr</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>mgr</parameter></term>
   <listitem>
    <para>
     manager to suspend
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This function tells the MST device that we can't handle UP messages
   anymore. This should stop it from sending any since we are suspended.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-dp-mst-topology-mgr-resume">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_dp_mst_topology_mgr_resume</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_dp_mst_topology_mgr_resume</refname>
 <refpurpose>
     resume the MST manager
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>drm_dp_mst_topology_mgr_resume </function></funcdef>
   <paramdef>struct drm_dp_mst_topology_mgr * <parameter>mgr</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>mgr</parameter></term>
   <listitem>
    <para>
     manager to resume
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This will fetch DPCD and see if the device is still there,
   if it is, it will rewrite the MSTM control bits, and return.
   </para><para>

   if the device fails this returns -1, and the driver should do
   a full MST reprobe, in case we were undocked.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-dp-mst-hpd-irq">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_dp_mst_hpd_irq</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_dp_mst_hpd_irq</refname>
 <refpurpose>
     MST hotplug IRQ notify
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>drm_dp_mst_hpd_irq </function></funcdef>
   <paramdef>struct drm_dp_mst_topology_mgr * <parameter>mgr</parameter></paramdef>
   <paramdef>u8 * <parameter>esi</parameter></paramdef>
   <paramdef>bool * <parameter>handled</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>mgr</parameter></term>
   <listitem>
    <para>
     manager to notify irq for.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>esi</parameter></term>
   <listitem>
    <para>
     4 bytes from SINK_COUNT_ESI
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>handled</parameter></term>
   <listitem>
    <para>
     whether the hpd interrupt was consumed or not
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This should be called from the driver when it detects a short IRQ,
   along with the value of the DEVICE_SERVICE_IRQ_VECTOR_ESI0. The
   topology manager will process the sideband messages received as a result
   of this.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-dp-mst-detect-port">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_dp_mst_detect_port</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_dp_mst_detect_port</refname>
 <refpurpose>
     get connection status for an MST port
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>enum drm_connector_status <function>drm_dp_mst_detect_port </function></funcdef>
   <paramdef>struct drm_dp_mst_topology_mgr * <parameter>mgr</parameter></paramdef>
   <paramdef>struct drm_dp_mst_port * <parameter>port</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>mgr</parameter></term>
   <listitem>
    <para>
     manager for this port
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>port</parameter></term>
   <listitem>
    <para>
     unverified pointer to a port
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This returns the current connection state for a port. It validates the
   port pointer still exists so the caller doesn't require a reference
</para>
</refsect1>
</refentry>

<refentry id="API-drm-dp-mst-get-edid">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_dp_mst_get_edid</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_dp_mst_get_edid</refname>
 <refpurpose>
     get EDID for an MST port
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct edid * <function>drm_dp_mst_get_edid </function></funcdef>
   <paramdef>struct drm_connector * <parameter>connector</parameter></paramdef>
   <paramdef>struct drm_dp_mst_topology_mgr * <parameter>mgr</parameter></paramdef>
   <paramdef>struct drm_dp_mst_port * <parameter>port</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>connector</parameter></term>
   <listitem>
    <para>
     toplevel connector to get EDID for
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>mgr</parameter></term>
   <listitem>
    <para>
     manager for this port
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>port</parameter></term>
   <listitem>
    <para>
     unverified pointer to a port.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This returns an EDID for the port connected to a connector,
   It validates the pointer still exists so the caller doesn't require a
   reference.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-dp-find-vcpi-slots">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_dp_find_vcpi_slots</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_dp_find_vcpi_slots</refname>
 <refpurpose>
     find slots for this PBN value
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>drm_dp_find_vcpi_slots </function></funcdef>
   <paramdef>struct drm_dp_mst_topology_mgr * <parameter>mgr</parameter></paramdef>
   <paramdef>int <parameter>pbn</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>mgr</parameter></term>
   <listitem>
    <para>
     manager to use
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>pbn</parameter></term>
   <listitem>
    <para>
     payload bandwidth to convert into slots.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-drm-dp-mst-allocate-vcpi">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_dp_mst_allocate_vcpi</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_dp_mst_allocate_vcpi</refname>
 <refpurpose>
     Allocate a virtual channel
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>bool <function>drm_dp_mst_allocate_vcpi </function></funcdef>
   <paramdef>struct drm_dp_mst_topology_mgr * <parameter>mgr</parameter></paramdef>
   <paramdef>struct drm_dp_mst_port * <parameter>port</parameter></paramdef>
   <paramdef>int <parameter>pbn</parameter></paramdef>
   <paramdef>int * <parameter>slots</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>mgr</parameter></term>
   <listitem>
    <para>
     manager for this port
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>port</parameter></term>
   <listitem>
    <para>
     port to allocate a virtual channel for.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>pbn</parameter></term>
   <listitem>
    <para>
     payload bandwidth number to request
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>slots</parameter></term>
   <listitem>
    <para>
     returned number of slots for this PBN.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-drm-dp-mst-reset-vcpi-slots">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_dp_mst_reset_vcpi_slots</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_dp_mst_reset_vcpi_slots</refname>
 <refpurpose>
     Reset number of slots to 0 for VCPI
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>drm_dp_mst_reset_vcpi_slots </function></funcdef>
   <paramdef>struct drm_dp_mst_topology_mgr * <parameter>mgr</parameter></paramdef>
   <paramdef>struct drm_dp_mst_port * <parameter>port</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>mgr</parameter></term>
   <listitem>
    <para>
     manager for this port
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>port</parameter></term>
   <listitem>
    <para>
     unverified pointer to a port.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This just resets the number of slots for the ports VCPI for later programming.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-dp-mst-deallocate-vcpi">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_dp_mst_deallocate_vcpi</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_dp_mst_deallocate_vcpi</refname>
 <refpurpose>
     deallocate a VCPI
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>drm_dp_mst_deallocate_vcpi </function></funcdef>
   <paramdef>struct drm_dp_mst_topology_mgr * <parameter>mgr</parameter></paramdef>
   <paramdef>struct drm_dp_mst_port * <parameter>port</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>mgr</parameter></term>
   <listitem>
    <para>
     manager for this port
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>port</parameter></term>
   <listitem>
    <para>
     unverified port to deallocate vcpi for
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-drm-dp-check-act-status">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_dp_check_act_status</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_dp_check_act_status</refname>
 <refpurpose>
     Check ACT handled status.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>drm_dp_check_act_status </function></funcdef>
   <paramdef>struct drm_dp_mst_topology_mgr * <parameter>mgr</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>mgr</parameter></term>
   <listitem>
    <para>
     manager to use
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Check the payload status bits in the DPCD for ACT handled completion.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-dp-calc-pbn-mode">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_dp_calc_pbn_mode</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_dp_calc_pbn_mode</refname>
 <refpurpose>
     Calculate the PBN for a mode.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>drm_dp_calc_pbn_mode </function></funcdef>
   <paramdef>int <parameter>clock</parameter></paramdef>
   <paramdef>int <parameter>bpp</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>clock</parameter></term>
   <listitem>
    <para>
     dot clock for the mode
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>bpp</parameter></term>
   <listitem>
    <para>
     bpp for the mode.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This uses the formula in the spec to calculate the PBN value for a mode.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-dp-mst-dump-topology">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_dp_mst_dump_topology</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_dp_mst_dump_topology</refname>
 <refpurpose>
   </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>drm_dp_mst_dump_topology </function></funcdef>
   <paramdef>struct seq_file * <parameter>m</parameter></paramdef>
   <paramdef>struct drm_dp_mst_topology_mgr * <parameter>mgr</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>m</parameter></term>
   <listitem>
    <para>
     seq_file to dump output to
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>mgr</parameter></term>
   <listitem>
    <para>
     manager to dump current topology for.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   helper to dump MST topology to a seq file for debugfs.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-dp-mst-topology-mgr-init">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_dp_mst_topology_mgr_init</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_dp_mst_topology_mgr_init</refname>
 <refpurpose>
     initialise a topology manager
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>drm_dp_mst_topology_mgr_init </function></funcdef>
   <paramdef>struct drm_dp_mst_topology_mgr * <parameter>mgr</parameter></paramdef>
   <paramdef>struct device * <parameter>dev</parameter></paramdef>
   <paramdef>struct drm_dp_aux * <parameter>aux</parameter></paramdef>
   <paramdef>int <parameter>max_dpcd_transaction_bytes</parameter></paramdef>
   <paramdef>int <parameter>max_payloads</parameter></paramdef>
   <paramdef>int <parameter>conn_base_id</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>mgr</parameter></term>
   <listitem>
    <para>
     manager struct to initialise
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     device providing this structure - for i2c addition.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>aux</parameter></term>
   <listitem>
    <para>
     DP helper aux channel to talk to this device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>max_dpcd_transaction_bytes</parameter></term>
   <listitem>
    <para>
     hw specific DPCD transaction limit
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>max_payloads</parameter></term>
   <listitem>
    <para>
     maximum number of payloads this GPU can source
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>conn_base_id</parameter></term>
   <listitem>
    <para>
     the connector object ID the MST device is connected to.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Return 0 for success, or negative error code on failure
</para>
</refsect1>
</refentry>

<refentry id="API-drm-dp-mst-topology-mgr-destroy">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_dp_mst_topology_mgr_destroy</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_dp_mst_topology_mgr_destroy</refname>
 <refpurpose>
     destroy topology manager.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>drm_dp_mst_topology_mgr_destroy </function></funcdef>
   <paramdef>struct drm_dp_mst_topology_mgr * <parameter>mgr</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>mgr</parameter></term>
   <listitem>
    <para>
     manager to destroy
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

    </sect2>
    <sect2>
      <title>EDID Helper Functions Reference</title>
<!-- drivers/gpu/drm/drm_edid.c -->
<refentry id="API-drm-edid-header-is-valid">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_edid_header_is_valid</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_edid_header_is_valid</refname>
 <refpurpose>
  sanity check the header of the base EDID block
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>drm_edid_header_is_valid </function></funcdef>
   <paramdef>const u8 * <parameter>raw_edid</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>raw_edid</parameter></term>
   <listitem>
    <para>
     pointer to raw base EDID block
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Sanity check the header of the base EDID block.
</para>
</refsect1>
<refsect1>
<title>Return</title>
<para>
   8 if the header is perfect, down to 0 if it's totally wrong.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-edid-block-valid">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_edid_block_valid</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_edid_block_valid</refname>
 <refpurpose>
     Sanity check the EDID block (base or extension)
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>bool <function>drm_edid_block_valid </function></funcdef>
   <paramdef>u8 * <parameter>raw_edid</parameter></paramdef>
   <paramdef>int <parameter>block</parameter></paramdef>
   <paramdef>bool <parameter>print_bad_edid</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>raw_edid</parameter></term>
   <listitem>
    <para>
     pointer to raw EDID block
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>block</parameter></term>
   <listitem>
    <para>
     type of block to validate (0 for base, extension otherwise)
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>print_bad_edid</parameter></term>
   <listitem>
    <para>
     if true, dump bad EDID blocks to the console
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Validate a base or extension EDID block and optionally dump bad blocks to
   the console.
</para>
</refsect1>
<refsect1>
<title>Return</title>
<para>
   True if the block is valid, false otherwise.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-edid-is-valid">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_edid_is_valid</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_edid_is_valid</refname>
 <refpurpose>
     sanity check EDID data
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>bool <function>drm_edid_is_valid </function></funcdef>
   <paramdef>struct edid * <parameter>edid</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>edid</parameter></term>
   <listitem>
    <para>
     EDID data
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Sanity-check an entire EDID record (including extensions)
</para>
</refsect1>
<refsect1>
<title>Return</title>
<para>
   True if the EDID data is valid, false otherwise.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-probe-ddc">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_probe_ddc</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_probe_ddc</refname>
 <refpurpose>
     probe DDC presence
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>bool <function>drm_probe_ddc </function></funcdef>
   <paramdef>struct i2c_adapter * <parameter>adapter</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>adapter</parameter></term>
   <listitem>
    <para>
     I2C adapter to probe
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Return</title>
<para>
   True on success, false on failure.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-get-edid">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_get_edid</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_get_edid</refname>
 <refpurpose>
     get EDID data, if available
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct edid * <function>drm_get_edid </function></funcdef>
   <paramdef>struct drm_connector * <parameter>connector</parameter></paramdef>
   <paramdef>struct i2c_adapter * <parameter>adapter</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>connector</parameter></term>
   <listitem>
    <para>
     connector we're probing
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>adapter</parameter></term>
   <listitem>
    <para>
     I2C adapter to use for DDC
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Poke the given I2C channel to grab EDID data if possible.  If found,
   attach it to the connector.
</para>
</refsect1>
<refsect1>
<title>Return</title>
<para>
   Pointer to valid EDID or NULL if we couldn't find any.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-edid-duplicate">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_edid_duplicate</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_edid_duplicate</refname>
 <refpurpose>
     duplicate an EDID and the extensions
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct edid * <function>drm_edid_duplicate </function></funcdef>
   <paramdef>const struct edid * <parameter>edid</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>edid</parameter></term>
   <listitem>
    <para>
     EDID to duplicate
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Return</title>
<para>
   Pointer to duplicated EDID or NULL on allocation failure.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-match-cea-mode">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_match_cea_mode</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_match_cea_mode</refname>
 <refpurpose>
     look for a CEA mode matching given mode
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>u8 <function>drm_match_cea_mode </function></funcdef>
   <paramdef>const struct drm_display_mode * <parameter>to_match</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>to_match</parameter></term>
   <listitem>
    <para>
     display mode
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Return</title>
<para>
   The CEA Video ID (VIC) of the mode or 0 if it isn't a CEA-861
   mode.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-get-cea-aspect-ratio">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_get_cea_aspect_ratio</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_get_cea_aspect_ratio</refname>
 <refpurpose>
     get the picture aspect ratio corresponding to the input VIC from the CEA mode list
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>enum hdmi_picture_aspect <function>drm_get_cea_aspect_ratio </function></funcdef>
   <paramdef>const u8 <parameter>video_code</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>video_code</parameter></term>
   <listitem>
    <para>
     ID given to each of the CEA modes
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Returns picture aspect ratio
</para>
</refsect1>
</refentry>

<refentry id="API-drm-edid-to-eld">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_edid_to_eld</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_edid_to_eld</refname>
 <refpurpose>
     build ELD from EDID
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>drm_edid_to_eld </function></funcdef>
   <paramdef>struct drm_connector * <parameter>connector</parameter></paramdef>
   <paramdef>struct edid * <parameter>edid</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>connector</parameter></term>
   <listitem>
    <para>
     connector corresponding to the HDMI/DP sink
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>edid</parameter></term>
   <listitem>
    <para>
     EDID to parse
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Fill the ELD (EDID-Like Data) buffer for passing to the audio driver. The
   Conn_Type, HDCP and Port_ID ELD fields are left for the graphics driver to
   fill in.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-edid-to-sad">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_edid_to_sad</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_edid_to_sad</refname>
 <refpurpose>
     extracts SADs from EDID
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>drm_edid_to_sad </function></funcdef>
   <paramdef>struct edid * <parameter>edid</parameter></paramdef>
   <paramdef>struct cea_sad ** <parameter>sads</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>edid</parameter></term>
   <listitem>
    <para>
     EDID to parse
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>sads</parameter></term>
   <listitem>
    <para>
     pointer that will be set to the extracted SADs
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Looks for CEA EDID block and extracts SADs (Short Audio Descriptors) from it.
</para>
</refsect1>
<refsect1>
<title>Note</title>
<para>
   The returned pointer needs to be freed using <function>kfree</function>.
</para>
</refsect1>
<refsect1>
<title>Return</title>
<para>
   The number of found SADs or negative number on error.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-edid-to-speaker-allocation">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_edid_to_speaker_allocation</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_edid_to_speaker_allocation</refname>
 <refpurpose>
     extracts Speaker Allocation Data Blocks from EDID
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>drm_edid_to_speaker_allocation </function></funcdef>
   <paramdef>struct edid * <parameter>edid</parameter></paramdef>
   <paramdef>u8 ** <parameter>sadb</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>edid</parameter></term>
   <listitem>
    <para>
     EDID to parse
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>sadb</parameter></term>
   <listitem>
    <para>
     pointer to the speaker block
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Looks for CEA EDID block and extracts the Speaker Allocation Data Block from it.
</para>
</refsect1>
<refsect1>
<title>Note</title>
<para>
   The returned pointer needs to be freed using <function>kfree</function>.
</para>
</refsect1>
<refsect1>
<title>Return</title>
<para>
   The number of found Speaker Allocation Blocks or negative number on
   error.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-av-sync-delay">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_av_sync_delay</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_av_sync_delay</refname>
 <refpurpose>
     compute the HDMI/DP sink audio-video sync delay
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>drm_av_sync_delay </function></funcdef>
   <paramdef>struct drm_connector * <parameter>connector</parameter></paramdef>
   <paramdef>struct drm_display_mode * <parameter>mode</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>connector</parameter></term>
   <listitem>
    <para>
     connector associated with the HDMI/DP sink
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>mode</parameter></term>
   <listitem>
    <para>
     the display mode
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Return</title>
<para>
   The HDMI/DP sink's audio-video sync delay in milliseconds or 0 if
   the sink doesn't support audio or video.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-select-eld">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_select_eld</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_select_eld</refname>
 <refpurpose>
     select one ELD from multiple HDMI/DP sinks
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct drm_connector * <function>drm_select_eld </function></funcdef>
   <paramdef>struct drm_encoder * <parameter>encoder</parameter></paramdef>
   <paramdef>struct drm_display_mode * <parameter>mode</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>encoder</parameter></term>
   <listitem>
    <para>
     the encoder just changed display mode
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>mode</parameter></term>
   <listitem>
    <para>
     the adjusted display mode
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   It's possible for one encoder to be associated with multiple HDMI/DP sinks.
   The policy is now hard coded to simply use the first HDMI/DP sink's ELD.
</para>
</refsect1>
<refsect1>
<title>Return</title>
<para>
   The connector associated with the first HDMI/DP sink that has ELD
   attached to it.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-detect-hdmi-monitor">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_detect_hdmi_monitor</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_detect_hdmi_monitor</refname>
 <refpurpose>
     detect whether monitor is HDMI
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>bool <function>drm_detect_hdmi_monitor </function></funcdef>
   <paramdef>struct edid * <parameter>edid</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>edid</parameter></term>
   <listitem>
    <para>
     monitor EDID information
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Parse the CEA extension according to CEA-861-B.
</para>
</refsect1>
<refsect1>
<title>Return</title>
<para>
   True if the monitor is HDMI, false if not or unknown.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-detect-monitor-audio">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_detect_monitor_audio</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_detect_monitor_audio</refname>
 <refpurpose>
     check monitor audio capability
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>bool <function>drm_detect_monitor_audio </function></funcdef>
   <paramdef>struct edid * <parameter>edid</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>edid</parameter></term>
   <listitem>
    <para>
     EDID block to scan
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Monitor should have CEA extension block.
   If monitor has 'basic audio', but no CEA audio blocks, it's 'basic
   audio' only. If there is any audio extension block and supported
   audio format, assume at least 'basic audio' support, even if 'basic
   audio' is not defined in EDID.
</para>
</refsect1>
<refsect1>
<title>Return</title>
<para>
   True if the monitor supports audio, false otherwise.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-rgb-quant-range-selectable">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_rgb_quant_range_selectable</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_rgb_quant_range_selectable</refname>
 <refpurpose>
     is RGB quantization range selectable?
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>bool <function>drm_rgb_quant_range_selectable </function></funcdef>
   <paramdef>struct edid * <parameter>edid</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>edid</parameter></term>
   <listitem>
    <para>
     EDID block to scan
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Check whether the monitor reports the RGB quantization range selection
   as supported. The AVI infoframe can then be used to inform the monitor
   which quantization range (full or limited) is used.
</para>
</refsect1>
<refsect1>
<title>Return</title>
<para>
   True if the RGB quantization range is selectable, false otherwise.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-add-edid-modes">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_add_edid_modes</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_add_edid_modes</refname>
 <refpurpose>
     add modes from EDID data, if available
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>drm_add_edid_modes </function></funcdef>
   <paramdef>struct drm_connector * <parameter>connector</parameter></paramdef>
   <paramdef>struct edid * <parameter>edid</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>connector</parameter></term>
   <listitem>
    <para>
     connector we're probing
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>edid</parameter></term>
   <listitem>
    <para>
     EDID data
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Add the specified modes to the connector's mode list.
</para>
</refsect1>
<refsect1>
<title>Return</title>
<para>
   The number of modes added or 0 if we couldn't find any.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-add-modes-noedid">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_add_modes_noedid</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_add_modes_noedid</refname>
 <refpurpose>
     add modes for the connectors without EDID
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>drm_add_modes_noedid </function></funcdef>
   <paramdef>struct drm_connector * <parameter>connector</parameter></paramdef>
   <paramdef>int <parameter>hdisplay</parameter></paramdef>
   <paramdef>int <parameter>vdisplay</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>connector</parameter></term>
   <listitem>
    <para>
     connector we're probing
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>hdisplay</parameter></term>
   <listitem>
    <para>
     the horizontal display limit
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>vdisplay</parameter></term>
   <listitem>
    <para>
     the vertical display limit
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Add the specified modes to the connector's mode list. Only when the
   hdisplay/vdisplay is not beyond the given limit, it will be added.
</para>
</refsect1>
<refsect1>
<title>Return</title>
<para>
   The number of modes added or 0 if we couldn't find any.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-set-preferred-mode">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_set_preferred_mode</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_set_preferred_mode</refname>
 <refpurpose>
     Sets the preferred mode of a connector
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>drm_set_preferred_mode </function></funcdef>
   <paramdef>struct drm_connector * <parameter>connector</parameter></paramdef>
   <paramdef>int <parameter>hpref</parameter></paramdef>
   <paramdef>int <parameter>vpref</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>connector</parameter></term>
   <listitem>
    <para>
     connector whose mode list should be processed
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>hpref</parameter></term>
   <listitem>
    <para>
     horizontal resolution of preferred mode
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>vpref</parameter></term>
   <listitem>
    <para>
     vertical resolution of preferred mode
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Marks a mode as preferred if it matches the resolution specified by <parameter>hpref</parameter>
   and <parameter>vpref</parameter>.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-hdmi-avi-infoframe-from-display-mode">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_hdmi_avi_infoframe_from_display_mode</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_hdmi_avi_infoframe_from_display_mode</refname>
 <refpurpose>
     fill an HDMI AVI infoframe with data from a DRM display mode
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>drm_hdmi_avi_infoframe_from_display_mode </function></funcdef>
   <paramdef>struct hdmi_avi_infoframe * <parameter>frame</parameter></paramdef>
   <paramdef>const struct drm_display_mode * <parameter>mode</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>frame</parameter></term>
   <listitem>
    <para>
     HDMI AVI infoframe
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>mode</parameter></term>
   <listitem>
    <para>
     DRM display mode
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Return</title>
<para>
   0 on success or a negative error code on failure.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-hdmi-vendor-infoframe-from-display-mode">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_hdmi_vendor_infoframe_from_display_mode</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_hdmi_vendor_infoframe_from_display_mode</refname>
 <refpurpose>
     fill an HDMI infoframe with data from a DRM display mode
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>drm_hdmi_vendor_infoframe_from_display_mode </function></funcdef>
   <paramdef>struct hdmi_vendor_infoframe * <parameter>frame</parameter></paramdef>
   <paramdef>const struct drm_display_mode * <parameter>mode</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>frame</parameter></term>
   <listitem>
    <para>
     HDMI vendor infoframe
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>mode</parameter></term>
   <listitem>
    <para>
     DRM display mode
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Note that there's is a need to send HDMI vendor infoframes only when using a
   4k or stereoscopic 3D mode. So when giving any other mode as input this
   function will return -EINVAL, error that can be safely ignored.
</para>
</refsect1>
<refsect1>
<title>Return</title>
<para>
   0 on success or a negative error code on failure.
</para>
</refsect1>
</refentry>

    </sect2>
    <sect2>
      <title>Rectangle Utilities Reference</title>
<para>
   </para><para>
   Utility functions to help manage rectangular areas for
   clipping, scaling, etc. calculations.
</para>

<!-- include/drm/drm_rect.h -->
<refentry id="API-struct-drm-rect">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct drm_rect</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct drm_rect</refname>
 <refpurpose>
  two dimensional rectangle
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct drm_rect {
  int x1;
  int y1;
  int x2;
  int y2;
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>x1</term>
      <listitem><para>
horizontal starting coordinate (inclusive)
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>y1</term>
      <listitem><para>
vertical starting coordinate (inclusive)
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>x2</term>
      <listitem><para>
horizontal ending coordinate (exclusive)
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>y2</term>
      <listitem><para>
vertical ending coordinate (exclusive)
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
</refentry>

<refentry id="API-drm-rect-adjust-size">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_rect_adjust_size</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_rect_adjust_size</refname>
 <refpurpose>
     adjust the size of the rectangle
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>drm_rect_adjust_size </function></funcdef>
   <paramdef>struct drm_rect * <parameter>r</parameter></paramdef>
   <paramdef>int <parameter>dw</parameter></paramdef>
   <paramdef>int <parameter>dh</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>r</parameter></term>
   <listitem>
    <para>
     rectangle to be adjusted
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>dw</parameter></term>
   <listitem>
    <para>
     horizontal adjustment
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>dh</parameter></term>
   <listitem>
    <para>
     vertical adjustment
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Change the size of rectangle <parameter>r</parameter> by <parameter>dw</parameter> in the horizontal direction,
   and by <parameter>dh</parameter> in the vertical direction, while keeping the center
   of <parameter>r</parameter> stationary.
   </para><para>

   Positive <parameter>dw</parameter> and <parameter>dh</parameter> increase the size, negative values decrease it.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-rect-translate">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_rect_translate</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_rect_translate</refname>
 <refpurpose>
     translate the rectangle
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>drm_rect_translate </function></funcdef>
   <paramdef>struct drm_rect * <parameter>r</parameter></paramdef>
   <paramdef>int <parameter>dx</parameter></paramdef>
   <paramdef>int <parameter>dy</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>r</parameter></term>
   <listitem>
    <para>
     rectangle to be tranlated
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>dx</parameter></term>
   <listitem>
    <para>
     horizontal translation
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>dy</parameter></term>
   <listitem>
    <para>
     vertical translation
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Move rectangle <parameter>r</parameter> by <parameter>dx</parameter> in the horizontal direction,
   and by <parameter>dy</parameter> in the vertical direction.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-rect-downscale">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_rect_downscale</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_rect_downscale</refname>
 <refpurpose>
     downscale a rectangle
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>drm_rect_downscale </function></funcdef>
   <paramdef>struct drm_rect * <parameter>r</parameter></paramdef>
   <paramdef>int <parameter>horz</parameter></paramdef>
   <paramdef>int <parameter>vert</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>r</parameter></term>
   <listitem>
    <para>
     rectangle to be downscaled
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>horz</parameter></term>
   <listitem>
    <para>
     horizontal downscale factor
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>vert</parameter></term>
   <listitem>
    <para>
     vertical downscale factor
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Divide the coordinates of rectangle <parameter>r</parameter> by <parameter>horz</parameter> and <parameter>vert</parameter>.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-rect-width">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_rect_width</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_rect_width</refname>
 <refpurpose>
     determine the rectangle width
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>drm_rect_width </function></funcdef>
   <paramdef>const struct drm_rect * <parameter>r</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>r</parameter></term>
   <listitem>
    <para>
     rectangle whose width is returned
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>RETURNS</title>
<para>
   The width of the rectangle.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-rect-height">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_rect_height</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_rect_height</refname>
 <refpurpose>
     determine the rectangle height
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>drm_rect_height </function></funcdef>
   <paramdef>const struct drm_rect * <parameter>r</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>r</parameter></term>
   <listitem>
    <para>
     rectangle whose height is returned
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>RETURNS</title>
<para>
   The height of the rectangle.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-rect-visible">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_rect_visible</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_rect_visible</refname>
 <refpurpose>
     determine if the the rectangle is visible
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>bool <function>drm_rect_visible </function></funcdef>
   <paramdef>const struct drm_rect * <parameter>r</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>r</parameter></term>
   <listitem>
    <para>
     rectangle whose visibility is returned
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>RETURNS</title>
<para>
   <constant>true</constant> if the rectangle is visible, <constant>false</constant> otherwise.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-rect-equals">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_rect_equals</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_rect_equals</refname>
 <refpurpose>
     determine if two rectangles are equal
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>bool <function>drm_rect_equals </function></funcdef>
   <paramdef>const struct drm_rect * <parameter>r1</parameter></paramdef>
   <paramdef>const struct drm_rect * <parameter>r2</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>r1</parameter></term>
   <listitem>
    <para>
     first rectangle
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>r2</parameter></term>
   <listitem>
    <para>
     second rectangle
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>RETURNS</title>
<para>
   <constant>true</constant> if the rectangles are equal, <constant>false</constant> otherwise.
</para>
</refsect1>
</refentry>

<!-- drivers/gpu/drm/drm_rect.c -->
<refentry id="API-drm-rect-intersect">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_rect_intersect</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_rect_intersect</refname>
 <refpurpose>
  intersect two rectangles
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>bool <function>drm_rect_intersect </function></funcdef>
   <paramdef>struct drm_rect * <parameter>r1</parameter></paramdef>
   <paramdef>const struct drm_rect * <parameter>r2</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>r1</parameter></term>
   <listitem>
    <para>
     first rectangle
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>r2</parameter></term>
   <listitem>
    <para>
     second rectangle
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Calculate the intersection of rectangles <parameter>r1</parameter> and <parameter>r2</parameter>.
   <parameter>r1</parameter> will be overwritten with the intersection.
</para>
</refsect1>
<refsect1>
<title>RETURNS</title>
<para>
   <constant>true</constant> if rectangle <parameter>r1</parameter> is still visible after the operation,
   <constant>false</constant> otherwise.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-rect-clip-scaled">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_rect_clip_scaled</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_rect_clip_scaled</refname>
 <refpurpose>
     perform a scaled clip operation
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>bool <function>drm_rect_clip_scaled </function></funcdef>
   <paramdef>struct drm_rect * <parameter>src</parameter></paramdef>
   <paramdef>struct drm_rect * <parameter>dst</parameter></paramdef>
   <paramdef>const struct drm_rect * <parameter>clip</parameter></paramdef>
   <paramdef>int <parameter>hscale</parameter></paramdef>
   <paramdef>int <parameter>vscale</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>src</parameter></term>
   <listitem>
    <para>
     source window rectangle
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>dst</parameter></term>
   <listitem>
    <para>
     destination window rectangle
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>clip</parameter></term>
   <listitem>
    <para>
     clip rectangle
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>hscale</parameter></term>
   <listitem>
    <para>
     horizontal scaling factor
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>vscale</parameter></term>
   <listitem>
    <para>
     vertical scaling factor
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Clip rectangle <parameter>dst</parameter> by rectangle <parameter>clip</parameter>. Clip rectangle <parameter>src</parameter> by the
   same amounts multiplied by <parameter>hscale</parameter> and <parameter>vscale</parameter>.
</para>
</refsect1>
<refsect1>
<title>RETURNS</title>
<para>
   <constant>true</constant> if rectangle <parameter>dst</parameter> is still visible after being clipped,
   <constant>false</constant> otherwise
</para>
</refsect1>
</refentry>

<refentry id="API-drm-rect-calc-hscale">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_rect_calc_hscale</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_rect_calc_hscale</refname>
 <refpurpose>
     calculate the horizontal scaling factor
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>drm_rect_calc_hscale </function></funcdef>
   <paramdef>const struct drm_rect * <parameter>src</parameter></paramdef>
   <paramdef>const struct drm_rect * <parameter>dst</parameter></paramdef>
   <paramdef>int <parameter>min_hscale</parameter></paramdef>
   <paramdef>int <parameter>max_hscale</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>src</parameter></term>
   <listitem>
    <para>
     source window rectangle
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>dst</parameter></term>
   <listitem>
    <para>
     destination window rectangle
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>min_hscale</parameter></term>
   <listitem>
    <para>
     minimum allowed horizontal scaling factor
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>max_hscale</parameter></term>
   <listitem>
    <para>
     maximum allowed horizontal scaling factor
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Calculate the horizontal scaling factor as
   (<parameter>src</parameter> width) / (<parameter>dst</parameter> width).
</para>
</refsect1>
<refsect1>
<title>RETURNS</title>
<para>
   The horizontal scaling factor, or errno of out of limits.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-rect-calc-vscale">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_rect_calc_vscale</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_rect_calc_vscale</refname>
 <refpurpose>
     calculate the vertical scaling factor
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>drm_rect_calc_vscale </function></funcdef>
   <paramdef>const struct drm_rect * <parameter>src</parameter></paramdef>
   <paramdef>const struct drm_rect * <parameter>dst</parameter></paramdef>
   <paramdef>int <parameter>min_vscale</parameter></paramdef>
   <paramdef>int <parameter>max_vscale</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>src</parameter></term>
   <listitem>
    <para>
     source window rectangle
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>dst</parameter></term>
   <listitem>
    <para>
     destination window rectangle
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>min_vscale</parameter></term>
   <listitem>
    <para>
     minimum allowed vertical scaling factor
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>max_vscale</parameter></term>
   <listitem>
    <para>
     maximum allowed vertical scaling factor
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Calculate the vertical scaling factor as
   (<parameter>src</parameter> height) / (<parameter>dst</parameter> height).
</para>
</refsect1>
<refsect1>
<title>RETURNS</title>
<para>
   The vertical scaling factor, or errno of out of limits.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-rect-calc-hscale-relaxed">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_rect_calc_hscale_relaxed</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_rect_calc_hscale_relaxed</refname>
 <refpurpose>
     calculate the horizontal scaling factor
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>drm_rect_calc_hscale_relaxed </function></funcdef>
   <paramdef>struct drm_rect * <parameter>src</parameter></paramdef>
   <paramdef>struct drm_rect * <parameter>dst</parameter></paramdef>
   <paramdef>int <parameter>min_hscale</parameter></paramdef>
   <paramdef>int <parameter>max_hscale</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>src</parameter></term>
   <listitem>
    <para>
     source window rectangle
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>dst</parameter></term>
   <listitem>
    <para>
     destination window rectangle
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>min_hscale</parameter></term>
   <listitem>
    <para>
     minimum allowed horizontal scaling factor
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>max_hscale</parameter></term>
   <listitem>
    <para>
     maximum allowed horizontal scaling factor
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Calculate the horizontal scaling factor as
   (<parameter>src</parameter> width) / (<parameter>dst</parameter> width).
   </para><para>

   If the calculated scaling factor is below <parameter>min_vscale</parameter>,
   decrease the height of rectangle <parameter>dst</parameter> to compensate.
   </para><para>

   If the calculated scaling factor is above <parameter>max_vscale</parameter>,
   decrease the height of rectangle <parameter>src</parameter> to compensate.
</para>
</refsect1>
<refsect1>
<title>RETURNS</title>
<para>
   The horizontal scaling factor.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-rect-calc-vscale-relaxed">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_rect_calc_vscale_relaxed</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_rect_calc_vscale_relaxed</refname>
 <refpurpose>
     calculate the vertical scaling factor
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>drm_rect_calc_vscale_relaxed </function></funcdef>
   <paramdef>struct drm_rect * <parameter>src</parameter></paramdef>
   <paramdef>struct drm_rect * <parameter>dst</parameter></paramdef>
   <paramdef>int <parameter>min_vscale</parameter></paramdef>
   <paramdef>int <parameter>max_vscale</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>src</parameter></term>
   <listitem>
    <para>
     source window rectangle
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>dst</parameter></term>
   <listitem>
    <para>
     destination window rectangle
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>min_vscale</parameter></term>
   <listitem>
    <para>
     minimum allowed vertical scaling factor
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>max_vscale</parameter></term>
   <listitem>
    <para>
     maximum allowed vertical scaling factor
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Calculate the vertical scaling factor as
   (<parameter>src</parameter> height) / (<parameter>dst</parameter> height).
   </para><para>

   If the calculated scaling factor is below <parameter>min_vscale</parameter>,
   decrease the height of rectangle <parameter>dst</parameter> to compensate.
   </para><para>

   If the calculated scaling factor is above <parameter>max_vscale</parameter>,
   decrease the height of rectangle <parameter>src</parameter> to compensate.
</para>
</refsect1>
<refsect1>
<title>RETURNS</title>
<para>
   The vertical scaling factor.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-rect-debug-print">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_rect_debug_print</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_rect_debug_print</refname>
 <refpurpose>
     print the rectangle information
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>drm_rect_debug_print </function></funcdef>
   <paramdef>const struct drm_rect * <parameter>r</parameter></paramdef>
   <paramdef>bool <parameter>fixed_point</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>r</parameter></term>
   <listitem>
    <para>
     rectangle to print
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>fixed_point</parameter></term>
   <listitem>
    <para>
     rectangle is in 16.16 fixed point format
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-drm-rect-rotate">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_rect_rotate</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_rect_rotate</refname>
 <refpurpose>
     Rotate the rectangle
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>drm_rect_rotate </function></funcdef>
   <paramdef>struct drm_rect * <parameter>r</parameter></paramdef>
   <paramdef>int <parameter>width</parameter></paramdef>
   <paramdef>int <parameter>height</parameter></paramdef>
   <paramdef>unsigned int <parameter>rotation</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>r</parameter></term>
   <listitem>
    <para>
     rectangle to be rotated
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>width</parameter></term>
   <listitem>
    <para>
     Width of the coordinate space
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>height</parameter></term>
   <listitem>
    <para>
     Height of the coordinate space
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>rotation</parameter></term>
   <listitem>
    <para>
     Transformation to be applied
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Apply <parameter>rotation</parameter> to the coordinates of rectangle <parameter>r</parameter>.
   </para><para>

   <parameter>width</parameter> and <parameter>height</parameter> combined with <parameter>rotation</parameter> define
   the location of the new origin.
   </para><para>

   <parameter>width</parameter> correcsponds to the horizontal and <parameter>height</parameter>
   to the vertical axis of the untransformed coordinate
   space.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-rect-rotate-inv">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_rect_rotate_inv</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_rect_rotate_inv</refname>
 <refpurpose>
     Inverse rotate the rectangle
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>drm_rect_rotate_inv </function></funcdef>
   <paramdef>struct drm_rect * <parameter>r</parameter></paramdef>
   <paramdef>int <parameter>width</parameter></paramdef>
   <paramdef>int <parameter>height</parameter></paramdef>
   <paramdef>unsigned int <parameter>rotation</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>r</parameter></term>
   <listitem>
    <para>
     rectangle to be rotated
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>width</parameter></term>
   <listitem>
    <para>
     Width of the coordinate space
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>height</parameter></term>
   <listitem>
    <para>
     Height of the coordinate space
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>rotation</parameter></term>
   <listitem>
    <para>
     Transformation whose inverse is to be applied
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Apply the inverse of <parameter>rotation</parameter> to the coordinates
   of rectangle <parameter>r</parameter>.
   </para><para>

   <parameter>width</parameter> and <parameter>height</parameter> combined with <parameter>rotation</parameter> define
   the location of the new origin.
   </para><para>

   <parameter>width</parameter> correcsponds to the horizontal and <parameter>height</parameter>
   to the vertical axis of the original untransformed
   coordinate space, so that you never have to flip
   them when doing a rotatation and its inverse.
   That is, if you do:
   </para><para>

   drm_rotate(<structname>r</structname>, width, height, rotation);
   drm_rotate_inv(<structname>r</structname>, width, height, rotation);
   </para><para>

   you will always get back the original rectangle.
</para>
</refsect1>
</refentry>

    </sect2>
    <sect2>
      <title>Flip-work Helper Reference</title>
<para>
   </para><para>
   Util to queue up work to run from work-queue context after flip/vblank.
   Typically this can be used to defer unref of framebuffer's, cursor
   bo's, etc until after vblank.  The APIs are all safe (and lockless)
   for up to one producer and once consumer at a time.  The single-consumer
   aspect is ensured by committing the queued work to a single work-queue.
</para>

<!-- include/drm/drm_flip_work.h -->
<refentry id="API-struct-drm-flip-work">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct drm_flip_work</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct drm_flip_work</refname>
 <refpurpose>
  flip work queue
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct drm_flip_work {
  const char * name;
  atomic_t pending;
  atomic_t count;
  drm_flip_func_t func;
  struct work_struct worker;
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>name</term>
      <listitem><para>
debug name
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>pending</term>
      <listitem><para>
number of queued but not committed items
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>count</term>
      <listitem><para>
number of committed items
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>func</term>
      <listitem><para>
callback fxn called for each committed item
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>worker</term>
      <listitem><para>
worker which calls <parameter>func</parameter>
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
</refentry>

<!-- drivers/gpu/drm/drm_flip_work.c -->
<refentry id="API-drm-flip-work-queue">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_flip_work_queue</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_flip_work_queue</refname>
 <refpurpose>
  queue work
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>drm_flip_work_queue </function></funcdef>
   <paramdef>struct drm_flip_work * <parameter>work</parameter></paramdef>
   <paramdef>void * <parameter>val</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>work</parameter></term>
   <listitem>
    <para>
     the flip-work
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>val</parameter></term>
   <listitem>
    <para>
     the value to queue
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Queues work, that will later be run (passed back to drm_flip_func_t
   func) on a work queue after <function>drm_flip_work_commit</function> is called.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-flip-work-commit">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_flip_work_commit</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_flip_work_commit</refname>
 <refpurpose>
     commit queued work
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>drm_flip_work_commit </function></funcdef>
   <paramdef>struct drm_flip_work * <parameter>work</parameter></paramdef>
   <paramdef>struct workqueue_struct * <parameter>wq</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>work</parameter></term>
   <listitem>
    <para>
     the flip-work
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>wq</parameter></term>
   <listitem>
    <para>
     the work-queue to run the queued work on
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Trigger work previously queued by <function>drm_flip_work_queue</function> to run
   on a workqueue.  The typical usage would be to queue work (via
   <function>drm_flip_work_queue</function>) at any point (from vblank irq and/or
   prior), and then from vblank irq commit the queued work.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-flip-work-init">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_flip_work_init</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_flip_work_init</refname>
 <refpurpose>
     initialize flip-work
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>drm_flip_work_init </function></funcdef>
   <paramdef>struct drm_flip_work * <parameter>work</parameter></paramdef>
   <paramdef>int <parameter>size</parameter></paramdef>
   <paramdef>const char * <parameter>name</parameter></paramdef>
   <paramdef>drm_flip_func_t <parameter>func</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>work</parameter></term>
   <listitem>
    <para>
     the flip-work to initialize
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>size</parameter></term>
   <listitem>
    <para>
     the max queue depth
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>name</parameter></term>
   <listitem>
    <para>
     debug name
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>func</parameter></term>
   <listitem>
    <para>
     the callback work function
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Initializes/allocates resources for the flip-work
</para>
</refsect1>
<refsect1>
<title>RETURNS</title>
<para>
   Zero on success, error code on failure.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-flip-work-cleanup">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_flip_work_cleanup</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_flip_work_cleanup</refname>
 <refpurpose>
     cleans up flip-work
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>drm_flip_work_cleanup </function></funcdef>
   <paramdef>struct drm_flip_work * <parameter>work</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>work</parameter></term>
   <listitem>
    <para>
     the flip-work to cleanup
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Destroy resources allocated for the flip-work
</para>
</refsect1>
</refentry>

    </sect2>
    <sect2>
      <title>HDMI Infoframes Helper Reference</title>
      <para>
	Strictly speaking this is not a DRM helper library but generally useable
	by any driver interfacing with HDMI outputs like v4l or alsa drivers.
	But it nicely fits into the overall topic of mode setting helper
	libraries and hence is also included here.
      </para>
<!-- include/linux/hdmi.h -->
<refentry id="API-struct-hdmi-infoframe">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>union hdmi_infoframe</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>union hdmi_infoframe</refname>
 <refpurpose>
  overall union of all abstract infoframe representations
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
union hdmi_infoframe {
  struct hdmi_any_infoframe any;
  struct hdmi_avi_infoframe avi;
  struct hdmi_spd_infoframe spd;
  union hdmi_vendor_any_infoframe vendor;
  struct hdmi_audio_infoframe audio;
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>any</term>
      <listitem><para>
generic infoframe
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>avi</term>
      <listitem><para>
avi infoframe
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>spd</term>
      <listitem><para>
spd infoframe
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>vendor</term>
      <listitem><para>
union of all vendor infoframes
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>audio</term>
      <listitem><para>
audio infoframe
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
<refsect1>
<title>Description</title>
<para>
   This is used by the generic pack function. This works since all infoframes
   have the same header which also indicates which type of infoframe should be
   packed.
</para>
</refsect1>
</refentry>

<!-- drivers/video/hdmi.c -->
<refentry id="API-hdmi-avi-infoframe-init">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>hdmi_avi_infoframe_init</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>hdmi_avi_infoframe_init</refname>
 <refpurpose>
  initialize an HDMI AVI infoframe
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>hdmi_avi_infoframe_init </function></funcdef>
   <paramdef>struct hdmi_avi_infoframe * <parameter>frame</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>frame</parameter></term>
   <listitem>
    <para>
     HDMI AVI infoframe
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Returns 0 on success or a negative error code on failure.
</para>
</refsect1>
</refentry>

<refentry id="API-hdmi-avi-infoframe-pack">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>hdmi_avi_infoframe_pack</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>hdmi_avi_infoframe_pack</refname>
 <refpurpose>
     write HDMI AVI infoframe to binary buffer
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>ssize_t <function>hdmi_avi_infoframe_pack </function></funcdef>
   <paramdef>struct hdmi_avi_infoframe * <parameter>frame</parameter></paramdef>
   <paramdef>void * <parameter>buffer</parameter></paramdef>
   <paramdef>size_t <parameter>size</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>frame</parameter></term>
   <listitem>
    <para>
     HDMI AVI infoframe
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>buffer</parameter></term>
   <listitem>
    <para>
     destination buffer
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>size</parameter></term>
   <listitem>
    <para>
     size of buffer
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Packs the information contained in the <parameter>frame</parameter> structure into a binary
   representation that can be written into the corresponding controller
   registers. Also computes the checksum as required by section 5.3.5 of
   the HDMI 1.4 specification.
   </para><para>

   Returns the number of bytes packed into the binary buffer or a negative
   error code on failure.
</para>
</refsect1>
</refentry>

<refentry id="API-hdmi-spd-infoframe-init">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>hdmi_spd_infoframe_init</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>hdmi_spd_infoframe_init</refname>
 <refpurpose>
     initialize an HDMI SPD infoframe
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>hdmi_spd_infoframe_init </function></funcdef>
   <paramdef>struct hdmi_spd_infoframe * <parameter>frame</parameter></paramdef>
   <paramdef>const char * <parameter>vendor</parameter></paramdef>
   <paramdef>const char * <parameter>product</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>frame</parameter></term>
   <listitem>
    <para>
     HDMI SPD infoframe
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>vendor</parameter></term>
   <listitem>
    <para>
     vendor string
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>product</parameter></term>
   <listitem>
    <para>
     product string
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Returns 0 on success or a negative error code on failure.
</para>
</refsect1>
</refentry>

<refentry id="API-hdmi-spd-infoframe-pack">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>hdmi_spd_infoframe_pack</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>hdmi_spd_infoframe_pack</refname>
 <refpurpose>
     write HDMI SPD infoframe to binary buffer
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>ssize_t <function>hdmi_spd_infoframe_pack </function></funcdef>
   <paramdef>struct hdmi_spd_infoframe * <parameter>frame</parameter></paramdef>
   <paramdef>void * <parameter>buffer</parameter></paramdef>
   <paramdef>size_t <parameter>size</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>frame</parameter></term>
   <listitem>
    <para>
     HDMI SPD infoframe
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>buffer</parameter></term>
   <listitem>
    <para>
     destination buffer
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>size</parameter></term>
   <listitem>
    <para>
     size of buffer
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Packs the information contained in the <parameter>frame</parameter> structure into a binary
   representation that can be written into the corresponding controller
   registers. Also computes the checksum as required by section 5.3.5 of
   the HDMI 1.4 specification.
   </para><para>

   Returns the number of bytes packed into the binary buffer or a negative
   error code on failure.
</para>
</refsect1>
</refentry>

<refentry id="API-hdmi-audio-infoframe-init">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>hdmi_audio_infoframe_init</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>hdmi_audio_infoframe_init</refname>
 <refpurpose>
     initialize an HDMI audio infoframe
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>hdmi_audio_infoframe_init </function></funcdef>
   <paramdef>struct hdmi_audio_infoframe * <parameter>frame</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>frame</parameter></term>
   <listitem>
    <para>
     HDMI audio infoframe
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Returns 0 on success or a negative error code on failure.
</para>
</refsect1>
</refentry>

<refentry id="API-hdmi-audio-infoframe-pack">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>hdmi_audio_infoframe_pack</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>hdmi_audio_infoframe_pack</refname>
 <refpurpose>
     write HDMI audio infoframe to binary buffer
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>ssize_t <function>hdmi_audio_infoframe_pack </function></funcdef>
   <paramdef>struct hdmi_audio_infoframe * <parameter>frame</parameter></paramdef>
   <paramdef>void * <parameter>buffer</parameter></paramdef>
   <paramdef>size_t <parameter>size</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>frame</parameter></term>
   <listitem>
    <para>
     HDMI audio infoframe
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>buffer</parameter></term>
   <listitem>
    <para>
     destination buffer
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>size</parameter></term>
   <listitem>
    <para>
     size of buffer
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Packs the information contained in the <parameter>frame</parameter> structure into a binary
   representation that can be written into the corresponding controller
   registers. Also computes the checksum as required by section 5.3.5 of
   the HDMI 1.4 specification.
   </para><para>

   Returns the number of bytes packed into the binary buffer or a negative
   error code on failure.
</para>
</refsect1>
</refentry>

<refentry id="API-hdmi-vendor-infoframe-init">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>hdmi_vendor_infoframe_init</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>hdmi_vendor_infoframe_init</refname>
 <refpurpose>
     initialize an HDMI vendor infoframe
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>hdmi_vendor_infoframe_init </function></funcdef>
   <paramdef>struct hdmi_vendor_infoframe * <parameter>frame</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>frame</parameter></term>
   <listitem>
    <para>
     HDMI vendor infoframe
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Returns 0 on success or a negative error code on failure.
</para>
</refsect1>
</refentry>

<refentry id="API-hdmi-vendor-infoframe-pack">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>hdmi_vendor_infoframe_pack</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>hdmi_vendor_infoframe_pack</refname>
 <refpurpose>
     write a HDMI vendor infoframe to binary buffer
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>ssize_t <function>hdmi_vendor_infoframe_pack </function></funcdef>
   <paramdef>struct hdmi_vendor_infoframe * <parameter>frame</parameter></paramdef>
   <paramdef>void * <parameter>buffer</parameter></paramdef>
   <paramdef>size_t <parameter>size</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>frame</parameter></term>
   <listitem>
    <para>
     HDMI infoframe
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>buffer</parameter></term>
   <listitem>
    <para>
     destination buffer
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>size</parameter></term>
   <listitem>
    <para>
     size of buffer
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Packs the information contained in the <parameter>frame</parameter> structure into a binary
   representation that can be written into the corresponding controller
   registers. Also computes the checksum as required by section 5.3.5 of
   the HDMI 1.4 specification.
   </para><para>

   Returns the number of bytes packed into the binary buffer or a negative
   error code on failure.
</para>
</refsect1>
</refentry>

<refentry id="API-hdmi-infoframe-pack">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>hdmi_infoframe_pack</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>hdmi_infoframe_pack</refname>
 <refpurpose>
     write a HDMI infoframe to binary buffer
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>ssize_t <function>hdmi_infoframe_pack </function></funcdef>
   <paramdef>union hdmi_infoframe * <parameter>frame</parameter></paramdef>
   <paramdef>void * <parameter>buffer</parameter></paramdef>
   <paramdef>size_t <parameter>size</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>frame</parameter></term>
   <listitem>
    <para>
     HDMI infoframe
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>buffer</parameter></term>
   <listitem>
    <para>
     destination buffer
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>size</parameter></term>
   <listitem>
    <para>
     size of buffer
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Packs the information contained in the <parameter>frame</parameter> structure into a binary
   representation that can be written into the corresponding controller
   registers. Also computes the checksum as required by section 5.3.5 of
   the HDMI 1.4 specification.
   </para><para>

   Returns the number of bytes packed into the binary buffer or a negative
   error code on failure.
</para>
</refsect1>
</refentry>

    </sect2>
    <sect2>
      <title id="drm-kms-planehelpers">Plane Helper Reference</title>
<!-- drivers/gpu/drm/drm_plane_helper.c -->
<refentry id="API-drm-plane-helper-check-update">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_plane_helper_check_update</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_plane_helper_check_update</refname>
 <refpurpose>
  Check plane update for validity
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>drm_plane_helper_check_update </function></funcdef>
   <paramdef>struct drm_plane * <parameter>plane</parameter></paramdef>
   <paramdef>struct drm_crtc * <parameter>crtc</parameter></paramdef>
   <paramdef>struct drm_framebuffer * <parameter>fb</parameter></paramdef>
   <paramdef>struct drm_rect * <parameter>src</parameter></paramdef>
   <paramdef>struct drm_rect * <parameter>dest</parameter></paramdef>
   <paramdef>const struct drm_rect * <parameter>clip</parameter></paramdef>
   <paramdef>int <parameter>min_scale</parameter></paramdef>
   <paramdef>int <parameter>max_scale</parameter></paramdef>
   <paramdef>bool <parameter>can_position</parameter></paramdef>
   <paramdef>bool <parameter>can_update_disabled</parameter></paramdef>
   <paramdef>bool * <parameter>visible</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>plane</parameter></term>
   <listitem>
    <para>
     plane object to update
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>crtc</parameter></term>
   <listitem>
    <para>
     owning CRTC of owning plane
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>fb</parameter></term>
   <listitem>
    <para>
     framebuffer to flip onto plane
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>src</parameter></term>
   <listitem>
    <para>
     source coordinates in 16.16 fixed point
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>dest</parameter></term>
   <listitem>
    <para>
     integer destination coordinates
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>clip</parameter></term>
   <listitem>
    <para>
     integer clipping coordinates
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>min_scale</parameter></term>
   <listitem>
    <para>
     minimum <parameter>src</parameter>:<parameter>dest</parameter> scaling factor in 16.16 fixed point
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>max_scale</parameter></term>
   <listitem>
    <para>
     maximum <parameter>src</parameter>:<parameter>dest</parameter> scaling factor in 16.16 fixed point
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>can_position</parameter></term>
   <listitem>
    <para>
     is it legal to position the plane such that it
     doesn't cover the entire crtc?  This will generally
     only be false for primary planes.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>can_update_disabled</parameter></term>
   <listitem>
    <para>
     can the plane be updated while the crtc
     is disabled?
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>visible</parameter></term>
   <listitem>
    <para>
     output parameter indicating whether plane is still visible after
     clipping
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Checks that a desired plane update is valid.  Drivers that provide
   their own plane handling rather than helper-provided implementations may
   still wish to call this function to avoid duplication of error checking
   code.
</para>
</refsect1>
<refsect1>
<title>RETURNS</title>
<para>
   Zero if update appears valid, error code on failure
</para>
</refsect1>
</refentry>

<refentry id="API-drm-primary-helper-update">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_primary_helper_update</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_primary_helper_update</refname>
 <refpurpose>
     Helper for primary plane update
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>drm_primary_helper_update </function></funcdef>
   <paramdef>struct drm_plane * <parameter>plane</parameter></paramdef>
   <paramdef>struct drm_crtc * <parameter>crtc</parameter></paramdef>
   <paramdef>struct drm_framebuffer * <parameter>fb</parameter></paramdef>
   <paramdef>int <parameter>crtc_x</parameter></paramdef>
   <paramdef>int <parameter>crtc_y</parameter></paramdef>
   <paramdef>unsigned int <parameter>crtc_w</parameter></paramdef>
   <paramdef>unsigned int <parameter>crtc_h</parameter></paramdef>
   <paramdef>uint32_t <parameter>src_x</parameter></paramdef>
   <paramdef>uint32_t <parameter>src_y</parameter></paramdef>
   <paramdef>uint32_t <parameter>src_w</parameter></paramdef>
   <paramdef>uint32_t <parameter>src_h</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>plane</parameter></term>
   <listitem>
    <para>
     plane object to update
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>crtc</parameter></term>
   <listitem>
    <para>
     owning CRTC of owning plane
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>fb</parameter></term>
   <listitem>
    <para>
     framebuffer to flip onto plane
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>crtc_x</parameter></term>
   <listitem>
    <para>
     x offset of primary plane on crtc
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>crtc_y</parameter></term>
   <listitem>
    <para>
     y offset of primary plane on crtc
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>crtc_w</parameter></term>
   <listitem>
    <para>
     width of primary plane rectangle on crtc
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>crtc_h</parameter></term>
   <listitem>
    <para>
     height of primary plane rectangle on crtc
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>src_x</parameter></term>
   <listitem>
    <para>
     x offset of <parameter>fb</parameter> for panning
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>src_y</parameter></term>
   <listitem>
    <para>
     y offset of <parameter>fb</parameter> for panning
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>src_w</parameter></term>
   <listitem>
    <para>
     width of source rectangle in <parameter>fb</parameter>
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>src_h</parameter></term>
   <listitem>
    <para>
     height of source rectangle in <parameter>fb</parameter>
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Provides a default plane update handler for primary planes.  This is handler
   is called in response to a userspace SetPlane operation on the plane with a
   non-NULL framebuffer.  We call the driver's modeset handler to update the
   framebuffer.
   </para><para>

   <function>SetPlane</function> on a primary plane of a disabled CRTC is not supported, and will
   return an error.
   </para><para>

   Note that we make some assumptions about hardware limitations that may not be
   true for all hardware --
   1) Primary plane cannot be repositioned.
   2) Primary plane cannot be scaled.
   3) Primary plane must cover the entire CRTC.
   4) Subpixel positioning is not supported.
   Drivers for hardware that don't have these restrictions can provide their
   own implementation rather than using this helper.
</para>
</refsect1>
<refsect1>
<title>RETURNS</title>
<para>
   Zero on success, error code on failure
</para>
</refsect1>
</refentry>

<refentry id="API-drm-primary-helper-disable">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_primary_helper_disable</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_primary_helper_disable</refname>
 <refpurpose>
     Helper for primary plane disable
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>drm_primary_helper_disable </function></funcdef>
   <paramdef>struct drm_plane * <parameter>plane</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>plane</parameter></term>
   <listitem>
    <para>
     plane to disable
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Provides a default plane disable handler for primary planes.  This is handler
   is called in response to a userspace SetPlane operation on the plane with a
   NULL framebuffer parameter.  It unconditionally fails the disable call with
   -EINVAL the only way to disable the primary plane without driver support is
   to disable the entier CRTC. Which does not match the plane -&gt;disable hook.
   </para><para>

   Note that some hardware may be able to disable the primary plane without
   disabling the whole CRTC.  Drivers for such hardware should provide their
   own disable handler that disables just the primary plane (and they'll likely
   need to provide their own update handler as well to properly re-enable a
   disabled primary plane).
</para>
</refsect1>
<refsect1>
<title>RETURNS</title>
<para>
   Unconditionally returns -EINVAL.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-primary-helper-destroy">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_primary_helper_destroy</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_primary_helper_destroy</refname>
 <refpurpose>
     Helper for primary plane destruction
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>drm_primary_helper_destroy </function></funcdef>
   <paramdef>struct drm_plane * <parameter>plane</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>plane</parameter></term>
   <listitem>
    <para>
     plane to destroy
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Provides a default plane destroy handler for primary planes.  This handler
   is called during CRTC destruction.  We disable the primary plane, remove
   it from the DRM plane list, and deallocate the plane structure.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-primary-helper-create-plane">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_primary_helper_create_plane</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_primary_helper_create_plane</refname>
 <refpurpose>
     Create a generic primary plane
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct drm_plane * <function>drm_primary_helper_create_plane </function></funcdef>
   <paramdef>struct drm_device * <parameter>dev</parameter></paramdef>
   <paramdef>const uint32_t * <parameter>formats</parameter></paramdef>
   <paramdef>int <parameter>num_formats</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     drm device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>formats</parameter></term>
   <listitem>
    <para>
     pixel formats supported, or NULL for a default safe list
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>num_formats</parameter></term>
   <listitem>
    <para>
     size of <parameter>formats</parameter>; ignored if <parameter>formats</parameter> is NULL
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Allocates and initializes a primary plane that can be used with the primary
   plane helpers.  Drivers that wish to use driver-specific plane structures or
   provide custom handler functions may perform their own allocation and
   initialization rather than calling this function.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-crtc-init">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_crtc_init</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_crtc_init</refname>
 <refpurpose>
     Legacy CRTC initialization function
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>drm_crtc_init </function></funcdef>
   <paramdef>struct drm_device * <parameter>dev</parameter></paramdef>
   <paramdef>struct drm_crtc * <parameter>crtc</parameter></paramdef>
   <paramdef>const struct drm_crtc_funcs * <parameter>funcs</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     DRM device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>crtc</parameter></term>
   <listitem>
    <para>
     CRTC object to init
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>funcs</parameter></term>
   <listitem>
    <para>
     callbacks for the new CRTC
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Initialize a CRTC object with a default helper-provided primary plane and no
   cursor plane.
</para>
</refsect1>
<refsect1>
<title>Returns</title>
<para>
   Zero on success, error code on failure.
</para>
</refsect1>
</refentry>

    </sect2>
  </sect1>

  <!-- Internals: kms properties -->

  <sect1 id="drm-kms-properties">
    <title>KMS Properties</title>
    <para>
      Drivers may need to expose additional parameters to applications than
      those described in the previous sections. KMS supports attaching
      properties to CRTCs, connectors and planes and offers a userspace API to
      list, get and set the property values.
    </para>
    <para>
      Properties are identified by a name that uniquely defines the property
      purpose, and store an associated value. For all property types except blob
      properties the value is a 64-bit unsigned integer.
    </para>
    <para>
      KMS differentiates between properties and property instances. Drivers
      first create properties and then create and associate individual instances
      of those properties to objects. A property can be instantiated multiple
      times and associated with different objects. Values are stored in property
      instances, and all other property information are stored in the property
      and shared between all instances of the property.
    </para>
    <para>
      Every property is created with a type that influences how the KMS core
      handles the property. Supported property types are
      <variablelist>
        <varlistentry>
          <term>DRM_MODE_PROP_RANGE</term>
          <listitem><para>Range properties report their minimum and maximum
            admissible values. The KMS core verifies that values set by
            application fit in that range.</para></listitem>
        </varlistentry>
        <varlistentry>
          <term>DRM_MODE_PROP_ENUM</term>
          <listitem><para>Enumerated properties take a numerical value that
            ranges from 0 to the number of enumerated values defined by the
            property minus one, and associate a free-formed string name to each
            value. Applications can retrieve the list of defined value-name pairs
            and use the numerical value to get and set property instance values.
            </para></listitem>
        </varlistentry>
        <varlistentry>
          <term>DRM_MODE_PROP_BITMASK</term>
          <listitem><para>Bitmask properties are enumeration properties that
            additionally restrict all enumerated values to the 0..63 range.
            Bitmask property instance values combine one or more of the
            enumerated bits defined by the property.</para></listitem>
        </varlistentry>
        <varlistentry>
          <term>DRM_MODE_PROP_BLOB</term>
          <listitem><para>Blob properties store a binary blob without any format
            restriction. The binary blobs are created as KMS standalone objects,
            and blob property instance values store the ID of their associated
            blob object.</para>
	    <para>Blob properties are only used for the connector EDID property
	    and cannot be created by drivers.</para></listitem>
        </varlistentry>
      </variablelist>
    </para>
    <para>
      To create a property drivers call one of the following functions depending
      on the property type. All property creation functions take property flags
      and name, as well as type-specific arguments.
      <itemizedlist>
        <listitem>
          <synopsis>struct drm_property *drm_property_create_range(struct drm_device *dev, int flags,
                                               const char *name,
                                               uint64_t min, uint64_t max);</synopsis>
          <para>Create a range property with the given minimum and maximum
            values.</para>
        </listitem>
        <listitem>
          <synopsis>struct drm_property *drm_property_create_enum(struct drm_device *dev, int flags,
                                              const char *name,
                                              const struct drm_prop_enum_list *props,
                                              int num_values);</synopsis>
          <para>Create an enumerated property. The <parameter>props</parameter>
            argument points to an array of <parameter>num_values</parameter>
            value-name pairs.</para>
        </listitem>
        <listitem>
          <synopsis>struct drm_property *drm_property_create_bitmask(struct drm_device *dev,
                                                 int flags, const char *name,
                                                 const struct drm_prop_enum_list *props,
                                                 int num_values);</synopsis>
          <para>Create a bitmask property. The <parameter>props</parameter>
            argument points to an array of <parameter>num_values</parameter>
            value-name pairs.</para>
        </listitem>
      </itemizedlist>
    </para>
    <para>
      Properties can additionally be created as immutable, in which case they
      will be read-only for applications but can be modified by the driver. To
      create an immutable property drivers must set the DRM_MODE_PROP_IMMUTABLE
      flag at property creation time.
    </para>
    <para>
      When no array of value-name pairs is readily available at property
      creation time for enumerated or range properties, drivers can create
      the property using the <function>drm_property_create</function> function
      and manually add enumeration value-name pairs by calling the
      <function>drm_property_add_enum</function> function. Care must be taken to
      properly specify the property type through the <parameter>flags</parameter>
      argument.
    </para>
    <para>
      After creating properties drivers can attach property instances to CRTC,
      connector and plane objects by calling the
      <function>drm_object_attach_property</function>. The function takes a
      pointer to the target object, a pointer to the previously created property
      and an initial instance value.
    </para>
    <sect2>
	<title>Existing KMS Properties</title>
	<para>
	The following table gives description of drm properties exposed by various
	modules/drivers.
	</para>
	<table border="1" cellpadding="0" cellspacing="0">
	<tbody>
	<tr style="font-weight: bold;">
	<td valign="top" >Owner Module/Drivers</td>
	<td valign="top" >Group</td>
	<td valign="top" >Property Name</td>
	<td valign="top" >Type</td>
	<td valign="top" >Property Values</td>
	<td valign="top" >Object attached</td>
	<td valign="top" >Description/Restrictions</td>
	</tr>
	<tr>
	<td rowspan="21" valign="top" >DRM</td>
	<td rowspan="2" valign="top" >Generic</td>
	<td valign="top" >EDID</td>
	<td valign="top" >BLOB | IMMUTABLE</td>
	<td valign="top" >0</td>
	<td valign="top" >Connector</td>
	<td valign="top" >Contains id of edid blob ptr object.</td>
	</tr>
	<tr>
	<td valign="top" >DPMS</td>
	<td valign="top" >ENUM</td>
	<td valign="top" >{ On, Standby, Suspend, Off }</td>
	<td valign="top" >Connector</td>
	<td valign="top" >Contains DPMS operation mode value.</td>
	</tr>
	<tr>
	<td rowspan="1" valign="top" >Plane</td>
	<td valign="top" >type</td>
	<td valign="top" >ENUM | IMMUTABLE</td>
	<td valign="top" >{ "Overlay", "Primary", "Cursor" }</td>
	<td valign="top" >Plane</td>
	<td valign="top" >Plane type</td>
	</tr>
	<tr>
	<td rowspan="2" valign="top" >DVI-I</td>
	<td valign="top" >subconnector</td>
	<td valign="top" >ENUM</td>
	<td valign="top" >{ Unknown, DVI-D, DVI-A }</td>
	<td valign="top" >Connector</td>
	<td valign="top" >TBD</td>
	</tr>
	<tr>
	<td valign="top" >select subconnector</td>
	<td valign="top" >ENUM</td>
	<td valign="top" >{ Automatic, DVI-D, DVI-A }</td>
	<td valign="top" >Connector</td>
	<td valign="top" >TBD</td>
	</tr>
	<tr>
	<td rowspan="13" valign="top" >TV</td>
	<td valign="top" >subconnector</td>
	<td valign="top" >ENUM</td>
	<td valign="top" >{ "Unknown", "Composite", "SVIDEO", "Component", "SCART" }</td>
	<td valign="top" >Connector</td>
	<td valign="top" >TBD</td>
	</tr>
	<tr>
	<td valign="top" >select subconnector</td>
	<td valign="top" >ENUM</td>
	<td valign="top" >{ "Automatic", "Composite", "SVIDEO", "Component", "SCART" }</td>
	<td valign="top" >Connector</td>
	<td valign="top" >TBD</td>
	</tr>
	<tr>
	<td valign="top" >mode</td>
	<td valign="top" >ENUM</td>
	<td valign="top" >{ "NTSC_M", "NTSC_J", "NTSC_443", "PAL_B" } etc.</td>
	<td valign="top" >Connector</td>
	<td valign="top" >TBD</td>
	</tr>
	<tr>
	<td valign="top" >left margin</td>
	<td valign="top" >RANGE</td>
	<td valign="top" >Min=0, Max=100</td>
	<td valign="top" >Connector</td>
	<td valign="top" >TBD</td>
	</tr>
	<tr>
	<td valign="top" >right margin</td>
	<td valign="top" >RANGE</td>
	<td valign="top" >Min=0, Max=100</td>
	<td valign="top" >Connector</td>
	<td valign="top" >TBD</td>
	</tr>
	<tr>
	<td valign="top" >top margin</td>
	<td valign="top" >RANGE</td>
	<td valign="top" >Min=0, Max=100</td>
	<td valign="top" >Connector</td>
	<td valign="top" >TBD</td>
	</tr>
	<tr>
	<td valign="top" >bottom margin</td>
	<td valign="top" >RANGE</td>
	<td valign="top" >Min=0, Max=100</td>
	<td valign="top" >Connector</td>
	<td valign="top" >TBD</td>
	</tr>
	<tr>
	<td valign="top" >brightness</td>
	<td valign="top" >RANGE</td>
	<td valign="top" >Min=0, Max=100</td>
	<td valign="top" >Connector</td>
	<td valign="top" >TBD</td>
	</tr>
	<tr>
	<td valign="top" >contrast</td>
	<td valign="top" >RANGE</td>
	<td valign="top" >Min=0, Max=100</td>
	<td valign="top" >Connector</td>
	<td valign="top" >TBD</td>
	</tr>
	<tr>
	<td valign="top" >flicker reduction</td>
	<td valign="top" >RANGE</td>
	<td valign="top" >Min=0, Max=100</td>
	<td valign="top" >Connector</td>
	<td valign="top" >TBD</td>
	</tr>
	<tr>
	<td valign="top" >overscan</td>
	<td valign="top" >RANGE</td>
	<td valign="top" >Min=0, Max=100</td>
	<td valign="top" >Connector</td>
	<td valign="top" >TBD</td>
	</tr>
	<tr>
	<td valign="top" >saturation</td>
	<td valign="top" >RANGE</td>
	<td valign="top" >Min=0, Max=100</td>
	<td valign="top" >Connector</td>
	<td valign="top" >TBD</td>
	</tr>
	<tr>
	<td valign="top" >hue</td>
	<td valign="top" >RANGE</td>
	<td valign="top" >Min=0, Max=100</td>
	<td valign="top" >Connector</td>
	<td valign="top" >TBD</td>
	</tr>
	<tr>
	<td rowspan="3" valign="top" >Optional</td>
	<td valign="top" >scaling mode</td>
	<td valign="top" >ENUM</td>
	<td valign="top" >{ "None", "Full", "Center", "Full aspect" }</td>
	<td valign="top" >Connector</td>
	<td valign="top" >TBD</td>
	</tr>
	<tr>
	<td valign="top" >"aspect ratio"</td>
	<td valign="top" >ENUM</td>
	<td valign="top" >{ "None", "4:3", "16:9" }</td>
	<td valign="top" >Connector</td>
	<td valign="top" >DRM property to set aspect ratio from user space app.
		This enum is made generic to allow addition of custom aspect
		ratios.</td>
	</tr>
	<tr>
	<td valign="top" >dirty</td>
	<td valign="top" >ENUM | IMMUTABLE</td>
	<td valign="top" >{ "Off", "On", "Annotate" }</td>
	<td valign="top" >Connector</td>
	<td valign="top" >TBD</td>
	</tr>
	<tr>
	<td rowspan="21" valign="top" >i915</td>
	<td rowspan="2" valign="top" >Generic</td>
	<td valign="top" >"Broadcast RGB"</td>
	<td valign="top" >ENUM</td>
	<td valign="top" >{ "Automatic", "Full", "Limited 16:235" }</td>
	<td valign="top" >Connector</td>
	<td valign="top" >TBD</td>
	</tr>
	<tr>
	<td valign="top" >audio</td>
	<td valign="top" >ENUM</td>
	<td valign="top" >{ "force-dvi", "off", "auto", "on" }</td>
	<td valign="top" >Connector</td>
	<td valign="top" >TBD</td>
	</tr>
	<tr>
	<td rowspan="1" valign="top" >Plane</td>
	<td valign="top" >rotation</td>
	<td valign="top" >BITMASK</td>
	<td valign="top" >{ 0, "rotate-0" }, { 2, "rotate-180" }</td>
	<td valign="top" >Plane</td>
	<td valign="top" >TBD</td>
	</tr>
	<tr>
	<td rowspan="17" valign="top" >SDVO-TV</td>
	<td valign="top" >mode</td>
	<td valign="top" >ENUM</td>
	<td valign="top" >{ "NTSC_M", "NTSC_J", "NTSC_443", "PAL_B" } etc.</td>
	<td valign="top" >Connector</td>
	<td valign="top" >TBD</td>
	</tr>
	<tr>
	<td valign="top" >"left_margin"</td>
	<td valign="top" >RANGE</td>
	<td valign="top" >Min=0, Max= SDVO dependent</td>
	<td valign="top" >Connector</td>
	<td valign="top" >TBD</td>
	</tr>
	<tr>
	<td valign="top" >"right_margin"</td>
	<td valign="top" >RANGE</td>
	<td valign="top" >Min=0, Max= SDVO dependent</td>
	<td valign="top" >Connector</td>
	<td valign="top" >TBD</td>
	</tr>
	<tr>
	<td valign="top" >"top_margin"</td>
	<td valign="top" >RANGE</td>
	<td valign="top" >Min=0, Max= SDVO dependent</td>
	<td valign="top" >Connector</td>
	<td valign="top" >TBD</td>
	</tr>
	<tr>
	<td valign="top" >"bottom_margin"</td>
	<td valign="top" >RANGE</td>
	<td valign="top" >Min=0, Max= SDVO dependent</td>
	<td valign="top" >Connector</td>
	<td valign="top" >TBD</td>
	</tr>
	<tr>
	<td valign="top" >hpos</td>
	<td valign="top" >RANGE</td>
	<td valign="top" >Min=0, Max= SDVO dependent</td>
	<td valign="top" >Connector</td>
	<td valign="top" >TBD</td>
	</tr>
	<tr>
	<td valign="top" >vpos</td>
	<td valign="top" >RANGE</td>
	<td valign="top" >Min=0, Max= SDVO dependent</td>
	<td valign="top" >Connector</td>
	<td valign="top" >TBD</td>
	</tr>
	<tr>
	<td valign="top" >contrast</td>
	<td valign="top" >RANGE</td>
	<td valign="top" >Min=0, Max= SDVO dependent</td>
	<td valign="top" >Connector</td>
	<td valign="top" >TBD</td>
	</tr>
	<tr>
	<td valign="top" >saturation</td>
	<td valign="top" >RANGE</td>
	<td valign="top" >Min=0, Max= SDVO dependent</td>
	<td valign="top" >Connector</td>
	<td valign="top" >TBD</td>
	</tr>
	<tr>
	<td valign="top" >hue</td>
	<td valign="top" >RANGE</td>
	<td valign="top" >Min=0, Max= SDVO dependent</td>
	<td valign="top" >Connector</td>
	<td valign="top" >TBD</td>
	</tr>
	<tr>
	<td valign="top" >sharpness</td>
	<td valign="top" >RANGE</td>
	<td valign="top" >Min=0, Max= SDVO dependent</td>
	<td valign="top" >Connector</td>
	<td valign="top" >TBD</td>
	</tr>
	<tr>
	<td valign="top" >flicker_filter</td>
	<td valign="top" >RANGE</td>
	<td valign="top" >Min=0, Max= SDVO dependent</td>
	<td valign="top" >Connector</td>
	<td valign="top" >TBD</td>
	</tr>
	<tr>
	<td valign="top" >flicker_filter_adaptive</td>
	<td valign="top" >RANGE</td>
	<td valign="top" >Min=0, Max= SDVO dependent</td>
	<td valign="top" >Connector</td>
	<td valign="top" >TBD</td>
	</tr>
	<tr>
	<td valign="top" >flicker_filter_2d</td>
	<td valign="top" >RANGE</td>
	<td valign="top" >Min=0, Max= SDVO dependent</td>
	<td valign="top" >Connector</td>
	<td valign="top" >TBD</td>
	</tr>
	<tr>
	<td valign="top" >tv_chroma_filter</td>
	<td valign="top" >RANGE</td>
	<td valign="top" >Min=0, Max= SDVO dependent</td>
	<td valign="top" >Connector</td>
	<td valign="top" >TBD</td>
	</tr>
	<tr>
	<td valign="top" >tv_luma_filter</td>
	<td valign="top" >RANGE</td>
	<td valign="top" >Min=0, Max= SDVO dependent</td>
	<td valign="top" >Connector</td>
	<td valign="top" >TBD</td>
	</tr>
	<tr>
	<td valign="top" >dot_crawl</td>
	<td valign="top" >RANGE</td>
	<td valign="top" >Min=0, Max=1</td>
	<td valign="top" >Connector</td>
	<td valign="top" >TBD</td>
	</tr>
	<tr>
	<td valign="top" >SDVO-TV/LVDS</td>
	<td valign="top" >brightness</td>
	<td valign="top" >RANGE</td>
	<td valign="top" >Min=0, Max= SDVO dependent</td>
	<td valign="top" >Connector</td>
	<td valign="top" >TBD</td>
	</tr>
	<tr>
	<td rowspan="2" valign="top" >CDV gma-500</td>
	<td rowspan="2" valign="top" >Generic</td>
	<td valign="top" >"Broadcast RGB"</td>
	<td valign="top" >ENUM</td>
	<td valign="top" >{ Full, Limited 16:235 }</td>
	<td valign="top" >Connector</td>
	<td valign="top" >TBD</td>
	</tr>
	<tr>
	<td valign="top" >"Broadcast RGB"</td>
	<td valign="top" >ENUM</td>
	<td valign="top" >{ off, auto, on }</td>
	<td valign="top" >Connector</td>
	<td valign="top" >TBD</td>
	</tr>
	<tr>
	<td rowspan="19" valign="top" >Poulsbo</td>
	<td rowspan="1" valign="top" >Generic</td>
	<td valign="top" >backlight</td>
	<td valign="top" >RANGE</td>
	<td valign="top" >Min=0, Max=100</td>
	<td valign="top" >Connector</td>
	<td valign="top" >TBD</td>
	</tr>
	<tr>
	<td rowspan="17" valign="top" >SDVO-TV</td>
	<td valign="top" >mode</td>
	<td valign="top" >ENUM</td>
	<td valign="top" >{ "NTSC_M", "NTSC_J", "NTSC_443", "PAL_B" } etc.</td>
	<td valign="top" >Connector</td>
	<td valign="top" >TBD</td>
	</tr>
	<tr>
	<td valign="top" >"left_margin"</td>
	<td valign="top" >RANGE</td>
	<td valign="top" >Min=0, Max= SDVO dependent</td>
	<td valign="top" >Connector</td>
	<td valign="top" >TBD</td>
	</tr>
	<tr>
	<td valign="top" >"right_margin"</td>
	<td valign="top" >RANGE</td>
	<td valign="top" >Min=0, Max= SDVO dependent</td>
	<td valign="top" >Connector</td>
	<td valign="top" >TBD</td>
	</tr>
	<tr>
	<td valign="top" >"top_margin"</td>
	<td valign="top" >RANGE</td>
	<td valign="top" >Min=0, Max= SDVO dependent</td>
	<td valign="top" >Connector</td>
	<td valign="top" >TBD</td>
	</tr>
	<tr>
	<td valign="top" >"bottom_margin"</td>
	<td valign="top" >RANGE</td>
	<td valign="top" >Min=0, Max= SDVO dependent</td>
	<td valign="top" >Connector</td>
	<td valign="top" >TBD</td>
	</tr>
	<tr>
	<td valign="top" >hpos</td>
	<td valign="top" >RANGE</td>
	<td valign="top" >Min=0, Max= SDVO dependent</td>
	<td valign="top" >Connector</td>
	<td valign="top" >TBD</td>
	</tr>
	<tr>
	<td valign="top" >vpos</td>
	<td valign="top" >RANGE</td>
	<td valign="top" >Min=0, Max= SDVO dependent</td>
	<td valign="top" >Connector</td>
	<td valign="top" >TBD</td>
	</tr>
	<tr>
	<td valign="top" >contrast</td>
	<td valign="top" >RANGE</td>
	<td valign="top" >Min=0, Max= SDVO dependent</td>
	<td valign="top" >Connector</td>
	<td valign="top" >TBD</td>
	</tr>
	<tr>
	<td valign="top" >saturation</td>
	<td valign="top" >RANGE</td>
	<td valign="top" >Min=0, Max= SDVO dependent</td>
	<td valign="top" >Connector</td>
	<td valign="top" >TBD</td>
	</tr>
	<tr>
	<td valign="top" >hue</td>
	<td valign="top" >RANGE</td>
	<td valign="top" >Min=0, Max= SDVO dependent</td>
	<td valign="top" >Connector</td>
	<td valign="top" >TBD</td>
	</tr>
	<tr>
	<td valign="top" >sharpness</td>
	<td valign="top" >RANGE</td>
	<td valign="top" >Min=0, Max= SDVO dependent</td>
	<td valign="top" >Connector</td>
	<td valign="top" >TBD</td>
	</tr>
	<tr>
	<td valign="top" >flicker_filter</td>
	<td valign="top" >RANGE</td>
	<td valign="top" >Min=0, Max= SDVO dependent</td>
	<td valign="top" >Connector</td>
	<td valign="top" >TBD</td>
	</tr>
	<tr>
	<td valign="top" >flicker_filter_adaptive</td>
	<td valign="top" >RANGE</td>
	<td valign="top" >Min=0, Max= SDVO dependent</td>
	<td valign="top" >Connector</td>
	<td valign="top" >TBD</td>
	</tr>
	<tr>
	<td valign="top" >flicker_filter_2d</td>
	<td valign="top" >RANGE</td>
	<td valign="top" >Min=0, Max= SDVO dependent</td>
	<td valign="top" >Connector</td>
	<td valign="top" >TBD</td>
	</tr>
	<tr>
	<td valign="top" >tv_chroma_filter</td>
	<td valign="top" >RANGE</td>
	<td valign="top" >Min=0, Max= SDVO dependent</td>
	<td valign="top" >Connector</td>
	<td valign="top" >TBD</td>
	</tr>
	<tr>
	<td valign="top" >tv_luma_filter</td>
	<td valign="top" >RANGE</td>
	<td valign="top" >Min=0, Max= SDVO dependent</td>
	<td valign="top" >Connector</td>
	<td valign="top" >TBD</td>
	</tr>
	<tr>
	<td valign="top" >dot_crawl</td>
	<td valign="top" >RANGE</td>
	<td valign="top" >Min=0, Max=1</td>
	<td valign="top" >Connector</td>
	<td valign="top" >TBD</td>
	</tr>
	<tr>
	<td valign="top" >SDVO-TV/LVDS</td>
	<td valign="top" >brightness</td>
	<td valign="top" >RANGE</td>
	<td valign="top" >Min=0, Max= SDVO dependent</td>
	<td valign="top" >Connector</td>
	<td valign="top" >TBD</td>
	</tr>
	<tr>
	<td rowspan="11" valign="top" >armada</td>
	<td rowspan="2" valign="top" >CRTC</td>
	<td valign="top" >"CSC_YUV"</td>
	<td valign="top" >ENUM</td>
	<td valign="top" >{ "Auto" , "CCIR601", "CCIR709" }</td>
	<td valign="top" >CRTC</td>
	<td valign="top" >TBD</td>
	</tr>
	<tr>
	<td valign="top" >"CSC_RGB"</td>
	<td valign="top" >ENUM</td>
	<td valign="top" >{ "Auto", "Computer system", "Studio" }</td>
	<td valign="top" >CRTC</td>
	<td valign="top" >TBD</td>
	</tr>
	<tr>
	<td rowspan="9" valign="top" >Overlay</td>
	<td valign="top" >"colorkey"</td>
	<td valign="top" >RANGE</td>
	<td valign="top" >Min=0, Max=0xffffff</td>
	<td valign="top" >Plane</td>
	<td valign="top" >TBD</td>
	</tr>
	<tr>
	<td valign="top" >"colorkey_min"</td>
	<td valign="top" >RANGE</td>
	<td valign="top" >Min=0, Max=0xffffff</td>
	<td valign="top" >Plane</td>
	<td valign="top" >TBD</td>
	</tr>
	<tr>
	<td valign="top" >"colorkey_max"</td>
	<td valign="top" >RANGE</td>
	<td valign="top" >Min=0, Max=0xffffff</td>
	<td valign="top" >Plane</td>
	<td valign="top" >TBD</td>
	</tr>
	<tr>
	<td valign="top" >"colorkey_val"</td>
	<td valign="top" >RANGE</td>
	<td valign="top" >Min=0, Max=0xffffff</td>
	<td valign="top" >Plane</td>
	<td valign="top" >TBD</td>
	</tr>
	<tr>
	<td valign="top" >"colorkey_alpha"</td>
	<td valign="top" >RANGE</td>
	<td valign="top" >Min=0, Max=0xffffff</td>
	<td valign="top" >Plane</td>
	<td valign="top" >TBD</td>
	</tr>
	<tr>
	<td valign="top" >"colorkey_mode"</td>
	<td valign="top" >ENUM</td>
	<td valign="top" >{ "disabled", "Y component", "U component"
	, "V component", "RGB", R component", "G component", "B component" }</td>
	<td valign="top" >Plane</td>
	<td valign="top" >TBD</td>
	</tr>
	<tr>
	<td valign="top" >"brightness"</td>
	<td valign="top" >RANGE</td>
	<td valign="top" >Min=0, Max=256 + 255</td>
	<td valign="top" >Plane</td>
	<td valign="top" >TBD</td>
	</tr>
	<tr>
	<td valign="top" >"contrast"</td>
	<td valign="top" >RANGE</td>
	<td valign="top" >Min=0, Max=0x7fff</td>
	<td valign="top" >Plane</td>
	<td valign="top" >TBD</td>
	</tr>
	<tr>
	<td valign="top" >"saturation"</td>
	<td valign="top" >RANGE</td>
	<td valign="top" >Min=0, Max=0x7fff</td>
	<td valign="top" >Plane</td>
	<td valign="top" >TBD</td>
	</tr>
	<tr>
	<td rowspan="2" valign="top" >exynos</td>
	<td valign="top" >CRTC</td>
	<td valign="top" >mode</td>
	<td valign="top" >ENUM</td>
	<td valign="top" >{ "normal", "blank" }</td>
	<td valign="top" >CRTC</td>
	<td valign="top" >TBD</td>
	</tr>
	<tr>
	<td valign="top" >Overlay</td>
	<td valign="top" >zpos</td>
	<td valign="top" >RANGE</td>
	<td valign="top" >Min=0, Max=MAX_PLANE-1</td>
	<td valign="top" >Plane</td>
	<td valign="top" >TBD</td>
	</tr>
	<tr>
	<td rowspan="2" valign="top" >i2c/ch7006_drv</td>
	<td valign="top" >Generic</td>
	<td valign="top" >scale</td>
	<td valign="top" >RANGE</td>
	<td valign="top" >Min=0, Max=2</td>
	<td valign="top" >Connector</td>
	<td valign="top" >TBD</td>
	</tr>
	<tr>
	<td rowspan="1" valign="top" >TV</td>
	<td valign="top" >mode</td>
	<td valign="top" >ENUM</td>
	<td valign="top" >{ "PAL", "PAL-M","PAL-N"}, PAL-Nc"
	, "PAL-60", "NTSC-M", "NTSC-J" }</td>
	<td valign="top" >Connector</td>
	<td valign="top" >TBD</td>
	</tr>
	<tr>
	<td rowspan="15" valign="top" >nouveau</td>
	<td rowspan="6" valign="top" >NV10 Overlay</td>
	<td valign="top" >"colorkey"</td>
	<td valign="top" >RANGE</td>
	<td valign="top" >Min=0, Max=0x01ffffff</td>
	<td valign="top" >Plane</td>
	<td valign="top" >TBD</td>
	</tr>
	<tr>
	<td valign="top" >contrast</td>
	<td valign="top" >RANGE</td>
	<td valign="top" >Min=0, Max=8192-1</td>
	<td valign="top" >Plane</td>
	<td valign="top" >TBD</td>
	</tr>
	<tr>
	<td valign="top" >brightness</td>
	<td valign="top" >RANGE</td>
	<td valign="top" >Min=0, Max=1024</td>
	<td valign="top" >Plane</td>
	<td valign="top" >TBD</td>
	</tr>
	<tr>
	<td valign="top" >hue</td>
	<td valign="top" >RANGE</td>
	<td valign="top" >Min=0, Max=359</td>
	<td valign="top" >Plane</td>
	<td valign="top" >TBD</td>
	</tr>
	<tr>
	<td valign="top" >saturation</td>
	<td valign="top" >RANGE</td>
	<td valign="top" >Min=0, Max=8192-1</td>
	<td valign="top" >Plane</td>
	<td valign="top" >TBD</td>
	</tr>
	<tr>
	<td valign="top" >iturbt_709</td>
	<td valign="top" >RANGE</td>
	<td valign="top" >Min=0, Max=1</td>
	<td valign="top" >Plane</td>
	<td valign="top" >TBD</td>
	</tr>
	<tr>
	<td rowspan="2" valign="top" >Nv04 Overlay</td>
	<td valign="top" >colorkey</td>
	<td valign="top" >RANGE</td>
	<td valign="top" >Min=0, Max=0x01ffffff</td>
	<td valign="top" >Plane</td>
	<td valign="top" >TBD</td>
	</tr>
	<tr>
	<td valign="top" >brightness</td>
	<td valign="top" >RANGE</td>
	<td valign="top" >Min=0, Max=1024</td>
	<td valign="top" >Plane</td>
	<td valign="top" >TBD</td>
	</tr>
	<tr>
	<td rowspan="7" valign="top" >Display</td>
	<td valign="top" >dithering mode</td>
	<td valign="top" >ENUM</td>
	<td valign="top" >{ "auto", "off", "on" }</td>
	<td valign="top" >Connector</td>
	<td valign="top" >TBD</td>
	</tr>
	<tr>
	<td valign="top" >dithering depth</td>
	<td valign="top" >ENUM</td>
	<td valign="top" >{ "auto", "off", "on", "static 2x2", "dynamic 2x2", "temporal" }</td>
	<td valign="top" >Connector</td>
	<td valign="top" >TBD</td>
	</tr>
	<tr>
	<td valign="top" >underscan</td>
	<td valign="top" >ENUM</td>
	<td valign="top" >{ "auto", "6 bpc", "8 bpc" }</td>
	<td valign="top" >Connector</td>
	<td valign="top" >TBD</td>
	</tr>
	<tr>
	<td valign="top" >underscan hborder</td>
	<td valign="top" >RANGE</td>
	<td valign="top" >Min=0, Max=128</td>
	<td valign="top" >Connector</td>
	<td valign="top" >TBD</td>
	</tr>
	<tr>
	<td valign="top" >underscan vborder</td>
	<td valign="top" >RANGE</td>
	<td valign="top" >Min=0, Max=128</td>
	<td valign="top" >Connector</td>
	<td valign="top" >TBD</td>
	</tr>
	<tr>
	<td valign="top" >vibrant hue</td>
	<td valign="top" >RANGE</td>
	<td valign="top" >Min=0, Max=180</td>
	<td valign="top" >Connector</td>
	<td valign="top" >TBD</td>
	</tr>
	<tr>
	<td valign="top" >color vibrance</td>
	<td valign="top" >RANGE</td>
	<td valign="top" >Min=0, Max=200</td>
	<td valign="top" >Connector</td>
	<td valign="top" >TBD</td>
	</tr>
	<tr>
	<td rowspan="2" valign="top" >omap</td>
	<td rowspan="2" valign="top" >Generic</td>
	<td valign="top" >rotation</td>
	<td valign="top" >BITMASK</td>
	<td valign="top" >{ 0, "rotate-0" },
	{ 1, "rotate-90" },
	{ 2, "rotate-180" },
	{ 3, "rotate-270" },
	{ 4, "reflect-x" },
	{ 5, "reflect-y" }</td>
	<td valign="top" >CRTC, Plane</td>
	<td valign="top" >TBD</td>
	</tr>
	<tr>
	<td valign="top" >zorder</td>
	<td valign="top" >RANGE</td>
	<td valign="top" >Min=0, Max=3</td>
	<td valign="top" >CRTC, Plane</td>
	<td valign="top" >TBD</td>
	</tr>
	<tr>
	<td valign="top" >qxl</td>
	<td valign="top" >Generic</td>
	<td valign="top" >hotplug_mode_update"</td>
	<td valign="top" >RANGE</td>
	<td valign="top" >Min=0, Max=1</td>
	<td valign="top" >Connector</td>
	<td valign="top" >TBD</td>
	</tr>
	<tr>
	<td rowspan="9" valign="top" >radeon</td>
	<td valign="top" >DVI-I</td>
	<td valign="top" >coherent</td>
	<td valign="top" >RANGE</td>
	<td valign="top" >Min=0, Max=1</td>
	<td valign="top" >Connector</td>
	<td valign="top" >TBD</td>
	</tr>
	<tr>
	<td valign="top" >DAC enable load detect</td>
	<td valign="top" >load detection</td>
	<td valign="top" >RANGE</td>
	<td valign="top" >Min=0, Max=1</td>
	<td valign="top" >Connector</td>
	<td valign="top" >TBD</td>
	</tr>
	<tr>
	<td valign="top" >TV Standard</td>
	<td valign="top" >"tv standard"</td>
	<td valign="top" >ENUM</td>
	<td valign="top" >{ "ntsc", "pal", "pal-m", "pal-60", "ntsc-j"
	, "scart-pal", "pal-cn", "secam" }</td>
	<td valign="top" >Connector</td>
	<td valign="top" >TBD</td>
	</tr>
	<tr>
	<td valign="top" >legacy TMDS PLL detect</td>
	<td valign="top" >"tmds_pll"</td>
	<td valign="top" >ENUM</td>
	<td valign="top" >{ "driver", "bios" }</td>
	<td valign="top" >-</td>
	<td valign="top" >TBD</td>
	</tr>
	<tr>
	<td rowspan="3" valign="top" >Underscan</td>
	<td valign="top" >"underscan"</td>
	<td valign="top" >ENUM</td>
	<td valign="top" >{ "off", "on", "auto" }</td>
	<td valign="top" >Connector</td>
	<td valign="top" >TBD</td>
	</tr>
	<tr>
	<td valign="top" >"underscan hborder"</td>
	<td valign="top" >RANGE</td>
	<td valign="top" >Min=0, Max=128</td>
	<td valign="top" >Connector</td>
	<td valign="top" >TBD</td>
	</tr>
	<tr>
	<td valign="top" >"underscan vborder"</td>
	<td valign="top" >RANGE</td>
	<td valign="top" >Min=0, Max=128</td>
	<td valign="top" >Connector</td>
	<td valign="top" >TBD</td>
	</tr>
	<tr>
	<td valign="top" >Audio</td>
	<td valign="top" >audio</td>
	<td valign="top" >ENUM</td>
	<td valign="top" >{ "off", "on", "auto" }</td>
	<td valign="top" >Connector</td>
	<td valign="top" >TBD</td>
	</tr>
	<tr>
	<td valign="top" >FMT Dithering</td>
	<td valign="top" >dither</td>
	<td valign="top" >ENUM</td>
	<td valign="top" >{ "off", "on" }</td>
	<td valign="top" >Connector</td>
	<td valign="top" >TBD</td>
	</tr>
	<tr>
	<td rowspan="3" valign="top" >rcar-du</td>
	<td rowspan="3" valign="top" >Generic</td>
	<td valign="top" >"alpha"</td>
	<td valign="top" >RANGE</td>
	<td valign="top" >Min=0, Max=255</td>
	<td valign="top" >Plane</td>
	<td valign="top" >TBD</td>
	</tr>
	<tr>
	<td valign="top" >"colorkey"</td>
	<td valign="top" >RANGE</td>
	<td valign="top" >Min=0, Max=0x01ffffff</td>
	<td valign="top" >Plane</td>
	<td valign="top" >TBD</td>
	</tr>
	<tr>
	<td valign="top" >"zpos"</td>
	<td valign="top" >RANGE</td>
	<td valign="top" >Min=1, Max=7</td>
	<td valign="top" >Plane</td>
	<td valign="top" >TBD</td>
	</tr>
	</tbody>
	</table>
    </sect2>
  </sect1>

  <!-- Internals: vertical blanking -->

  <sect1 id="drm-vertical-blank">
    <title>Vertical Blanking</title>
    <para>
      Vertical blanking plays a major role in graphics rendering. To achieve
      tear-free display, users must synchronize page flips and/or rendering to
      vertical blanking. The DRM API offers ioctls to perform page flips
      synchronized to vertical blanking and wait for vertical blanking.
    </para>
    <para>
      The DRM core handles most of the vertical blanking management logic, which
      involves filtering out spurious interrupts, keeping race-free blanking
      counters, coping with counter wrap-around and resets and keeping use
      counts. It relies on the driver to generate vertical blanking interrupts
      and optionally provide a hardware vertical blanking counter. Drivers must
      implement the following operations.
    </para>
    <itemizedlist>
      <listitem>
        <synopsis>int (*enable_vblank) (struct drm_device *dev, int crtc);
void (*disable_vblank) (struct drm_device *dev, int crtc);</synopsis>
        <para>
	  Enable or disable vertical blanking interrupts for the given CRTC.
	</para>
      </listitem>
      <listitem>
        <synopsis>u32 (*get_vblank_counter) (struct drm_device *dev, int crtc);</synopsis>
        <para>
	  Retrieve the value of the vertical blanking counter for the given
	  CRTC. If the hardware maintains a vertical blanking counter its value
	  should be returned. Otherwise drivers can use the
	  <function>drm_vblank_count</function> helper function to handle this
	  operation.
	</para>
      </listitem>
    </itemizedlist>
    <para>
      Drivers must initialize the vertical blanking handling core with a call to
      <function>drm_vblank_init</function> in their
      <methodname>load</methodname> operation. The function will set the struct
      <structname>drm_device</structname>
      <structfield>vblank_disable_allowed</structfield> field to 0. This will
      keep vertical blanking interrupts enabled permanently until the first mode
      set operation, where <structfield>vblank_disable_allowed</structfield> is
      set to 1. The reason behind this is not clear. Drivers can set the field
      to 1 after <function>calling drm_vblank_init</function> to make vertical
      blanking interrupts dynamically managed from the beginning.
    </para>
    <para>
      Vertical blanking interrupts can be enabled by the DRM core or by drivers
      themselves (for instance to handle page flipping operations). The DRM core
      maintains a vertical blanking use count to ensure that the interrupts are
      not disabled while a user still needs them. To increment the use count,
      drivers call <function>drm_vblank_get</function>. Upon return vertical
      blanking interrupts are guaranteed to be enabled.
    </para>
    <para>
      To decrement the use count drivers call
      <function>drm_vblank_put</function>. Only when the use count drops to zero
      will the DRM core disable the vertical blanking interrupts after a delay
      by scheduling a timer. The delay is accessible through the vblankoffdelay
      module parameter or the <varname>drm_vblank_offdelay</varname> global
      variable and expressed in milliseconds. Its default value is 5000 ms.
      Zero means never disable, and a negative value means disable immediately.
      Drivers may override the behaviour by setting the
      <structname>drm_device</structname>
      <structfield>vblank_disable_immediate</structfield> flag, which when set
      causes vblank interrupts to be disabled immediately regardless of the
      drm_vblank_offdelay value. The flag should only be set if there's a
      properly working hardware vblank counter present.
    </para>
    <para>
      When a vertical blanking interrupt occurs drivers only need to call the
      <function>drm_handle_vblank</function> function to account for the
      interrupt.
    </para>
    <para>
      Resources allocated by <function>drm_vblank_init</function> must be freed
      with a call to <function>drm_vblank_cleanup</function> in the driver
      <methodname>unload</methodname> operation handler.
    </para>
    <sect2>
      <title>Vertical Blanking and Interrupt Handling Functions Reference</title>
<!-- drivers/gpu/drm/drm_irq.c -->
<refentry id="API-drm-vblank-cleanup">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_vblank_cleanup</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_vblank_cleanup</refname>
 <refpurpose>
  cleanup vblank support
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>drm_vblank_cleanup </function></funcdef>
   <paramdef>struct drm_device * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     DRM device
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This function cleans up any resources allocated in drm_vblank_init.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-vblank-init">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_vblank_init</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_vblank_init</refname>
 <refpurpose>
     initialize vblank support
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>drm_vblank_init </function></funcdef>
   <paramdef>struct drm_device * <parameter>dev</parameter></paramdef>
   <paramdef>int <parameter>num_crtcs</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     drm_device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>num_crtcs</parameter></term>
   <listitem>
    <para>
     number of crtcs supported by <parameter>dev</parameter>
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This function initializes vblank support for <parameter>num_crtcs</parameter> display pipelines.
</para>
</refsect1>
<refsect1>
<title>Returns</title>
<para>
   Zero on success or a negative error code on failure.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-irq-install">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_irq_install</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_irq_install</refname>
 <refpurpose>
     install IRQ handler
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>drm_irq_install </function></funcdef>
   <paramdef>struct drm_device * <parameter>dev</parameter></paramdef>
   <paramdef>int <parameter>irq</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     DRM device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>irq</parameter></term>
   <listitem>
    <para>
     IRQ number to install the handler for
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Initializes the IRQ related data. Installs the handler, calling the driver
   <function>irq_preinstall</function> and <function>irq_postinstall</function> functions before and after the
   installation.
   </para><para>

   This is the simplified helper interface provided for drivers with no special
   needs. Drivers which need to install interrupt handlers for multiple
   interrupts must instead set drm_device-&gt;irq_enabled to signal the DRM core
   that vblank interrupts are available.
</para>
</refsect1>
<refsect1>
<title>Returns</title>
<para>
   Zero on success or a negative error code on failure.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-irq-uninstall">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_irq_uninstall</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_irq_uninstall</refname>
 <refpurpose>
     uninstall the IRQ handler
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>drm_irq_uninstall </function></funcdef>
   <paramdef>struct drm_device * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     DRM device
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Calls the driver's <function>irq_uninstall</function> function and unregisters the IRQ handler.
   This should only be called by drivers which used <function>drm_irq_install</function> to set up
   their interrupt handler. Other drivers must only reset
   drm_device-&gt;irq_enabled to false.
   </para><para>

   Note that for kernel modesetting drivers it is a bug if this function fails.
   The sanity checks are only to catch buggy user modesetting drivers which call
   the same function through an ioctl.
</para>
</refsect1>
<refsect1>
<title>Returns</title>
<para>
   Zero on success or a negative error code on failure.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-calc-timestamping-constants">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_calc_timestamping_constants</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_calc_timestamping_constants</refname>
 <refpurpose>
     calculate vblank timestamp constants
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>drm_calc_timestamping_constants </function></funcdef>
   <paramdef>struct drm_crtc * <parameter>crtc</parameter></paramdef>
   <paramdef>const struct drm_display_mode * <parameter>mode</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>crtc</parameter></term>
   <listitem>
    <para>
     drm_crtc whose timestamp constants should be updated.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>mode</parameter></term>
   <listitem>
    <para>
     display mode containing the scanout timings
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Calculate and store various constants which are later
   needed by vblank and swap-completion timestamping, e.g,
   by <function>drm_calc_vbltimestamp_from_scanoutpos</function>. They are
   derived from CRTC's true scanout timing, so they take
   things like panel scaling or other adjustments into account.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-calc-vbltimestamp-from-scanoutpos">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_calc_vbltimestamp_from_scanoutpos</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_calc_vbltimestamp_from_scanoutpos</refname>
 <refpurpose>
     precise vblank timestamp helper
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>drm_calc_vbltimestamp_from_scanoutpos </function></funcdef>
   <paramdef>struct drm_device * <parameter>dev</parameter></paramdef>
   <paramdef>int <parameter>crtc</parameter></paramdef>
   <paramdef>int * <parameter>max_error</parameter></paramdef>
   <paramdef>struct timeval * <parameter>vblank_time</parameter></paramdef>
   <paramdef>unsigned <parameter>flags</parameter></paramdef>
   <paramdef>const struct drm_crtc * <parameter>refcrtc</parameter></paramdef>
   <paramdef>const struct drm_display_mode * <parameter>mode</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     DRM device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>crtc</parameter></term>
   <listitem>
    <para>
     Which CRTC's vblank timestamp to retrieve
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>max_error</parameter></term>
   <listitem>
    <para>
     Desired maximum allowable error in timestamps (nanosecs)
     On return contains true maximum error of timestamp
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>vblank_time</parameter></term>
   <listitem>
    <para>
     Pointer to struct timeval which should receive the timestamp
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>flags</parameter></term>
   <listitem>
    <para>
     Flags to pass to driver:
     0 = Default,
     DRM_CALLED_FROM_VBLIRQ = If function is called from vbl IRQ handler
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>refcrtc</parameter></term>
   <listitem>
    <para>
     CRTC which defines scanout timing
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>mode</parameter></term>
   <listitem>
    <para>
     mode which defines the scanout timings
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Implements calculation of exact vblank timestamps from given drm_display_mode
   timings and current video scanout position of a CRTC. This can be called from
   within <function>get_vblank_timestamp</function> implementation of a kms driver to implement the
   actual timestamping.
   </para><para>

   Should return timestamps conforming to the OML_sync_control OpenML
   extension specification. The timestamp corresponds to the end of
   the vblank interval, aka start of scanout of topmost-leftmost display
   pixel in the following video frame.
   </para><para>

   Requires support for optional dev-&gt;driver-&gt;<function>get_scanout_position</function>
   in kms driver, plus a bit of setup code to provide a drm_display_mode
   that corresponds to the true scanout timing.
   </para><para>

   The current implementation only handles standard video modes. It
   returns as no operation if a doublescan or interlaced video mode is
   active. Higher level code is expected to handle this.
</para>
</refsect1>
<refsect1>
<title>Returns</title>
<para>
   Negative value on error, failure or if not supported in current
</para>
</refsect1>
<refsect1>
<title>video mode</title>
<para>
   </para><para>

   -EINVAL   - Invalid CRTC.
   -EAGAIN   - Temporary unavailable, e.g., called before initial modeset.
   -ENOTSUPP - Function not supported in current display mode.
   -EIO      - Failed, e.g., due to failed scanout position query.
   </para><para>

   Returns or'ed positive status flags on success:
   </para><para>

   DRM_VBLANKTIME_SCANOUTPOS_METHOD - Signal this method used for timestamping.
   DRM_VBLANKTIME_INVBL - Timestamp taken while scanout was in vblank interval.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-vblank-count">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_vblank_count</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_vblank_count</refname>
 <refpurpose>
     retrieve <quote>cooked</quote> vblank counter value
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>u32 <function>drm_vblank_count </function></funcdef>
   <paramdef>struct drm_device * <parameter>dev</parameter></paramdef>
   <paramdef>int <parameter>crtc</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     DRM device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>crtc</parameter></term>
   <listitem>
    <para>
     which counter to retrieve
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Fetches the <quote>cooked</quote> vblank count value that represents the number of
   vblank events since the system was booted, including lost events due to
   modesetting activity.
</para>
</refsect1>
<refsect1>
<title>Returns</title>
<para>
   The software vblank counter.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-vblank-count-and-time">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_vblank_count_and_time</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_vblank_count_and_time</refname>
 <refpurpose>
     retrieve <quote>cooked</quote> vblank counter value and the system timestamp corresponding to that vblank counter value.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>u32 <function>drm_vblank_count_and_time </function></funcdef>
   <paramdef>struct drm_device * <parameter>dev</parameter></paramdef>
   <paramdef>int <parameter>crtc</parameter></paramdef>
   <paramdef>struct timeval * <parameter>vblanktime</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     DRM device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>crtc</parameter></term>
   <listitem>
    <para>
     which counter to retrieve
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>vblanktime</parameter></term>
   <listitem>
    <para>
     Pointer to struct timeval to receive the vblank timestamp.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Fetches the <quote>cooked</quote> vblank count value that represents the number of
   vblank events since the system was booted, including lost events due to
   modesetting activity. Returns corresponding system timestamp of the time
   of the vblank interval that corresponds to the current vblank counter value.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-send-vblank-event">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_send_vblank_event</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_send_vblank_event</refname>
 <refpurpose>
     helper to send vblank event after pageflip
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>drm_send_vblank_event </function></funcdef>
   <paramdef>struct drm_device * <parameter>dev</parameter></paramdef>
   <paramdef>int <parameter>crtc</parameter></paramdef>
   <paramdef>struct drm_pending_vblank_event * <parameter>e</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     DRM device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>crtc</parameter></term>
   <listitem>
    <para>
     CRTC in question
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>e</parameter></term>
   <listitem>
    <para>
     the event to send
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Updates sequence # and timestamp on event, and sends it to userspace.
   Caller must hold event lock.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-vblank-get">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_vblank_get</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_vblank_get</refname>
 <refpurpose>
     get a reference count on vblank events
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>drm_vblank_get </function></funcdef>
   <paramdef>struct drm_device * <parameter>dev</parameter></paramdef>
   <paramdef>int <parameter>crtc</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     DRM device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>crtc</parameter></term>
   <listitem>
    <para>
     which CRTC to own
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Acquire a reference count on vblank events to avoid having them disabled
   while in use.
   </para><para>

   This is the legacy version of <function>drm_crtc_vblank_get</function>.
</para>
</refsect1>
<refsect1>
<title>Returns</title>
<para>
   Zero on success, nonzero on failure.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-crtc-vblank-get">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_crtc_vblank_get</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_crtc_vblank_get</refname>
 <refpurpose>
     get a reference count on vblank events
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>drm_crtc_vblank_get </function></funcdef>
   <paramdef>struct drm_crtc * <parameter>crtc</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>crtc</parameter></term>
   <listitem>
    <para>
     which CRTC to own
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Acquire a reference count on vblank events to avoid having them disabled
   while in use.
   </para><para>

   This is the native kms version of <function>drm_vblank_off</function>.
</para>
</refsect1>
<refsect1>
<title>Returns</title>
<para>
   Zero on success, nonzero on failure.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-vblank-put">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_vblank_put</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_vblank_put</refname>
 <refpurpose>
     give up ownership of vblank events
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>drm_vblank_put </function></funcdef>
   <paramdef>struct drm_device * <parameter>dev</parameter></paramdef>
   <paramdef>int <parameter>crtc</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     DRM device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>crtc</parameter></term>
   <listitem>
    <para>
     which counter to give up
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Release ownership of a given vblank counter, turning off interrupts
   if possible. Disable interrupts after drm_vblank_offdelay milliseconds.
   </para><para>

   This is the legacy version of <function>drm_crtc_vblank_put</function>.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-crtc-vblank-put">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_crtc_vblank_put</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_crtc_vblank_put</refname>
 <refpurpose>
     give up ownership of vblank events
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>drm_crtc_vblank_put </function></funcdef>
   <paramdef>struct drm_crtc * <parameter>crtc</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>crtc</parameter></term>
   <listitem>
    <para>
     which counter to give up
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Release ownership of a given vblank counter, turning off interrupts
   if possible. Disable interrupts after drm_vblank_offdelay milliseconds.
   </para><para>

   This is the native kms version of <function>drm_vblank_put</function>.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-wait-one-vblank">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_wait_one_vblank</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_wait_one_vblank</refname>
 <refpurpose>
     wait for one vblank
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>drm_wait_one_vblank </function></funcdef>
   <paramdef>struct drm_device * <parameter>dev</parameter></paramdef>
   <paramdef>int <parameter>crtc</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     DRM device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>crtc</parameter></term>
   <listitem>
    <para>
     crtc index
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This waits for one vblank to pass on <parameter>crtc</parameter>, using the irq driver interfaces.
   It is a failure to call this when the vblank irq for <parameter>crtc</parameter> is disabled, e.g.
   due to lack of driver support or because the crtc is off.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-crtc-wait-one-vblank">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_crtc_wait_one_vblank</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_crtc_wait_one_vblank</refname>
 <refpurpose>
     wait for one vblank
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>drm_crtc_wait_one_vblank </function></funcdef>
   <paramdef>struct drm_crtc * <parameter>crtc</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>crtc</parameter></term>
   <listitem>
    <para>
     DRM crtc
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This waits for one vblank to pass on <parameter>crtc</parameter>, using the irq driver interfaces.
   It is a failure to call this when the vblank irq for <parameter>crtc</parameter> is disabled, e.g.
   due to lack of driver support or because the crtc is off.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-vblank-off">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_vblank_off</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_vblank_off</refname>
 <refpurpose>
     disable vblank events on a CRTC
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>drm_vblank_off </function></funcdef>
   <paramdef>struct drm_device * <parameter>dev</parameter></paramdef>
   <paramdef>int <parameter>crtc</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     DRM device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>crtc</parameter></term>
   <listitem>
    <para>
     CRTC in question
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Drivers can use this function to shut down the vblank interrupt handling when
   disabling a crtc. This function ensures that the latest vblank frame count is
   stored so that <function>drm_vblank_on</function> can restore it again.
   </para><para>

   Drivers must use this function when the hardware vblank counter can get
   reset, e.g. when suspending.
   </para><para>

   This is the legacy version of <function>drm_crtc_vblank_off</function>.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-crtc-vblank-off">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_crtc_vblank_off</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_crtc_vblank_off</refname>
 <refpurpose>
     disable vblank events on a CRTC
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>drm_crtc_vblank_off </function></funcdef>
   <paramdef>struct drm_crtc * <parameter>crtc</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>crtc</parameter></term>
   <listitem>
    <para>
     CRTC in question
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Drivers can use this function to shut down the vblank interrupt handling when
   disabling a crtc. This function ensures that the latest vblank frame count is
   stored so that drm_vblank_on can restore it again.
   </para><para>

   Drivers must use this function when the hardware vblank counter can get
   reset, e.g. when suspending.
   </para><para>

   This is the native kms version of <function>drm_vblank_off</function>.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-vblank-on">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_vblank_on</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_vblank_on</refname>
 <refpurpose>
     enable vblank events on a CRTC
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>drm_vblank_on </function></funcdef>
   <paramdef>struct drm_device * <parameter>dev</parameter></paramdef>
   <paramdef>int <parameter>crtc</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     DRM device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>crtc</parameter></term>
   <listitem>
    <para>
     CRTC in question
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This functions restores the vblank interrupt state captured with
   <function>drm_vblank_off</function> again. Note that calls to <function>drm_vblank_on</function> and
   <function>drm_vblank_off</function> can be unbalanced and so can also be unconditionaly called
   in driver load code to reflect the current hardware state of the crtc.
   </para><para>

   This is the legacy version of <function>drm_crtc_vblank_on</function>.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-crtc-vblank-on">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_crtc_vblank_on</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_crtc_vblank_on</refname>
 <refpurpose>
     enable vblank events on a CRTC
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>drm_crtc_vblank_on </function></funcdef>
   <paramdef>struct drm_crtc * <parameter>crtc</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>crtc</parameter></term>
   <listitem>
    <para>
     CRTC in question
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This functions restores the vblank interrupt state captured with
   <function>drm_vblank_off</function> again. Note that calls to <function>drm_vblank_on</function> and
   <function>drm_vblank_off</function> can be unbalanced and so can also be unconditionaly called
   in driver load code to reflect the current hardware state of the crtc.
   </para><para>

   This is the native kms version of <function>drm_vblank_on</function>.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-vblank-pre-modeset">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_vblank_pre_modeset</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_vblank_pre_modeset</refname>
 <refpurpose>
     account for vblanks across mode sets
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>drm_vblank_pre_modeset </function></funcdef>
   <paramdef>struct drm_device * <parameter>dev</parameter></paramdef>
   <paramdef>int <parameter>crtc</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     DRM device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>crtc</parameter></term>
   <listitem>
    <para>
     CRTC in question
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Account for vblank events across mode setting events, which will likely
   reset the hardware frame counter.
   </para><para>

   This is done by grabbing a temporary vblank reference to ensure that the
   vblank interrupt keeps running across the modeset sequence. With this the
   software-side vblank frame counting will ensure that there are no jumps or
   discontinuities.
   </para><para>

   Unfortunately this approach is racy and also doesn't work when the vblank
   interrupt stops running, e.g. across system suspend resume. It is therefore
   highly recommended that drivers use the newer <function>drm_vblank_off</function> and
   <function>drm_vblank_on</function> instead. <function>drm_vblank_pre_modeset</function> only works correctly when
   using <quote>cooked</quote> software vblank frame counters and not relying on any hardware
   counters.
   </para><para>

   Drivers must call <function>drm_vblank_post_modeset</function> when re-enabling the same crtc
   again.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-vblank-post-modeset">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_vblank_post_modeset</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_vblank_post_modeset</refname>
 <refpurpose>
     undo drm_vblank_pre_modeset changes
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>drm_vblank_post_modeset </function></funcdef>
   <paramdef>struct drm_device * <parameter>dev</parameter></paramdef>
   <paramdef>int <parameter>crtc</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     DRM device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>crtc</parameter></term>
   <listitem>
    <para>
     CRTC in question
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This function again drops the temporary vblank reference acquired in
   drm_vblank_pre_modeset.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-handle-vblank">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_handle_vblank</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_handle_vblank</refname>
 <refpurpose>
     handle a vblank event
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>bool <function>drm_handle_vblank </function></funcdef>
   <paramdef>struct drm_device * <parameter>dev</parameter></paramdef>
   <paramdef>int <parameter>crtc</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     DRM device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>crtc</parameter></term>
   <listitem>
    <para>
     where this event occurred
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Drivers should call this routine in their vblank interrupt handlers to
   update the vblank counter and send any signals that may be pending.
</para>
</refsect1>
</refentry>

<refentry id="API-drm-crtc-vblank-waitqueue">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drm_crtc_vblank_waitqueue</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drm_crtc_vblank_waitqueue</refname>
 <refpurpose>
  get vblank waitqueue for the CRTC
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>wait_queue_head_t * <function>drm_crtc_vblank_waitqueue </function></funcdef>
   <paramdef>struct drm_crtc * <parameter>crtc</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>crtc</parameter></term>
   <listitem>
    <para>
     which CRTC's vblank waitqueue to retrieve
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This function returns a pointer to the vblank waitqueue for the CRTC.
   Drivers can use this to implement vblank waits using <function>wait_event</function> &amp; co.
</para>
</refsect1>
</refentry>

    </sect2>
  </sect1>

  <!-- Internals: open/close, file operations and ioctls -->

  <sect1>
    <title>Open/Close, File Operations and IOCTLs</title>
    <sect2>
      <title>Open and Close</title>
      <synopsis>int (*firstopen) (struct drm_device *);
void (*lastclose) (struct drm_device *);
int (*open) (struct drm_device *, struct drm_file *);
void (*preclose) (struct drm_device *, struct drm_file *);
void (*postclose) (struct drm_device *, struct drm_file *);</synopsis>
      <abstract>Open and close handlers. None of those methods are mandatory.
      </abstract>
      <para>
        The <methodname>firstopen</methodname> method is called by the DRM core
	for legacy UMS (User Mode Setting) drivers only when an application
	opens a device that has no other opened file handle. UMS drivers can
	implement it to acquire device resources. KMS drivers can't use the
	method and must acquire resources in the <methodname>load</methodname>
	method instead.
      </para>
      <para>
	Similarly the <methodname>lastclose</methodname> method is called when
	the last application holding a file handle opened on the device closes
	it, for both UMS and KMS drivers. Additionally, the method is also
	called at module unload time or, for hot-pluggable devices, when the
	device is unplugged. The <methodname>firstopen</methodname> and
	<methodname>lastclose</methodname> calls can thus be unbalanced.
      </para>
      <para>
        The <methodname>open</methodname> method is called every time the device
	is opened by an application. Drivers can allocate per-file private data
	in this method and store them in the struct
	<structname>drm_file</structname> <structfield>driver_priv</structfield>
	field. Note that the <methodname>open</methodname> method is called
	before <methodname>firstopen</methodname>.
      </para>
      <para>
        The close operation is split into <methodname>preclose</methodname> and
	<methodname>postclose</methodname> methods. Drivers must stop and
	cleanup all per-file operations in the <methodname>preclose</methodname>
	method. For instance pending vertical blanking and page flip events must
	be cancelled. No per-file operation is allowed on the file handle after
	returning from the <methodname>preclose</methodname> method.
      </para>
      <para>
        Finally the <methodname>postclose</methodname> method is called as the
	last step of the close operation, right before calling the
	<methodname>lastclose</methodname> method if no other open file handle
	exists for the device. Drivers that have allocated per-file private data
	in the <methodname>open</methodname> method should free it here.
      </para>
      <para>
        The <methodname>lastclose</methodname> method should restore CRTC and
	plane properties to default value, so that a subsequent open of the
	device will not inherit state from the previous user. It can also be
	used to execute delayed power switching state changes, e.g. in
	conjunction with the vga-switcheroo infrastructure. Beyond that KMS
	drivers should not do any further cleanup. Only legacy UMS drivers might
	need to clean up device state so that the vga console or an independent
	fbdev driver could take over.
      </para>
    </sect2>
    <sect2>
      <title>File Operations</title>
      <synopsis>const struct file_operations *fops</synopsis>
      <abstract>File operations for the DRM device node.</abstract>
      <para>
        Drivers must define the file operations structure that forms the DRM
	userspace API entry point, even though most of those operations are
	implemented in the DRM core. The <methodname>open</methodname>,
	<methodname>release</methodname> and <methodname>ioctl</methodname>
	operations are handled by
	<programlisting>
	.owner = THIS_MODULE,
	.open = drm_open,
	.release = drm_release,
	.unlocked_ioctl = drm_ioctl,
  #ifdef CONFIG_COMPAT
	.compat_ioctl = drm_compat_ioctl,
  #endif
        </programlisting>
      </para>
      <para>
        Drivers that implement private ioctls that requires 32/64bit
	compatibility support must provide their own
	<methodname>compat_ioctl</methodname> handler that processes private
	ioctls and calls <function>drm_compat_ioctl</function> for core ioctls.
      </para>
      <para>
        The <methodname>read</methodname> and <methodname>poll</methodname>
	operations provide support for reading DRM events and polling them. They
	are implemented by
	<programlisting>
	.poll = drm_poll,
	.read = drm_read,
	.llseek = no_llseek,
	</programlisting>
      </para>
      <para>
        The memory mapping implementation varies depending on how the driver
	manages memory. Pre-GEM drivers will use <function>drm_mmap</function>,
	while GEM-aware drivers will use <function>drm_gem_mmap</function>. See
	<xref linkend="drm-gem"/>.
	<programlisting>
	.mmap = drm_gem_mmap,
	</programlisting>
      </para>
      <para>
        No other file operation is supported by the DRM API.
      </para>
    </sect2>
    <sect2>
      <title>IOCTLs</title>
      <synopsis>struct drm_ioctl_desc *ioctls;
int num_ioctls;</synopsis>
      <abstract>Driver-specific ioctls descriptors table.</abstract>
      <para>
        Driver-specific ioctls numbers start at DRM_COMMAND_BASE. The ioctls
	descriptors table is indexed by the ioctl number offset from the base
	value. Drivers can use the DRM_IOCTL_DEF_DRV() macro to initialize the
	table entries.
      </para>
      <para>
        <programlisting>DRM_IOCTL_DEF_DRV(ioctl, func, flags)</programlisting>
	<para>
	  <parameter>ioctl</parameter> is the ioctl name. Drivers must define
	  the DRM_##ioctl and DRM_IOCTL_##ioctl macros to the ioctl number
	  offset from DRM_COMMAND_BASE and the ioctl number respectively. The
	  first macro is private to the device while the second must be exposed
	  to userspace in a public header.
	</para>
	<para>
	  <parameter>func</parameter> is a pointer to the ioctl handler function
	  compatible with the <type>drm_ioctl_t</type> type.
	  <programlisting>typedef int drm_ioctl_t(struct drm_device *dev, void *data,
		struct drm_file *file_priv);</programlisting>
	</para>
	<para>
	  <parameter>flags</parameter> is a bitmask combination of the following
	  values. It restricts how the ioctl is allowed to be called.
	  <itemizedlist>
	    <listitem><para>
	      DRM_AUTH - Only authenticated callers allowed
	    </para></listitem>
	    <listitem><para>
	      DRM_MASTER - The ioctl can only be called on the master file
	      handle
	    </para></listitem>
            <listitem><para>
	      DRM_ROOT_ONLY - Only callers with the SYSADMIN capability allowed
	    </para></listitem>
            <listitem><para>
	      DRM_CONTROL_ALLOW - The ioctl can only be called on a control
	      device
	    </para></listitem>
            <listitem><para>
	      DRM_UNLOCKED - The ioctl handler will be called without locking
	      the DRM global mutex
	    </para></listitem>
	  </itemizedlist>
	</para>
      </para>
    </sect2>
  </sect1>
  <sect1>
    <title>Legacy Support Code</title>
    <para>
      The section very briefly covers some of the old legacy support code which
      is only used by old DRM drivers which have done a so-called shadow-attach
      to the underlying device instead of registering as a real driver. This
      also includes some of the old generic buffer management and command
      submission code. Do not use any of this in new and modern drivers.
    </para>

    <sect2>
      <title>Legacy Suspend/Resume</title>
      <para>
	The DRM core provides some suspend/resume code, but drivers wanting full
	suspend/resume support should provide save() and restore() functions.
	These are called at suspend, hibernate, or resume time, and should perform
	any state save or restore required by your device across suspend or
	hibernate states.
      </para>
      <synopsis>int (*suspend) (struct drm_device *, pm_message_t state);
  int (*resume) (struct drm_device *);</synopsis>
      <para>
	Those are legacy suspend and resume methods which
	<emphasis>only</emphasis> work with the legacy shadow-attach driver
	registration functions. New driver should use the power management
	interface provided by their bus type (usually through
	the struct <structname>device_driver</structname> dev_pm_ops) and set
	these methods to NULL.
      </para>
    </sect2>

    <sect2>
      <title>Legacy DMA Services</title>
      <para>
	This should cover how DMA mapping etc. is supported by the core.
	These functions are deprecated and should not be used.
      </para>
    </sect2>
  </sect1>
  </chapter>

<!-- TODO

- Add a glossary
- Document the struct_mutex catch-all lock
- Document connector properties

- Why is the load method optional?
- What are drivers supposed to set the initial display state to, and how?
  Connector's DPMS states are not initialized and are thus equal to
  DRM_MODE_DPMS_ON. The fbcon compatibility layer calls
  drm_helper_disable_unused_functions(), which disables unused encoders and
  CRTCs, but doesn't touch the connectors' DPMS state, and
  drm_helper_connector_dpms() in reaction to fbdev blanking events. Do drivers
  that don't implement (or just don't use) fbcon compatibility need to call
  those functions themselves?
- KMS drivers must call drm_vblank_pre_modeset() and drm_vblank_post_modeset()
  around mode setting. Should this be done in the DRM core?
- vblank_disable_allowed is set to 1 in the first drm_vblank_post_modeset()
  call and never set back to 0. It seems to be safe to permanently set it to 1
  in drm_vblank_init() for KMS driver, and it might be safe for UMS drivers as
  well. This should be investigated.
- crtc and connector .save and .restore operations are only used internally in
  drivers, should they be removed from the core?
- encoder mid-layer .save and .restore operations are only used internally in
  drivers, should they be removed from the core?
- encoder mid-layer .detect operation is only used internally in drivers,
  should it be removed from the core?
-->

  <!-- External interfaces -->

  <chapter id="drmExternals">
    <title>Userland interfaces</title>
    <para>
      The DRM core exports several interfaces to applications,
      generally intended to be used through corresponding libdrm
      wrapper functions.  In addition, drivers export device-specific
      interfaces for use by userspace drivers &amp; device-aware
      applications through ioctls and sysfs files.
    </para>
    <para>
      External interfaces include: memory mapping, context management,
      DMA operations, AGP management, vblank control, fence
      management, memory management, and output management.
    </para>
    <para>
      Cover generic ioctls and sysfs layout here.  We only need high-level
      info, since man pages should cover the rest.
    </para>

  <!-- External: render nodes -->

    <sect1>
      <title>Render nodes</title>
      <para>
        DRM core provides multiple character-devices for user-space to use.
        Depending on which device is opened, user-space can perform a different
        set of operations (mainly ioctls). The primary node is always created
        and called card&lt;num&gt;. Additionally, a currently
        unused control node, called controlD&lt;num&gt; is also
        created. The primary node provides all legacy operations and
        historically was the only interface used by userspace. With KMS, the
        control node was introduced. However, the planned KMS control interface
        has never been written and so the control node stays unused to date.
      </para>
      <para>
        With the increased use of offscreen renderers and GPGPU applications,
        clients no longer require running compositors or graphics servers to
        make use of a GPU. But the DRM API required unprivileged clients to
        authenticate to a DRM-Master prior to getting GPU access. To avoid this
        step and to grant clients GPU access without authenticating, render
        nodes were introduced. Render nodes solely serve render clients, that
        is, no modesetting or privileged ioctls can be issued on render nodes.
        Only non-global rendering commands are allowed. If a driver supports
        render nodes, it must advertise it via the DRIVER_RENDER
        DRM driver capability. If not supported, the primary node must be used
        for render clients together with the legacy drmAuth authentication
        procedure.
      </para>
      <para>
        If a driver advertises render node support, DRM core will create a
        separate render node called renderD&lt;num&gt;. There will
        be one render node per device. No ioctls except  PRIME-related ioctls
        will be allowed on this node. Especially GEM_OPEN will be
        explicitly prohibited. Render nodes are designed to avoid the
        buffer-leaks, which occur if clients guess the flink names or mmap
        offsets on the legacy interface. Additionally to this basic interface,
        drivers must mark their driver-dependent render-only ioctls as
        DRM_RENDER_ALLOW so render clients can use them. Driver
        authors must be careful not to allow any privileged ioctls on render
        nodes.
      </para>
      <para>
        With render nodes, user-space can now control access to the render node
        via basic file-system access-modes. A running graphics server which
        authenticates clients on the privileged primary/legacy node is no longer
        required. Instead, a client can open the render node and is immediately
        granted GPU access. Communication between clients (or servers) is done
        via PRIME. FLINK from render node to legacy node is not supported. New
        clients must not use the insecure FLINK interface.
      </para>
      <para>
        Besides dropping all modeset/global ioctls, render nodes also drop the
        DRM-Master concept. There is no reason to associate render clients with
        a DRM-Master as they are independent of any graphics server. Besides,
        they must work without any running master, anyway.
        Drivers must be able to run without a master object if they support
        render nodes. If, on the other hand, a driver requires shared state
        between clients which is visible to user-space and accessible beyond
        open-file boundaries, they cannot support render nodes.
      </para>
    </sect1>

  <!-- External: vblank handling -->

    <sect1>
      <title>VBlank event handling</title>
      <para>
        The DRM core exposes two vertical blank related ioctls:
        <variablelist>
          <varlistentry>
            <term>DRM_IOCTL_WAIT_VBLANK</term>
            <listitem>
              <para>
                This takes a struct drm_wait_vblank structure as its argument,
                and it is used to block or request a signal when a specified
                vblank event occurs.
              </para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>DRM_IOCTL_MODESET_CTL</term>
            <listitem>
              <para>
		This was only used for user-mode-settind drivers around
		modesetting changes to allow the kernel to update the vblank
		interrupt after mode setting, since on many devices the vertical
		blank counter is reset to 0 at some point during modeset. Modern
		drivers should not call this any more since with kernel mode
		setting it is a no-op.
              </para>
            </listitem>
          </varlistentry>
        </variablelist>
      </para>
    </sect1>

  </chapter>
</part>
<part id="drmDrivers">
  <title>DRM Drivers</title>

  <partintro>
    <para>
      This second part of the DRM Developer's Guide documents driver code,
      implementation details and also all the driver-specific userspace
      interfaces. Especially since all hardware-acceleration interfaces to
      userspace are driver specific for efficiency and other reasons these
      interfaces can be rather substantial. Hence every driver has its own
      chapter.
    </para>
  </partintro>

  <chapter id="drmI915">
    <title>drm/i915 Intel GFX Driver</title>
    <para>
      The drm/i915 driver supports all (with the exception of some very early
      models) integrated GFX chipsets with both Intel display and rendering
      blocks. This excludes a set of SoC platforms with an SGX rendering unit,
      those have basic support through the gma500 drm driver.
    </para>
    <sect1>
      <title>Display Hardware Handling</title>
      <para>
        This section covers everything related to the display hardware including
        the mode setting infrastructure, plane, sprite and cursor handling and
        display, output probing and related topics.
      </para>
      <sect2>
        <title>Mode Setting Infrastructure</title>
        <para>
          The i915 driver is thus far the only DRM driver which doesn't use the
          common DRM helper code to implement mode setting sequences. Thus it
          has its own tailor-made infrastructure for executing a display
          configuration change.
        </para>
      </sect2>
      <sect2>
        <title>Plane Configuration</title>
        <para>
	  This section covers plane configuration and composition with the
	  primary plane, sprites, cursors and overlays. This includes the
	  infrastructure to do atomic vsync'ed updates of all this state and
	  also tightly coupled topics like watermark setup and computation,
	  framebuffer compression and panel self refresh.
        </para>
      </sect2>
      <sect2>
        <title>Output Probing</title>
        <para>
	  This section covers output probing and related infrastructure like the
	  hotplug interrupt storm detection and mitigation code. Note that the
	  i915 driver still uses most of the common DRM helper code for output
	  probing, so those sections fully apply.
        </para>
      </sect2>
      <sect2>
        <title>DPIO</title>
<para>
   </para><para>
   VLV and CHV have slightly peculiar display PHYs for driving DP/HDMI
   ports. DPIO is the name given to such a display PHY. These PHYs
   don't follow the standard programming model using direct MMIO
   registers, and instead their registers must be accessed trough IOSF
   sideband. VLV has one such PHY for driving ports B and C, and CHV
   adds another PHY for driving port D. Each PHY responds to specific
   IOSF-SB port.
   </para><para>
   Each display PHY is made up of one or two channels. Each channel
   houses a common lane part which contains the PLL and other common
   logic. CH0 common lane also contains the IOSF-SB logic for the
   Common Register Interface (CRI) ie. the DPIO registers. CRI clock
   must be running when any DPIO registers are accessed.
   </para><para>
   In addition to having their own registers, the PHYs are also
   controlled through some dedicated signals from the display
   controller. These include PLL reference clock enable, PLL enable,
   and CRI clock selection, for example.
   </para><para>
   Eeach channel also has two splines (also called data lanes), and
   each spline is made up of one Physical Access Coding Sub-Layer
   (PCS) block and two TX lanes. So each channel has two PCS blocks
   and four TX lanes. The TX lanes are used as DP lanes or TMDS
   data/clock pairs depending on the output type.
   </para><para>
   Additionally the PHY also contains an AUX lane with AUX blocks
   for each channel. This is used for DP AUX communication, but
   this fact isn't really relevant for the driver since AUX is
   controlled from the display controller side. No DPIO registers
   need to be accessed during AUX communication,
   </para><para>
   Generally the common lane corresponds to the pipe and
   the spline (PCS/TX) correponds to the port.
   </para><para>
   For dual channel PHY (VLV/CHV):
   </para><para>
   pipe A == CMN/PLL/REF CH0
   </para><para>
   pipe B == CMN/PLL/REF CH1
   </para><para>
   port B == PCS/TX CH0
   </para><para>
   port C == PCS/TX CH1
   </para><para>
   This is especially important when we cross the streams
   ie. drive port B with pipe B, or port C with pipe A.
   </para><para>
   For single channel PHY (CHV):
   </para><para>
   pipe C == CMN/PLL/REF CH0
   </para><para>
   port D == PCS/TX CH0
   </para><para>
   Note: digital port B is DDI0, digital port C is DDI1,
   digital port D is DDI2
</para>

	<table id="dpiox2">
	  <title>Dual channel PHY (VLV/CHV)</title>
	  <tgroup cols="8">
	    <colspec colname="c0" />
	    <colspec colname="c1" />
	    <colspec colname="c2" />
	    <colspec colname="c3" />
	    <colspec colname="c4" />
	    <colspec colname="c5" />
	    <colspec colname="c6" />
	    <colspec colname="c7" />
	    <spanspec spanname="ch0" namest="c0" nameend="c3" />
	    <spanspec spanname="ch1" namest="c4" nameend="c7" />
	    <spanspec spanname="ch0pcs01" namest="c0" nameend="c1" />
	    <spanspec spanname="ch0pcs23" namest="c2" nameend="c3" />
	    <spanspec spanname="ch1pcs01" namest="c4" nameend="c5" />
	    <spanspec spanname="ch1pcs23" namest="c6" nameend="c7" />
	    <thead>
	      <row>
		<entry spanname="ch0">CH0</entry>
		<entry spanname="ch1">CH1</entry>
	      </row>
	    </thead>
	    <tbody valign="top" align="center">
	      <row>
		<entry spanname="ch0">CMN/PLL/REF</entry>
		<entry spanname="ch1">CMN/PLL/REF</entry>
	      </row>
	      <row>
		<entry spanname="ch0pcs01">PCS01</entry>
		<entry spanname="ch0pcs23">PCS23</entry>
		<entry spanname="ch1pcs01">PCS01</entry>
		<entry spanname="ch1pcs23">PCS23</entry>
	      </row>
	      <row>
		<entry>TX0</entry>
		<entry>TX1</entry>
		<entry>TX2</entry>
		<entry>TX3</entry>
		<entry>TX0</entry>
		<entry>TX1</entry>
		<entry>TX2</entry>
		<entry>TX3</entry>
	      </row>
	      <row>
		<entry spanname="ch0">DDI0</entry>
		<entry spanname="ch1">DDI1</entry>
	      </row>
	    </tbody>
	  </tgroup>
	</table>
	<table id="dpiox1">
	  <title>Single channel PHY (CHV)</title>
	  <tgroup cols="4">
	    <colspec colname="c0" />
	    <colspec colname="c1" />
	    <colspec colname="c2" />
	    <colspec colname="c3" />
	    <spanspec spanname="ch0" namest="c0" nameend="c3" />
	    <spanspec spanname="ch0pcs01" namest="c0" nameend="c1" />
	    <spanspec spanname="ch0pcs23" namest="c2" nameend="c3" />
	    <thead>
	      <row>
		<entry spanname="ch0">CH0</entry>
	      </row>
	    </thead>
	    <tbody valign="top" align="center">
	      <row>
		<entry spanname="ch0">CMN/PLL/REF</entry>
	      </row>
	      <row>
		<entry spanname="ch0pcs01">PCS01</entry>
		<entry spanname="ch0pcs23">PCS23</entry>
	      </row>
	      <row>
		<entry>TX0</entry>
		<entry>TX1</entry>
		<entry>TX2</entry>
		<entry>TX3</entry>
	      </row>
	      <row>
		<entry spanname="ch0">DDI2</entry>
	      </row>
	    </tbody>
	  </tgroup>
	</table>
      </sect2>
    </sect1>

    <sect1>
      <title>Memory Management and Command Submission</title>
      <para>
	This sections covers all things related to the GEM implementation in the
	i915 driver.
      </para>
      <sect2>
        <title>Batchbuffer Parsing</title>
<para>
   </para><para>
   Motivation:
   Certain OpenGL features (e.g. transform feedback, performance monitoring)
   require userspace code to submit batches containing commands such as
   MI_LOAD_REGISTER_IMM to access various registers. Unfortunately, some
   generations of the hardware will noop these commands in <quote>unsecure</quote> batches
   (which includes all userspace batches submitted via i915) even though the
   commands may be safe and represent the intended programming model of the
   device.
   </para><para>
   The software command parser is similar in operation to the command parsing
   done in hardware for unsecure batches. However, the software parser allows
   some operations that would be noop'd by hardware, if the parser determines
   the operation is safe, and submits the batch as <quote>secure</quote> to prevent hardware
   parsing.
   </para><para>
   Threats:
   At a high level, the hardware (and software) checks attempt to prevent
   granting userspace undue privileges. There are three categories of privilege.
   </para><para>
   First, commands which are explicitly defined as privileged or which should
   only be used by the kernel driver. The parser generally rejects such
   commands, though it may allow some from the drm master process.
   </para><para>
   Second, commands which access registers. To support correct/enhanced
   userspace functionality, particularly certain OpenGL extensions, the parser
   provides a whitelist of registers which userspace may safely access (for both
   normal and drm master processes).
   </para><para>
   Third, commands which access privileged memory (i.e. GGTT, HWS page, etc).
   The parser always rejects such commands.
   </para><para>
   The majority of the problematic commands fall in the MI_* range, with only a
   few specific commands on each ring (e.g. PIPE_CONTROL and MI_FLUSH_DW).
   </para><para>
   Implementation:
   Each ring maintains tables of commands and registers which the parser uses in
   scanning batch buffers submitted to that ring.
   </para><para>
   Since the set of commands that the parser must check for is significantly
   smaller than the number of commands supported, the parser tables contain only
   those commands required by the parser. This generally works because command
   opcode ranges have standard command length encodings. So for commands that
   the parser does not need to check, it can easily skip them. This is
   implementated via a per-ring length decoding vfunc.
   </para><para>
   Unfortunately, there are a number of commands that do not follow the standard
   length encoding for their opcode range, primarily amongst the MI_* commands.
   To handle this, the parser provides a way to define explicit <quote>skip</quote> entries
   in the per-ring command tables.
   </para><para>
   Other command table entries map fairly directly to high level categories
   mentioned above: rejected, master-only, register whitelist. The parser
   implements a number of checks, including the privileged memory checks, via a
   general bitmasking mechanism.
</para>

<!-- drivers/gpu/drm/i915/i915_cmd_parser.c -->
<refentry id="API-i915-cmd-parser-init-ring">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>i915_cmd_parser_init_ring</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>i915_cmd_parser_init_ring</refname>
 <refpurpose>
  set cmd parser related fields for a ringbuffer
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>i915_cmd_parser_init_ring </function></funcdef>
   <paramdef>struct intel_engine_cs * <parameter>ring</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ring</parameter></term>
   <listitem>
    <para>
     the ringbuffer to initialize
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Optionally initializes fields related to batch buffer command parsing in the
   struct intel_engine_cs based on whether the platform requires software
   command parsing.
</para>
</refsect1>
<refsect1>
<title>Return</title>
<para>
   non-zero if initialization fails
</para>
</refsect1>
</refentry>

<refentry id="API-i915-cmd-parser-fini-ring">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>i915_cmd_parser_fini_ring</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>i915_cmd_parser_fini_ring</refname>
 <refpurpose>
     clean up cmd parser related fields
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>i915_cmd_parser_fini_ring </function></funcdef>
   <paramdef>struct intel_engine_cs * <parameter>ring</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ring</parameter></term>
   <listitem>
    <para>
     the ringbuffer to clean up
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Releases any resources related to command parsing that may have been
   initialized for the specified ring.
</para>
</refsect1>
</refentry>

<refentry id="API-i915-needs-cmd-parser">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>i915_needs_cmd_parser</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>i915_needs_cmd_parser</refname>
 <refpurpose>
     should a given ring use software command parsing?
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>bool <function>i915_needs_cmd_parser </function></funcdef>
   <paramdef>struct intel_engine_cs * <parameter>ring</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ring</parameter></term>
   <listitem>
    <para>
     the ring in question
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Only certain platforms require software batch buffer command parsing, and
   only when enabled via module paramter.
</para>
</refsect1>
<refsect1>
<title>Return</title>
<para>
   true if the ring requires software command parsing
</para>
</refsect1>
</refentry>

<refentry id="API-i915-parse-cmds">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>i915_parse_cmds</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>i915_parse_cmds</refname>
 <refpurpose>
     parse a submitted batch buffer for privilege violations
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>i915_parse_cmds </function></funcdef>
   <paramdef>struct intel_engine_cs * <parameter>ring</parameter></paramdef>
   <paramdef>struct drm_i915_gem_object * <parameter>batch_obj</parameter></paramdef>
   <paramdef>u32 <parameter>batch_start_offset</parameter></paramdef>
   <paramdef>bool <parameter>is_master</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ring</parameter></term>
   <listitem>
    <para>
     the ring on which the batch is to execute
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>batch_obj</parameter></term>
   <listitem>
    <para>
     the batch buffer in question
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>batch_start_offset</parameter></term>
   <listitem>
    <para>
     byte offset in the batch at which execution starts
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>is_master</parameter></term>
   <listitem>
    <para>
     is the submitting process the drm master?
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Parses the specified batch buffer looking for privilege violations as
   described in the overview.
</para>
</refsect1>
<refsect1>
<title>Return</title>
<para>
   non-zero if the parser finds violations or otherwise fails
</para>
</refsect1>
</refentry>

<refentry id="API-i915-cmd-parser-get-version">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>i915_cmd_parser_get_version</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>i915_cmd_parser_get_version</refname>
 <refpurpose>
     get the cmd parser version number
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>i915_cmd_parser_get_version </function></funcdef>
   <paramdef> <parameter>void</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>void</parameter></term>
   <listitem>
    <para>
     no arguments
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   </para><para>

   The cmd parser maintains a simple increasing integer version number suitable
   for passing to userspace clients to determine what operations are permitted.
</para>
</refsect1>
<refsect1>
<title>Return</title>
<para>
   the current version number of the cmd parser
</para>
</refsect1>
</refentry>

      </sect2>
      <sect2>
        <title>Logical Rings, Logical Ring Contexts and Execlists</title>
<para>
   </para><para>
   Motivation:
   GEN8 brings an expansion of the HW contexts: <quote>Logical Ring Contexts</quote>.
   These expanded contexts enable a number of new abilities, especially
   <quote>Execlists</quote> (also implemented in this file).
   </para><para>
   One of the main differences with the legacy HW contexts is that logical
   ring contexts incorporate many more things to the context's state, like
   PDPs or ringbuffer control registers:
   </para><para>
   The reason why PDPs are included in the context is straightforward: as
   PPGTTs (per-process GTTs) are actually per-context, having the PDPs
   contained there mean you don't need to do a ppgtt-&gt;switch_mm yourself,
   instead, the GPU will do it for you on the context switch.
   </para><para>
   But, what about the ringbuffer control registers (head, tail, etc..)?
   shouldn't we just need a set of those per engine command streamer? This is
   where the name <quote>Logical Rings</quote> starts to make sense: by virtualizing the
   rings, the engine cs shifts to a new <quote>ring buffer</quote> with every context
   switch. When you want to submit a workload to the GPU you: A) choose your
   context, B) find its appropriate virtualized ring, C) write commands to it
   and then, finally, D) tell the GPU to switch to that context.
   </para><para>
   Instead of the legacy MI_SET_CONTEXT, the way you tell the GPU to switch
   to a contexts is via a context execution list, ergo <quote>Execlists</quote>.
   </para><para>
   LRC implementation:
   Regarding the creation of contexts, we have:
   </para><para>
   - One global default context.
   - One local default context for each opened fd.
   - One local extra context for each context create ioctl call.
   </para><para>
   Now that ringbuffers belong per-context (and not per-engine, like before)
   and that contexts are uniquely tied to a given engine (and not reusable,
   like before) we need:
   </para><para>
   - One ringbuffer per-engine inside each context.
   - One backing object per-engine inside each context.
   </para><para>
   The global default context starts its life with these new objects fully
   allocated and populated. The local default context for each opened fd is
   more complex, because we don't know at creation time which engine is going
   to use them. To handle this, we have implemented a deferred creation of LR
   contexts:
   </para><para>
   The local context starts its life as a hollow or blank holder, that only
   gets populated for a given engine once we receive an execbuffer. If later
   on we receive another execbuffer ioctl for the same context but a different
   engine, we allocate/populate a new ringbuffer and context backing object and
   so on.
   </para><para>
   Finally, regarding local contexts created using the ioctl call: as they are
   only allowed with the render ring, we can allocate &amp; populate them right
   away (no need to defer anything, at least for now).
   </para><para>
   Execlists implementation:
   Execlists are the new method by which, on gen8+ hardware, workloads are
   submitted for execution (as opposed to the legacy, ringbuffer-based, method).
   This method works as follows:
   </para><para>
   When a request is committed, its commands (the BB start and any leading or
   trailing commands, like the seqno breadcrumbs) are placed in the ringbuffer
   for the appropriate context. The tail pointer in the hardware context is not
   updated at this time, but instead, kept by the driver in the ringbuffer
   structure. A structure representing this request is added to a request queue
   for the appropriate engine: this structure contains a copy of the context's
   tail after the request was written to the ring buffer and a pointer to the
   context itself.
   </para><para>
   If the engine's request queue was empty before the request was added, the
   queue is processed immediately. Otherwise the queue will be processed during
   a context switch interrupt. In any case, elements on the queue will get sent
   (in pairs) to the GPU's ExecLists Submit Port (ELSP, for short) with a
   globally unique 20-bits submission ID.
   </para><para>
   When execution of a request completes, the GPU updates the context status
   buffer with a context complete event and generates a context switch interrupt.
   During the interrupt handling, the driver examines the events in the buffer:
   for each context complete event, if the announced ID matches that on the head
   of the request queue, then that request is retired and removed from the queue.
   </para><para>
   After processing, if any requests were retired and the queue is not empty
   then a new execution list can be submitted. The two requests at the front of
   the queue are next to be submitted but since a context may not occur twice in
   an execution list, if subsequent requests have the same ID as the first then
   the two requests must be combined. This is done simply by discarding requests
   at the head of the queue until either only one requests is left (in which case
   we use a NULL second context) or the first two requests have unique IDs.
   </para><para>
   By always executing the first two requests in the queue the driver ensures
   that the GPU is kept as busy as possible. In the case where a single context
   completes but a second context is still executing, the request for this second
   context will be at the head of the queue when we remove the first one. This
   request will then be resubmitted along with a new request for a different context,
   which will cause the hardware to continue executing the second request and queue
   the new request (the GPU detects the condition of a context getting preempted
   with the same context and optimizes the context switch flow by not doing
   preemption, but just sampling the new tail pointer).
   </para><para>
</para>

<!-- drivers/gpu/drm/i915/intel_lrc.c -->
<refentry id="API-intel-sanitize-enable-execlists">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>intel_sanitize_enable_execlists</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>intel_sanitize_enable_execlists</refname>
 <refpurpose>
  sanitize i915.enable_execlists
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>intel_sanitize_enable_execlists </function></funcdef>
   <paramdef>struct drm_device * <parameter>dev</parameter></paramdef>
   <paramdef>int <parameter>enable_execlists</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     DRM device.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>enable_execlists</parameter></term>
   <listitem>
    <para>
     value of i915.enable_execlists module parameter.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Only certain platforms support Execlists (the prerequisites being
   support for Logical Ring Contexts and Aliasing PPGTT or better),
   and only when enabled via module parameter.
</para>
</refsect1>
<refsect1>
<title>Return</title>
<para>
   1 if Execlists is supported and has to be enabled.
</para>
</refsect1>
</refentry>

<refentry id="API-intel-execlists-ctx-id">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>intel_execlists_ctx_id</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>intel_execlists_ctx_id</refname>
 <refpurpose>
     get the Execlists Context ID
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>u32 <function>intel_execlists_ctx_id </function></funcdef>
   <paramdef>struct drm_i915_gem_object * <parameter>ctx_obj</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ctx_obj</parameter></term>
   <listitem>
    <para>
     Logical Ring Context backing object.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Do not confuse with ctx-&gt;id! Unfortunately we have a name overload
</para>
</refsect1>
<refsect1>
<title>here</title>
<para>
   the old context ID we pass to userspace as a handler so that
   they can refer to a context, and the new context ID we pass to the
   ELSP so that the GPU can inform us of the context status via
   interrupts.
</para>
</refsect1>
<refsect1>
<title>Return</title>
<para>
   20-bits globally unique context ID.
</para>
</refsect1>
</refentry>

<refentry id="API-intel-execlists-handle-ctx-events">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>intel_execlists_handle_ctx_events</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>intel_execlists_handle_ctx_events</refname>
 <refpurpose>
     handle Context Switch interrupts
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>intel_execlists_handle_ctx_events </function></funcdef>
   <paramdef>struct intel_engine_cs * <parameter>ring</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ring</parameter></term>
   <listitem>
    <para>
     Engine Command Streamer to handle.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Check the unread Context Status Buffers and manage the submission of new
   contexts to the ELSP accordingly.
</para>
</refsect1>
</refentry>

<refentry id="API-intel-execlists-submission">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>intel_execlists_submission</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>intel_execlists_submission</refname>
 <refpurpose>
     submit a batchbuffer for execution, Execlists style
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>intel_execlists_submission </function></funcdef>
   <paramdef>struct drm_device * <parameter>dev</parameter></paramdef>
   <paramdef>struct drm_file * <parameter>file</parameter></paramdef>
   <paramdef>struct intel_engine_cs * <parameter>ring</parameter></paramdef>
   <paramdef>struct intel_context * <parameter>ctx</parameter></paramdef>
   <paramdef>struct drm_i915_gem_execbuffer2 * <parameter>args</parameter></paramdef>
   <paramdef>struct list_head * <parameter>vmas</parameter></paramdef>
   <paramdef>struct drm_i915_gem_object * <parameter>batch_obj</parameter></paramdef>
   <paramdef>u64 <parameter>exec_start</parameter></paramdef>
   <paramdef>u32 <parameter>flags</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     DRM device.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>file</parameter></term>
   <listitem>
    <para>
     DRM file.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>ring</parameter></term>
   <listitem>
    <para>
     Engine Command Streamer to submit to.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>ctx</parameter></term>
   <listitem>
    <para>
     Context to employ for this submission.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>args</parameter></term>
   <listitem>
    <para>
     execbuffer call arguments.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>vmas</parameter></term>
   <listitem>
    <para>
     list of vmas.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>batch_obj</parameter></term>
   <listitem>
    <para>
     the batchbuffer to submit.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>exec_start</parameter></term>
   <listitem>
    <para>
     batchbuffer start virtual address pointer.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>flags</parameter></term>
   <listitem>
    <para>
     translated execbuffer call flags.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This is the evil twin version of i915_gem_ringbuffer_submission. It abstracts
   away the submission details of the execbuffer ioctl call.
</para>
</refsect1>
<refsect1>
<title>Return</title>
<para>
   non-zero if the submission fails.
</para>
</refsect1>
</refentry>

<refentry id="API-intel-logical-ring-advance-and-submit">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>intel_logical_ring_advance_and_submit</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>intel_logical_ring_advance_and_submit</refname>
 <refpurpose>
     advance the tail and submit the workload
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>intel_logical_ring_advance_and_submit </function></funcdef>
   <paramdef>struct intel_ringbuffer * <parameter>ringbuf</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ringbuf</parameter></term>
   <listitem>
    <para>
     Logical Ringbuffer to advance.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   The tail is updated in our logical ringbuffer struct, not in the actual context. What
   really happens during submission is that the context and current tail will be placed
   on a queue waiting for the ELSP to be ready to accept a new context submission. At that
   point, the tail *inside* the context is updated and the ELSP written to.
</para>
</refsect1>
</refentry>

<refentry id="API-intel-logical-ring-begin">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>intel_logical_ring_begin</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>intel_logical_ring_begin</refname>
 <refpurpose>
     prepare the logical ringbuffer to accept some commands
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>intel_logical_ring_begin </function></funcdef>
   <paramdef>struct intel_ringbuffer * <parameter>ringbuf</parameter></paramdef>
   <paramdef>int <parameter>num_dwords</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ringbuf</parameter></term>
   <listitem>
    <para>
     Logical ringbuffer.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>num_dwords</parameter></term>
   <listitem>
    <para>
     number of DWORDs that we plan to write to the ringbuffer.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   The ringbuffer might not be ready to accept the commands right away (maybe it needs to
   be wrapped, or wait a bit for the tail to be updated). This function takes care of that
   and also preallocates a request (every workload submission is still mediated through
   requests, same as it did with legacy ringbuffer submission).
</para>
</refsect1>
<refsect1>
<title>Return</title>
<para>
   non-zero if the ringbuffer is not ready to be written to.
</para>
</refsect1>
</refentry>

<refentry id="API-intel-logical-ring-cleanup">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>intel_logical_ring_cleanup</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>intel_logical_ring_cleanup</refname>
 <refpurpose>
     deallocate the Engine Command Streamer
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>intel_logical_ring_cleanup </function></funcdef>
   <paramdef>struct intel_engine_cs * <parameter>ring</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ring</parameter></term>
   <listitem>
    <para>
     Engine Command Streamer.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-intel-logical-rings-init">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>intel_logical_rings_init</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>intel_logical_rings_init</refname>
 <refpurpose>
     allocate, populate and init the Engine Command Streamers
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>intel_logical_rings_init </function></funcdef>
   <paramdef>struct drm_device * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     DRM device.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This function inits the engines for an Execlists submission style (the equivalent in the
   legacy ringbuffer submission world would be i915_gem_init_rings). It does it only for
   those engines that are present in the hardware.
</para>
</refsect1>
<refsect1>
<title>Return</title>
<para>
   non-zero if the initialization failed.
</para>
</refsect1>
</refentry>

<refentry id="API-intel-lr-context-free">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>intel_lr_context_free</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>intel_lr_context_free</refname>
 <refpurpose>
     free the LRC specific bits of a context
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>intel_lr_context_free </function></funcdef>
   <paramdef>struct intel_context * <parameter>ctx</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ctx</parameter></term>
   <listitem>
    <para>
     the LR context to free.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>The real context freeing is done in i915_gem_context_free</title>
<para>
   this only
</para>
</refsect1>
<refsect1>
<title>takes care of the bits that are LRC related</title>
<para>
   the per-engine backing
   objects and the logical ringbuffer.
</para>
</refsect1>
</refentry>

<refentry id="API-intel-lr-context-deferred-create">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>intel_lr_context_deferred_create</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>intel_lr_context_deferred_create</refname>
 <refpurpose>
     create the LRC specific bits of a context
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>intel_lr_context_deferred_create </function></funcdef>
   <paramdef>struct intel_context * <parameter>ctx</parameter></paramdef>
   <paramdef>struct intel_engine_cs * <parameter>ring</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ctx</parameter></term>
   <listitem>
    <para>
     LR context to create.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>ring</parameter></term>
   <listitem>
    <para>
     engine to be used with the context.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This function can be called more than once, with different engines, if we plan
   to use the context with them. The context backing objects and the ringbuffers
   (specially the ringbuffer backing objects) suck a lot of memory up, and that's why
</para>
</refsect1>
<refsect1>
<title>the creation is a deferred call</title>
<para>
   it's better to make sure first that we need to use
   a given ring with the context.
</para>
</refsect1>
<refsect1>
<title>Return</title>
<para>
   non-zero on eror.
</para>
</refsect1>
</refentry>

      </sect2>
    </sect1>
  </chapter>
</part>
</book>
