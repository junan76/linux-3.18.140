<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>struct spi_master</title><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot"><link rel="home" href="index.html" title="Linux Device Drivers"><link rel="up" href="spi.html" title="Chapter 9. Serial Peripheral Interface (SPI)"><link rel="prev" href="API-module-spi-driver.html" title="module_spi_driver"><link rel="next" href="API-struct-spi-transfer.html" title="struct spi_transfer"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center"><span class="phrase">struct spi_master</span></th></tr><tr><td width="20%" align="left"><a accesskey="p" href="API-module-spi-driver.html">Prev</a> </td><th width="60%" align="center">Chapter 9. Serial Peripheral Interface (SPI)</th><td width="20%" align="right"> <a accesskey="n" href="API-struct-spi-transfer.html">Next</a></td></tr></table><hr></div><div class="refentry"><a name="API-struct-spi-master"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>struct spi_master — 
     interface to SPI master controller
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><pre class="programlisting">
struct spi_master {
  struct device dev;
  struct list_head list;
  s16 bus_num;
  u16 num_chipselect;
  u16 dma_alignment;
  u16 mode_bits;
  u32 bits_per_word_mask;
#define SPI_BPW_MASK(bits) BIT((bits) - 1)
#define SPI_BIT_MASK(bits) (((bits) == 32) ? ~0U : (BIT(bits) - 1))
#define SPI_BPW_RANGE_MASK(min# max) (SPI_BIT_MASK(max) - SPI_BIT_MASK(min - 1))
  u32 min_speed_hz;
  u32 max_speed_hz;
  u16 flags;
#define SPI_MASTER_HALF_DUPLEX	BIT(0)
#define SPI_MASTER_NO_RX	BIT(1)
#define SPI_MASTER_NO_TX	BIT(2)
#define SPI_MASTER_MUST_RX      BIT(3)
#define SPI_MASTER_MUST_TX      BIT(4)
  spinlock_t bus_lock_spinlock;
  struct mutex bus_lock_mutex;
  bool bus_lock_flag;
  int (* setup) (struct spi_device *spi);
  int (* transfer) (struct spi_device *spi,struct spi_message *mesg);
  void (* cleanup) (struct spi_device *spi);
  bool (* can_dma) (struct spi_master *master,struct spi_device *spi,struct spi_transfer *xfer);
  bool queued;
  struct kthread_worker kworker;
  struct task_struct * kworker_task;
  struct kthread_work pump_messages;
  spinlock_t queue_lock;
  struct list_head queue;
  struct spi_message * cur_msg;
  bool busy;
  bool running;
  bool rt;
  bool auto_runtime_pm;
  bool cur_msg_prepared;
  bool cur_msg_mapped;
  struct completion xfer_completion;
  size_t max_dma_len;
  int (* prepare_transfer_hardware) (struct spi_master *master);
  int (* transfer_one_message) (struct spi_master *master,struct spi_message *mesg);
  int (* unprepare_transfer_hardware) (struct spi_master *master);
  int (* prepare_message) (struct spi_master *master,struct spi_message *message);
  int (* unprepare_message) (struct spi_master *master,struct spi_message *message);
  void (* set_cs) (struct spi_device *spi, bool enable);
  int (* transfer_one) (struct spi_master *master, struct spi_device *spi,struct spi_transfer *transfer);
  int * cs_gpios;
  struct dma_chan * dma_tx;
  struct dma_chan * dma_rx;
  void * dummy_rx;
  void * dummy_tx;
};  </pre></div><div class="refsect1"><a name="idm40975"></a><h2>Members</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term">dev</span></dt><dd><p>
   device interface to this driver
      </p></dd><dt><span class="term">list</span></dt><dd><p>
   link with the global spi_master list
      </p></dd><dt><span class="term">bus_num</span></dt><dd><p>
   board-specific (and often SOC-specific) identifier for a
   given SPI controller.
      </p></dd><dt><span class="term">num_chipselect</span></dt><dd><p>
   chipselects are used to distinguish individual
   SPI slaves, and are numbered from zero to num_chipselects.
   each slave has a chipselect signal, but it's common that not
   every chipselect is connected to a slave.
      </p></dd><dt><span class="term">dma_alignment</span></dt><dd><p>
   SPI controller constraint on DMA buffers alignment.
      </p></dd><dt><span class="term">mode_bits</span></dt><dd><p>
   flags understood by this controller driver
      </p></dd><dt><span class="term">bits_per_word_mask</span></dt><dd><p>
   A mask indicating which values of bits_per_word are
   supported by the driver. Bit n indicates that a bits_per_word n+1 is
   supported. If set, the SPI core will reject any transfer with an
   unsupported bits_per_word. If not set, this value is simply ignored,
   and it's up to the individual driver to perform any validation.
      </p></dd><dt><span class="term">min_speed_hz</span></dt><dd><p>
   Lowest supported transfer speed
      </p></dd><dt><span class="term">max_speed_hz</span></dt><dd><p>
   Highest supported transfer speed
      </p></dd><dt><span class="term">flags</span></dt><dd><p>
   other constraints relevant to this driver
      </p></dd><dt><span class="term">bus_lock_spinlock</span></dt><dd><p>
   spinlock for SPI bus locking
      </p></dd><dt><span class="term">bus_lock_mutex</span></dt><dd><p>
   mutex for SPI bus locking
      </p></dd><dt><span class="term">bus_lock_flag</span></dt><dd><p>
   indicates that the SPI bus is locked for exclusive use
      </p></dd><dt><span class="term">setup</span></dt><dd><p>
   updates the device mode and clocking records used by a
   device's SPI controller; protocol code may call this.  This
   must fail if an unrecognized or unsupported mode is requested.
   It's always safe to call this unless transfers are pending on
   the device whose settings are being modified.
      </p></dd><dt><span class="term">transfer</span></dt><dd><p>
   adds a message to the controller's transfer queue.
      </p></dd><dt><span class="term">cleanup</span></dt><dd><p>
   frees controller-specific state
      </p></dd><dt><span class="term">can_dma</span></dt><dd><p>
   determine whether this master supports DMA
      </p></dd><dt><span class="term">queued</span></dt><dd><p>
   whether this master is providing an internal message queue
      </p></dd><dt><span class="term">kworker</span></dt><dd><p>
   thread struct for message pump
      </p></dd><dt><span class="term">kworker_task</span></dt><dd><p>
   pointer to task for message pump kworker thread
      </p></dd><dt><span class="term">pump_messages</span></dt><dd><p>
   work struct for scheduling work to the message pump
      </p></dd><dt><span class="term">queue_lock</span></dt><dd><p>
   spinlock to syncronise access to message queue
      </p></dd><dt><span class="term">queue</span></dt><dd><p>
   message queue
      </p></dd><dt><span class="term">cur_msg</span></dt><dd><p>
   the currently in-flight message
      </p></dd><dt><span class="term">busy</span></dt><dd><p>
   message pump is busy
      </p></dd><dt><span class="term">running</span></dt><dd><p>
   message pump is running
      </p></dd><dt><span class="term">rt</span></dt><dd><p>
   whether this queue is set to run as a realtime task
      </p></dd><dt><span class="term">auto_runtime_pm</span></dt><dd><p>
   the core should ensure a runtime PM reference is held
   while the hardware is prepared, using the parent
   device for the spidev
      </p></dd><dt><span class="term">cur_msg_prepared</span></dt><dd><p>
   spi_prepare_message was called for the currently
   in-flight message
      </p></dd><dt><span class="term">cur_msg_mapped</span></dt><dd><p>
   message has been mapped for DMA
      </p></dd><dt><span class="term">xfer_completion</span></dt><dd><p>
   used by core <code class="function">transfer_one_message</code>
      </p></dd><dt><span class="term">max_dma_len</span></dt><dd><p>
   Maximum length of a DMA transfer for the device.
      </p></dd><dt><span class="term">prepare_transfer_hardware</span></dt><dd><p>
   a message will soon arrive from the queue
   so the subsystem requests the driver to prepare the transfer hardware
   by issuing this call
      </p></dd><dt><span class="term">transfer_one_message</span></dt><dd><p>
   the subsystem calls the driver to transfer a single
   message while queuing transfers that arrive in the meantime. When the
   driver is finished with this message, it must call
   <code class="function">spi_finalize_current_message</code> so the subsystem can issue the next
   message
      </p></dd><dt><span class="term">unprepare_transfer_hardware</span></dt><dd><p>
   there are currently no more messages on the
   queue so the subsystem notifies the driver that it may relax the
   hardware by issuing this call
      </p></dd><dt><span class="term">prepare_message</span></dt><dd><p>
   set up the controller to transfer a single message,
   for example doing DMA mapping.  Called from threaded
   context.
      </p></dd><dt><span class="term">unprepare_message</span></dt><dd><p>
   undo any work done by <code class="function">prepare_message</code>.
      </p></dd><dt><span class="term">set_cs</span></dt><dd><p>
   set the logic level of the chip select line.  May be called
   from interrupt context.
      </p></dd><dt><span class="term">transfer_one</span></dt><dd><p>
   transfer a single spi_transfer.
   - return 0 if the transfer is finished,
   - return 1 if the transfer is still in progress. When
   the driver is finished with this transfer it must
   call <code class="function">spi_finalize_current_transfer</code> so the subsystem
   can issue the next transfer. Note: transfer_one and
   transfer_one_message are mutually exclusive; when both
   are set, the generic subsystem does not call your
   transfer_one callback.
      </p></dd><dt><span class="term">cs_gpios</span></dt><dd><p>
   Array of GPIOs to use as chip select lines; one per CS
   number. Any individual value may be -ENOENT for CS lines that
   are not GPIOs (driven by the SPI controller itself).
      </p></dd><dt><span class="term">dma_tx</span></dt><dd><p>
   DMA transmit channel
      </p></dd><dt><span class="term">dma_rx</span></dt><dd><p>
   DMA receive channel
      </p></dd><dt><span class="term">dummy_rx</span></dt><dd><p>
   dummy receive buffer for full-duplex devices
      </p></dd><dt><span class="term">dummy_tx</span></dt><dd><p>
   dummy transmit buffer for full-duplex devices
      </p></dd></dl></div></div><div class="refsect1"><a name="idm41158"></a><h2>Description</h2><p>
   Each SPI master controller can communicate with one or more <em class="parameter"><code>spi_device</code></em>
   children.  These make a small bus, sharing MOSI, MISO and SCK signals
   but not chip select signals.  Each device may be configured to use a
   different clock rate, since those shared signals are ignored unless
   the chip is selected.
   </p><p>

   The driver for an SPI controller manages access to those devices through
   a queue of spi_message transactions, copying data between CPU memory and
   an SPI slave device.  For each such message it queues, it calls the
   message's completion function when the transaction completes.
</p></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="API-module-spi-driver.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="spi.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="API-struct-spi-transfer.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top"><span class="phrase">module_spi_driver</span> </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> <span class="phrase">struct spi_transfer</span></td></tr></table></div></body></html>
