<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>seqno_fence_init</title><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot"><link rel="home" href="index.html" title="Linux Device Drivers"><link rel="up" href="ch02s03.html" title="Device Drivers DMA Management"><link rel="prev" href="API-to-seqno-fence.html" title="to_seqno_fence"><link rel="next" href="re406.html" title="..//drivers/dma-buf/reservation.c"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center"><span class="phrase">seqno_fence_init</span></th></tr><tr><td width="20%" align="left"><a accesskey="p" href="API-to-seqno-fence.html">Prev</a> </td><th width="60%" align="center">Device Drivers DMA Management</th><td width="20%" align="right"> <a accesskey="n" href="re406.html">Next</a></td></tr></table><hr></div><div class="refentry"><a name="API-seqno-fence-init"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>seqno_fence_init — 
     initialize a seqno fence
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">void <b class="fsfunc">seqno_fence_init </b>(</code></td><td>struct seqno_fence * <var class="pdparam">fence</var>, </td></tr><tr><td> </td><td>spinlock_t * <var class="pdparam">lock</var>, </td></tr><tr><td> </td><td>struct dma_buf * <var class="pdparam">sync_buf</var>, </td></tr><tr><td> </td><td>uint32_t <var class="pdparam">context</var>, </td></tr><tr><td> </td><td>uint32_t <var class="pdparam">seqno_ofs</var>, </td></tr><tr><td> </td><td>uint32_t <var class="pdparam">seqno</var>, </td></tr><tr><td> </td><td>enum seqno_fence_condition <var class="pdparam">cond</var>, </td></tr><tr><td> </td><td>const struct fence_ops * <var class="pdparam">ops</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"> </div></div></div><div class="refsect1"><a name="idm17434"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>fence</code></em></span></dt><dd><p>
     seqno_fence to initialize
    </p></dd><dt><span class="term"><em class="parameter"><code>lock</code></em></span></dt><dd><p>
     pointer to spinlock to use for fence
    </p></dd><dt><span class="term"><em class="parameter"><code>sync_buf</code></em></span></dt><dd><p>
     buffer containing the memory location to signal on
    </p></dd><dt><span class="term"><em class="parameter"><code>context</code></em></span></dt><dd><p>
     the execution context this fence is a part of
    </p></dd><dt><span class="term"><em class="parameter"><code>seqno_ofs</code></em></span></dt><dd><p>
     the offset within <em class="parameter"><code>sync_buf</code></em>
    </p></dd><dt><span class="term"><em class="parameter"><code>seqno</code></em></span></dt><dd><p>
     the sequence # to signal on
    </p></dd><dt><span class="term"><em class="parameter"><code>cond</code></em></span></dt><dd><p>
     fence wait condition
    </p></dd><dt><span class="term"><em class="parameter"><code>ops</code></em></span></dt><dd><p>
     the fence_ops for operations on this seqno fence
    </p></dd></dl></div></div><div class="refsect1"><a name="idm17478"></a><h2>Description</h2><p>
   This function initializes a struct seqno_fence with passed parameters,
   and takes a reference on sync_buf which is released on fence destruction.
   </p><p>

   A seqno_fence is a dma_fence which can complete in software when
   enable_signaling is called, but it also completes when
   (s32)((sync_buf)[seqno_ofs] - seqno) &gt;= 0 is true
   </p><p>

   The seqno_fence will take a refcount on the sync_buf until it's
   destroyed, but actual lifetime of sync_buf may be longer if one of the
   callers take a reference to it.
   </p><p>

   Certain hardware have instructions to insert this type of wait condition
   in the command stream, so no intervention from software would be needed.
   This type of fence can be destroyed before completed, however a reference
   on the sync_buf dma-buf can be taken. It is encouraged to re-use the same
   dma-buf for sync_buf, since mapping or unmapping the sync_buf to the
   device's vm can be expensive.
   </p><p>

   It is recommended for creators of seqno_fence to call fence_signal
   before destruction. This will prevent possible issues from wraparound at
   time of issue vs time of check, since users can check fence_is_signaled
   before submitting instructions for the hardware to wait on the fence.
   However, when ops.enable_signaling is not called, it doesn't have to be
   done as soon as possible, just before there's any real danger of seqno
   wraparound.
</p></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="API-to-seqno-fence.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="ch02s03.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="re406.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top"><span class="phrase">to_seqno_fence</span> </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> 
   ..//drivers/dma-buf/reservation.c
  </td></tr></table></div></body></html>
