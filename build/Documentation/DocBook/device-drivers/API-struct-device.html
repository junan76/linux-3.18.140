<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>struct device</title><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot"><link rel="home" href="index.html" title="Linux Device Drivers"><link rel="up" href="devdrivers.html#idm11078" title="The Basic Device Driver-Model Structures"><link rel="prev" href="API-struct-class.html" title="struct class"><link rel="next" href="API-module-driver.html" title="module_driver"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center"><span class="phrase">struct device</span></th></tr><tr><td width="20%" align="left"><a accesskey="p" href="API-struct-class.html">Prev</a> </td><th width="60%" align="center">The Basic Device Driver-Model Structures </th><td width="20%" align="right"> <a accesskey="n" href="API-module-driver.html">Next</a></td></tr></table><hr></div><div class="refentry"><a name="API-struct-device"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>struct device — 
     The basic device structure
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><pre class="programlisting">
struct device {
  struct device * parent;
  struct device_private * p;
  struct kobject kobj;
  const char * init_name;
  const struct device_type * type;
  struct mutex mutex;
  struct bus_type * bus;
  struct device_driver * driver;
  void * platform_data;
  void * driver_data;
  struct dev_pm_info power;
  struct dev_pm_domain * pm_domain;
#ifdef CONFIG_PINCTRL
  struct dev_pin_info * pins;
#endif
#ifdef CONFIG_NUMA
  int numa_node;
#endif
  u64 * dma_mask;
  u64 coherent_dma_mask;
  unsigned long dma_pfn_offset;
  struct device_dma_parameters * dma_parms;
  struct list_head dma_pools;
  struct dma_coherent_mem * dma_mem;
#ifdef CONFIG_DMA_CMA
  struct cma * cma_area;
#endif
  struct dev_archdata archdata;
  struct device_node * of_node;
  struct acpi_dev_node acpi_node;
  dev_t devt;
  u32 id;
  spinlock_t devres_lock;
  struct list_head devres_head;
  struct klist_node knode_class;
  struct class * class;
  const struct attribute_group ** groups;
  void (* release) (struct device *dev);
  struct iommu_group * iommu_group;
  bool offline_disabled:1;
  bool offline:1;
};  </pre></div><div class="refsect1"><a name="idm11406"></a><h2>Members</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term">parent</span></dt><dd><p>
   The device's <span class="quote">“<span class="quote">parent</span>”</span> device, the device to which it is attached.
   In most cases, a parent device is some sort of bus or host
   controller. If parent is NULL, the device, is a top-level device,
   which is not usually what you want.
      </p></dd><dt><span class="term">p</span></dt><dd><p>
   Holds the private data of the driver core portions of the device.
   See the comment of the struct device_private for detail.
      </p></dd><dt><span class="term">kobj</span></dt><dd><p>
   A top-level, abstract class from which other classes are derived.
      </p></dd><dt><span class="term">init_name</span></dt><dd><p>
   Initial name of the device.
      </p></dd><dt><span class="term">type</span></dt><dd><p>
   The type of device.
   This identifies the device type and carries type-specific
   information.
      </p></dd><dt><span class="term">mutex</span></dt><dd><p>
   Mutex to synchronize calls to its driver.
      </p></dd><dt><span class="term">bus</span></dt><dd><p>
   Type of bus device is on.
      </p></dd><dt><span class="term">driver</span></dt><dd><p>
   Which driver has allocated this
      </p></dd><dt><span class="term">platform_data</span></dt><dd><p>
   Platform data specific to the device.
      </p></dd><dt><span class="term">driver_data</span></dt><dd><p>
   Private pointer for driver specific info.
      </p></dd><dt><span class="term">power</span></dt><dd><p>
   For device power management.
   See Documentation/power/devices.txt for details.
      </p></dd><dt><span class="term">pm_domain</span></dt><dd><p>
   Provide callbacks that are executed during system suspend,
   hibernation, system resume and during runtime PM transitions
   along with subsystem-level and driver-level callbacks.
      </p></dd><dt><span class="term">pins</span></dt><dd><p>
   For device pin management.
   See Documentation/pinctrl.txt for details.
      </p></dd><dt><span class="term">numa_node</span></dt><dd><p>
   NUMA node this device is close to.
      </p></dd><dt><span class="term">dma_mask</span></dt><dd><p>
   Dma mask (if dma'ble device).
      </p></dd><dt><span class="term">coherent_dma_mask</span></dt><dd><p>
   Like dma_mask, but for alloc_coherent mapping as not all
   hardware supports 64-bit addresses for consistent allocations
   such descriptors.
      </p></dd><dt><span class="term">dma_pfn_offset</span></dt><dd><p>
   offset of DMA memory range relatively of RAM
      </p></dd><dt><span class="term">dma_parms</span></dt><dd><p>
   A low level driver may set these to teach IOMMU code about
   segment limitations.
      </p></dd><dt><span class="term">dma_pools</span></dt><dd><p>
   Dma pools (if dma'ble device).
      </p></dd><dt><span class="term">dma_mem</span></dt><dd><p>
   Internal for coherent mem override.
      </p></dd><dt><span class="term">cma_area</span></dt><dd><p>
   Contiguous memory area for dma allocations
      </p></dd><dt><span class="term">archdata</span></dt><dd><p>
   For arch-specific additions.
      </p></dd><dt><span class="term">of_node</span></dt><dd><p>
   Associated device tree node.
      </p></dd><dt><span class="term">acpi_node</span></dt><dd><p>
   Associated ACPI device node.
      </p></dd><dt><span class="term">devt</span></dt><dd><p>
   For creating the sysfs <span class="quote">“<span class="quote">dev</span>”</span>.
      </p></dd><dt><span class="term">id</span></dt><dd><p>
   device instance
      </p></dd><dt><span class="term">devres_lock</span></dt><dd><p>
   Spinlock to protect the resource of the device.
      </p></dd><dt><span class="term">devres_head</span></dt><dd><p>
   The resources list of the device.
      </p></dd><dt><span class="term">knode_class</span></dt><dd><p>
   The node used to add the device to the class list.
      </p></dd><dt><span class="term">class</span></dt><dd><p>
   The class of the device.
      </p></dd><dt><span class="term">groups</span></dt><dd><p>
   Optional attribute groups.
      </p></dd><dt><span class="term">release</span></dt><dd><p>
   Callback to free the device after all references have
   gone away. This should be set by the allocator of the
   device (i.e. the bus driver that discovered the device).
      </p></dd><dt><span class="term">iommu_group</span></dt><dd><p>
   IOMMU group the device belongs to.
      </p></dd><dt><span class="term">offline_disabled</span></dt><dd><p>
   If set, the device is permanently online.
      </p></dd><dt><span class="term">offline</span></dt><dd><p>
   Set after successful invocation of bus type's .<code class="function">offline</code>.
      </p></dd></dl></div></div><div class="refsect1"><a name="idm11552"></a><h2>Example</h2><div class="informalexample"><pre class="programlisting">
   For devices on custom boards, as typical of embedded
   		and SOC based hardware, Linux often uses platform_data to point
   		to board-specific structures describing devices and how they
   		are wired.  That can include what ports are available, chip
   		variants, which GPIO pins act in what additional roles, and so
   		on.  This shrinks the <span class="quote">“<span class="quote">Board Support Packages</span>”</span> (BSPs) and
   		minimizes board-specific #ifdefs in drivers.
</pre></div></div><div class="refsect1"><a name="idm11557"></a><h2>Description</h2><p>
   At the lowest level, every device in a Linux system is represented by an
   instance of struct device. The device structure contains the information
   that the device model core needs to model the system. Most subsystems,
   however, track additional information about the devices they host. As a
   result, it is rare for devices to be represented by bare device structures;
   instead, that structure, like kobject structures, is usually embedded within
   a higher-level representation of the device.
</p></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="API-struct-class.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="devdrivers.html#idm11078">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="API-module-driver.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top"><span class="phrase">struct class</span> </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> <span class="phrase">module_driver</span></td></tr></table></div></body></html>
