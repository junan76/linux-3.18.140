<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>Constructor</title><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot"><link rel="home" href="index.html" title="Writing an ALSA Driver"><link rel="up" href="midi-interface.html" title="Chapter 8. MIDI (MPU401-UART) Interface"><link rel="prev" href="midi-interface.html" title="Chapter 8. MIDI (MPU401-UART) Interface"><link rel="next" href="midi-interface-interrupt-handler.html" title="Interrupt Handler"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Constructor</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="midi-interface.html">Prev</a> </td><th width="60%" align="center">Chapter 8. MIDI (MPU401-UART) Interface</th><td width="20%" align="right"> <a accesskey="n" href="midi-interface-interrupt-handler.html">Next</a></td></tr></table><hr></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="midi-interface-constructor"></a>Constructor</h2></div></div></div><p>
        To create a rawmidi object, call
      <code class="function">snd_mpu401_uart_new()</code>. 

        </p><div class="informalexample"><pre class="programlisting">

  struct snd_rawmidi *rmidi;
  snd_mpu401_uart_new(card, 0, MPU401_HW_MPU401, port, info_flags,
                      irq, &amp;rmidi);

          </pre></div><p>
      </p><p>
        The first argument is the card pointer, and the second is the
      index of this component. You can create up to 8 rawmidi
      devices. 
      </p><p>
        The third argument is the type of the hardware,
      <code class="constant">MPU401_HW_XXX</code>. If it's not a special one,
      you can use <code class="constant">MPU401_HW_MPU401</code>. 
      </p><p>
        The 4th argument is the I/O port address. Many
      backward-compatible MPU401 have an I/O port such as 0x330. Or, it
      might be a part of its own PCI I/O region. It depends on the
      chip design. 
      </p><p>
	The 5th argument is a bitflag for additional information.
        When the I/O port address above is part of the PCI I/O
      region, the MPU401 I/O port might have been already allocated
      (reserved) by the driver itself. In such a case, pass a bit flag
      <code class="constant">MPU401_INFO_INTEGRATED</code>,
      and the mpu401-uart layer will allocate the I/O ports by itself. 
      </p><p>
	When the controller supports only the input or output MIDI stream,
	pass the <code class="constant">MPU401_INFO_INPUT</code> or
	<code class="constant">MPU401_INFO_OUTPUT</code> bitflag, respectively.
	Then the rawmidi instance is created as a single stream.
	</p><p>
	<code class="constant">MPU401_INFO_MMIO</code> bitflag is used to change
	the access method to MMIO (via readb and writeb) instead of
	iob and outb. In this case, you have to pass the iomapped address
	to <code class="function">snd_mpu401_uart_new()</code>.
	</p><p>
	When <code class="constant">MPU401_INFO_TX_IRQ</code> is set, the output
	stream isn't checked in the default interrupt handler.  The driver
	needs to call <code class="function">snd_mpu401_uart_interrupt_tx()</code>
	by itself to start processing the output stream in the irq handler.
	</p><p>
	If the MPU-401 interface shares its interrupt with the other logical
	devices on the card, set <code class="constant">MPU401_INFO_IRQ_HOOK</code>
	(see <a class="link" href="midi-interface-interrupt-handler.html" title="Interrupt Handler"><em class="citetitle">
	below</em></a>).
	</p><p>
        Usually, the port address corresponds to the command port and
        port + 1 corresponds to the data port. If not, you may change
        the <em class="structfield"><code>cport</code></em> field of
        struct <span class="structname">snd_mpu401</span> manually 
        afterward. However, <span class="structname">snd_mpu401</span> pointer is not
        returned explicitly by
        <code class="function">snd_mpu401_uart_new()</code>. You need to cast
        rmidi-&gt;private_data to
        <span class="structname">snd_mpu401</span> explicitly, 

        </p><div class="informalexample"><pre class="programlisting">

  struct snd_mpu401 *mpu;
  mpu = rmidi-&gt;private_data;

          </pre></div><p>

        and reset the cport as you like:

        </p><div class="informalexample"><pre class="programlisting">

  mpu-&gt;cport = my_own_control_port;

          </pre></div><p>
      </p><p>
	The 6th argument specifies the ISA irq number that will be
	allocated.  If no interrupt is to be allocated (because your
	code is already allocating a shared interrupt, or because the
	device does not use interrupts), pass -1 instead.
	For a MPU-401 device without an interrupt, a polling timer
	will be used instead.
      </p></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="midi-interface.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="midi-interface.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="midi-interface-interrupt-handler.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Chapter 8. MIDI (MPU401-UART) Interface </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> Interrupt Handler</td></tr></table></div></body></html>
