<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>Chapter 5. PCM Interface</title><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot"><link rel="home" href="index.html" title="Writing an ALSA Driver"><link rel="up" href="index.html" title="Writing an ALSA Driver"><link rel="prev" href="pci-resource-entries.html" title="PCI Entries"><link rel="next" href="pcm-interface-example.html" title="Full Code Example"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Chapter 5. PCM Interface</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="pci-resource-entries.html">Prev</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="pcm-interface-example.html">Next</a></td></tr></table><hr></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="pcm-interface"></a>Chapter 5. PCM Interface</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="section"><a href="pcm-interface.html#pcm-interface-general">General</a></span></dt><dt><span class="section"><a href="pcm-interface-example.html">Full Code Example</a></span></dt><dt><span class="section"><a href="pcm-interface-constructor.html">Constructor</a></span></dt><dt><span class="section"><a href="pcm-interface-destructor.html">... And the Destructor?</a></span></dt><dt><span class="section"><a href="pcm-interface-runtime.html">Runtime Pointer - The Chest of PCM Information</a></span></dt><dd><dl><dt><span class="section"><a href="pcm-interface-runtime.html#pcm-interface-runtime-hw">Hardware Description</a></span></dt><dt><span class="section"><a href="pcm-interface-runtime.html#pcm-interface-runtime-config">PCM Configurations</a></span></dt><dt><span class="section"><a href="pcm-interface-runtime.html#pcm-interface-runtime-dma">DMA Buffer Information</a></span></dt><dt><span class="section"><a href="pcm-interface-runtime.html#pcm-interface-runtime-status">Running Status</a></span></dt><dt><span class="section"><a href="pcm-interface-runtime.html#pcm-interface-runtime-private">Private Data</a></span></dt><dt><span class="section"><a href="pcm-interface-runtime.html#pcm-interface-runtime-intr">Interrupt Callbacks</a></span></dt></dl></dd><dt><span class="section"><a href="pcm-interface-operators.html">Operators</a></span></dt><dd><dl><dt><span class="section"><a href="pcm-interface-operators.html#pcm-interface-operators-open-callback">open callback</a></span></dt><dt><span class="section"><a href="pcm-interface-operators.html#pcm-interface-operators-close-callback">close callback</a></span></dt><dt><span class="section"><a href="pcm-interface-operators.html#pcm-interface-operators-ioctl-callback">ioctl callback</a></span></dt><dt><span class="section"><a href="pcm-interface-operators.html#pcm-interface-operators-hw-params-callback">hw_params callback</a></span></dt><dt><span class="section"><a href="pcm-interface-operators.html#pcm-interface-operators-hw-free-callback">hw_free callback</a></span></dt><dt><span class="section"><a href="pcm-interface-operators.html#pcm-interface-operators-prepare-callback">prepare callback</a></span></dt><dt><span class="section"><a href="pcm-interface-operators.html#pcm-interface-operators-trigger-callback">trigger callback</a></span></dt><dt><span class="section"><a href="pcm-interface-operators.html#pcm-interface-operators-pointer-callback">pointer callback</a></span></dt><dt><span class="section"><a href="pcm-interface-operators.html#pcm-interface-operators-copy-silence">copy and silence callbacks</a></span></dt><dt><span class="section"><a href="pcm-interface-operators.html#pcm-interface-operators-ack">ack callback</a></span></dt><dt><span class="section"><a href="pcm-interface-operators.html#pcm-interface-operators-page-callback">page callback</a></span></dt></dl></dd><dt><span class="section"><a href="pcm-interface-interrupt-handler.html">Interrupt Handler</a></span></dt><dd><dl><dt><span class="section"><a href="pcm-interface-interrupt-handler.html#pcm-interface-interrupt-handler-boundary">Interrupts at the period (fragment) boundary</a></span></dt><dt><span class="section"><a href="pcm-interface-interrupt-handler.html#pcm-interface-interrupt-handler-timer">High frequency timer interrupts</a></span></dt><dt><span class="section"><a href="pcm-interface-interrupt-handler.html#pcm-interface-interrupt-handler-both">On calling <code class="function">snd_pcm_period_elapsed()</code></a></span></dt></dl></dd><dt><span class="section"><a href="pcm-interface-atomicity.html">Atomicity</a></span></dt><dt><span class="section"><a href="pcm-interface-constraints.html">Constraints</a></span></dt></dl></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="pcm-interface-general"></a>General</h2></div></div></div><p>
        The PCM middle layer of ALSA is quite powerful and it is only
      necessary for each driver to implement the low-level functions
      to access its hardware.
      </p><p>
        For accessing to the PCM layer, you need to include
      <code class="filename">&lt;sound/pcm.h&gt;</code> first. In addition,
      <code class="filename">&lt;sound/pcm_params.h&gt;</code> might be needed
      if you access to some functions related with hw_param. 
      </p><p>
        Each card device can have up to four pcm instances. A pcm
      instance corresponds to a pcm device file. The limitation of
      number of instances comes only from the available bit size of
      the Linux's device numbers. Once when 64bit device number is
      used, we'll have more pcm instances available. 
      </p><p>
        A pcm instance consists of pcm playback and capture streams,
      and each pcm stream consists of one or more pcm substreams. Some
      soundcards support multiple playback functions. For example,
      emu10k1 has a PCM playback of 32 stereo substreams. In this case, at
      each open, a free substream is (usually) automatically chosen
      and opened. Meanwhile, when only one substream exists and it was
      already opened, the successful open will either block
      or error with <code class="constant">EAGAIN</code> according to the
      file open mode. But you don't have to care about such details in your
      driver. The PCM middle layer will take care of such work.
      </p></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="pci-resource-entries.html">Prev</a> </td><td width="20%" align="center"> </td><td width="40%" align="right"> <a accesskey="n" href="pcm-interface-example.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">PCI Entries </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> Full Code Example</td></tr></table></div></body></html>
