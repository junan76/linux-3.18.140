<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN"
	"http://www.oasis-open.org/docbook/xml/4.1.2/docbookx.dtd" []>

<book id="w1id">
  <bookinfo>
    <title>W1: Dallas' 1-wire bus</title>

    <authorgroup>
      <author>
        <firstname>David</firstname>
        <surname>Fries</surname>
        <affiliation>
          <address>
            <email>David@Fries.net</email>
          </address>
        </affiliation>
      </author>

    </authorgroup>

    <copyright>
      <year>2013</year>
      <!--
      <holder></holder>
      -->
    </copyright>

    <legalnotice>
      <para>
        This documentation is free software; you can redistribute
        it and/or modify it under the terms of the GNU General Public
        License version 2.
      </para>

      <para>
        This program is distributed in the hope that it will be
        useful, but WITHOUT ANY WARRANTY; without even the implied
        warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
        For more details see the file COPYING in the source
        distribution of Linux.
      </para>
    </legalnotice>
  </bookinfo>

  <toc></toc>

  <chapter id="w1_internal">
    <title>W1 API internal to the kernel</title>

    <sect1 id="w1_internal_api">
      <title>W1 API internal to the kernel</title>
      <sect2 id="w1.h">
        <title>drivers/w1/w1.h</title>
        <para>W1 core functions.</para>
<!-- drivers/w1/w1.h -->
<refentry id="API-struct-w1-reg-num">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct w1_reg_num</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct w1_reg_num</refname>
 <refpurpose>
  broken out slave device id
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct w1_reg_num {
#if defined(__LITTLE_ENDIAN_BITFIELD)
  __u64 family:8;
  __u64 id:48;
  __u64 crc:8;
#elif defined(__BIG_ENDIAN_BITFIELD)
  __u64 crc:8;
  __u64 id:48;
  __u64 family:8;
#else
#error "Please fix &lt;asm/byteorder.h&gt;"
#endif
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>family</term>
      <listitem><para>
identifies the type of device
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>id</term>
      <listitem><para>
along with family is the unique device id
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>crc</term>
      <listitem><para>
checksum of the other bytes
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>crc</term>
      <listitem><para>
checksum of the other bytes
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>id</term>
      <listitem><para>
along with family is the unique device id
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>family</term>
      <listitem><para>
identifies the type of device
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
</refentry>

<refentry id="API-struct-w1-slave">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct w1_slave</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct w1_slave</refname>
 <refpurpose>
     holds a single slave device on the bus
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct w1_slave {
  struct module * owner;
  unsigned char name[W1_MAXNAMELEN];
  struct list_head w1_slave_entry;
  struct w1_reg_num reg_num;
  atomic_t refcnt;
  int ttl;
  unsigned long flags;
  struct w1_master * master;
  struct w1_family * family;
  void * family_data;
  struct device dev;
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>owner</term>
      <listitem><para>
   Points to the one wire <quote>wire</quote> kernel module.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>name[W1_MAXNAMELEN]</term>
      <listitem><para>
   Device id is ascii.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>w1_slave_entry</term>
      <listitem><para>
   data for the linked list
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>reg_num</term>
      <listitem><para>
   the slave id in binary
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>refcnt</term>
      <listitem><para>
   reference count, delete when 0
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>ttl</term>
      <listitem><para>
   decrement per search this slave isn't found, deatch at 0
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>flags</term>
      <listitem><para>
   bit flags for W1_SLAVE_ACTIVE W1_SLAVE_DETACH
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>master</term>
      <listitem><para>
   bus which this slave is on
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>family</term>
      <listitem><para>
   module for device family type
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>family_data</term>
      <listitem><para>
   pointer for use by the family module
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>dev</term>
      <listitem><para>
   kernel device identifier
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
</refentry>

<refentry id="API-struct-w1-bus-master">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct w1_bus_master</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct w1_bus_master</refname>
 <refpurpose>
     operations available on a bus master
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct w1_bus_master {
  void * data;
  u8 (* read_bit) (void *);
  void (* write_bit) (void *, u8);
  u8 (* touch_bit) (void *, u8);
  u8 (* read_byte) (void *);
  void (* write_byte) (void *, u8);
  u8 (* read_block) (void *, u8 *, int);
  void (* write_block) (void *, const u8 *, int);
  u8 (* triplet) (void *, u8);
  u8 (* reset_bus) (void *);
  u8 (* set_pullup) (void *, int);
  void (* search) (void *, struct w1_master *,u8, w1_slave_found_callback);
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>data</term>
      <listitem><para>
   the first parameter in all the functions below
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>read_bit</term>
      <listitem><para>
   Sample the line level <parameter>return</parameter> the level read (0 or 1)
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>write_bit</term>
      <listitem><para>
   Sets the line level
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>touch_bit</term>
      <listitem><para>
   the lowest-level function for devices that really support the
   1-wire protocol.
   touch_bit(0) = write-0 cycle
   touch_bit(1) = write-1 / read cycle
   <parameter>return</parameter> the bit read (0 or 1)
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>read_byte</term>
      <listitem><para>
   Reads a bytes. Same as 8 touch_bit(1) calls.
   <parameter>return</parameter> the byte read
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>write_byte</term>
      <listitem><para>
   Writes a byte. Same as 8 touch_bit(x) calls.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>read_block</term>
      <listitem><para>
   Same as a series of <function>read_byte</function> calls
   <parameter>return</parameter> the number of bytes read
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>write_block</term>
      <listitem><para>
   Same as a series of <function>write_byte</function> calls
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>triplet</term>
      <listitem><para>
   Combines two reads and a smart write for ROM searches
   <parameter>return</parameter> bit0=Id bit1=comp_id bit2=dir_taken
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>reset_bus</term>
      <listitem><para>
   long write-0 with a read for the presence pulse detection
   <parameter>return</parameter> -1=Error, 0=Device present, 1=No device present
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>set_pullup</term>
      <listitem><para>
   Put out a strong pull-up pulse of the specified duration.
   <parameter>return</parameter> -1=Error, 0=completed
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>search</term>
      <listitem><para>
   Really nice hardware can handles the different types of ROM search
   w1_master* is passed to the slave found callback.
   u8 is search_type, W1_SEARCH or W1_ALARM_SEARCH
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
<refsect1>
<title>Note</title>
<para>
   read_bit and write_bit are very low level functions and should only
   be used with hardware that doesn't really support 1-wire operations,
   like a parallel/serial port.
   Either define read_bit and write_bit OR define, at minimum, touch_bit and
   reset_bus.
</para>
</refsect1>
</refentry>

<refentry id="API-enum-w1-master-flags">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>enum w1_master_flags</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>enum w1_master_flags</refname>
 <refpurpose>
     bitfields used in w1_master.flags
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
enum w1_master_flags {
  W1_ABORT_SEARCH,
  W1_WARN_MAX_COUNT
};  </programlisting>
</refsynopsisdiv>
<refsect1>
 <title>Constants</title>
  <variablelist>
    <varlistentry>      <term>W1_ABORT_SEARCH</term>
      <listitem><para>
   abort searching early on shutdown
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>W1_WARN_MAX_COUNT</term>
      <listitem><para>
   limit warning when the maximum count is reached
      </para></listitem>
    </varlistentry>
  </variablelist>
</refsect1>
</refentry>

<refentry id="API-struct-w1-master">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct w1_master</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct w1_master</refname>
 <refpurpose>
     one per bus master
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct w1_master {
  struct list_head w1_master_entry;
  struct module * owner;
  unsigned char name[W1_MAXNAMELEN];
  struct mutex list_mutex;
  struct list_head slist;
  struct list_head async_list;
  int max_slave_count;
  int slave_count;
  unsigned long attempts;
  int slave_ttl;
  int initialized;
  u32 id;
  int search_count;
  u64 search_id;
  atomic_t refcnt;
  void * priv;
  int enable_pullup;
  int pullup_duration;
  long flags;
  struct task_struct * thread;
  struct mutex mutex;
  struct mutex bus_mutex;
  struct device_driver * driver;
  struct device dev;
  struct w1_bus_master * bus_master;
  u32 seq;
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>w1_master_entry</term>
      <listitem><para>
   master linked list
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>owner</term>
      <listitem><para>
   module owner
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>name[W1_MAXNAMELEN]</term>
      <listitem><para>
   dynamically allocate bus name
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>list_mutex</term>
      <listitem><para>
   protect slist and async_list
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>slist</term>
      <listitem><para>
   linked list of slaves
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>async_list</term>
      <listitem><para>
   linked list of netlink commands to execute
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>max_slave_count</term>
      <listitem><para>
   maximum number of slaves to search for at a time
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>slave_count</term>
      <listitem><para>
   current number of slaves known
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>attempts</term>
      <listitem><para>
   number of searches ran
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>slave_ttl</term>
      <listitem><para>
   number of searches before a slave is timed out
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>initialized</term>
      <listitem><para>
   prevent init/removal race conditions
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>id</term>
      <listitem><para>
   w1 bus number
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>search_count</term>
      <listitem><para>
   number of automatic searches to run, -1 unlimited
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>search_id</term>
      <listitem><para>
   allows continuing a search
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>refcnt</term>
      <listitem><para>
   reference count
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>priv</term>
      <listitem><para>
   private data storage
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>enable_pullup</term>
      <listitem><para>
   allows a strong pullup
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>pullup_duration</term>
      <listitem><para>
   time for the next strong pullup
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>flags</term>
      <listitem><para>
   one of w1_master_flags
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>thread</term>
      <listitem><para>
   thread for bus search and netlink commands
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>mutex</term>
      <listitem><para>
   protect most of w1_master
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>bus_mutex</term>
      <listitem><para>
   pretect concurrent bus access
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>driver</term>
      <listitem><para>
   sysfs driver
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>dev</term>
      <listitem><para>
   sysfs device
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>bus_master</term>
      <listitem><para>
   io operations available
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>seq</term>
      <listitem><para>
   sequence number used for netlink broadcasts
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
</refentry>

<refentry id="API-struct-w1-async-cmd">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct w1_async_cmd</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct w1_async_cmd</refname>
 <refpurpose>
     execute callback from the w1_process kthread
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct w1_async_cmd {
  struct list_head async_entry;
  void (* cb) (struct w1_master *dev, struct w1_async_cmd *async_cmd);
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>async_entry</term>
      <listitem><para>
   link entry
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>cb</term>
      <listitem><para>
   callback function, must list_del and destroy this list before
   returning
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
<refsect1>
<title>Description</title>
<para>
   When inserted into the w1_master async_list, w1_process will execute
   the callback.  Embed this into the structure with the command details.
</para>
</refsect1>
</refentry>

      </sect2>

      <sect2 id="w1.c">
        <title>drivers/w1/w1.c</title>
        <para>W1 core functions.</para>
<!-- drivers/w1/w1.c -->
<refentry id="API-w1-search">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>w1_search</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>w1_search</refname>
 <refpurpose>
  Performs a ROM Search &amp; registers any devices found.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>w1_search </function></funcdef>
   <paramdef>struct w1_master * <parameter>dev</parameter></paramdef>
   <paramdef>u8 <parameter>search_type</parameter></paramdef>
   <paramdef>w1_slave_found_callback <parameter>cb</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     The master device to search
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>search_type</parameter></term>
   <listitem>
    <para>
     W1_SEARCH to search all devices, or W1_ALARM_SEARCH
     to return only devices in the alarmed state
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>cb</parameter></term>
   <listitem>
    <para>
     Function to call when a device is found
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   The 1-wire search is a simple binary tree search.
   For each bit of the address, we read two bits and write one bit.
   The bit written will put to sleep all devies that don't match that bit.
   When the two reads differ, the direction choice is obvious.
   When both bits are 0, we must choose a path to take.
   When we can scan all 64 bits without having to choose a path, we are done.
   </para><para>

   See <quote>Application note 187 1-wire search algorithm</quote> at www.maxim-ic.com
</para>
</refsect1>
</refentry>

<refentry id="API-w1-process-callbacks">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>w1_process_callbacks</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>w1_process_callbacks</refname>
 <refpurpose>
     execute each dev-&gt;async_list callback entry
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>w1_process_callbacks </function></funcdef>
   <paramdef>struct w1_master * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     w1_master device
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   The w1 master list_mutex must be held.
</para>
</refsect1>
<refsect1>
<title>Return</title>
<para>
   1 if there were commands to executed 0 otherwise
</para>
</refsect1>
</refentry>

      </sect2>

      <sect2 id="w1_family.h">
        <title>drivers/w1/w1_family.h</title>
        <para>Allows registering device family operations.</para>
<!-- drivers/w1/w1_family.h -->
<refentry id="API-struct-w1-family-ops">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct w1_family_ops</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct w1_family_ops</refname>
 <refpurpose>
  operations for a family type
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct w1_family_ops {
  int (* add_slave) (struct w1_slave *);
  void (* remove_slave) (struct w1_slave *);
  const struct attribute_group ** groups;
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>add_slave</term>
      <listitem><para>
add_slave
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>remove_slave</term>
      <listitem><para>
remove_slave
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>groups</term>
      <listitem><para>
sysfs group
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
</refentry>

<refentry id="API-struct-w1-family">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct w1_family</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct w1_family</refname>
 <refpurpose>
     reference counted family structure.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct w1_family {
  struct list_head family_entry;
  u8 fid;
  struct w1_family_ops * fops;
  atomic_t refcnt;
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>family_entry</term>
      <listitem><para>
   family linked list
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>fid</term>
      <listitem><para>
   8 bit family identifier
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>fops</term>
      <listitem><para>
   operations for this family
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>refcnt</term>
      <listitem><para>
   reference counter
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
</refentry>

      </sect2>

      <sect2 id="w1_family.c">
        <title>drivers/w1/w1_family.c</title>
        <para>Allows registering device family operations.</para>
<!-- drivers/w1/w1_family.c -->
<refentry id="API-w1-register-family">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>w1_register_family</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>w1_register_family</refname>
 <refpurpose>
  register a device family driver
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>w1_register_family </function></funcdef>
   <paramdef>struct w1_family * <parameter>newf</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>newf</parameter></term>
   <listitem>
    <para>
     family to register
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-w1-unregister-family">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>w1_unregister_family</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>w1_unregister_family</refname>
 <refpurpose>
     unregister a device family driver
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>w1_unregister_family </function></funcdef>
   <paramdef>struct w1_family * <parameter>fent</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>fent</parameter></term>
   <listitem>
    <para>
     family to unregister
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

      </sect2>

      <sect2 id="w1_int.c">
        <title>drivers/w1/w1_int.c</title>
        <para>W1 internal initialization for master devices.</para>
<!-- drivers/w1/w1_int.c -->
<refentry id="API-w1-add-master-device">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>w1_add_master_device</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>w1_add_master_device</refname>
 <refpurpose>
  registers a new master device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>w1_add_master_device </function></funcdef>
   <paramdef>struct w1_bus_master * <parameter>master</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>master</parameter></term>
   <listitem>
    <para>
     master bus device to register
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-w1-remove-master-device">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>w1_remove_master_device</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>w1_remove_master_device</refname>
 <refpurpose>
     unregister a master device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>w1_remove_master_device </function></funcdef>
   <paramdef>struct w1_bus_master * <parameter>bm</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>bm</parameter></term>
   <listitem>
    <para>
     master bus device to remove
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

      </sect2>

      <sect2 id="w1_netlink.h">
        <title>drivers/w1/w1_netlink.h</title>
        <para>W1 external netlink API structures and commands.</para>
<!-- drivers/w1/w1_netlink.h -->
<refentry id="API-enum-w1-cn-msg-flags">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>enum w1_cn_msg_flags</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>enum w1_cn_msg_flags</refname>
 <refpurpose>
  bitfield flags for struct cn_msg.flags
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
enum w1_cn_msg_flags {
  W1_CN_BUNDLE
};  </programlisting>
</refsynopsisdiv>
<refsect1>
 <title>Constants</title>
  <variablelist>
    <varlistentry>      <term>W1_CN_BUNDLE</term>
      <listitem><para>
Request bundling replies into fewer messagse.  Be prepared
to handle multiple struct cn_msg, struct w1_netlink_msg, and
struct w1_netlink_cmd in one packet.
      </para></listitem>
    </varlistentry>
  </variablelist>
</refsect1>
</refentry>

<refentry id="API-enum-w1-netlink-message-types">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>enum w1_netlink_message_types</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>enum w1_netlink_message_types</refname>
 <refpurpose>
     message type
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
enum w1_netlink_message_types {
  W1_SLAVE_ADD,
  W1_SLAVE_REMOVE,
  W1_MASTER_ADD,
  W1_MASTER_REMOVE,
  W1_MASTER_CMD,
  W1_SLAVE_CMD,
  W1_LIST_MASTERS
};  </programlisting>
</refsynopsisdiv>
<refsect1>
 <title>Constants</title>
  <variablelist>
    <varlistentry>      <term>W1_SLAVE_ADD</term>
      <listitem><para>
   notification that a slave device was added
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>W1_SLAVE_REMOVE</term>
      <listitem><para>
   notification that a slave device was removed
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>W1_MASTER_ADD</term>
      <listitem><para>
   notification that a new bus master was added
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>W1_MASTER_REMOVE</term>
      <listitem><para>
   notification that a bus masterwas removed
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>W1_MASTER_CMD</term>
      <listitem><para>
   initiate operations on a specific master
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>W1_SLAVE_CMD</term>
      <listitem><para>
   sends reset, selects the slave, then does a read/write/touch
   operation
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>W1_LIST_MASTERS</term>
      <listitem><para>
   used to determine the bus master identifiers
      </para></listitem>
    </varlistentry>
  </variablelist>
</refsect1>
</refentry>

<refentry id="API-struct-w1-netlink-msg">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct w1_netlink_msg</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct w1_netlink_msg</refname>
 <refpurpose>
     holds w1 message type, id, and result
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct w1_netlink_msg {
  __u8 type;
  __u8 status;
  __u16 len;
  union id;
  __u8 data[0];
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>type</term>
      <listitem><para>
   one of enum w1_netlink_message_types
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>status</term>
      <listitem><para>
   kernel feedback for success 0 or errno failure value
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>len</term>
      <listitem><para>
   length of data following w1_netlink_msg
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>id</term>
      <listitem><para>
   union holding master bus id (msg.id) and slave device id (id[8]).
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>data[0]</term>
      <listitem><para>
   start address of any following data
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
<refsect1>
<title>Description</title>
<para>
   The base message structure for w1 messages over netlink.
   The netlink connector data sequence is, struct nlmsghdr, struct cn_msg,
   then one or more struct w1_netlink_msg (each with optional data).
</para>
</refsect1>
</refentry>

<refentry id="API-enum-w1-commands">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>enum w1_commands</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>enum w1_commands</refname>
 <refpurpose>
     commands available for master or slave operations
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
enum w1_commands {
  W1_CMD_READ,
  W1_CMD_WRITE,
  W1_CMD_SEARCH,
  W1_CMD_ALARM_SEARCH,
  W1_CMD_TOUCH,
  W1_CMD_RESET,
  W1_CMD_SLAVE_ADD,
  W1_CMD_SLAVE_REMOVE,
  W1_CMD_LIST_SLAVES,
  W1_CMD_MAX
};  </programlisting>
</refsynopsisdiv>
<refsect1>
 <title>Constants</title>
  <variablelist>
    <varlistentry>      <term>W1_CMD_READ</term>
      <listitem><para>
   read len bytes
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>W1_CMD_WRITE</term>
      <listitem><para>
   write len bytes
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>W1_CMD_SEARCH</term>
      <listitem><para>
   initiate a standard search, returns only the slave
   devices found during that search
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>W1_CMD_ALARM_SEARCH</term>
      <listitem><para>
   search for devices that are currently alarming
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>W1_CMD_TOUCH</term>
      <listitem><para>
   Touches a series of bytes.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>W1_CMD_RESET</term>
      <listitem><para>
   sends a bus reset on the given master
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>W1_CMD_SLAVE_ADD</term>
      <listitem><para>
   adds a slave to the given master,
   8 byte slave id at data[0]
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>W1_CMD_SLAVE_REMOVE</term>
      <listitem><para>
   removes a slave to the given master,
   8 byte slave id at data[0]
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>W1_CMD_LIST_SLAVES</term>
      <listitem><para>
   list of slaves registered on this master
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>W1_CMD_MAX</term>
      <listitem><para>
   number of available commands
      </para></listitem>
    </varlistentry>
  </variablelist>
</refsect1>
</refentry>

<refentry id="API-struct-w1-netlink-cmd">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct w1_netlink_cmd</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct w1_netlink_cmd</refname>
 <refpurpose>
     holds the command and data
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct w1_netlink_cmd {
  __u8 cmd;
  __u8 res;
  __u16 len;
  __u8 data[0];
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>cmd</term>
      <listitem><para>
   one of enum w1_commands
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>res</term>
      <listitem><para>
   reserved
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>len</term>
      <listitem><para>
   length of data following w1_netlink_cmd
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>data[0]</term>
      <listitem><para>
   start address of any following data
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
<refsect1>
<title>Description</title>
<para>
   One or more struct w1_netlink_cmd is placed starting at w1_netlink_msg.data
   each with optional data.
</para>
</refsect1>
</refentry>

      </sect2>

      <sect2 id="w1_io.c">
        <title>drivers/w1/w1_io.c</title>
        <para>W1 input/output.</para>
<!-- drivers/w1/w1_io.c -->
<refentry id="API-w1-write-8">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>w1_write_8</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>w1_write_8</refname>
 <refpurpose>
  Writes 8 bits.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>w1_write_8 </function></funcdef>
   <paramdef>struct w1_master * <parameter>dev</parameter></paramdef>
   <paramdef>u8 <parameter>byte</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     the master device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>byte</parameter></term>
   <listitem>
    <para>
     the byte to write
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-w1-read-8">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>w1_read_8</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>w1_read_8</refname>
 <refpurpose>
     Reads 8 bits.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>u8 <function>w1_read_8 </function></funcdef>
   <paramdef>struct w1_master * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     the master device
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Return</title>
<para>
   the byte read
</para>
</refsect1>
</refentry>

<refentry id="API-w1-write-block">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>w1_write_block</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>w1_write_block</refname>
 <refpurpose>
     Writes a series of bytes.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>w1_write_block </function></funcdef>
   <paramdef>struct w1_master * <parameter>dev</parameter></paramdef>
   <paramdef>const u8 * <parameter>buf</parameter></paramdef>
   <paramdef>int <parameter>len</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     the master device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>buf</parameter></term>
   <listitem>
    <para>
     pointer to the data to write
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>len</parameter></term>
   <listitem>
    <para>
     the number of bytes to write
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-w1-touch-block">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>w1_touch_block</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>w1_touch_block</refname>
 <refpurpose>
     Touches a series of bytes.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>w1_touch_block </function></funcdef>
   <paramdef>struct w1_master * <parameter>dev</parameter></paramdef>
   <paramdef>u8 * <parameter>buf</parameter></paramdef>
   <paramdef>int <parameter>len</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     the master device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>buf</parameter></term>
   <listitem>
    <para>
     pointer to the data to write
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>len</parameter></term>
   <listitem>
    <para>
     the number of bytes to write
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-w1-read-block">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>w1_read_block</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>w1_read_block</refname>
 <refpurpose>
     Reads a series of bytes.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>u8 <function>w1_read_block </function></funcdef>
   <paramdef>struct w1_master * <parameter>dev</parameter></paramdef>
   <paramdef>u8 * <parameter>buf</parameter></paramdef>
   <paramdef>int <parameter>len</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     the master device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>buf</parameter></term>
   <listitem>
    <para>
     pointer to the buffer to fill
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>len</parameter></term>
   <listitem>
    <para>
     the number of bytes to read
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Return</title>
<para>
   the number of bytes read
</para>
</refsect1>
</refentry>

<refentry id="API-w1-reset-bus">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>w1_reset_bus</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>w1_reset_bus</refname>
 <refpurpose>
     Issues a reset bus sequence.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>w1_reset_bus </function></funcdef>
   <paramdef>struct w1_master * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     the master device
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Return</title>
<para>
   0=Device present, 1=No device present or error
</para>
</refsect1>
</refentry>

<refentry id="API-w1-reset-select-slave">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>w1_reset_select_slave</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>w1_reset_select_slave</refname>
 <refpurpose>
     reset and select a slave
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>w1_reset_select_slave </function></funcdef>
   <paramdef>struct w1_slave * <parameter>sl</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>sl</parameter></term>
   <listitem>
    <para>
     the slave to select
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Resets the bus and then selects the slave by sending either a skip rom
   or a rom match.  A skip rom is issued if there is only one device
   registered on the bus.
   The w1 master lock must be held.
</para>
</refsect1>
<refsect1>
<title>Return</title>
<para>
   0=success, anything else=error
</para>
</refsect1>
</refentry>

<refentry id="API-w1-reset-resume-command">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>w1_reset_resume_command</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>w1_reset_resume_command</refname>
 <refpurpose>
     resume instead of another match ROM
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>w1_reset_resume_command </function></funcdef>
   <paramdef>struct w1_master * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     the master device
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   When the workflow with a slave amongst many requires several
   successive commands a reset between each, this function is similar
   to doing a reset then a match ROM for the last matched ROM. The
   advantage being that the matched ROM step is skipped in favor of the
   resume command. The slave must support the command of course.
   </para><para>

   If the bus has only one slave, traditionnaly the match ROM is skipped
   and a <quote>SKIP ROM</quote> is done for efficiency. On multi-slave busses, this
   doesn't work of course, but the resume command is the next best thing.
   </para><para>

   The w1 master lock must be held.
</para>
</refsect1>
</refentry>

<refentry id="API-w1-next-pullup">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>w1_next_pullup</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>w1_next_pullup</refname>
 <refpurpose>
     register for a strong pullup
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>w1_next_pullup </function></funcdef>
   <paramdef>struct w1_master * <parameter>dev</parameter></paramdef>
   <paramdef>int <parameter>delay</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     the master device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>delay</parameter></term>
   <listitem>
    <para>
     time in milliseconds
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Put out a strong pull-up of the specified duration after the next write
   operation.  Not all hardware supports strong pullups.  Hardware that
   doesn't support strong pullups will sleep for the given time after the
   write operation without a strong pullup.  This is a one shot request for
   the next write, specifying zero will clear a previous request.
   The w1 master lock must be held.
</para>
</refsect1>
<refsect1>
<title>Return</title>
<para>
   0=success, anything else=error
</para>
</refsect1>
</refentry>

<!-- drivers/w1/w1_io.c -->
<refentry id="API-w1-touch-bit">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>w1_touch_bit</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>w1_touch_bit</refname>
 <refpurpose>
  Generates a write-0 or write-1 cycle and samples the level.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>u8 <function>w1_touch_bit </function></funcdef>
   <paramdef>struct w1_master * <parameter>dev</parameter></paramdef>
   <paramdef>int <parameter>bit</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     the master device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>bit</parameter></term>
   <listitem>
    <para>
     0 - write a 0, 1 - write a 0 read the level
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-w1-write-bit">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>w1_write_bit</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>w1_write_bit</refname>
 <refpurpose>
     Generates a write-0 or write-1 cycle.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>w1_write_bit </function></funcdef>
   <paramdef>struct w1_master * <parameter>dev</parameter></paramdef>
   <paramdef>int <parameter>bit</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     the master device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>bit</parameter></term>
   <listitem>
    <para>
     bit to write
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Only call if dev-&gt;bus_master-&gt;touch_bit is NULL
</para>
</refsect1>
</refentry>

<refentry id="API-w1-pre-write">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>w1_pre_write</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>w1_pre_write</refname>
 <refpurpose>
     pre-write operations
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>w1_pre_write </function></funcdef>
   <paramdef>struct w1_master * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     the master device
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Pre-write operation, currently only supporting strong pullups.
   Program the hardware for a strong pullup, if one has been requested and
   the hardware supports it.
</para>
</refsect1>
</refentry>

<refentry id="API-w1-post-write">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>w1_post_write</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>w1_post_write</refname>
 <refpurpose>
     post-write options
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>w1_post_write </function></funcdef>
   <paramdef>struct w1_master * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     the master device
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Post-write operation, currently only supporting strong pullups.
   If a strong pullup was requested, clear it if the hardware supports
   them, or execute the delay otherwise, in either case clear the request.
</para>
</refsect1>
</refentry>

<refentry id="API-w1-read-bit">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>w1_read_bit</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>w1_read_bit</refname>
 <refpurpose>
     Generates a write-1 cycle and samples the level.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>u8 <function>w1_read_bit </function></funcdef>
   <paramdef>struct w1_master * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     the master device
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Only call if dev-&gt;bus_master-&gt;touch_bit is NULL
</para>
</refsect1>
</refentry>

<refentry id="API-w1-triplet">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>w1_triplet</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>w1_triplet</refname>
 <refpurpose>
     * Does a triplet - used for searching ROM addresses.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>u8 <function>w1_triplet </function></funcdef>
   <paramdef>struct w1_master * <parameter>dev</parameter></paramdef>
   <paramdef>int <parameter>bdir</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     the master device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>bdir</parameter></term>
   <listitem>
    <para>
     the bit to write if both id_bit and comp_bit are 0
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Return bits</title>
<para>
   bit 0 = id_bit
   bit 1 = comp_bit
   bit 2 = dir_taken
   If both bits 0 &amp; 1 are set, the search should be restarted.
</para>
</refsect1>
<refsect1>
<title>Return</title>
<para>
   bit fields - see above
</para>
</refsect1>
</refentry>

      </sect2>

    </sect1>


  </chapter>

</book>
