<programlisting>
/*
 * frontend.h
 *
 * Copyright (C) 2000 Marcus Metzler &lt;marcus@convergence.de&gt;
 *                  Ralph  Metzler &lt;ralph@convergence.de&gt;
 *                  Holger Waechtler &lt;holger@convergence.de&gt;
 *                  Andre Draszik &lt;ad@convergence.de&gt;
 *                  for convergence integrated media GmbH
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * as published by the Free Software Foundation; either version 2.1
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 *
 */

#ifndef _DVBFRONTEND_H_
#define _DVBFRONTEND_H_

#include &lt;linux/types.h&gt;

typedef enum fe_type {
        FE_QPSK,
        FE_QAM,
        FE_OFDM,
        FE_ATSC
} <link linkend="fe-type-t">fe_type_t</link>;


typedef enum fe_caps {
        FE_IS_STUPID                    = 0,
        FE_CAN_INVERSION_AUTO           = 0x1,
        FE_CAN_FEC_1_2                  = 0x2,
        FE_CAN_FEC_2_3                  = 0x4,
        FE_CAN_FEC_3_4                  = 0x8,
        FE_CAN_FEC_4_5                  = 0x10,
        FE_CAN_FEC_5_6                  = 0x20,
        FE_CAN_FEC_6_7                  = 0x40,
        FE_CAN_FEC_7_8                  = 0x80,
        FE_CAN_FEC_8_9                  = 0x100,
        FE_CAN_FEC_AUTO                 = 0x200,
        FE_CAN_QPSK                     = 0x400,
        FE_CAN_QAM_16                   = 0x800,
        FE_CAN_QAM_32                   = 0x1000,
        FE_CAN_QAM_64                   = 0x2000,
        FE_CAN_QAM_128                  = 0x4000,
        FE_CAN_QAM_256                  = 0x8000,
        FE_CAN_QAM_AUTO                 = 0x10000,
        FE_CAN_TRANSMISSION_MODE_AUTO   = 0x20000,
        FE_CAN_BANDWIDTH_AUTO           = 0x40000,
        FE_CAN_GUARD_INTERVAL_AUTO      = 0x80000,
        FE_CAN_HIERARCHY_AUTO           = 0x100000,
        FE_CAN_8VSB                     = 0x200000,
        FE_CAN_16VSB                    = 0x400000,
        FE_HAS_EXTENDED_CAPS            = 0x800000,   /* We need more bitspace for newer APIs, indicate this. */
        FE_CAN_MULTISTREAM              = 0x4000000,  /* frontend supports multistream filtering */
        FE_CAN_TURBO_FEC                = 0x8000000,  /* frontend supports "turbo fec modulation" */
        FE_CAN_2G_MODULATION            = 0x10000000, /* frontend supports "2nd generation modulation" (DVB-S2) */
        FE_NEEDS_BENDING                = 0x20000000, /* not supported anymore, don't use (frontend requires frequency bending) */
        FE_CAN_RECOVER                  = 0x40000000, /* frontend can recover from a cable unplug automatically */
        FE_CAN_MUTE_TS                  = 0x80000000  /* frontend can stop spurious TS data output */
} <link linkend="fe-caps-t">fe_caps_t</link>;


struct <link linkend="dvb-frontend-info">dvb_frontend_info</link> {
        char       name[128];
        fe_type_t  type;                        /* DEPRECATED. Use DTV_ENUM_DELSYS instead */
        __u32      frequency_min;
        __u32      frequency_max;
        __u32      frequency_stepsize;
        __u32      frequency_tolerance;
        __u32      symbol_rate_min;
        __u32      symbol_rate_max;
        __u32      symbol_rate_tolerance;       /* ppm */
        __u32      notifier_delay;              /* DEPRECATED */
        fe_caps_t  caps;
};


/**
 *  Check out the DiSEqC bus spec available on http://www.eutelsat.org/ for
 *  the meaning of this struct...
 */
struct <link linkend="dvb-diseqc-master-cmd">dvb_diseqc_master_cmd</link> {
        __u8 msg [6];   /*  { framing, address, command, data [3] } */
        __u8 msg_len;   /*  valid values are 3...6  */
};


struct <link linkend="dvb-diseqc-slave-reply">dvb_diseqc_slave_reply</link> {
        __u8 msg [4];   /*  { framing, data [3] } */
        __u8 msg_len;   /*  valid values are 0...4, 0 means no msg  */
        int  timeout;   /*  return from ioctl after timeout ms with */
};                      /*  errorcode when no message was received  */


typedef enum fe_sec_voltage {
        SEC_VOLTAGE_13,
        SEC_VOLTAGE_18,
        SEC_VOLTAGE_OFF
} <link linkend="fe-sec-voltage-t">fe_sec_voltage_t</link>;


typedef enum fe_sec_tone_mode {
        SEC_TONE_ON,
        SEC_TONE_OFF
} <link linkend="fe-sec-tone-mode-t">fe_sec_tone_mode_t</link>;


typedef enum fe_sec_mini_cmd {
        SEC_MINI_A,
        SEC_MINI_B
} <link linkend="fe-sec-mini-cmd-t">fe_sec_mini_cmd_t</link>;


/**
 * enum fe_status - enumerates the possible frontend status
 * @FE_HAS_SIGNAL:      found something above the noise level
 * @FE_HAS_CARRIER:     found a DVB signal
 * @FE_HAS_VITERBI:     FEC is stable
 * @FE_HAS_SYNC:        found sync bytes
 * @FE_HAS_LOCK:        everything's working
 * @FE_TIMEDOUT:        no lock within the last ~2 seconds
 * @FE_REINIT:          frontend was reinitialized, application is recommended
 *                      to reset DiSEqC, tone and parameters
 */

typedef enum fe_status {
        FE_HAS_SIGNAL           = 0x01,
        FE_HAS_CARRIER          = 0x02,
        FE_HAS_VITERBI          = 0x04,
        FE_HAS_SYNC             = 0x08,
        FE_HAS_LOCK             = 0x10,
        FE_TIMEDOUT             = 0x20,
        FE_REINIT               = 0x40,
} <link linkend="fe-status-t">fe_status_t</link>;

typedef enum fe_spectral_inversion {
        INVERSION_OFF,
        INVERSION_ON,
        INVERSION_AUTO
} <link linkend="fe-spectral-inversion-t">fe_spectral_inversion_t</link>;


typedef enum fe_code_rate {
        FEC_NONE = 0,
        FEC_1_2,
        FEC_2_3,
        FEC_3_4,
        FEC_4_5,
        FEC_5_6,
        FEC_6_7,
        FEC_7_8,
        FEC_8_9,
        FEC_AUTO,
        FEC_3_5,
        FEC_9_10,
        FEC_2_5,
} <link linkend="fe-code-rate-t">fe_code_rate_t</link>;


typedef enum fe_modulation {
        QPSK,
        QAM_16,
        QAM_32,
        QAM_64,
        QAM_128,
        QAM_256,
        QAM_AUTO,
        VSB_8,
        VSB_16,
        PSK_8,
        APSK_16,
        APSK_32,
        DQPSK,
        QAM_4_NR,
} <link linkend="fe-modulation-t">fe_modulation_t</link>;

typedef enum fe_transmit_mode {
        TRANSMISSION_MODE_2K,
        TRANSMISSION_MODE_8K,
        TRANSMISSION_MODE_AUTO,
        TRANSMISSION_MODE_4K,
        TRANSMISSION_MODE_1K,
        TRANSMISSION_MODE_16K,
        TRANSMISSION_MODE_32K,
        TRANSMISSION_MODE_C1,
        TRANSMISSION_MODE_C3780,
} <link linkend="fe-transmit-mode-t">fe_transmit_mode_t</link>;

#if defined(__DVB_CORE__) || !defined (__KERNEL__)
typedef enum fe_bandwidth {
        BANDWIDTH_8_MHZ,
        BANDWIDTH_7_MHZ,
        BANDWIDTH_6_MHZ,
        BANDWIDTH_AUTO,
        BANDWIDTH_5_MHZ,
        BANDWIDTH_10_MHZ,
        BANDWIDTH_1_712_MHZ,
} <link linkend="fe-bandwidth-t">fe_bandwidth_t</link>;
#endif

typedef enum fe_guard_interval {
        GUARD_INTERVAL_1_32,
        GUARD_INTERVAL_1_16,
        GUARD_INTERVAL_1_8,
        GUARD_INTERVAL_1_4,
        GUARD_INTERVAL_AUTO,
        GUARD_INTERVAL_1_128,
        GUARD_INTERVAL_19_128,
        GUARD_INTERVAL_19_256,
        GUARD_INTERVAL_PN420,
        GUARD_INTERVAL_PN595,
        GUARD_INTERVAL_PN945,
} <link linkend="fe-guard-interval-t">fe_guard_interval_t</link>;


typedef enum fe_hierarchy {
        HIERARCHY_NONE,
        HIERARCHY_1,
        HIERARCHY_2,
        HIERARCHY_4,
        HIERARCHY_AUTO
} <link linkend="fe-hierarchy-t">fe_hierarchy_t</link>;

enum fe_interleaving {
        INTERLEAVING_NONE,
        INTERLEAVING_AUTO,
        INTERLEAVING_240,
        INTERLEAVING_720,
};

#if defined(__DVB_CORE__) || !defined (__KERNEL__)
struct <link linkend="dvb-qpsk-parameters">dvb_qpsk_parameters</link> {
        __u32           symbol_rate;  /* symbol rate in Symbols per second */
        fe_code_rate_t  fec_inner;    /* forward error correction (see above) */
};

struct <link linkend="dvb-qam-parameters">dvb_qam_parameters</link> {
        __u32           symbol_rate; /* symbol rate in Symbols per second */
        fe_code_rate_t  fec_inner;   /* forward error correction (see above) */
        fe_modulation_t modulation;  /* modulation type (see above) */
};

struct <link linkend="dvb-vsb-parameters">dvb_vsb_parameters</link> {
        fe_modulation_t modulation;  /* modulation type (see above) */
};

struct <link linkend="dvb-ofdm-parameters">dvb_ofdm_parameters</link> {
        fe_bandwidth_t      bandwidth;
        fe_code_rate_t      code_rate_HP;  /* high priority stream code rate */
        fe_code_rate_t      code_rate_LP;  /* low priority stream code rate */
        fe_modulation_t     constellation; /* modulation type (see above) */
        fe_transmit_mode_t  transmission_mode;
        fe_guard_interval_t guard_interval;
        fe_hierarchy_t      hierarchy_information;
};


struct <link linkend="dvb-frontend-parameters">dvb_frontend_parameters</link> {
        __u32 frequency;     /* (absolute) frequency in Hz for QAM/OFDM/ATSC */
                             /* intermediate frequency in kHz for QPSK */
        fe_spectral_inversion_t inversion;
        union {
                struct dvb_qpsk_parameters qpsk;
                struct dvb_qam_parameters  qam;
                struct dvb_ofdm_parameters ofdm;
                struct dvb_vsb_parameters vsb;
        } u;
};

struct <link linkend="dvb-frontend-event">dvb_frontend_event</link> {
        fe_status_t status;
        struct dvb_frontend_parameters parameters;
};
#endif

/* S2API Commands */
#define <link linkend="DTV-UNDEFINED">DTV_UNDEFINED</link>           0
#define <link linkend="DTV-TUNE">DTV_TUNE</link>                1
#define <link linkend="DTV-CLEAR">DTV_CLEAR</link>               2
#define <link linkend="DTV-FREQUENCY">DTV_FREQUENCY</link>           3
#define <link linkend="DTV-MODULATION">DTV_MODULATION</link>          4
#define <link linkend="DTV-BANDWIDTH-HZ">DTV_BANDWIDTH_HZ</link>        5
#define <link linkend="DTV-INVERSION">DTV_INVERSION</link>           6
#define <link linkend="DTV-DISEQC-MASTER">DTV_DISEQC_MASTER</link>       7
#define <link linkend="DTV-SYMBOL-RATE">DTV_SYMBOL_RATE</link>         8
#define <link linkend="DTV-INNER-FEC">DTV_INNER_FEC</link>           9
#define <link linkend="DTV-VOLTAGE">DTV_VOLTAGE</link>             10
#define <link linkend="DTV-TONE">DTV_TONE</link>                11
#define <link linkend="DTV-PILOT">DTV_PILOT</link>               12
#define <link linkend="DTV-ROLLOFF">DTV_ROLLOFF</link>             13
#define <link linkend="DTV-DISEQC-SLAVE-REPLY">DTV_DISEQC_SLAVE_REPLY</link>  14

/* Basic enumeration set for querying unlimited capabilities */
#define <link linkend="DTV-FE-CAPABILITY-COUNT">DTV_FE_CAPABILITY_COUNT</link> 15
#define <link linkend="DTV-FE-CAPABILITY">DTV_FE_CAPABILITY</link>       16
#define <link linkend="DTV-DELIVERY-SYSTEM">DTV_DELIVERY_SYSTEM</link>     17

/* ISDB-T and ISDB-Tsb */
#define <link linkend="DTV-ISDBT-PARTIAL-RECEPTION">DTV_ISDBT_PARTIAL_RECEPTION</link>     18
#define <link linkend="DTV-ISDBT-SOUND-BROADCASTING">DTV_ISDBT_SOUND_BROADCASTING</link>    19

#define <link linkend="DTV-ISDBT-SB-SUBCHANNEL-ID">DTV_ISDBT_SB_SUBCHANNEL_ID</link>      20
#define <link linkend="DTV-ISDBT-SB-SEGMENT-IDX">DTV_ISDBT_SB_SEGMENT_IDX</link>        21
#define <link linkend="DTV-ISDBT-SB-SEGMENT-COUNT">DTV_ISDBT_SB_SEGMENT_COUNT</link>      22

#define <link linkend="DTV-ISDBT-LAYER-FEC">DTV_ISDBT_LAYERA_FEC</link>                    23
#define <link linkend="DTV-ISDBT-LAYER-MODULATION">DTV_ISDBT_LAYERA_MODULATION</link>             24
#define <link linkend="DTV-ISDBT-LAYER-SEGMENT-COUNT">DTV_ISDBT_LAYERA_SEGMENT_COUNT</link>          25
#define <link linkend="DTV-ISDBT-LAYER-TIME-INTERLEAVING">DTV_ISDBT_LAYERA_TIME_INTERLEAVING</link>      26

#define <link linkend="DTV-ISDBT-LAYER-FEC">DTV_ISDBT_LAYERB_FEC</link>                    27
#define <link linkend="DTV-ISDBT-LAYER-MODULATION">DTV_ISDBT_LAYERB_MODULATION</link>             28
#define <link linkend="DTV-ISDBT-LAYER-SEGMENT-COUNT">DTV_ISDBT_LAYERB_SEGMENT_COUNT</link>          29
#define <link linkend="DTV-ISDBT-LAYER-TIME-INTERLEAVING">DTV_ISDBT_LAYERB_TIME_INTERLEAVING</link>      30

#define <link linkend="DTV-ISDBT-LAYER-FEC">DTV_ISDBT_LAYERC_FEC</link>                    31
#define <link linkend="DTV-ISDBT-LAYER-MODULATION">DTV_ISDBT_LAYERC_MODULATION</link>             32
#define <link linkend="DTV-ISDBT-LAYER-SEGMENT-COUNT">DTV_ISDBT_LAYERC_SEGMENT_COUNT</link>          33
#define <link linkend="DTV-ISDBT-LAYER-TIME-INTERLEAVING">DTV_ISDBT_LAYERC_TIME_INTERLEAVING</link>      34

#define <link linkend="DTV-API-VERSION">DTV_API_VERSION</link>         35

#define <link linkend="DTV-CODE-RATE-HP">DTV_CODE_RATE_HP</link>        36
#define <link linkend="DTV-CODE-RATE-LP">DTV_CODE_RATE_LP</link>        37
#define <link linkend="DTV-GUARD-INTERVAL">DTV_GUARD_INTERVAL</link>      38
#define <link linkend="DTV-TRANSMISSION-MODE">DTV_TRANSMISSION_MODE</link>   39
#define <link linkend="DTV-HIERARCHY">DTV_HIERARCHY</link>           40

#define <link linkend="DTV-ISDBT-LAYER-ENABLED">DTV_ISDBT_LAYER_ENABLED</link> 41

#define <link linkend="DTV-STREAM-ID">DTV_STREAM_ID</link>           42
#define DTV_ISDBS_TS_ID_LEGACY  DTV_STREAM_ID
#define <link linkend="DTV-DVBT2-PLP-ID-LEGACY">DTV_DVBT2_PLP_ID_LEGACY</link> 43

#define <link linkend="DTV-ENUM-DELSYS">DTV_ENUM_DELSYS</link>         44

/* ATSC-MH */
#define <link linkend="DTV-ATSCMH-FIC-VER">DTV_ATSCMH_FIC_VER</link>              45
#define <link linkend="DTV-ATSCMH-PARADE-ID">DTV_ATSCMH_PARADE_ID</link>            46
#define <link linkend="DTV-ATSCMH-NOG">DTV_ATSCMH_NOG</link>                  47
#define <link linkend="DTV-ATSCMH-TNOG">DTV_ATSCMH_TNOG</link>                 48
#define <link linkend="DTV-ATSCMH-SGN">DTV_ATSCMH_SGN</link>                  49
#define <link linkend="DTV-ATSCMH-PRC">DTV_ATSCMH_PRC</link>                  50
#define <link linkend="DTV-ATSCMH-RS-FRAME-MODE">DTV_ATSCMH_RS_FRAME_MODE</link>        51
#define <link linkend="DTV-ATSCMH-RS-FRAME-ENSEMBLE">DTV_ATSCMH_RS_FRAME_ENSEMBLE</link>    52
#define <link linkend="DTV-ATSCMH-RS-CODE-MODE-PRI">DTV_ATSCMH_RS_CODE_MODE_PRI</link>     53
#define <link linkend="DTV-ATSCMH-RS-CODE-MODE-SEC">DTV_ATSCMH_RS_CODE_MODE_SEC</link>     54
#define <link linkend="DTV-ATSCMH-SCCC-BLOCK-MODE">DTV_ATSCMH_SCCC_BLOCK_MODE</link>      55
#define <link linkend="DTV-ATSCMH-SCCC-CODE-MODE-A">DTV_ATSCMH_SCCC_CODE_MODE_A</link>     56
#define <link linkend="DTV-ATSCMH-SCCC-CODE-MODE-B">DTV_ATSCMH_SCCC_CODE_MODE_B</link>     57
#define <link linkend="DTV-ATSCMH-SCCC-CODE-MODE-C">DTV_ATSCMH_SCCC_CODE_MODE_C</link>     58
#define <link linkend="DTV-ATSCMH-SCCC-CODE-MODE-D">DTV_ATSCMH_SCCC_CODE_MODE_D</link>     59

#define <link linkend="DTV-INTERLEAVING">DTV_INTERLEAVING</link>                        60
#define <link linkend="DTV-LNA">DTV_LNA</link>                                 61

/* Quality parameters */
#define <link linkend="DTV-STAT-SIGNAL-STRENGTH">DTV_STAT_SIGNAL_STRENGTH</link>        62
#define <link linkend="DTV-STAT-CNR">DTV_STAT_CNR</link>                    63
#define <link linkend="DTV-STAT-PRE-ERROR-BIT-COUNT">DTV_STAT_PRE_ERROR_BIT_COUNT</link>    64
#define <link linkend="DTV-STAT-PRE-TOTAL-BIT-COUNT">DTV_STAT_PRE_TOTAL_BIT_COUNT</link>    65
#define <link linkend="DTV-STAT-POST-ERROR-BIT-COUNT">DTV_STAT_POST_ERROR_BIT_COUNT</link>   66
#define <link linkend="DTV-STAT-POST-TOTAL-BIT-COUNT">DTV_STAT_POST_TOTAL_BIT_COUNT</link>   67
#define <link linkend="DTV-STAT-ERROR-BLOCK-COUNT">DTV_STAT_ERROR_BLOCK_COUNT</link>      68
#define <link linkend="DTV-STAT-TOTAL-BLOCK-COUNT">DTV_STAT_TOTAL_BLOCK_COUNT</link>      69

#define DTV_MAX_COMMAND         DTV_STAT_TOTAL_BLOCK_COUNT

typedef enum fe_pilot {
        PILOT_ON,
        PILOT_OFF,
        PILOT_AUTO,
} <link linkend="fe-pilot-t">fe_pilot_t</link>;

typedef enum fe_rolloff {
        ROLLOFF_35, /* Implied value in DVB-S, default for DVB-S2 */
        ROLLOFF_20,
        ROLLOFF_25,
        ROLLOFF_AUTO,
} <link linkend="fe-rolloff-t">fe_rolloff_t</link>;

typedef enum fe_delivery_system {
        SYS_UNDEFINED,
        SYS_DVBC_ANNEX_A,
        SYS_DVBC_ANNEX_B,
        SYS_DVBT,
        SYS_DSS,
        SYS_DVBS,
        SYS_DVBS2,
        SYS_DVBH,
        SYS_ISDBT,
        SYS_ISDBS,
        SYS_ISDBC,
        SYS_ATSC,
        SYS_ATSCMH,
        SYS_DTMB,
        SYS_CMMB,
        SYS_DAB,
        SYS_DVBT2,
        SYS_TURBO,
        SYS_DVBC_ANNEX_C,
} <link linkend="fe-delivery-system-t">fe_delivery_system_t</link>;

/* backward compatibility */
#define SYS_DVBC_ANNEX_AC       SYS_DVBC_ANNEX_A
#define SYS_DMBTH SYS_DTMB /* DMB-TH is legacy name, use DTMB instead */

/* ATSC-MH */

enum atscmh_sccc_block_mode {
        ATSCMH_SCCC_BLK_SEP      = 0,
        ATSCMH_SCCC_BLK_COMB     = 1,
        ATSCMH_SCCC_BLK_RES      = 2,
};

enum atscmh_sccc_code_mode {
        ATSCMH_SCCC_CODE_HLF     = 0,
        ATSCMH_SCCC_CODE_QTR     = 1,
        ATSCMH_SCCC_CODE_RES     = 2,
};

enum atscmh_rs_frame_ensemble {
        ATSCMH_RSFRAME_ENS_PRI   = 0,
        ATSCMH_RSFRAME_ENS_SEC   = 1,
};

enum atscmh_rs_frame_mode {
        ATSCMH_RSFRAME_PRI_ONLY  = 0,
        ATSCMH_RSFRAME_PRI_SEC   = 1,
        ATSCMH_RSFRAME_RES       = 2,
};

enum atscmh_rs_code_mode {
        ATSCMH_RSCODE_211_187    = 0,
        ATSCMH_RSCODE_223_187    = 1,
        ATSCMH_RSCODE_235_187    = 2,
        ATSCMH_RSCODE_RES        = 3,
};

#define NO_STREAM_ID_FILTER     (~0U)
#define LNA_AUTO                (~0U)

struct dtv_cmds_h {
        char    *name;          /* A display name for debugging purposes */

        __u32   cmd;            /* A unique ID */

        /* Flags */
        __u32   set:1;          /* Either a set or get property */
        __u32   buffer:1;       /* Does this property use the buffer? */
        __u32   reserved:30;    /* Align */
};

/**
 * Scale types for the quality parameters.
 * @FE_SCALE_NOT_AVAILABLE: That QoS measure is not available. That
 *                          could indicate a temporary or a permanent
 *                          condition.
 * @FE_SCALE_DECIBEL: The scale is measured in 0.0001 dB steps, typically
 *                used on signal measures.
 * @FE_SCALE_RELATIVE: The scale is a relative percentual measure,
 *                      ranging from 0 (0%) to 0xffff (100%).
 * @FE_SCALE_COUNTER: The scale counts the occurrence of an event, like
 *                      bit error, block error, lapsed time.
 */
enum fecap_scale_params {
        FE_SCALE_NOT_AVAILABLE = 0,
        FE_SCALE_DECIBEL,
        FE_SCALE_RELATIVE,
        FE_SCALE_COUNTER
};

/**
 * struct dtv_stats - Used for reading a DTV status property
 *
 * @value:      value of the measure. Should range from 0 to 0xffff;
 * @scale:      Filled with enum fecap_scale_params - the scale
 *              in usage for that parameter
 *
 * For most delivery systems, this will return a single value for each
 * parameter.
 * It should be noticed, however, that new OFDM delivery systems like
 * ISDB can use different modulation types for each group of carriers.
 * On such standards, up to 8 groups of statistics can be provided, one
 * for each carrier group (called "layer" on ISDB).
 * In order to be consistent with other delivery systems, the first
 * value refers to the entire set of carriers ("global").
 * dtv_status:scale should use the value FE_SCALE_NOT_AVAILABLE when
 * the value for the entire group of carriers or from one specific layer
 * is not provided by the hardware.
 * st.len should be filled with the latest filled status + 1.
 *
 * In other words, for ISDB, those values should be filled like:
 *      u.st.stat.svalue[0] = global statistics;
 *      u.st.stat.scale[0] = FE_SCALE_DECIBELS;
 *      u.st.stat.value[1] = layer A statistics;
 *      u.st.stat.scale[1] = FE_SCALE_NOT_AVAILABLE (if not available);
 *      u.st.stat.svalue[2] = layer B statistics;
 *      u.st.stat.scale[2] = FE_SCALE_DECIBELS;
 *      u.st.stat.svalue[3] = layer C statistics;
 *      u.st.stat.scale[3] = FE_SCALE_DECIBELS;
 *      u.st.len = 4;
 */
struct <link linkend="dtv-stats">dtv_stats</link> {
        __u8 scale;     /* enum fecap_scale_params type */
        union {
                __u64 uvalue;   /* for counters and relative scales */
                __s64 svalue;   /* for 0.0001 dB measures */
        };
} __attribute__ ((packed));


#define MAX_DTV_STATS   4

struct <link linkend="dtv-fe-stats">dtv_fe_stats</link> {
        __u8 len;
        struct dtv_stats stat[MAX_DTV_STATS];
} __attribute__ ((packed));

struct <link linkend="dtv-property">dtv_property</link> {
        __u32 cmd;
        __u32 reserved[3];
        union {
                __u32 data;
                struct dtv_fe_stats st;
                struct {
                        __u8 data[32];
                        __u32 len;
                        __u32 reserved1[3];
                        void *reserved2;
                } buffer;
        } u;
        int result;
} __attribute__ ((packed));

/* num of properties cannot exceed DTV_IOCTL_MAX_MSGS per ioctl */
#define DTV_IOCTL_MAX_MSGS 64

struct <link linkend="dtv-properties">dtv_properties</link> {
        __u32 num;
        struct dtv_property *props;
};

#define <link linkend="FE_SET_PROPERTY">FE_SET_PROPERTY</link>            _IOW('o', 82, struct dtv_properties)
#define <link linkend="FE_GET_PROPERTY">FE_GET_PROPERTY</link>            _IOR('o', 83, struct dtv_properties)


/**
 * When set, this flag will disable any zigzagging or other "normal" tuning
 * behaviour. Additionally, there will be no automatic monitoring of the lock
 * status, and hence no frontend events will be generated. If a frontend device
 * is closed, this flag will be automatically turned off when the device is
 * reopened read-write.
 */
#define FE_TUNE_MODE_ONESHOT 0x01


#define <link linkend="FE_GET_INFO">FE_GET_INFO</link>                _IOR('o', 61, struct dvb_frontend_info)

#define <link linkend="FE_DISEQC_RESET_OVERLOAD">FE_DISEQC_RESET_OVERLOAD</link>   _IO('o', 62)
#define <link linkend="FE_DISEQC_SEND_MASTER_CMD">FE_DISEQC_SEND_MASTER_CMD</link>  _IOW('o', 63, struct dvb_diseqc_master_cmd)
#define <link linkend="FE_DISEQC_RECV_SLAVE_REPLY">FE_DISEQC_RECV_SLAVE_REPLY</link> _IOR('o', 64, struct dvb_diseqc_slave_reply)
#define <link linkend="FE_DISEQC_SEND_BURST">FE_DISEQC_SEND_BURST</link>       _IO('o', 65)  /* fe_sec_mini_cmd_t */

#define <link linkend="FE_SET_TONE">FE_SET_TONE</link>                _IO('o', 66)  /* fe_sec_tone_mode_t */
#define <link linkend="FE_SET_VOLTAGE">FE_SET_VOLTAGE</link>             _IO('o', 67)  /* fe_sec_voltage_t */
#define <link linkend="FE_ENABLE_HIGH_LNB_VOLTAGE">FE_ENABLE_HIGH_LNB_VOLTAGE</link> _IO('o', 68)  /* int */

#define <link linkend="FE_READ_STATUS">FE_READ_STATUS</link>             _IOR('o', 69, fe_status_t)
#define <link linkend="FE_READ_BER">FE_READ_BER</link>                _IOR('o', 70, __u32)
#define <link linkend="FE_READ_SIGNAL_STRENGTH">FE_READ_SIGNAL_STRENGTH</link>    _IOR('o', 71, __u16)
#define <link linkend="FE_READ_SNR">FE_READ_SNR</link>                _IOR('o', 72, __u16)
#define <link linkend="FE_READ_UNCORRECTED_BLOCKS">FE_READ_UNCORRECTED_BLOCKS</link> _IOR('o', 73, __u32)

#define <link linkend="FE_SET_FRONTEND">FE_SET_FRONTEND</link>            _IOW('o', 76, struct dvb_frontend_parameters)
#define <link linkend="FE_GET_FRONTEND">FE_GET_FRONTEND</link>            _IOR('o', 77, struct dvb_frontend_parameters)
#define <link linkend="FE_SET_FRONTEND_TUNE_MODE">FE_SET_FRONTEND_TUNE_MODE</link>  _IO('o', 81) /* unsigned int */
#define <link linkend="FE_GET_EVENT">FE_GET_EVENT</link>               _IOR('o', 78, struct dvb_frontend_event)

#define <link linkend="FE_DISHNETWORK_SEND_LEGACY_CMD">FE_DISHNETWORK_SEND_LEGACY_CMD</link> _IO('o', 80) /* unsigned int */

#endif /*_DVBFRONTEND_H_*/
</programlisting>
