<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN"
	"http://www.oasis-open.org/docbook/xml/4.1.2/docbookx.dtd" []>

<book id="Generic-IRQ-Guide">
 <bookinfo>
  <title>Linux generic IRQ handling</title>

  <authorgroup>
   <author>
    <firstname>Thomas</firstname>
    <surname>Gleixner</surname>
    <affiliation>
     <address>
      <email>tglx@linutronix.de</email>
     </address>
    </affiliation>
   </author>
   <author>
    <firstname>Ingo</firstname>
    <surname>Molnar</surname>
    <affiliation>
     <address>
      <email>mingo@elte.hu</email>
     </address>
    </affiliation>
   </author>
  </authorgroup>

  <copyright>
   <year>2005-2010</year>
   <holder>Thomas Gleixner</holder>
  </copyright>
  <copyright>
   <year>2005-2006</year>
   <holder>Ingo Molnar</holder>
  </copyright>

  <legalnotice>
   <para>
     This documentation is free software; you can redistribute
     it and/or modify it under the terms of the GNU General Public
     License version 2 as published by the Free Software Foundation.
   </para>

   <para>
     This program is distributed in the hope that it will be
     useful, but WITHOUT ANY WARRANTY; without even the implied
     warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
     See the GNU General Public License for more details.
   </para>

   <para>
     You should have received a copy of the GNU General Public
     License along with this program; if not, write to the Free
     Software Foundation, Inc., 59 Temple Place, Suite 330, Boston,
     MA 02111-1307 USA
   </para>

   <para>
     For more details see the file COPYING in the source
     distribution of Linux.
   </para>
  </legalnotice>
 </bookinfo>

<toc></toc>

  <chapter id="intro">
    <title>Introduction</title>
    <para>
	The generic interrupt handling layer is designed to provide a
	complete abstraction of interrupt handling for device drivers.
	It is able to handle all the different types of interrupt controller
	hardware. Device drivers use generic API functions to request, enable,
	disable and free interrupts. The drivers do not have to know anything
	about interrupt hardware details, so they can be used on different
	platforms without code changes.
    </para>
    <para>
  	This documentation is provided to developers who want to implement
	an interrupt subsystem based for their architecture, with the help
	of the generic IRQ handling layer.
    </para>
  </chapter>

  <chapter id="rationale">
    <title>Rationale</title>
	<para>
	The original implementation of interrupt handling in Linux uses
	the __do_IRQ() super-handler, which is able to deal with every
	type of interrupt logic.
	</para>
	<para>
	Originally, Russell King identified different types of handlers to
	build a quite universal set for the ARM interrupt handler
	implementation in Linux 2.5/2.6. He distinguished between:
	<itemizedlist>
	  <listitem><para>Level type</para></listitem>
	  <listitem><para>Edge type</para></listitem>
	  <listitem><para>Simple type</para></listitem>
	</itemizedlist>
	During the implementation we identified another type:
	<itemizedlist>
	  <listitem><para>Fast EOI type</para></listitem>
	</itemizedlist>
	In the SMP world of the __do_IRQ() super-handler another type
	was identified:
	<itemizedlist>
	  <listitem><para>Per CPU type</para></listitem>
	</itemizedlist>
	</para>
	<para>
	This split implementation of high-level IRQ handlers allows us to
	optimize the flow of the interrupt handling for each specific
	interrupt type. This reduces complexity in that particular code path
	and allows the optimized handling of a given type.
	</para>
	<para>
	The original general IRQ implementation used hw_interrupt_type
	structures and their ->ack(), ->end() [etc.] callbacks to
	differentiate the flow control in the super-handler. This leads to
	a mix of flow logic and low-level hardware logic, and it also leads
	to unnecessary code duplication: for example in i386, there is an
	ioapic_level_irq and an ioapic_edge_irq IRQ-type which share many
	of the low-level details but have different flow handling.
	</para>
	<para>
	A more natural abstraction is the clean separation of the
	'irq flow' and the 'chip details'.
	</para>
	<para>
	Analysing a couple of architecture's IRQ subsystem implementations
	reveals that most of them can use a generic set of 'irq flow'
	methods and only need to add the chip-level specific code.
	The separation is also valuable for (sub)architectures
	which need specific quirks in the IRQ flow itself but not in the
	chip details - and thus provides a more transparent IRQ subsystem
	design.
	</para>
	<para>
	Each interrupt descriptor is assigned its own high-level flow
	handler, which is normally one of the generic
	implementations. (This high-level flow handler implementation also
	makes it simple to provide demultiplexing handlers which can be
	found in embedded platforms on various architectures.)
	</para>
	<para>
	The separation makes the generic interrupt handling layer more
	flexible and extensible. For example, an (sub)architecture can
	use a generic IRQ-flow implementation for 'level type' interrupts
	and add a (sub)architecture specific 'edge type' implementation.
	</para>
	<para>
	To make the transition to the new model easier and prevent the
	breakage of existing implementations, the __do_IRQ() super-handler
	is still available. This leads to a kind of duality for the time
	being. Over time the new model should be used in more and more
	architectures, as it enables smaller and cleaner IRQ subsystems.
	It's deprecated for three years now and about to be removed.
	</para>
  </chapter>
  <chapter id="bugs">
    <title>Known Bugs And Assumptions</title>
    <para>
	None (knock on wood).
    </para>
  </chapter>

  <chapter id="Abstraction">
    <title>Abstraction layers</title>
    <para>
	There are three main levels of abstraction in the interrupt code:
	<orderedlist>
	  <listitem><para>High-level driver API</para></listitem>
	  <listitem><para>High-level IRQ flow handlers</para></listitem>
	  <listitem><para>Chip-level hardware encapsulation</para></listitem>
	</orderedlist>
    </para>
    <sect1 id="Interrupt_control_flow">
	<title>Interrupt control flow</title>
	<para>
	Each interrupt is described by an interrupt descriptor structure
	irq_desc. The interrupt is referenced by an 'unsigned int' numeric
	value which selects the corresponding interrupt description structure
	in the descriptor structures array.
	The descriptor structure contains status information and pointers
	to the interrupt flow method and the interrupt chip structure
	which are assigned to this interrupt.
	</para>
	<para>
	Whenever an interrupt triggers, the low-level architecture code calls
	into the generic interrupt code by calling desc->handle_irq().
	This high-level IRQ handling function only uses desc->irq_data.chip
	primitives referenced by the assigned chip descriptor structure.
	</para>
    </sect1>
    <sect1 id="Highlevel_Driver_API">
	<title>High-level Driver API</title>
	<para>
	  The high-level Driver API consists of following functions:
	  <itemizedlist>
	  <listitem><para>request_irq()</para></listitem>
	  <listitem><para>free_irq()</para></listitem>
	  <listitem><para>disable_irq()</para></listitem>
	  <listitem><para>enable_irq()</para></listitem>
	  <listitem><para>disable_irq_nosync() (SMP only)</para></listitem>
	  <listitem><para>synchronize_irq() (SMP only)</para></listitem>
	  <listitem><para>irq_set_irq_type()</para></listitem>
	  <listitem><para>irq_set_irq_wake()</para></listitem>
	  <listitem><para>irq_set_handler_data()</para></listitem>
	  <listitem><para>irq_set_chip()</para></listitem>
	  <listitem><para>irq_set_chip_data()</para></listitem>
          </itemizedlist>
	  See the autogenerated function documentation for details.
	</para>
    </sect1>
    <sect1 id="Highlevel_IRQ_flow_handlers">
	<title>High-level IRQ flow handlers</title>
	<para>
	  The generic layer provides a set of pre-defined irq-flow methods:
	  <itemizedlist>
	  <listitem><para>handle_level_irq</para></listitem>
	  <listitem><para>handle_edge_irq</para></listitem>
	  <listitem><para>handle_fasteoi_irq</para></listitem>
	  <listitem><para>handle_simple_irq</para></listitem>
	  <listitem><para>handle_percpu_irq</para></listitem>
	  <listitem><para>handle_edge_eoi_irq</para></listitem>
	  <listitem><para>handle_bad_irq</para></listitem>
	  </itemizedlist>
	  The interrupt flow handlers (either pre-defined or architecture
	  specific) are assigned to specific interrupts by the architecture
	  either during bootup or during device initialization.
	</para>
	<sect2 id="Default_flow_implementations">
	<title>Default flow implementations</title>
	    <sect3 id="Helper_functions">
	 	<title>Helper functions</title>
		<para>
		The helper functions call the chip primitives and
		are used by the default flow implementations.
		The following helper functions are implemented (simplified excerpt):
		<programlisting>
default_enable(struct irq_data *data)
{
	desc->irq_data.chip->irq_unmask(data);
}

default_disable(struct irq_data *data)
{
	if (!delay_disable(data))
		desc->irq_data.chip->irq_mask(data);
}

default_ack(struct irq_data *data)
{
	chip->irq_ack(data);
}

default_mask_ack(struct irq_data *data)
{
	if (chip->irq_mask_ack) {
		chip->irq_mask_ack(data);
	} else {
		chip->irq_mask(data);
		chip->irq_ack(data);
	}
}

noop(struct irq_data *data))
{
}

		</programlisting>
	        </para>
	    </sect3>
	</sect2>
	<sect2 id="Default_flow_handler_implementations">
	<title>Default flow handler implementations</title>
	    <sect3 id="Default_Level_IRQ_flow_handler">
	 	<title>Default Level IRQ flow handler</title>
		<para>
		handle_level_irq provides a generic implementation
		for level-triggered interrupts.
		</para>
		<para>
		The following control flow is implemented (simplified excerpt):
		<programlisting>
desc->irq_data.chip->irq_mask_ack();
handle_irq_event(desc->action);
desc->irq_data.chip->irq_unmask();
		</programlisting>
		</para>
	    </sect3>
	    <sect3 id="Default_FASTEOI_IRQ_flow_handler">
		<title>Default Fast EOI IRQ flow handler</title>
		<para>
		handle_fasteoi_irq provides a generic implementation
		for interrupts, which only need an EOI at the end of
		the handler.
		</para>
		<para>
		The following control flow is implemented (simplified excerpt):
		<programlisting>
handle_irq_event(desc->action);
desc->irq_data.chip->irq_eoi();
		</programlisting>
		</para>
	    </sect3>
	    <sect3 id="Default_Edge_IRQ_flow_handler">
	 	<title>Default Edge IRQ flow handler</title>
		<para>
		handle_edge_irq provides a generic implementation
		for edge-triggered interrupts.
		</para>
		<para>
		The following control flow is implemented (simplified excerpt):
		<programlisting>
if (desc->status &amp; running) {
	desc->irq_data.chip->irq_mask_ack();
	desc->status |= pending | masked;
	return;
}
desc->irq_data.chip->irq_ack();
desc->status |= running;
do {
	if (desc->status &amp; masked)
		desc->irq_data.chip->irq_unmask();
	desc->status &amp;= ~pending;
	handle_irq_event(desc->action);
} while (status &amp; pending);
desc->status &amp;= ~running;
		</programlisting>
		</para>
   	    </sect3>
	    <sect3 id="Default_simple_IRQ_flow_handler">
	 	<title>Default simple IRQ flow handler</title>
		<para>
		handle_simple_irq provides a generic implementation
		for simple interrupts.
		</para>
		<para>
		Note: The simple flow handler does not call any
		handler/chip primitives.
		</para>
		<para>
		The following control flow is implemented (simplified excerpt):
		<programlisting>
handle_irq_event(desc->action);
		</programlisting>
		</para>
   	    </sect3>
	    <sect3 id="Default_per_CPU_flow_handler">
	 	<title>Default per CPU flow handler</title>
		<para>
		handle_percpu_irq provides a generic implementation
		for per CPU interrupts.
		</para>
		<para>
		Per CPU interrupts are only available on SMP and
		the handler provides a simplified version without
		locking.
		</para>
		<para>
		The following control flow is implemented (simplified excerpt):
		<programlisting>
if (desc->irq_data.chip->irq_ack)
	desc->irq_data.chip->irq_ack();
handle_irq_event(desc->action);
if (desc->irq_data.chip->irq_eoi)
        desc->irq_data.chip->irq_eoi();
		</programlisting>
		</para>
   	    </sect3>
	    <sect3 id="EOI_Edge_IRQ_flow_handler">
	 	<title>EOI Edge IRQ flow handler</title>
		<para>
		handle_edge_eoi_irq provides an abnomination of the edge
		handler which is solely used to tame a badly wreckaged
		irq controller on powerpc/cell.
		</para>
   	    </sect3>
	    <sect3 id="BAD_IRQ_flow_handler">
	 	<title>Bad IRQ flow handler</title>
		<para>
		handle_bad_irq is used for spurious interrupts which
		have no real handler assigned..
		</para>
   	    </sect3>
	</sect2>
	<sect2 id="Quirks_and_optimizations">
	<title>Quirks and optimizations</title>
	<para>
	The generic functions are intended for 'clean' architectures and chips,
	which have no platform-specific IRQ handling quirks. If an architecture
	needs to implement quirks on the 'flow' level then it can do so by
	overriding the high-level irq-flow handler.
	</para>
	</sect2>
	<sect2 id="Delayed_interrupt_disable">
	<title>Delayed interrupt disable</title>
	<para>
	This per interrupt selectable feature, which was introduced by Russell
	King in the ARM interrupt implementation, does not mask an interrupt
	at the hardware level when disable_irq() is called. The interrupt is
	kept enabled and is masked in the flow handler when an interrupt event
	happens. This prevents losing edge interrupts on hardware which does
	not store an edge interrupt event while the interrupt is disabled at
	the hardware level. When an interrupt arrives while the IRQ_DISABLED
	flag is set, then the interrupt is masked at the hardware level and
	the IRQ_PENDING bit is set. When the interrupt is re-enabled by
	enable_irq() the pending bit is checked and if it is set, the
	interrupt is resent either via hardware or by a software resend
	mechanism. (It's necessary to enable CONFIG_HARDIRQS_SW_RESEND when
	you want to use the delayed interrupt disable feature and your
	hardware is not capable of retriggering	an interrupt.)
	The delayed interrupt disable is not configurable.
	</para>
	</sect2>
    </sect1>
    <sect1 id="Chiplevel_hardware_encapsulation">
	<title>Chip-level hardware encapsulation</title>
	<para>
	The chip-level hardware descriptor structure irq_chip
	contains all the direct chip relevant functions, which
	can be utilized by the irq flow implementations.
	  <itemizedlist>
	  <listitem><para>irq_ack()</para></listitem>
	  <listitem><para>irq_mask_ack() - Optional, recommended for performance</para></listitem>
	  <listitem><para>irq_mask()</para></listitem>
	  <listitem><para>irq_unmask()</para></listitem>
	  <listitem><para>irq_eoi() - Optional, required for EOI flow handlers</para></listitem>
	  <listitem><para>irq_retrigger() - Optional</para></listitem>
	  <listitem><para>irq_set_type() - Optional</para></listitem>
	  <listitem><para>irq_set_wake() - Optional</para></listitem>
	  </itemizedlist>
	These primitives are strictly intended to mean what they say: ack means
	ACK, masking means masking of an IRQ line, etc. It is up to the flow
	handler(s) to use these basic units of low-level functionality.
	</para>
    </sect1>
  </chapter>

  <chapter id="doirq">
     <title>__do_IRQ entry point</title>
     <para>
	The original implementation __do_IRQ() was an alternative entry
	point for all types of interrupts. It no longer exists.
     </para>
     <para>
	This handler turned out to be not suitable for all
	interrupt hardware and was therefore reimplemented with split
	functionality for edge/level/simple/percpu interrupts. This is not
	only a functional optimization. It also shortens code paths for
	interrupts.
      </para>
  </chapter>

  <chapter id="locking">
     <title>Locking on SMP</title>
     <para>
	The locking of chip registers is up to the architecture that
	defines the chip primitives. The per-irq structure is
	protected via desc->lock, by the generic layer.
     </para>
  </chapter>

  <chapter id="genericchip">
     <title>Generic interrupt chip</title>
     <para>
       To avoid copies of identical implementations of IRQ chips the
       core provides a configurable generic interrupt chip
       implementation. Developers should check carefully whether the
       generic chip fits their needs before implementing the same
       functionality slightly differently themselves.
     </para>
<!-- kernel/irq/generic-chip.c -->
<refentry id="API-irq-gc-mask-set-bit">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>irq_gc_mask_set_bit</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>irq_gc_mask_set_bit</refname>
 <refpurpose>
  Mask chip via setting bit in mask register
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>irq_gc_mask_set_bit </function></funcdef>
   <paramdef>struct irq_data * <parameter>d</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>d</parameter></term>
   <listitem>
    <para>
     irq_data
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Chip has a single mask register. Values of this register are cached
   and protected by gc-&gt;lock
</para>
</refsect1>
</refentry>

<refentry id="API-irq-gc-mask-clr-bit">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>irq_gc_mask_clr_bit</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>irq_gc_mask_clr_bit</refname>
 <refpurpose>
     Mask chip via clearing bit in mask register
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>irq_gc_mask_clr_bit </function></funcdef>
   <paramdef>struct irq_data * <parameter>d</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>d</parameter></term>
   <listitem>
    <para>
     irq_data
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Chip has a single mask register. Values of this register are cached
   and protected by gc-&gt;lock
</para>
</refsect1>
</refentry>

<refentry id="API-irq-gc-ack-set-bit">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>irq_gc_ack_set_bit</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>irq_gc_ack_set_bit</refname>
 <refpurpose>
     Ack pending interrupt via setting bit
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>irq_gc_ack_set_bit </function></funcdef>
   <paramdef>struct irq_data * <parameter>d</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>d</parameter></term>
   <listitem>
    <para>
     irq_data
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-irq-alloc-generic-chip">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>irq_alloc_generic_chip</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>irq_alloc_generic_chip</refname>
 <refpurpose>
     Allocate a generic chip and initialize it
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct irq_chip_generic * <function>irq_alloc_generic_chip </function></funcdef>
   <paramdef>const char * <parameter>name</parameter></paramdef>
   <paramdef>int <parameter>num_ct</parameter></paramdef>
   <paramdef>unsigned int <parameter>irq_base</parameter></paramdef>
   <paramdef>void __iomem * <parameter>reg_base</parameter></paramdef>
   <paramdef>irq_flow_handler_t <parameter>handler</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>name</parameter></term>
   <listitem>
    <para>
     Name of the irq chip
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>num_ct</parameter></term>
   <listitem>
    <para>
     Number of irq_chip_type instances associated with this
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>irq_base</parameter></term>
   <listitem>
    <para>
     Interrupt base nr for this chip
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>reg_base</parameter></term>
   <listitem>
    <para>
     Register base address (virtual)
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>handler</parameter></term>
   <listitem>
    <para>
     Default flow handler associated with this chip
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Returns an initialized irq_chip_generic structure. The chip defaults
   to the primary (index 0) irq_chip_type and <parameter>handler</parameter>
</para>
</refsect1>
</refentry>

<refentry id="API-irq-alloc-domain-generic-chips">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>irq_alloc_domain_generic_chips</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>irq_alloc_domain_generic_chips</refname>
 <refpurpose>
     Allocate generic chips for an irq domain
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>irq_alloc_domain_generic_chips </function></funcdef>
   <paramdef>struct irq_domain * <parameter>d</parameter></paramdef>
   <paramdef>int <parameter>irqs_per_chip</parameter></paramdef>
   <paramdef>int <parameter>num_ct</parameter></paramdef>
   <paramdef>const char * <parameter>name</parameter></paramdef>
   <paramdef>irq_flow_handler_t <parameter>handler</parameter></paramdef>
   <paramdef>unsigned int <parameter>clr</parameter></paramdef>
   <paramdef>unsigned int <parameter>set</parameter></paramdef>
   <paramdef>enum irq_gc_flags <parameter>gcflags</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>d</parameter></term>
   <listitem>
    <para>
     irq domain for which to allocate chips
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>irqs_per_chip</parameter></term>
   <listitem>
    <para>
     Number of interrupts each chip handles
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>num_ct</parameter></term>
   <listitem>
    <para>
     Number of irq_chip_type instances associated with this
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>name</parameter></term>
   <listitem>
    <para>
     Name of the irq chip
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>handler</parameter></term>
   <listitem>
    <para>
     Default flow handler associated with these chips
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>clr</parameter></term>
   <listitem>
    <para>
     IRQ_* bits to clear in the mapping function
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>set</parameter></term>
   <listitem>
    <para>
     IRQ_* bits to set in the mapping function
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>gcflags</parameter></term>
   <listitem>
    <para>
     Generic chip specific setup flags
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-irq-get-domain-generic-chip">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>irq_get_domain_generic_chip</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>irq_get_domain_generic_chip</refname>
 <refpurpose>
     Get a pointer to the generic chip of a hw_irq
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct irq_chip_generic * <function>irq_get_domain_generic_chip </function></funcdef>
   <paramdef>struct irq_domain * <parameter>d</parameter></paramdef>
   <paramdef>unsigned int <parameter>hw_irq</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>d</parameter></term>
   <listitem>
    <para>
     irq domain pointer
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>hw_irq</parameter></term>
   <listitem>
    <para>
     Hardware interrupt number
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-irq-setup-generic-chip">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>irq_setup_generic_chip</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>irq_setup_generic_chip</refname>
 <refpurpose>
     Setup a range of interrupts with a generic chip
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>irq_setup_generic_chip </function></funcdef>
   <paramdef>struct irq_chip_generic * <parameter>gc</parameter></paramdef>
   <paramdef>u32 <parameter>msk</parameter></paramdef>
   <paramdef>enum irq_gc_flags <parameter>flags</parameter></paramdef>
   <paramdef>unsigned int <parameter>clr</parameter></paramdef>
   <paramdef>unsigned int <parameter>set</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>gc</parameter></term>
   <listitem>
    <para>
     Generic irq chip holding all data
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>msk</parameter></term>
   <listitem>
    <para>
     Bitmask holding the irqs to initialize relative to gc-&gt;irq_base
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>flags</parameter></term>
   <listitem>
    <para>
     Flags for initialization
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>clr</parameter></term>
   <listitem>
    <para>
     IRQ_* bits to clear
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>set</parameter></term>
   <listitem>
    <para>
     IRQ_* bits to set
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Set up max. 32 interrupts starting from gc-&gt;irq_base. Note, this
   initializes all interrupts to the primary irq_chip_type and its
   associated handler.
</para>
</refsect1>
</refentry>

<refentry id="API-irq-setup-alt-chip">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>irq_setup_alt_chip</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>irq_setup_alt_chip</refname>
 <refpurpose>
     Switch to alternative chip
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>irq_setup_alt_chip </function></funcdef>
   <paramdef>struct irq_data * <parameter>d</parameter></paramdef>
   <paramdef>unsigned int <parameter>type</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>d</parameter></term>
   <listitem>
    <para>
     irq_data for this interrupt
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>type</parameter></term>
   <listitem>
    <para>
     Flow type to be initialized
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Only to be called from chip-&gt;<function>irq_set_type</function> callbacks.
</para>
</refsect1>
</refentry>

<refentry id="API-irq-remove-generic-chip">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>irq_remove_generic_chip</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>irq_remove_generic_chip</refname>
 <refpurpose>
     Remove a chip
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>irq_remove_generic_chip </function></funcdef>
   <paramdef>struct irq_chip_generic * <parameter>gc</parameter></paramdef>
   <paramdef>u32 <parameter>msk</parameter></paramdef>
   <paramdef>unsigned int <parameter>clr</parameter></paramdef>
   <paramdef>unsigned int <parameter>set</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>gc</parameter></term>
   <listitem>
    <para>
     Generic irq chip holding all data
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>msk</parameter></term>
   <listitem>
    <para>
     Bitmask holding the irqs to initialize relative to gc-&gt;irq_base
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>clr</parameter></term>
   <listitem>
    <para>
     IRQ_* bits to clear
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>set</parameter></term>
   <listitem>
    <para>
     IRQ_* bits to set
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Remove up to 32 interrupts starting from gc-&gt;irq_base.
</para>
</refsect1>
</refentry>

  </chapter>

  <chapter id="structs">
     <title>Structures</title>
     <para>
     This chapter contains the autogenerated documentation of the structures which are
     used in the generic IRQ layer.
     </para>
<!-- include/linux/irq.h -->
<refentry id="API-struct-irq-data">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct irq_data</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct irq_data</refname>
 <refpurpose>
  per irq and irq chip data passed down to chip functions
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct irq_data {
  u32 mask;
  unsigned int irq;
  unsigned long hwirq;
  unsigned int node;
  unsigned int state_use_accessors;
  struct irq_chip * chip;
  struct irq_domain * domain;
  void * handler_data;
  void * chip_data;
  struct msi_desc * msi_desc;
  cpumask_var_t affinity;
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>mask</term>
      <listitem><para>
precomputed bitmask for accessing the chip registers
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>irq</term>
      <listitem><para>
interrupt number
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>hwirq</term>
      <listitem><para>
hardware interrupt number, local to the interrupt domain
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>node</term>
      <listitem><para>
node index useful for balancing
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>state_use_accessors</term>
      <listitem><para>
status information for irq chip functions.
Use accessor functions to deal with it
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>chip</term>
      <listitem><para>
low level interrupt hardware access
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>domain</term>
      <listitem><para>
Interrupt translation domain; responsible for mapping
between hwirq number and linux irq number.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>handler_data</term>
      <listitem><para>
per-IRQ data for the irq_chip methods
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>chip_data</term>
      <listitem><para>
platform-specific per-chip private data for the chip
methods, to allow shared chip implementations
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>msi_desc</term>
      <listitem><para>
MSI descriptor
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>affinity</term>
      <listitem><para>
IRQ affinity on SMP
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
<refsect1>
<title>Description</title>
<para>
   The fields here need to overlay the ones in irq_desc until we
   cleaned up the direct references and switched everything over to
   irq_data.
</para>
</refsect1>
</refentry>

<refentry id="API-struct-irq-chip">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct irq_chip</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct irq_chip</refname>
 <refpurpose>
     hardware interrupt chip descriptor
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct irq_chip {
  const char * name;
  unsigned int	(* irq_startup) (struct irq_data *data);
  void (* irq_shutdown) (struct irq_data *data);
  void (* irq_enable) (struct irq_data *data);
  void (* irq_disable) (struct irq_data *data);
  void (* irq_ack) (struct irq_data *data);
  void (* irq_mask) (struct irq_data *data);
  void (* irq_mask_ack) (struct irq_data *data);
  void (* irq_unmask) (struct irq_data *data);
  void (* irq_eoi) (struct irq_data *data);
  int (* irq_set_affinity) (struct irq_data *data, const struct cpumask *dest, bool force);
  int (* irq_retrigger) (struct irq_data *data);
  int (* irq_set_type) (struct irq_data *data, unsigned int flow_type);
  int (* irq_set_wake) (struct irq_data *data, unsigned int on);
  void (* irq_bus_lock) (struct irq_data *data);
  void (* irq_bus_sync_unlock) (struct irq_data *data);
  void (* irq_cpu_online) (struct irq_data *data);
  void (* irq_cpu_offline) (struct irq_data *data);
  void (* irq_suspend) (struct irq_data *data);
  void (* irq_resume) (struct irq_data *data);
  void (* irq_pm_shutdown) (struct irq_data *data);
  void (* irq_calc_mask) (struct irq_data *data);
  void (* irq_print_chip) (struct irq_data *data, struct seq_file *p);
  int (* irq_request_resources) (struct irq_data *data);
  void (* irq_release_resources) (struct irq_data *data);
  unsigned long flags;
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>name</term>
      <listitem><para>
   name for /proc/interrupts
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>irq_startup</term>
      <listitem><para>
   start up the interrupt (defaults to -&gt;enable if NULL)
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>irq_shutdown</term>
      <listitem><para>
   shut down the interrupt (defaults to -&gt;disable if NULL)
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>irq_enable</term>
      <listitem><para>
   enable the interrupt (defaults to chip-&gt;unmask if NULL)
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>irq_disable</term>
      <listitem><para>
   disable the interrupt
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>irq_ack</term>
      <listitem><para>
   start of a new interrupt
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>irq_mask</term>
      <listitem><para>
   mask an interrupt source
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>irq_mask_ack</term>
      <listitem><para>
   ack and mask an interrupt source
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>irq_unmask</term>
      <listitem><para>
   unmask an interrupt source
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>irq_eoi</term>
      <listitem><para>
   end of interrupt
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>irq_set_affinity</term>
      <listitem><para>
   set the CPU affinity on SMP machines
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>irq_retrigger</term>
      <listitem><para>
   resend an IRQ to the CPU
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>irq_set_type</term>
      <listitem><para>
   set the flow type (IRQ_TYPE_LEVEL/etc.) of an IRQ
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>irq_set_wake</term>
      <listitem><para>
   enable/disable power-management wake-on of an IRQ
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>irq_bus_lock</term>
      <listitem><para>
   function to lock access to slow bus (i2c) chips
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>irq_bus_sync_unlock</term>
      <listitem><para>
   function to sync and unlock slow bus (i2c) chips
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>irq_cpu_online</term>
      <listitem><para>
   configure an interrupt source for a secondary CPU
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>irq_cpu_offline</term>
      <listitem><para>
   un-configure an interrupt source for a secondary CPU
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>irq_suspend</term>
      <listitem><para>
   function called from core code on suspend once per chip
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>irq_resume</term>
      <listitem><para>
   function called from core code on resume once per chip
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>irq_pm_shutdown</term>
      <listitem><para>
   function called from core code on shutdown once per chip
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>irq_calc_mask</term>
      <listitem><para>
   Optional function to set irq_data.mask for special cases
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>irq_print_chip</term>
      <listitem><para>
   optional to print special chip info in show_interrupts
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>irq_request_resources</term>
      <listitem><para>
   optional to request resources before calling
   any other callback related to this irq
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>irq_release_resources</term>
      <listitem><para>
   optional to release resources acquired with
   irq_request_resources
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>flags</term>
      <listitem><para>
   chip specific flags
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
</refentry>

<refentry id="API-struct-irq-chip-regs">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct irq_chip_regs</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct irq_chip_regs</refname>
 <refpurpose>
     register offsets for struct irq_gci
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct irq_chip_regs {
  unsigned long enable;
  unsigned long disable;
  unsigned long mask;
  unsigned long ack;
  unsigned long eoi;
  unsigned long type;
  unsigned long polarity;
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>enable</term>
      <listitem><para>
   Enable register offset to reg_base
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>disable</term>
      <listitem><para>
   Disable register offset to reg_base
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>mask</term>
      <listitem><para>
   Mask register offset to reg_base
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>ack</term>
      <listitem><para>
   Ack register offset to reg_base
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>eoi</term>
      <listitem><para>
   Eoi register offset to reg_base
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>type</term>
      <listitem><para>
   Type configuration register offset to reg_base
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>polarity</term>
      <listitem><para>
   Polarity configuration register offset to reg_base
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
</refentry>

<refentry id="API-struct-irq-chip-type">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct irq_chip_type</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct irq_chip_type</refname>
 <refpurpose>
     Generic interrupt chip instance for a flow type
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct irq_chip_type {
  struct irq_chip chip;
  struct irq_chip_regs regs;
  irq_flow_handler_t handler;
  u32 type;
  u32 mask_cache_priv;
  u32 * mask_cache;
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>chip</term>
      <listitem><para>
   The real interrupt chip which provides the callbacks
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>regs</term>
      <listitem><para>
   Register offsets for this chip
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>handler</term>
      <listitem><para>
   Flow handler associated with this chip
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>type</term>
      <listitem><para>
   Chip can handle these flow types
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>mask_cache_priv</term>
      <listitem><para>
   Cached mask register private to the chip type
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>mask_cache</term>
      <listitem><para>
   Pointer to cached mask register
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
<refsect1>
<title>Description</title>
<para>
   A irq_generic_chip can have several instances of irq_chip_type when
   it requires different functions and register offsets for different
   flow types.
</para>
</refsect1>
</refentry>

<refentry id="API-struct-irq-chip-generic">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct irq_chip_generic</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct irq_chip_generic</refname>
 <refpurpose>
     Generic irq chip data structure
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct irq_chip_generic {
  raw_spinlock_t lock;
  void __iomem * reg_base;
  unsigned int irq_base;
  unsigned int irq_cnt;
  u32 mask_cache;
  u32 type_cache;
  u32 polarity_cache;
  u32 wake_enabled;
  u32 wake_active;
  unsigned int num_ct;
  void * private;
  unsigned long installed;
  unsigned long unused;
  struct irq_domain * domain;
  struct list_head list;
  struct irq_chip_type chip_types[0];
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>lock</term>
      <listitem><para>
   Lock to protect register and cache data access
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>reg_base</term>
      <listitem><para>
   Register base address (virtual)
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>irq_base</term>
      <listitem><para>
   Interrupt base nr for this chip
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>irq_cnt</term>
      <listitem><para>
   Number of interrupts handled by this chip
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>mask_cache</term>
      <listitem><para>
   Cached mask register shared between all chip types
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>type_cache</term>
      <listitem><para>
   Cached type register
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>polarity_cache</term>
      <listitem><para>
   Cached polarity register
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>wake_enabled</term>
      <listitem><para>
   Interrupt can wakeup from suspend
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>wake_active</term>
      <listitem><para>
   Interrupt is marked as an wakeup from suspend source
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>num_ct</term>
      <listitem><para>
   Number of available irq_chip_type instances (usually 1)
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>private</term>
      <listitem><para>
   Private data for non generic chip callbacks
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>installed</term>
      <listitem><para>
   bitfield to denote installed interrupts
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>unused</term>
      <listitem><para>
   bitfield to denote unused interrupts
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>domain</term>
      <listitem><para>
   irq domain pointer
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>list</term>
      <listitem><para>
   List head for keeping track of instances
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>chip_types[0]</term>
      <listitem><para>
   Array of interrupt irq_chip_types
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
<refsect1>
<title>Description</title>
<para>
   Note, that irq_chip_generic can have multiple irq_chip_type
   implementations which can be associated to a particular irq line of
   an irq_chip_generic instance. That allows to share and protect
   state in an irq_chip_generic instance when we need to implement
   different flow mechanisms (level/edge) for it.
</para>
</refsect1>
</refentry>

<refentry id="API-enum-irq-gc-flags">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>enum irq_gc_flags</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>enum irq_gc_flags</refname>
 <refpurpose>
     Initialization flags for generic irq chips
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
enum irq_gc_flags {
  IRQ_GC_INIT_MASK_CACHE,
  IRQ_GC_INIT_NESTED_LOCK,
  IRQ_GC_MASK_CACHE_PER_TYPE,
  IRQ_GC_NO_MASK
};  </programlisting>
</refsynopsisdiv>
<refsect1>
 <title>Constants</title>
  <variablelist>
    <varlistentry>      <term>IRQ_GC_INIT_MASK_CACHE</term>
      <listitem><para>
   Initialize the mask_cache by reading mask reg
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>IRQ_GC_INIT_NESTED_LOCK</term>
      <listitem><para>
   Set the lock class of the irqs to nested for
   irq chips which need to call <function>irq_set_wake</function> on
   the parent irq. Usually GPIO implementations
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>IRQ_GC_MASK_CACHE_PER_TYPE</term>
      <listitem><para>
   Mask cache is chip type private
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>IRQ_GC_NO_MASK</term>
      <listitem><para>
   Do not calculate irq_data-&gt;mask
      </para></listitem>
    </varlistentry>
  </variablelist>
</refsect1>
</refentry>

<!-- include/linux/interrupt.h -->
<refentry id="API-struct-irqaction">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct irqaction</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct irqaction</refname>
 <refpurpose>
  per interrupt action descriptor
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct irqaction {
  irq_handler_t handler;
  void * dev_id;
  void __percpu * percpu_dev_id;
  struct irqaction * next;
  irq_handler_t thread_fn;
  struct task_struct * thread;
  unsigned int irq;
  unsigned int flags;
  unsigned long thread_flags;
  unsigned long thread_mask;
  const char * name;
  struct proc_dir_entry * dir;
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>handler</term>
      <listitem><para>
interrupt handler function
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>dev_id</term>
      <listitem><para>
cookie to identify the device
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>percpu_dev_id</term>
      <listitem><para>
cookie to identify the device
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>next</term>
      <listitem><para>
pointer to the next irqaction for shared interrupts
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>thread_fn</term>
      <listitem><para>
interrupt handler function for threaded interrupts
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>thread</term>
      <listitem><para>
thread pointer for threaded interrupts
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>irq</term>
      <listitem><para>
interrupt number
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>flags</term>
      <listitem><para>
flags (see IRQF_* above)
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>thread_flags</term>
      <listitem><para>
flags related to <parameter>thread</parameter>
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>thread_mask</term>
      <listitem><para>
bitmask for keeping track of <parameter>thread</parameter> activity
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>name</term>
      <listitem><para>
name of the device
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>dir</term>
      <listitem><para>
pointer to the proc/irq/NN/name entry
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
</refentry>

<refentry id="API-struct-irq-affinity-notify">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct irq_affinity_notify</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct irq_affinity_notify</refname>
 <refpurpose>
     context for notification of IRQ affinity changes
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct irq_affinity_notify {
  unsigned int irq;
  struct kref kref;
  struct work_struct work;
  void (* notify) (struct irq_affinity_notify *, const cpumask_t *mask);
  void (* release) (struct kref *ref);
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>irq</term>
      <listitem><para>
   Interrupt to which notification applies
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>kref</term>
      <listitem><para>
   Reference count, for internal use
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>work</term>
      <listitem><para>
   Work item, for internal use
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>notify</term>
      <listitem><para>
   Function to be called on change.  This will be
   called in process context.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>release</term>
      <listitem><para>
   Function to be called on release.  This will be
   called in process context.  Once registered, the
   structure must only be freed when this function is
   called or later.
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
</refentry>

<refentry id="API-irq-set-affinity">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>irq_set_affinity</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>irq_set_affinity</refname>
 <refpurpose>
     Set the irq affinity of a given irq
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>irq_set_affinity </function></funcdef>
   <paramdef>unsigned int <parameter>irq</parameter></paramdef>
   <paramdef>const struct cpumask * <parameter>cpumask</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>irq</parameter></term>
   <listitem>
    <para>
     Interrupt to set affinity
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>cpumask</parameter></term>
   <listitem>
    <para>
     cpumask
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Fails if cpumask does not contain an online CPU
</para>
</refsect1>
</refentry>

<refentry id="API-irq-force-affinity">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>irq_force_affinity</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>irq_force_affinity</refname>
 <refpurpose>
     Force the irq affinity of a given irq
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>irq_force_affinity </function></funcdef>
   <paramdef>unsigned int <parameter>irq</parameter></paramdef>
   <paramdef>const struct cpumask * <parameter>cpumask</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>irq</parameter></term>
   <listitem>
    <para>
     Interrupt to set affinity
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>cpumask</parameter></term>
   <listitem>
    <para>
     cpumask
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Same as irq_set_affinity, but without checking the mask against
   online cpus.
   </para><para>

   Solely for low level cpu hotplug code, where we need to make per
   cpu interrupts affine before the cpu becomes online.
</para>
</refsect1>
</refentry>

  </chapter>

  <chapter id="pubfunctions">
     <title>Public Functions Provided</title>
     <para>
     This chapter contains the autogenerated documentation of the kernel API functions
      which are exported.
     </para>
<!-- kernel/irq/manage.c -->
<refentry id="API-synchronize-hardirq">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>synchronize_hardirq</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>synchronize_hardirq</refname>
 <refpurpose>
  wait for pending hard IRQ handlers (on other CPUs)
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>synchronize_hardirq </function></funcdef>
   <paramdef>unsigned int <parameter>irq</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>irq</parameter></term>
   <listitem>
    <para>
     interrupt number to wait for
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This function waits for any pending hard IRQ handlers for this
   interrupt to complete before returning. If you use this
   function while holding a resource the IRQ handler may need you
   will deadlock. It does not take associated threaded handlers
   into account.
   </para><para>

   Do not use this for shutdown scenarios where you must be sure
   that all parts (hardirq and threaded handler) have completed.
   </para><para>

   This function may be called - with care - from IRQ context.
</para>
</refsect1>
</refentry>

<refentry id="API-synchronize-irq">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>synchronize_irq</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>synchronize_irq</refname>
 <refpurpose>
     wait for pending IRQ handlers (on other CPUs)
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>synchronize_irq </function></funcdef>
   <paramdef>unsigned int <parameter>irq</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>irq</parameter></term>
   <listitem>
    <para>
     interrupt number to wait for
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This function waits for any pending IRQ handlers for this interrupt
   to complete before returning. If you use this function while
   holding a resource the IRQ handler may need you will deadlock.
   </para><para>

   This function may be called - with care - from IRQ context.
</para>
</refsect1>
</refentry>

<refentry id="API-irq-set-affinity-notifier">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>irq_set_affinity_notifier</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>irq_set_affinity_notifier</refname>
 <refpurpose>
     control notification of IRQ affinity changes
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>irq_set_affinity_notifier </function></funcdef>
   <paramdef>unsigned int <parameter>irq</parameter></paramdef>
   <paramdef>struct irq_affinity_notify * <parameter>notify</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>irq</parameter></term>
   <listitem>
    <para>
     Interrupt for which to enable/disable notification
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>notify</parameter></term>
   <listitem>
    <para>
     Context for notification, or <constant>NULL</constant> to disable
     notification.  Function pointers must be initialised;
     the other fields will be initialised by this function.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Must be called in process context.  Notification may only be enabled
   after the IRQ is allocated and must be disabled before the IRQ is
   freed using <function>free_irq</function>.
</para>
</refsect1>
</refentry>

<refentry id="API-disable-irq-nosync">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>disable_irq_nosync</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>disable_irq_nosync</refname>
 <refpurpose>
     disable an irq without waiting
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>disable_irq_nosync </function></funcdef>
   <paramdef>unsigned int <parameter>irq</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>irq</parameter></term>
   <listitem>
    <para>
     Interrupt to disable
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Disable the selected interrupt line.  Disables and Enables are
   nested.
   Unlike <function>disable_irq</function>, this function does not ensure existing
   instances of the IRQ handler have completed before returning.
   </para><para>

   This function may be called from IRQ context.
</para>
</refsect1>
</refentry>

<refentry id="API-disable-irq">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>disable_irq</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>disable_irq</refname>
 <refpurpose>
     disable an irq and wait for completion
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>disable_irq </function></funcdef>
   <paramdef>unsigned int <parameter>irq</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>irq</parameter></term>
   <listitem>
    <para>
     Interrupt to disable
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Disable the selected interrupt line.  Enables and Disables are
   nested.
   This function waits for any pending IRQ handlers for this interrupt
   to complete before returning. If you use this function while
   holding a resource the IRQ handler may need you will deadlock.
   </para><para>

   This function may be called - with care - from IRQ context.
</para>
</refsect1>
</refentry>

<refentry id="API-enable-irq">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>enable_irq</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>enable_irq</refname>
 <refpurpose>
     enable handling of an irq
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>enable_irq </function></funcdef>
   <paramdef>unsigned int <parameter>irq</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>irq</parameter></term>
   <listitem>
    <para>
     Interrupt to enable
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Undoes the effect of one call to <function>disable_irq</function>.  If this
   matches the last disable, processing of interrupts on this
   IRQ line is re-enabled.
   </para><para>

   This function may be called from IRQ context only when
   desc-&gt;irq_data.chip-&gt;bus_lock and desc-&gt;chip-&gt;bus_sync_unlock are NULL !
</para>
</refsect1>
</refentry>

<refentry id="API-irq-set-irq-wake">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>irq_set_irq_wake</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>irq_set_irq_wake</refname>
 <refpurpose>
     control irq power management wakeup
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>irq_set_irq_wake </function></funcdef>
   <paramdef>unsigned int <parameter>irq</parameter></paramdef>
   <paramdef>unsigned int <parameter>on</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>irq</parameter></term>
   <listitem>
    <para>
     interrupt to control
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>on</parameter></term>
   <listitem>
    <para>
     enable/disable power management wakeup
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Enable/disable power management wakeup mode, which is
   disabled by default.  Enables and disables must match,
   just as they match for non-wakeup mode support.
   </para><para>

   Wakeup mode lets this IRQ wake the system from sleep
   states like <quote>suspend to RAM</quote>.
</para>
</refsect1>
</refentry>

<refentry id="API-irq-wake-thread">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>irq_wake_thread</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>irq_wake_thread</refname>
 <refpurpose>
     wake the irq thread for the action identified by dev_id
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>irq_wake_thread </function></funcdef>
   <paramdef>unsigned int <parameter>irq</parameter></paramdef>
   <paramdef>void * <parameter>dev_id</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>irq</parameter></term>
   <listitem>
    <para>
     Interrupt line
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>dev_id</parameter></term>
   <listitem>
    <para>
     Device identity for which the thread should be woken
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-setup-irq">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>setup_irq</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>setup_irq</refname>
 <refpurpose>
     setup an interrupt
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>setup_irq </function></funcdef>
   <paramdef>unsigned int <parameter>irq</parameter></paramdef>
   <paramdef>struct irqaction * <parameter>act</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>irq</parameter></term>
   <listitem>
    <para>
     Interrupt line to setup
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>act</parameter></term>
   <listitem>
    <para>
     irqaction for the interrupt
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Used to statically setup interrupts in the early boot process.
</para>
</refsect1>
</refentry>

<refentry id="API-remove-irq">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>remove_irq</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>remove_irq</refname>
 <refpurpose>
     free an interrupt
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>remove_irq </function></funcdef>
   <paramdef>unsigned int <parameter>irq</parameter></paramdef>
   <paramdef>struct irqaction * <parameter>act</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>irq</parameter></term>
   <listitem>
    <para>
     Interrupt line to free
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>act</parameter></term>
   <listitem>
    <para>
     irqaction for the interrupt
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Used to remove interrupts statically setup by the early boot process.
</para>
</refsect1>
</refentry>

<refentry id="API-free-irq">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>free_irq</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>free_irq</refname>
 <refpurpose>
     free an interrupt allocated with request_irq
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>free_irq </function></funcdef>
   <paramdef>unsigned int <parameter>irq</parameter></paramdef>
   <paramdef>void * <parameter>dev_id</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>irq</parameter></term>
   <listitem>
    <para>
     Interrupt line to free
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>dev_id</parameter></term>
   <listitem>
    <para>
     Device identity to free
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Remove an interrupt handler. The handler is removed and if the
   interrupt line is no longer in use by any driver it is disabled.
   On a shared IRQ the caller must ensure the interrupt is disabled
   on the card it drives before calling this function. The function
   does not return until any executing interrupts for this IRQ
   have completed.
   </para><para>

   This function must not be called from interrupt context.
</para>
</refsect1>
</refentry>

<refentry id="API-request-threaded-irq">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>request_threaded_irq</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>request_threaded_irq</refname>
 <refpurpose>
     allocate an interrupt line
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>request_threaded_irq </function></funcdef>
   <paramdef>unsigned int <parameter>irq</parameter></paramdef>
   <paramdef>irq_handler_t <parameter>handler</parameter></paramdef>
   <paramdef>irq_handler_t <parameter>thread_fn</parameter></paramdef>
   <paramdef>unsigned long <parameter>irqflags</parameter></paramdef>
   <paramdef>const char * <parameter>devname</parameter></paramdef>
   <paramdef>void * <parameter>dev_id</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>irq</parameter></term>
   <listitem>
    <para>
     Interrupt line to allocate
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>handler</parameter></term>
   <listitem>
    <para>
     Function to be called when the IRQ occurs.
     Primary handler for threaded interrupts
     If NULL and thread_fn != NULL the default
     primary handler is installed
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>thread_fn</parameter></term>
   <listitem>
    <para>
     Function called from the irq handler thread
     If NULL, no irq thread is created
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>irqflags</parameter></term>
   <listitem>
    <para>
     Interrupt type flags
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>devname</parameter></term>
   <listitem>
    <para>
     An ascii name for the claiming device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>dev_id</parameter></term>
   <listitem>
    <para>
     A cookie passed back to the handler function
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This call allocates interrupt resources and enables the
   interrupt line and IRQ handling. From the point this
   call is made your handler function may be invoked. Since
   your handler function must clear any interrupt the board
   raises, you must take care both to initialise your hardware
   and to set up the interrupt handler in the right order.
   </para><para>

   If you want to set up a threaded irq handler for your device
   then you need to supply <parameter>handler</parameter> and <parameter>thread_fn</parameter>. <parameter>handler</parameter> is
   still called in hard interrupt context and has to check
   whether the interrupt originates from the device. If yes it
   needs to disable the interrupt on the device and return
   IRQ_WAKE_THREAD which will wake up the handler thread and run
   <parameter>thread_fn</parameter>. This split handler design is necessary to support
   shared interrupts.
   </para><para>

   Dev_id must be globally unique. Normally the address of the
   device data structure is used as the cookie. Since the handler
   receives this value it makes sense to use it.
   </para><para>

   If your interrupt is shared you must pass a non NULL dev_id
   as this is required when freeing the interrupt.
</para>
</refsect1>
<refsect1>
<title>Flags</title>
<para>
   </para><para>

   IRQF_SHARED		Interrupt is shared
   IRQF_TRIGGER_*		Specify active edge(s) or level
</para>
</refsect1>
</refentry>

<refentry id="API-request-any-context-irq">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>request_any_context_irq</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>request_any_context_irq</refname>
 <refpurpose>
     allocate an interrupt line
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>request_any_context_irq </function></funcdef>
   <paramdef>unsigned int <parameter>irq</parameter></paramdef>
   <paramdef>irq_handler_t <parameter>handler</parameter></paramdef>
   <paramdef>unsigned long <parameter>flags</parameter></paramdef>
   <paramdef>const char * <parameter>name</parameter></paramdef>
   <paramdef>void * <parameter>dev_id</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>irq</parameter></term>
   <listitem>
    <para>
     Interrupt line to allocate
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>handler</parameter></term>
   <listitem>
    <para>
     Function to be called when the IRQ occurs.
     Threaded handler for threaded interrupts.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>flags</parameter></term>
   <listitem>
    <para>
     Interrupt type flags
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>name</parameter></term>
   <listitem>
    <para>
     An ascii name for the claiming device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>dev_id</parameter></term>
   <listitem>
    <para>
     A cookie passed back to the handler function
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This call allocates interrupt resources and enables the
   interrupt line and IRQ handling. It selects either a
   hardirq or threaded handling method depending on the
   context.
   </para><para>

   On failure, it returns a negative value. On success,
   it returns either IRQC_IS_HARDIRQ or IRQC_IS_NESTED.
</para>
</refsect1>
</refentry>

<!-- kernel/irq/chip.c -->
<refentry id="API-irq-set-chip">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>irq_set_chip</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>irq_set_chip</refname>
 <refpurpose>
  set the irq chip for an irq
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>irq_set_chip </function></funcdef>
   <paramdef>unsigned int <parameter>irq</parameter></paramdef>
   <paramdef>struct irq_chip * <parameter>chip</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>irq</parameter></term>
   <listitem>
    <para>
     irq number
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>chip</parameter></term>
   <listitem>
    <para>
     pointer to irq chip description structure
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-irq-set-irq-type">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>irq_set_irq_type</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>irq_set_irq_type</refname>
 <refpurpose>
     set the irq trigger type for an irq
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>irq_set_irq_type </function></funcdef>
   <paramdef>unsigned int <parameter>irq</parameter></paramdef>
   <paramdef>unsigned int <parameter>type</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>irq</parameter></term>
   <listitem>
    <para>
     irq number
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>type</parameter></term>
   <listitem>
    <para>
     IRQ_TYPE_{LEVEL,EDGE}_* value - see include/linux/irq.h
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-irq-set-handler-data">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>irq_set_handler_data</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>irq_set_handler_data</refname>
 <refpurpose>
     set irq handler data for an irq
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>irq_set_handler_data </function></funcdef>
   <paramdef>unsigned int <parameter>irq</parameter></paramdef>
   <paramdef>void * <parameter>data</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>irq</parameter></term>
   <listitem>
    <para>
     Interrupt number
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>data</parameter></term>
   <listitem>
    <para>
     Pointer to interrupt specific data
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Set the hardware irq controller data for an irq
</para>
</refsect1>
</refentry>

<refentry id="API-irq-set-chip-data">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>irq_set_chip_data</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>irq_set_chip_data</refname>
 <refpurpose>
     set irq chip data for an irq
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>irq_set_chip_data </function></funcdef>
   <paramdef>unsigned int <parameter>irq</parameter></paramdef>
   <paramdef>void * <parameter>data</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>irq</parameter></term>
   <listitem>
    <para>
     Interrupt number
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>data</parameter></term>
   <listitem>
    <para>
     Pointer to chip specific data
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Set the hardware irq chip data for an irq
</para>
</refsect1>
</refentry>

<refentry id="API-handle-simple-irq">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>handle_simple_irq</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>handle_simple_irq</refname>
 <refpurpose>
     Simple and software-decoded IRQs.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>handle_simple_irq </function></funcdef>
   <paramdef>unsigned int <parameter>irq</parameter></paramdef>
   <paramdef>struct irq_desc * <parameter>desc</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>irq</parameter></term>
   <listitem>
    <para>
     the interrupt number
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>desc</parameter></term>
   <listitem>
    <para>
     the interrupt description structure for this irq
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Simple interrupts are either sent from a demultiplexing interrupt
   handler or come from hardware, where no interrupt hardware control
   is necessary.
</para>
</refsect1>
<refsect1>
<title>Note</title>
<para>
   The caller is expected to handle the ack, clear, mask and
   unmask issues if necessary.
</para>
</refsect1>
</refentry>

<refentry id="API-handle-level-irq">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>handle_level_irq</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>handle_level_irq</refname>
 <refpurpose>
     Level type irq handler
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>handle_level_irq </function></funcdef>
   <paramdef>unsigned int <parameter>irq</parameter></paramdef>
   <paramdef>struct irq_desc * <parameter>desc</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>irq</parameter></term>
   <listitem>
    <para>
     the interrupt number
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>desc</parameter></term>
   <listitem>
    <para>
     the interrupt description structure for this irq
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Level type interrupts are active as long as the hardware line has
   the active level. This may require to mask the interrupt and unmask
   it after the associated handler has acknowledged the device, so the
   interrupt line is back to inactive.
</para>
</refsect1>
</refentry>

<refentry id="API-handle-fasteoi-irq">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>handle_fasteoi_irq</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>handle_fasteoi_irq</refname>
 <refpurpose>
     irq handler for transparent controllers
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>handle_fasteoi_irq </function></funcdef>
   <paramdef>unsigned int <parameter>irq</parameter></paramdef>
   <paramdef>struct irq_desc * <parameter>desc</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>irq</parameter></term>
   <listitem>
    <para>
     the interrupt number
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>desc</parameter></term>
   <listitem>
    <para>
     the interrupt description structure for this irq
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Only a single callback will be issued to the chip</title>
<para>
   an -&gt;<function>eoi</function>
   call when the interrupt has been serviced. This enables support
   for modern forms of interrupt handlers, which handle the flow
   details in hardware, transparently.
</para>
</refsect1>
</refentry>

<refentry id="API-handle-edge-irq">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>handle_edge_irq</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>handle_edge_irq</refname>
 <refpurpose>
     edge type IRQ handler
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>handle_edge_irq </function></funcdef>
   <paramdef>unsigned int <parameter>irq</parameter></paramdef>
   <paramdef>struct irq_desc * <parameter>desc</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>irq</parameter></term>
   <listitem>
    <para>
     the interrupt number
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>desc</parameter></term>
   <listitem>
    <para>
     the interrupt description structure for this irq
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Interrupt occures on the falling and/or rising edge of a hardware
   signal. The occurrence is latched into the irq controller hardware
   and must be acked in order to be reenabled. After the ack another
   interrupt can happen on the same source even before the first one
   is handled by the associated event handler. If this happens it
   might be necessary to disable (mask) the interrupt depending on the
   controller hardware. This requires to reenable the interrupt inside
   of the loop which handles the interrupts which have arrived while
   the handler was running. If all pending interrupts are handled, the
   loop is left.
</para>
</refsect1>
</refentry>

  </chapter>

  <chapter id="intfunctions">
     <title>Internal Functions Provided</title>
     <para>
     This chapter contains the autogenerated documentation of the internal functions.
     </para>
<!-- kernel/irq/irqdesc.c -->
<refentry id="API---handle-domain-irq">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>__handle_domain_irq</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>__handle_domain_irq</refname>
 <refpurpose>
  Invoke the handler for a HW irq belonging to a domain
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>__handle_domain_irq </function></funcdef>
   <paramdef>struct irq_domain * <parameter>domain</parameter></paramdef>
   <paramdef>unsigned int <parameter>hwirq</parameter></paramdef>
   <paramdef>bool <parameter>lookup</parameter></paramdef>
   <paramdef>struct pt_regs * <parameter>regs</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>domain</parameter></term>
   <listitem>
    <para>
     The domain where to perform the lookup
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>hwirq</parameter></term>
   <listitem>
    <para>
     The HW irq number to convert to a logical one
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>lookup</parameter></term>
   <listitem>
    <para>
     Whether to perform the domain lookup or not
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>regs</parameter></term>
   <listitem>
    <para>
     Register file coming from the low-level handling code
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Returns</title>
<para>
   0 on success, or -EINVAL if conversion has failed
</para>
</refsect1>
</refentry>

<refentry id="API-irq-get-next-irq">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>irq_get_next_irq</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>irq_get_next_irq</refname>
 <refpurpose>
     get next allocated irq number
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>unsigned int <function>irq_get_next_irq </function></funcdef>
   <paramdef>unsigned int <parameter>offset</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>offset</parameter></term>
   <listitem>
    <para>
     where to start the search
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Returns next irq number after offset or nr_irqs if none is found.
</para>
</refsect1>
</refentry>

<refentry id="API-kstat-irqs-cpu">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>kstat_irqs_cpu</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>kstat_irqs_cpu</refname>
 <refpurpose>
     Get the statistics for an interrupt on a cpu
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>unsigned int <function>kstat_irqs_cpu </function></funcdef>
   <paramdef>unsigned int <parameter>irq</parameter></paramdef>
   <paramdef>int <parameter>cpu</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>irq</parameter></term>
   <listitem>
    <para>
     The interrupt number
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>cpu</parameter></term>
   <listitem>
    <para>
     The cpu number
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Returns the sum of interrupt counts on <parameter>cpu</parameter> since boot for
   <parameter>irq</parameter>. The caller must ensure that the interrupt is not removed
   concurrently.
</para>
</refsect1>
</refentry>

<refentry id="API-kstat-irqs">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>kstat_irqs</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>kstat_irqs</refname>
 <refpurpose>
     Get the statistics for an interrupt
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>unsigned int <function>kstat_irqs </function></funcdef>
   <paramdef>unsigned int <parameter>irq</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>irq</parameter></term>
   <listitem>
    <para>
     The interrupt number
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Returns the sum of interrupt counts on all cpus since boot for
   <parameter>irq</parameter>. The caller must ensure that the interrupt is not removed
   concurrently.
</para>
</refsect1>
</refentry>

<refentry id="API-kstat-irqs-usr">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>kstat_irqs_usr</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>kstat_irqs_usr</refname>
 <refpurpose>
     Get the statistics for an interrupt
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>unsigned int <function>kstat_irqs_usr </function></funcdef>
   <paramdef>unsigned int <parameter>irq</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>irq</parameter></term>
   <listitem>
    <para>
     The interrupt number
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Returns the sum of interrupt counts on all cpus since boot for
   <parameter>irq</parameter>. Contrary to <function>kstat_irqs</function> this can be called from any
   preemptible context. It's protected against concurrent removal of
   an interrupt descriptor when sparse irqs are enabled.
</para>
</refsect1>
</refentry>

<!-- kernel/irq/handle.c -->
<refentry id="API-handle-bad-irq">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>handle_bad_irq</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>handle_bad_irq</refname>
 <refpurpose>
  handle spurious and unhandled irqs
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>handle_bad_irq </function></funcdef>
   <paramdef>unsigned int <parameter>irq</parameter></paramdef>
   <paramdef>struct irq_desc * <parameter>desc</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>irq</parameter></term>
   <listitem>
    <para>
     the interrupt number
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>desc</parameter></term>
   <listitem>
    <para>
     description of the interrupt
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Handles spurious and unhandled IRQ's. It also prints a debugmessage.
</para>
</refsect1>
</refentry>

<!-- kernel/irq/chip.c -->
<refentry id="API-irq-set-msi-desc-off">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>irq_set_msi_desc_off</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>irq_set_msi_desc_off</refname>
 <refpurpose>
  set MSI descriptor data for an irq at offset
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>irq_set_msi_desc_off </function></funcdef>
   <paramdef>unsigned int <parameter>irq_base</parameter></paramdef>
   <paramdef>unsigned int <parameter>irq_offset</parameter></paramdef>
   <paramdef>struct msi_desc * <parameter>entry</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>irq_base</parameter></term>
   <listitem>
    <para>
     Interrupt number base
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>irq_offset</parameter></term>
   <listitem>
    <para>
     Interrupt number offset
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>entry</parameter></term>
   <listitem>
    <para>
     Pointer to MSI descriptor data
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Set the MSI descriptor entry for an irq at offset
</para>
</refsect1>
</refentry>

<refentry id="API-irq-set-msi-desc">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>irq_set_msi_desc</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>irq_set_msi_desc</refname>
 <refpurpose>
     set MSI descriptor data for an irq
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>irq_set_msi_desc </function></funcdef>
   <paramdef>unsigned int <parameter>irq</parameter></paramdef>
   <paramdef>struct msi_desc * <parameter>entry</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>irq</parameter></term>
   <listitem>
    <para>
     Interrupt number
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>entry</parameter></term>
   <listitem>
    <para>
     Pointer to MSI descriptor data
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Set the MSI descriptor entry for an irq
</para>
</refsect1>
</refentry>

<refentry id="API-irq-disable">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>irq_disable</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>irq_disable</refname>
 <refpurpose>
     Mark interrupt disabled
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>irq_disable </function></funcdef>
   <paramdef>struct irq_desc * <parameter>desc</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>desc</parameter></term>
   <listitem>
    <para>
     irq descriptor which should be disabled
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   If the chip does not implement the irq_disable callback, we
   use a lazy disable approach. That means we mark the interrupt
   disabled, but leave the hardware unmasked. That's an
   optimization because we avoid the hardware access for the
   common case where no interrupt happens after we marked it
   disabled. If an interrupt happens, then the interrupt flow
   handler masks the line at the hardware level and marks it
   pending.
</para>
</refsect1>
</refentry>

<refentry id="API-handle-edge-eoi-irq">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>handle_edge_eoi_irq</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>handle_edge_eoi_irq</refname>
 <refpurpose>
     edge eoi type IRQ handler
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>handle_edge_eoi_irq </function></funcdef>
   <paramdef>unsigned int <parameter>irq</parameter></paramdef>
   <paramdef>struct irq_desc * <parameter>desc</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>irq</parameter></term>
   <listitem>
    <para>
     the interrupt number
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>desc</parameter></term>
   <listitem>
    <para>
     the interrupt description structure for this irq
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Similar as the above handle_edge_irq, but using eoi and w/o the
   mask/unmask logic.
</para>
</refsect1>
</refentry>

<refentry id="API-handle-percpu-irq">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>handle_percpu_irq</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>handle_percpu_irq</refname>
 <refpurpose>
     Per CPU local irq handler
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>handle_percpu_irq </function></funcdef>
   <paramdef>unsigned int <parameter>irq</parameter></paramdef>
   <paramdef>struct irq_desc * <parameter>desc</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>irq</parameter></term>
   <listitem>
    <para>
     the interrupt number
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>desc</parameter></term>
   <listitem>
    <para>
     the interrupt description structure for this irq
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Per CPU interrupts on SMP machines without locking requirements
</para>
</refsect1>
</refentry>

<refentry id="API-handle-percpu-devid-irq">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>handle_percpu_devid_irq</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>handle_percpu_devid_irq</refname>
 <refpurpose>
     Per CPU local irq handler with per cpu dev ids
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>handle_percpu_devid_irq </function></funcdef>
   <paramdef>unsigned int <parameter>irq</parameter></paramdef>
   <paramdef>struct irq_desc * <parameter>desc</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>irq</parameter></term>
   <listitem>
    <para>
     the interrupt number
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>desc</parameter></term>
   <listitem>
    <para>
     the interrupt description structure for this irq
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Per CPU interrupts on SMP machines without locking requirements. Same as
   <function>handle_percpu_irq</function> above but with the following extras:
   </para><para>

   action-&gt;percpu_dev_id is a pointer to percpu variables which
   contain the real device id for the cpu on which this handler is
   called
</para>
</refsect1>
</refentry>

<refentry id="API-irq-cpu-online">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>irq_cpu_online</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>irq_cpu_online</refname>
 <refpurpose>
     Invoke all irq_cpu_online functions.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>irq_cpu_online </function></funcdef>
   <paramdef> <parameter>void</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>void</parameter></term>
   <listitem>
    <para>
     no arguments
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   </para><para>

   Iterate through all irqs and invoke the chip.<function>irq_cpu_online</function>
   for each.
</para>
</refsect1>
</refentry>

<refentry id="API-irq-cpu-offline">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>irq_cpu_offline</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>irq_cpu_offline</refname>
 <refpurpose>
     Invoke all irq_cpu_offline functions.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>irq_cpu_offline </function></funcdef>
   <paramdef> <parameter>void</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>void</parameter></term>
   <listitem>
    <para>
     no arguments
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   </para><para>

   Iterate through all irqs and invoke the chip.<function>irq_cpu_offline</function>
   for each.
</para>
</refsect1>
</refentry>

  </chapter>

  <chapter id="credits">
     <title>Credits</title>
	<para>
		The following people have contributed to this document:
		<orderedlist>
			<listitem><para>Thomas Gleixner<email>tglx@linutronix.de</email></para></listitem>
			<listitem><para>Ingo Molnar<email>mingo@elte.hu</email></para></listitem>
		</orderedlist>
	</para>
  </chapter>
</book>
