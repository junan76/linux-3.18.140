<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN"
	"http://www.oasis-open.org/docbook/xml/4.1.2/docbookx.dtd" []>

<book id="scsimid">
  <bookinfo>
    <title>SCSI Interfaces Guide</title>

    <authorgroup>
      <author>
        <firstname>James</firstname>
        <surname>Bottomley</surname>
        <affiliation>
          <address>
            <email>James.Bottomley@hansenpartnership.com</email>
          </address>
        </affiliation>
      </author>

      <author>
        <firstname>Rob</firstname>
        <surname>Landley</surname>
        <affiliation>
          <address>
            <email>rob@landley.net</email>
          </address>
        </affiliation>
      </author>

    </authorgroup>

    <copyright>
      <year>2007</year>
      <holder>Linux Foundation</holder>
    </copyright>

    <legalnotice>
      <para>
        This documentation is free software; you can redistribute
        it and/or modify it under the terms of the GNU General Public
        License version 2.
      </para>

      <para>
        This program is distributed in the hope that it will be
        useful, but WITHOUT ANY WARRANTY; without even the implied
        warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
        For more details see the file COPYING in the source
        distribution of Linux.
      </para>
    </legalnotice>
  </bookinfo>

  <toc></toc>

  <chapter id="intro">
    <title>Introduction</title>
    <sect1 id="protocol_vs_bus">
      <title>Protocol vs bus</title>
      <para>
        Once upon a time, the Small Computer Systems Interface defined both
        a parallel I/O bus and a data protocol to connect a wide variety of
        peripherals (disk drives, tape drives, modems, printers, scanners,
        optical drives, test equipment, and medical devices) to a host
        computer.
      </para>
      <para>
        Although the old parallel (fast/wide/ultra) SCSI bus has largely
        fallen out of use, the SCSI command set is more widely used than ever
        to communicate with devices over a number of different busses.
      </para>
      <para>
        The <ulink url='http://www.t10.org/scsi-3.htm'>SCSI protocol</ulink>
        is a big-endian peer-to-peer packet based protocol.  SCSI commands
        are 6, 10, 12, or 16 bytes long, often followed by an associated data
        payload.
      </para>
      <para>
        SCSI commands can be transported over just about any kind of bus, and
        are the default protocol for storage devices attached to USB, SATA,
        SAS, Fibre Channel, FireWire, and ATAPI devices.  SCSI packets are
        also commonly exchanged over Infiniband,
        <ulink url='http://i2o.shadowconnect.com/faq.php'>I20</ulink>, TCP/IP
        (<ulink url='http://en.wikipedia.org/wiki/ISCSI'>iSCSI</ulink>), even
        <ulink url='http://cyberelk.net/tim/parport/parscsi.html'>Parallel
        ports</ulink>.
      </para>
    </sect1>
    <sect1 id="subsystem_design">
      <title>Design of the Linux SCSI subsystem</title>
      <para>
        The SCSI subsystem uses a three layer design, with upper, mid, and low
        layers.  Every operation involving the SCSI subsystem (such as reading
        a sector from a disk) uses one driver at each of the 3 levels: one
        upper layer driver, one lower layer driver, and the SCSI midlayer.
      </para>
      <para>
        The SCSI upper layer provides the interface between userspace and the
        kernel, in the form of block and char device nodes for I/O and
        ioctl().  The SCSI lower layer contains drivers for specific hardware
        devices.
      </para>
      <para>
        In between is the SCSI mid-layer, analogous to a network routing
        layer such as the IPv4 stack.  The SCSI mid-layer routes a packet
        based data protocol between the upper layer's /dev nodes and the
        corresponding devices in the lower layer.  It manages command queues,
        provides error handling and power management functions, and responds
        to ioctl() requests.
      </para>
    </sect1>
  </chapter>

  <chapter id="upper_layer">
    <title>SCSI upper layer</title>
    <para>
      The upper layer supports the user-kernel interface by providing
      device nodes.
    </para>
    <sect1 id="sd">
      <title>sd (SCSI Disk)</title>
      <para>sd (sd_mod.o)</para>
<!-- !Idrivers/scsi/sd.c -->
    </sect1>
    <sect1 id="sr">
      <title>sr (SCSI CD-ROM)</title>
      <para>sr (sr_mod.o)</para>
    </sect1>
    <sect1 id="st">
      <title>st (SCSI Tape)</title>
      <para>st (st.o)</para>
    </sect1>
    <sect1 id="sg">
      <title>sg (SCSI Generic)</title>
      <para>sg (sg.o)</para>
    </sect1>
    <sect1 id="ch">
      <title>ch (SCSI Media Changer)</title>
      <para>ch (ch.c)</para>
    </sect1>
  </chapter>

  <chapter id="mid_layer">
    <title>SCSI mid layer</title>

    <sect1 id="midlayer_implementation">
      <title>SCSI midlayer implementation</title>
      <sect2 id="scsi_device.h">
        <title>include/scsi/scsi_device.h</title>
        <para>
        </para>
<!-- include/scsi/scsi_device.h -->
<refentry id="API-shost-for-each-device">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>shost_for_each_device</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>shost_for_each_device</refname>
 <refpurpose>
  iterate over all devices of a host
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef> <function>shost_for_each_device </function></funcdef>
   <paramdef> <parameter>sdev</parameter></paramdef>
   <paramdef> <parameter>shost</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>sdev</parameter></term>
   <listitem>
    <para>
     the <structname>struct scsi_device</structname> to use as a cursor
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>shost</parameter></term>
   <listitem>
    <para>
     the <structname>struct scsi_host</structname> to iterate over
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Iterator that returns each device attached to <parameter>shost</parameter>.  This loop
   takes a reference on each device and releases it at the end.  If
   you break out of the loop, you must call scsi_device_put(sdev).
</para>
</refsect1>
</refentry>

<refentry id="API---shost-for-each-device">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>__shost_for_each_device</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>__shost_for_each_device</refname>
 <refpurpose>
     iterate over all devices of a host (UNLOCKED)
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef> <function>__shost_for_each_device </function></funcdef>
   <paramdef> <parameter>sdev</parameter></paramdef>
   <paramdef> <parameter>shost</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>sdev</parameter></term>
   <listitem>
    <para>
     the <structname>struct scsi_device</structname> to use as a cursor
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>shost</parameter></term>
   <listitem>
    <para>
     the <structname>struct scsi_host</structname> to iterate over
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Iterator that returns each device attached to <parameter>shost</parameter>.  It does _not_
   take a reference on the scsi_device, so the whole loop must be
   protected by shost-&gt;host_lock.
</para>
</refsect1>
<refsect1>
<title>Note</title>
<para>
   The only reason to use this is because you need to access the
   device list in interrupt context.  Otherwise you really want to use
   shost_for_each_device instead.
</para>
</refsect1>
</refentry>

      </sect2>

      <sect2 id="scsi.c">
        <title>drivers/scsi/scsi.c</title>
        <para>Main file for the SCSI midlayer.</para>
<!-- drivers/scsi/scsi.c -->
<refentry id="API-scsi-device-type">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>scsi_device_type</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>scsi_device_type</refname>
 <refpurpose>
  Return 17 char string indicating device type.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>const char * <function>scsi_device_type </function></funcdef>
   <paramdef>unsigned <parameter>type</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>type</parameter></term>
   <listitem>
    <para>
     type number to look up
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-scsi-cmd-get-serial">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>scsi_cmd_get_serial</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>scsi_cmd_get_serial</refname>
 <refpurpose>
     Assign a serial number to a command
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>scsi_cmd_get_serial </function></funcdef>
   <paramdef>struct Scsi_Host * <parameter>host</parameter></paramdef>
   <paramdef>struct scsi_cmnd * <parameter>cmd</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>host</parameter></term>
   <listitem>
    <para>
     the scsi host
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>cmd</parameter></term>
   <listitem>
    <para>
     command to assign serial number to
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   a serial number identifies a request for error recovery
   and debugging purposes.  Protected by the Host_Lock of host.
</para>
</refsect1>
</refentry>

<refentry id="API-scsi-adjust-queue-depth">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>scsi_adjust_queue_depth</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>scsi_adjust_queue_depth</refname>
 <refpurpose>
     Let low level drivers change a device's queue depth
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>scsi_adjust_queue_depth </function></funcdef>
   <paramdef>struct scsi_device * <parameter>sdev</parameter></paramdef>
   <paramdef>int <parameter>tagged</parameter></paramdef>
   <paramdef>int <parameter>tags</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>sdev</parameter></term>
   <listitem>
    <para>
     SCSI Device in question
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>tagged</parameter></term>
   <listitem>
    <para>
     Do we use tagged queueing (non-0) or do we treat
     this device as an untagged device (0)
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>tags</parameter></term>
   <listitem>
    <para>
     Number of tags allowed if tagged queueing enabled,
     or number of commands the low level driver can
     queue up in non-tagged mode (as per cmd_per_lun).
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Returns</title>
<para>
   Nothing
</para>
</refsect1>
<refsect1>
<title>Lock Status</title>
<para>
   None held on entry
</para>
</refsect1>
<refsect1>
<title>Notes</title>
<para>
   Low level drivers may call this at any time and we will do
   the right thing depending on whether or not the device is
   currently active and whether or not it even has the
   command blocks built yet.
</para>
</refsect1>
</refentry>

<refentry id="API-scsi-track-queue-full">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>scsi_track_queue_full</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>scsi_track_queue_full</refname>
 <refpurpose>
     track QUEUE_FULL events to adjust queue depth
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>scsi_track_queue_full </function></funcdef>
   <paramdef>struct scsi_device * <parameter>sdev</parameter></paramdef>
   <paramdef>int <parameter>depth</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>sdev</parameter></term>
   <listitem>
    <para>
     SCSI Device in question
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>depth</parameter></term>
   <listitem>
    <para>
     Current number of outstanding SCSI commands on this device,
     not counting the one returned as QUEUE_FULL.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This function will track successive QUEUE_FULL events on a
   specific SCSI device to determine if and when there is a
   need to adjust the queue depth on the device.
</para>
</refsect1>
<refsect1>
<title>Returns</title>
<para>
   0 - No change needed, &gt;0 - Adjust queue depth to this new depth,
   -1 - Drop back to untagged operation using host-&gt;cmd_per_lun
   as the untagged command depth
</para>
</refsect1>
<refsect1>
<title>Lock Status</title>
<para>
   None held on entry
</para>
</refsect1>
<refsect1>
<title>Notes</title>
<para>
   Low level drivers may call this at any time and we will do
   <quote>The Right Thing.</quote>  We are interrupt context safe.
</para>
</refsect1>
</refentry>

<refentry id="API-scsi-get-vpd-page">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>scsi_get_vpd_page</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>scsi_get_vpd_page</refname>
 <refpurpose>
     Get Vital Product Data from a SCSI device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>scsi_get_vpd_page </function></funcdef>
   <paramdef>struct scsi_device * <parameter>sdev</parameter></paramdef>
   <paramdef>u8 <parameter>page</parameter></paramdef>
   <paramdef>unsigned char * <parameter>buf</parameter></paramdef>
   <paramdef>int <parameter>buf_len</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>sdev</parameter></term>
   <listitem>
    <para>
     The device to ask
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>page</parameter></term>
   <listitem>
    <para>
     Which Vital Product Data to return
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>buf</parameter></term>
   <listitem>
    <para>
     where to store the VPD
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>buf_len</parameter></term>
   <listitem>
    <para>
     number of bytes in the VPD buffer area
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   SCSI devices may optionally supply Vital Product Data.  Each 'page'
   of VPD is defined in the appropriate SCSI document (eg SPC, SBC).
   If the device supports this VPD page, this routine returns a pointer
   to a buffer containing the data from that page.  The caller is
   responsible for calling <function>kfree</function> on this pointer when it is no longer
   needed.  If we cannot retrieve the VPD page this routine returns <constant>NULL</constant>.
</para>
</refsect1>
</refentry>

<refentry id="API-scsi-report-opcode">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>scsi_report_opcode</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>scsi_report_opcode</refname>
 <refpurpose>
     Find out if a given command opcode is supported
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>scsi_report_opcode </function></funcdef>
   <paramdef>struct scsi_device * <parameter>sdev</parameter></paramdef>
   <paramdef>unsigned char * <parameter>buffer</parameter></paramdef>
   <paramdef>unsigned int <parameter>len</parameter></paramdef>
   <paramdef>unsigned char <parameter>opcode</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>sdev</parameter></term>
   <listitem>
    <para>
     scsi device to query
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>buffer</parameter></term>
   <listitem>
    <para>
     scratch buffer (must be at least 20 bytes long)
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>len</parameter></term>
   <listitem>
    <para>
     length of buffer
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>opcode</parameter></term>
   <listitem>
    <para>
     opcode for command to look up
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Uses the REPORT SUPPORTED OPERATION CODES to look up the given
   opcode. Returns -EINVAL if RSOC fails, 0 if the command opcode is
   unsupported and 1 if the device claims to support the command.
</para>
</refsect1>
</refentry>

<refentry id="API-scsi-device-get">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>scsi_device_get</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>scsi_device_get</refname>
 <refpurpose>
     get an additional reference to a scsi_device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>scsi_device_get </function></funcdef>
   <paramdef>struct scsi_device * <parameter>sdev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>sdev</parameter></term>
   <listitem>
    <para>
     device to get a reference to
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Gets a reference to the scsi_device and increments the use count
   of the underlying LLDD module.  You must hold host_lock of the
   parent Scsi_Host or already have a reference when calling this.
</para>
</refsect1>
</refentry>

<refentry id="API-scsi-device-put">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>scsi_device_put</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>scsi_device_put</refname>
 <refpurpose>
     release a reference to a scsi_device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>scsi_device_put </function></funcdef>
   <paramdef>struct scsi_device * <parameter>sdev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>sdev</parameter></term>
   <listitem>
    <para>
     device to release a reference on.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Release a reference to the scsi_device and decrements the use
   count of the underlying LLDD module.  The device is freed once the last
   user vanishes.
</para>
</refsect1>
</refentry>

<refentry id="API-starget-for-each-device">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>starget_for_each_device</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>starget_for_each_device</refname>
 <refpurpose>
     helper to walk all devices of a target
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>starget_for_each_device </function></funcdef>
   <paramdef>struct scsi_target * <parameter>starget</parameter></paramdef>
   <paramdef>void * <parameter>data</parameter></paramdef>
   <paramdef>void (*<parameter>fn</parameter>)
     <funcparams>struct scsi_device *, void *</funcparams></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>starget</parameter></term>
   <listitem>
    <para>
     target whose devices we want to iterate over.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>data</parameter></term>
   <listitem>
    <para>
     Opaque passed to each function call.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>fn</parameter></term>
   <listitem>
    <para>
     Function to call on each device
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This traverses over each device of <parameter>starget</parameter>.  The devices have
   a reference that must be released by scsi_host_put when breaking
   out of the loop.
</para>
</refsect1>
</refentry>

<refentry id="API---starget-for-each-device">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>__starget_for_each_device</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>__starget_for_each_device</refname>
 <refpurpose>
     helper to walk all devices of a target (UNLOCKED)
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>__starget_for_each_device </function></funcdef>
   <paramdef>struct scsi_target * <parameter>starget</parameter></paramdef>
   <paramdef>void * <parameter>data</parameter></paramdef>
   <paramdef>void (*<parameter>fn</parameter>)
     <funcparams>struct scsi_device *, void *</funcparams></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>starget</parameter></term>
   <listitem>
    <para>
     target whose devices we want to iterate over.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>data</parameter></term>
   <listitem>
    <para>
     parameter for callback @<function>fn</function>
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>fn</parameter></term>
   <listitem>
    <para>
     callback function that is invoked for each device
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This traverses over each device of <parameter>starget</parameter>.  It does _not_
   take a reference on the scsi_device, so the whole loop must be
   protected by shost-&gt;host_lock.
</para>
</refsect1>
<refsect1>
<title>Note</title>
<para>
   The only reason why drivers would want to use this is because
   they need to access the device list in irq context.  Otherwise you
   really want to use starget_for_each_device instead.
</para>
</refsect1>
</refentry>

<refentry id="API---scsi-device-lookup-by-target">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>__scsi_device_lookup_by_target</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>__scsi_device_lookup_by_target</refname>
 <refpurpose>
     find a device given the target (UNLOCKED)
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct scsi_device * <function>__scsi_device_lookup_by_target </function></funcdef>
   <paramdef>struct scsi_target * <parameter>starget</parameter></paramdef>
   <paramdef>u64 <parameter>lun</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>starget</parameter></term>
   <listitem>
    <para>
     SCSI target pointer
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>lun</parameter></term>
   <listitem>
    <para>
     SCSI Logical Unit Number
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Looks up the scsi_device with the specified <parameter>lun</parameter> for a given
   <parameter>starget</parameter>.  The returned scsi_device does not have an additional
   reference.  You must hold the host's host_lock over this call and
   any access to the returned scsi_device. A scsi_device in state
   SDEV_DEL is skipped.
</para>
</refsect1>
<refsect1>
<title>Note</title>
<para>
   The only reason why drivers should use this is because
   they need to access the device list in irq context.  Otherwise you
   really want to use scsi_device_lookup_by_target instead.
</para>
</refsect1>
</refentry>

<refentry id="API-scsi-device-lookup-by-target">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>scsi_device_lookup_by_target</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>scsi_device_lookup_by_target</refname>
 <refpurpose>
     find a device given the target
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct scsi_device * <function>scsi_device_lookup_by_target </function></funcdef>
   <paramdef>struct scsi_target * <parameter>starget</parameter></paramdef>
   <paramdef>u64 <parameter>lun</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>starget</parameter></term>
   <listitem>
    <para>
     SCSI target pointer
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>lun</parameter></term>
   <listitem>
    <para>
     SCSI Logical Unit Number
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Looks up the scsi_device with the specified <parameter>lun</parameter> for a given
   <parameter>starget</parameter>.  The returned scsi_device has an additional reference that
   needs to be released with scsi_device_put once you're done with it.
</para>
</refsect1>
</refentry>

<refentry id="API---scsi-device-lookup">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>__scsi_device_lookup</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>__scsi_device_lookup</refname>
 <refpurpose>
     find a device given the host (UNLOCKED)
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct scsi_device * <function>__scsi_device_lookup </function></funcdef>
   <paramdef>struct Scsi_Host * <parameter>shost</parameter></paramdef>
   <paramdef>uint <parameter>channel</parameter></paramdef>
   <paramdef>uint <parameter>id</parameter></paramdef>
   <paramdef>u64 <parameter>lun</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>shost</parameter></term>
   <listitem>
    <para>
     SCSI host pointer
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>channel</parameter></term>
   <listitem>
    <para>
     SCSI channel (zero if only one channel)
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>id</parameter></term>
   <listitem>
    <para>
     SCSI target number (physical unit number)
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>lun</parameter></term>
   <listitem>
    <para>
     SCSI Logical Unit Number
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Looks up the scsi_device with the specified <parameter>channel</parameter>, <parameter>id</parameter>, <parameter>lun</parameter>
   for a given host. The returned scsi_device does not have an additional
   reference.  You must hold the host's host_lock over this call and any access
   to the returned scsi_device.
</para>
</refsect1>
<refsect1>
<title>Note</title>
<para>
   The only reason why drivers would want to use this is because
   they need to access the device list in irq context.  Otherwise you
   really want to use scsi_device_lookup instead.
</para>
</refsect1>
</refentry>

<refentry id="API-scsi-device-lookup">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>scsi_device_lookup</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>scsi_device_lookup</refname>
 <refpurpose>
     find a device given the host
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct scsi_device * <function>scsi_device_lookup </function></funcdef>
   <paramdef>struct Scsi_Host * <parameter>shost</parameter></paramdef>
   <paramdef>uint <parameter>channel</parameter></paramdef>
   <paramdef>uint <parameter>id</parameter></paramdef>
   <paramdef>u64 <parameter>lun</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>shost</parameter></term>
   <listitem>
    <para>
     SCSI host pointer
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>channel</parameter></term>
   <listitem>
    <para>
     SCSI channel (zero if only one channel)
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>id</parameter></term>
   <listitem>
    <para>
     SCSI target number (physical unit number)
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>lun</parameter></term>
   <listitem>
    <para>
     SCSI Logical Unit Number
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Looks up the scsi_device with the specified <parameter>channel</parameter>, <parameter>id</parameter>, <parameter>lun</parameter>
   for a given host.  The returned scsi_device has an additional reference that
   needs to be released with scsi_device_put once you're done with it.
</para>
</refsect1>
</refentry>

      </sect2>
      <sect2 id="scsicam.c">
        <title>drivers/scsi/scsicam.c</title>
        <para>
          <ulink url='http://www.t10.org/ftp/t10/drafts/cam/cam-r12b.pdf'>SCSI
          Common Access Method</ulink> support functions, for use with
          HDIO_GETGEO, etc.
        </para>
<!-- drivers/scsi/scsicam.c -->
<refentry id="API-scsi-bios-ptable">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>scsi_bios_ptable</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>scsi_bios_ptable</refname>
 <refpurpose>
  Read PC partition table out of first sector of device.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>unsigned char * <function>scsi_bios_ptable </function></funcdef>
   <paramdef>struct block_device * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     from this device
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Reads the first sector from the device and returns <constant>0x42</constant> bytes
   starting at offset <constant>0x1be</constant>.
</para>
</refsect1>
<refsect1>
<title>Returns</title>
<para>
   partition table in kmalloc(GFP_KERNEL) memory, or NULL on error.
</para>
</refsect1>
</refentry>

<refentry id="API-scsicam-bios-param">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>scsicam_bios_param</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>scsicam_bios_param</refname>
 <refpurpose>
     Determine geometry of a disk in cylinders/heads/sectors.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>scsicam_bios_param </function></funcdef>
   <paramdef>struct block_device * <parameter>bdev</parameter></paramdef>
   <paramdef>sector_t <parameter>capacity</parameter></paramdef>
   <paramdef>int * <parameter>ip</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>bdev</parameter></term>
   <listitem>
    <para>
     which device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>capacity</parameter></term>
   <listitem>
    <para>
     size of the disk in sectors
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>ip</parameter></term>
   <listitem>
    <para>
     return value: ip[0]=heads, ip[1]=sectors, ip[2]=cylinders
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description </title>
<para>
   determine the BIOS mapping/geometry used for a drive in a
   SCSI-CAM system, storing the results in ip as required
   by the HDIO_GETGEO <function>ioctl</function>.
</para>
</refsect1>
<refsect1>
<title>Returns </title>
<para>
   -1 on failure, 0 on success.
</para>
</refsect1>
</refentry>

<refentry id="API-scsi-partsize">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>scsi_partsize</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>scsi_partsize</refname>
 <refpurpose>
     Parse cylinders/heads/sectors from PC partition table
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>scsi_partsize </function></funcdef>
   <paramdef>unsigned char * <parameter>buf</parameter></paramdef>
   <paramdef>unsigned long <parameter>capacity</parameter></paramdef>
   <paramdef>unsigned int * <parameter>cyls</parameter></paramdef>
   <paramdef>unsigned int * <parameter>hds</parameter></paramdef>
   <paramdef>unsigned int * <parameter>secs</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>buf</parameter></term>
   <listitem>
    <para>
     partition table, see <function>scsi_bios_ptable</function>
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>capacity</parameter></term>
   <listitem>
    <para>
     size of the disk in sectors
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>cyls</parameter></term>
   <listitem>
    <para>
     put cylinders here
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>hds</parameter></term>
   <listitem>
    <para>
     put heads here
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>secs</parameter></term>
   <listitem>
    <para>
     put sectors here
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   determine the BIOS mapping/geometry used to create the partition
   table, storing the results in *cyls, *hds, and *secs 
</para>
</refsect1>
<refsect1>
<title>Returns</title>
<para>
   -1 on failure, 0 on success.
</para>
</refsect1>
</refentry>

      </sect2>
      <sect2 id="scsi_error.c">
        <title>drivers/scsi/scsi_error.c</title>
        <para>Common SCSI error/timeout handling routines.</para>
<!-- drivers/scsi/scsi_error.c -->
<refentry id="API-scsi-schedule-eh">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>scsi_schedule_eh</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>scsi_schedule_eh</refname>
 <refpurpose>
  schedule EH for SCSI host
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>scsi_schedule_eh </function></funcdef>
   <paramdef>struct Scsi_Host * <parameter>shost</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>shost</parameter></term>
   <listitem>
    <para>
     SCSI host to invoke error handling on.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Schedule SCSI EH without scmd.
</para>
</refsect1>
</refentry>

<refentry id="API-scsi-block-when-processing-errors">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>scsi_block_when_processing_errors</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>scsi_block_when_processing_errors</refname>
 <refpurpose>
     Prevent cmds from being queued.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>scsi_block_when_processing_errors </function></funcdef>
   <paramdef>struct scsi_device * <parameter>sdev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>sdev</parameter></term>
   <listitem>
    <para>
     Device on which we are performing recovery.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   We block until the host is out of error recovery, and then check to
   see whether the host or the device is offline.
</para>
</refsect1>
<refsect1>
<title>Return value</title>
<para>
   0 when dev was taken offline by error recovery. 1 OK to proceed.
</para>
</refsect1>
</refentry>

<refentry id="API-scsi-eh-prep-cmnd">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>scsi_eh_prep_cmnd</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>scsi_eh_prep_cmnd</refname>
 <refpurpose>
     Save a scsi command info as part of error recovery
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>scsi_eh_prep_cmnd </function></funcdef>
   <paramdef>struct scsi_cmnd * <parameter>scmd</parameter></paramdef>
   <paramdef>struct scsi_eh_save * <parameter>ses</parameter></paramdef>
   <paramdef>unsigned char * <parameter>cmnd</parameter></paramdef>
   <paramdef>int <parameter>cmnd_size</parameter></paramdef>
   <paramdef>unsigned <parameter>sense_bytes</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>scmd</parameter></term>
   <listitem>
    <para>
     SCSI command structure to hijack
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>ses</parameter></term>
   <listitem>
    <para>
     structure to save restore information
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>cmnd</parameter></term>
   <listitem>
    <para>
     CDB to send. Can be NULL if no new cmnd is needed
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>cmnd_size</parameter></term>
   <listitem>
    <para>
     size in bytes of <parameter>cmnd</parameter> (must be &lt;= BLK_MAX_CDB)
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>sense_bytes</parameter></term>
   <listitem>
    <para>
     size of sense data to copy. or 0 (if != 0 <parameter>cmnd</parameter> is ignored)
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This function is used to save a scsi command information before re-execution
   as part of the error recovery process.  If <parameter>sense_bytes</parameter> is 0 the command
   sent must be one that does not transfer any data.  If <parameter>sense_bytes</parameter> != 0
   <parameter>cmnd</parameter> is ignored and this functions sets up a REQUEST_SENSE command
   and cmnd buffers to read <parameter>sense_bytes</parameter> into <parameter>scmd</parameter>-&gt;sense_buffer.
</para>
</refsect1>
</refentry>

<refentry id="API-scsi-eh-restore-cmnd">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>scsi_eh_restore_cmnd</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>scsi_eh_restore_cmnd</refname>
 <refpurpose>
     Restore a scsi command info as part of error recovery
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>scsi_eh_restore_cmnd </function></funcdef>
   <paramdef>struct scsi_cmnd * <parameter>scmd</parameter></paramdef>
   <paramdef>struct scsi_eh_save * <parameter>ses</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>scmd</parameter></term>
   <listitem>
    <para>
     SCSI command structure to restore
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>ses</parameter></term>
   <listitem>
    <para>
     saved information from a coresponding call to scsi_eh_prep_cmnd
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Undo any damage done by above <function>scsi_eh_prep_cmnd</function>.
</para>
</refsect1>
</refentry>

<refentry id="API-scsi-eh-finish-cmd">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>scsi_eh_finish_cmd</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>scsi_eh_finish_cmd</refname>
 <refpurpose>
     Handle a cmd that eh is finished with.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>scsi_eh_finish_cmd </function></funcdef>
   <paramdef>struct scsi_cmnd * <parameter>scmd</parameter></paramdef>
   <paramdef>struct list_head * <parameter>done_q</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>scmd</parameter></term>
   <listitem>
    <para>
     Original SCSI cmd that eh has finished.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>done_q</parameter></term>
   <listitem>
    <para>
     Queue for processed commands.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Notes</title>
<para>
   We don't want to use the normal command completion while we are are
   still handling errors - it may cause other commands to be queued,
   and that would disturb what we are doing.  Thus we really want to
   keep a list of pending commands for final completion, and once we
   are ready to leave error handling we handle completion for real.
</para>
</refsect1>
</refentry>

<refentry id="API-scsi-eh-get-sense">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>scsi_eh_get_sense</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>scsi_eh_get_sense</refname>
 <refpurpose>
     Get device sense data.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>scsi_eh_get_sense </function></funcdef>
   <paramdef>struct list_head * <parameter>work_q</parameter></paramdef>
   <paramdef>struct list_head * <parameter>done_q</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>work_q</parameter></term>
   <listitem>
    <para>
     Queue of commands to process.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>done_q</parameter></term>
   <listitem>
    <para>
     Queue of processed commands.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   See if we need to request sense information.  if so, then get it
   now, so we have a better idea of what to do.
</para>
</refsect1>
<refsect1>
<title>Notes</title>
<para>
   This has the unfortunate side effect that if a shost adapter does
   not automatically request sense information, we end up shutting
   it down before we request it.
   </para><para>

   All drivers should request sense information internally these days,
   so for now all I have to say is tough noogies if you end up in here.
</para>
</refsect1>
<refsect1>
<title>XXX</title>
<para>
   Long term this code should go away, but that needs an audit of
   all LLDDs first.
</para>
</refsect1>
</refentry>

<refentry id="API-scsi-eh-ready-devs">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>scsi_eh_ready_devs</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>scsi_eh_ready_devs</refname>
 <refpurpose>
     check device ready state and recover if not.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>scsi_eh_ready_devs </function></funcdef>
   <paramdef>struct Scsi_Host * <parameter>shost</parameter></paramdef>
   <paramdef>struct list_head * <parameter>work_q</parameter></paramdef>
   <paramdef>struct list_head * <parameter>done_q</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>shost</parameter></term>
   <listitem>
    <para>
     host to be recovered.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>work_q</parameter></term>
   <listitem>
    <para>
     <structname>list_head</structname> for pending commands.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>done_q</parameter></term>
   <listitem>
    <para>
     <structname>list_head</structname> for processed commands.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-scsi-eh-flush-done-q">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>scsi_eh_flush_done_q</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>scsi_eh_flush_done_q</refname>
 <refpurpose>
     finish processed commands or retry them.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>scsi_eh_flush_done_q </function></funcdef>
   <paramdef>struct list_head * <parameter>done_q</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>done_q</parameter></term>
   <listitem>
    <para>
     list_head of processed commands.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-scsi-normalize-sense">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>scsi_normalize_sense</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>scsi_normalize_sense</refname>
 <refpurpose>
     normalize main elements from either fixed or descriptor sense data format into a common format.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>scsi_normalize_sense </function></funcdef>
   <paramdef>const u8 * <parameter>sense_buffer</parameter></paramdef>
   <paramdef>int <parameter>sb_len</parameter></paramdef>
   <paramdef>struct scsi_sense_hdr * <parameter>sshdr</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>sense_buffer</parameter></term>
   <listitem>
    <para>
     byte array containing sense data returned by device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>sb_len</parameter></term>
   <listitem>
    <para>
     number of valid bytes in sense_buffer
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>sshdr</parameter></term>
   <listitem>
    <para>
     pointer to instance of structure that common
     elements are written to.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Notes</title>
<para>
   The <quote>main elements</quote> from sense data are: response_code, sense_key,
   asc, ascq and additional_length (only for descriptor format).
   </para><para>

   Typically this function can be called after a device has
   responded to a SCSI command with the CHECK_CONDITION status.
</para>
</refsect1>
<refsect1>
<title>Return value</title>
<para>
   1 if valid sense data information found, else 0;
</para>
</refsect1>
</refentry>

<refentry id="API-scsi-sense-desc-find">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>scsi_sense_desc_find</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>scsi_sense_desc_find</refname>
 <refpurpose>
     search for a given descriptor type in descriptor sense data format.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>const u8 * <function>scsi_sense_desc_find </function></funcdef>
   <paramdef>const u8 * <parameter>sense_buffer</parameter></paramdef>
   <paramdef>int <parameter>sb_len</parameter></paramdef>
   <paramdef>int <parameter>desc_type</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>sense_buffer</parameter></term>
   <listitem>
    <para>
     byte array of descriptor format sense data
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>sb_len</parameter></term>
   <listitem>
    <para>
     number of valid bytes in sense_buffer
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>desc_type</parameter></term>
   <listitem>
    <para>
     value of descriptor type to find
     (e.g. 0 -&gt; information)
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Notes</title>
<para>
   only valid when sense data is in descriptor format
</para>
</refsect1>
<refsect1>
<title>Return value</title>
<para>
   pointer to start of (first) descriptor if found else NULL
</para>
</refsect1>
</refentry>

<refentry id="API-scsi-get-sense-info-fld">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>scsi_get_sense_info_fld</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>scsi_get_sense_info_fld</refname>
 <refpurpose>
     get information field from sense data (either fixed or descriptor format)
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>scsi_get_sense_info_fld </function></funcdef>
   <paramdef>const u8 * <parameter>sense_buffer</parameter></paramdef>
   <paramdef>int <parameter>sb_len</parameter></paramdef>
   <paramdef>u64 * <parameter>info_out</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>sense_buffer</parameter></term>
   <listitem>
    <para>
     byte array of sense data
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>sb_len</parameter></term>
   <listitem>
    <para>
     number of valid bytes in sense_buffer
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>info_out</parameter></term>
   <listitem>
    <para>
     pointer to 64 integer where 8 or 4 byte information
     field will be placed if found.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Return value</title>
<para>
   1 if information field found, 0 if not found.
</para>
</refsect1>
</refentry>

<refentry id="API-scsi-build-sense-buffer">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>scsi_build_sense_buffer</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>scsi_build_sense_buffer</refname>
 <refpurpose>
     build sense data in a buffer
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>scsi_build_sense_buffer </function></funcdef>
   <paramdef>int <parameter>desc</parameter></paramdef>
   <paramdef>u8 * <parameter>buf</parameter></paramdef>
   <paramdef>u8 <parameter>key</parameter></paramdef>
   <paramdef>u8 <parameter>asc</parameter></paramdef>
   <paramdef>u8 <parameter>ascq</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>desc</parameter></term>
   <listitem>
    <para>
     Sense format (non zero == descriptor format,
     0 == fixed format)
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>buf</parameter></term>
   <listitem>
    <para>
     Where to build sense data
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>key</parameter></term>
   <listitem>
    <para>
     Sense key
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>asc</parameter></term>
   <listitem>
    <para>
     Additional sense code
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>ascq</parameter></term>
   <listitem>
    <para>
     Additional sense code qualifier
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

      </sect2>
      <sect2 id="scsi_devinfo.c">
        <title>drivers/scsi/scsi_devinfo.c</title>
        <para>
          Manage scsi_dev_info_list, which tracks blacklisted and whitelisted
          devices.
        </para>
<!-- drivers/scsi/scsi_devinfo.c -->
<refentry id="API-scsi-dev-info-list-add">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>scsi_dev_info_list_add</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>scsi_dev_info_list_add</refname>
 <refpurpose>
  add one dev_info list entry.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>scsi_dev_info_list_add </function></funcdef>
   <paramdef>int <parameter>compatible</parameter></paramdef>
   <paramdef>char * <parameter>vendor</parameter></paramdef>
   <paramdef>char * <parameter>model</parameter></paramdef>
   <paramdef>char * <parameter>strflags</parameter></paramdef>
   <paramdef>int <parameter>flags</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>compatible</parameter></term>
   <listitem>
    <para>
     if true, null terminate short strings.  Otherwise space pad.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>vendor</parameter></term>
   <listitem>
    <para>
     vendor string
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>model</parameter></term>
   <listitem>
    <para>
     model (product) string
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>strflags</parameter></term>
   <listitem>
    <para>
     integer string
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>flags</parameter></term>
   <listitem>
    <para>
     if strflags NULL, use this flag value
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Create and add one dev_info entry for <parameter>vendor</parameter>, <parameter>model</parameter>, <parameter>strflags</parameter> or
   <parameter>flag</parameter>. If <parameter>compatible</parameter>, add to the tail of the list, do not space
   pad, and set devinfo-&gt;compatible. The scsi_static_device_list entries
   are added with <parameter>compatible</parameter> 1 and <parameter>clfags</parameter> NULL.
</para>
</refsect1>
<refsect1>
<title>Returns</title>
<para>
   0 OK, -error on failure.
</para>
</refsect1>
</refentry>

<refentry id="API-scsi-dev-info-list-add-str">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>scsi_dev_info_list_add_str</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>scsi_dev_info_list_add_str</refname>
 <refpurpose>
     parse dev_list and add to the scsi_dev_info_list.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>scsi_dev_info_list_add_str </function></funcdef>
   <paramdef>char * <parameter>dev_list</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev_list</parameter></term>
   <listitem>
    <para>
     string of device flags to add
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Parse dev_list, and add entries to the scsi_dev_info_list.
   dev_list is of the form <quote>vendor:product:flag,vendor:product:flag</quote>.
   dev_list is modified via strsep. Can be called for command line
   addition, for proc or mabye a sysfs interface.
</para>
</refsect1>
<refsect1>
<title>Returns</title>
<para>
   0 if OK, -error on failure.
</para>
</refsect1>
</refentry>

<refentry id="API-scsi-get-device-flags">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>scsi_get_device_flags</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>scsi_get_device_flags</refname>
 <refpurpose>
     get device specific flags from the dynamic device list.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>scsi_get_device_flags </function></funcdef>
   <paramdef>struct scsi_device * <parameter>sdev</parameter></paramdef>
   <paramdef>const unsigned char * <parameter>vendor</parameter></paramdef>
   <paramdef>const unsigned char * <parameter>model</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>sdev</parameter></term>
   <listitem>
    <para>
     <structname>scsi_device</structname> to get flags for
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>vendor</parameter></term>
   <listitem>
    <para>
     vendor name
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>model</parameter></term>
   <listitem>
    <para>
     model name
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Search the global scsi_dev_info_list (specified by list zero)
   for an entry matching <parameter>vendor</parameter> and <parameter>model</parameter>, if found, return the
   matching flags value, else return the host or global default
   settings.  Called during scan time.
</para>
</refsect1>
</refentry>

<refentry id="API-scsi-exit-devinfo">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>scsi_exit_devinfo</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>scsi_exit_devinfo</refname>
 <refpurpose>
     remove /proc/scsi/device_info &amp; the scsi_dev_info_list
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>scsi_exit_devinfo </function></funcdef>
   <paramdef> <parameter>void</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>void</parameter></term>
   <listitem>
    <para>
     no arguments
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-scsi-init-devinfo">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>scsi_init_devinfo</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>scsi_init_devinfo</refname>
 <refpurpose>
     set up the dynamic device list.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>scsi_init_devinfo </function></funcdef>
   <paramdef> <parameter>void</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>void</parameter></term>
   <listitem>
    <para>
     no arguments
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Add command line entries from scsi_dev_flags, then add
   scsi_static_device_list entries to the scsi device info list.
</para>
</refsect1>
</refentry>

      </sect2>
      <sect2 id="scsi_ioctl.c">
        <title>drivers/scsi/scsi_ioctl.c</title>
        <para>
          Handle ioctl() calls for SCSI devices.
        </para>
<!-- drivers/scsi/scsi_ioctl.c -->
<refentry id="API-scsi-ioctl">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>scsi_ioctl</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>scsi_ioctl</refname>
 <refpurpose>
  Dispatch ioctl to scsi device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>scsi_ioctl </function></funcdef>
   <paramdef>struct scsi_device * <parameter>sdev</parameter></paramdef>
   <paramdef>int <parameter>cmd</parameter></paramdef>
   <paramdef>void __user * <parameter>arg</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>sdev</parameter></term>
   <listitem>
    <para>
     scsi device receiving ioctl
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>cmd</parameter></term>
   <listitem>
    <para>
     which ioctl is it
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>arg</parameter></term>
   <listitem>
    <para>
     data associated with ioctl
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   The <function>scsi_ioctl</function> function differs from most ioctls in that it
   does not take a major/minor number as the dev field.  Rather, it takes
   a pointer to a <structname>struct scsi_device</structname>.
</para>
</refsect1>
</refentry>

<refentry id="API-scsi-nonblockable-ioctl">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>scsi_nonblockable_ioctl</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>scsi_nonblockable_ioctl</refname>
 <refpurpose>
     Handle SG_SCSI_RESET
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>scsi_nonblockable_ioctl </function></funcdef>
   <paramdef>struct scsi_device * <parameter>sdev</parameter></paramdef>
   <paramdef>int <parameter>cmd</parameter></paramdef>
   <paramdef>void __user * <parameter>arg</parameter></paramdef>
   <paramdef>int <parameter>ndelay</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>sdev</parameter></term>
   <listitem>
    <para>
     scsi device receiving ioctl
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>cmd</parameter></term>
   <listitem>
    <para>
     Must be SC_SCSI_RESET
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>arg</parameter></term>
   <listitem>
    <para>
     pointer to int containing SG_SCSI_RESET_{DEVICE,BUS,HOST}
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>ndelay</parameter></term>
   <listitem>
    <para>
     file mode O_NDELAY flag
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

      </sect2>
      <sect2 id="scsi_lib.c">
        <title>drivers/scsi/scsi_lib.c</title>
        <para>
          SCSI queuing library.
        </para>
<!-- drivers/scsi/scsi_lib.c -->
<refentry id="API-scsi-execute">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>scsi_execute</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>scsi_execute</refname>
 <refpurpose>
  insert request and wait for the result
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>scsi_execute </function></funcdef>
   <paramdef>struct scsi_device * <parameter>sdev</parameter></paramdef>
   <paramdef>const unsigned char * <parameter>cmd</parameter></paramdef>
   <paramdef>int <parameter>data_direction</parameter></paramdef>
   <paramdef>void * <parameter>buffer</parameter></paramdef>
   <paramdef>unsigned <parameter>bufflen</parameter></paramdef>
   <paramdef>unsigned char * <parameter>sense</parameter></paramdef>
   <paramdef>int <parameter>timeout</parameter></paramdef>
   <paramdef>int <parameter>retries</parameter></paramdef>
   <paramdef>u64 <parameter>flags</parameter></paramdef>
   <paramdef>int * <parameter>resid</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>sdev</parameter></term>
   <listitem>
    <para>
     scsi device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>cmd</parameter></term>
   <listitem>
    <para>
     scsi command
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>data_direction</parameter></term>
   <listitem>
    <para>
     data direction
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>buffer</parameter></term>
   <listitem>
    <para>
     data buffer
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>bufflen</parameter></term>
   <listitem>
    <para>
     len of buffer
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>sense</parameter></term>
   <listitem>
    <para>
     optional sense buffer
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>timeout</parameter></term>
   <listitem>
    <para>
     request timeout in seconds
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>retries</parameter></term>
   <listitem>
    <para>
     number of times to retry request
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>flags</parameter></term>
   <listitem>
    <para>
     or into request flags;
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>resid</parameter></term>
   <listitem>
    <para>
     optional residual length
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   returns the req-&gt;errors value which is the scsi_cmnd result
   field.
</para>
</refsect1>
</refentry>

<refentry id="API-scsi-mode-select">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>scsi_mode_select</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>scsi_mode_select</refname>
 <refpurpose>
     issue a mode select
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>scsi_mode_select </function></funcdef>
   <paramdef>struct scsi_device * <parameter>sdev</parameter></paramdef>
   <paramdef>int <parameter>pf</parameter></paramdef>
   <paramdef>int <parameter>sp</parameter></paramdef>
   <paramdef>int <parameter>modepage</parameter></paramdef>
   <paramdef>unsigned char * <parameter>buffer</parameter></paramdef>
   <paramdef>int <parameter>len</parameter></paramdef>
   <paramdef>int <parameter>timeout</parameter></paramdef>
   <paramdef>int <parameter>retries</parameter></paramdef>
   <paramdef>struct scsi_mode_data * <parameter>data</parameter></paramdef>
   <paramdef>struct scsi_sense_hdr * <parameter>sshdr</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>sdev</parameter></term>
   <listitem>
    <para>
     SCSI device to be queried
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>pf</parameter></term>
   <listitem>
    <para>
     Page format bit (1 == standard, 0 == vendor specific)
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>sp</parameter></term>
   <listitem>
    <para>
     Save page bit (0 == don't save, 1 == save)
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>modepage</parameter></term>
   <listitem>
    <para>
     mode page being requested
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>buffer</parameter></term>
   <listitem>
    <para>
     request buffer (may not be smaller than eight bytes)
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>len</parameter></term>
   <listitem>
    <para>
     length of request buffer.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>timeout</parameter></term>
   <listitem>
    <para>
     command timeout
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>retries</parameter></term>
   <listitem>
    <para>
     number of retries before failing
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>data</parameter></term>
   <listitem>
    <para>
     returns a structure abstracting the mode header data
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>sshdr</parameter></term>
   <listitem>
    <para>
     place to put sense data (or NULL if no sense to be collected).
     must be SCSI_SENSE_BUFFERSIZE big.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Returns zero if successful; negative error number or scsi
   status on error
</para>
</refsect1>
</refentry>

<refentry id="API-scsi-mode-sense">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>scsi_mode_sense</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>scsi_mode_sense</refname>
 <refpurpose>
     issue a mode sense, falling back from 10 to six bytes if necessary.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>scsi_mode_sense </function></funcdef>
   <paramdef>struct scsi_device * <parameter>sdev</parameter></paramdef>
   <paramdef>int <parameter>dbd</parameter></paramdef>
   <paramdef>int <parameter>modepage</parameter></paramdef>
   <paramdef>unsigned char * <parameter>buffer</parameter></paramdef>
   <paramdef>int <parameter>len</parameter></paramdef>
   <paramdef>int <parameter>timeout</parameter></paramdef>
   <paramdef>int <parameter>retries</parameter></paramdef>
   <paramdef>struct scsi_mode_data * <parameter>data</parameter></paramdef>
   <paramdef>struct scsi_sense_hdr * <parameter>sshdr</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>sdev</parameter></term>
   <listitem>
    <para>
     SCSI device to be queried
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>dbd</parameter></term>
   <listitem>
    <para>
     set if mode sense will allow block descriptors to be returned
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>modepage</parameter></term>
   <listitem>
    <para>
     mode page being requested
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>buffer</parameter></term>
   <listitem>
    <para>
     request buffer (may not be smaller than eight bytes)
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>len</parameter></term>
   <listitem>
    <para>
     length of request buffer.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>timeout</parameter></term>
   <listitem>
    <para>
     command timeout
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>retries</parameter></term>
   <listitem>
    <para>
     number of retries before failing
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>data</parameter></term>
   <listitem>
    <para>
     returns a structure abstracting the mode header data
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>sshdr</parameter></term>
   <listitem>
    <para>
     place to put sense data (or NULL if no sense to be collected).
     must be SCSI_SENSE_BUFFERSIZE big.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Returns zero if unsuccessful, or the header offset (either 4
   or 8 depending on whether a six or ten byte command was
   issued) if successful.
</para>
</refsect1>
</refentry>

<refentry id="API-scsi-test-unit-ready">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>scsi_test_unit_ready</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>scsi_test_unit_ready</refname>
 <refpurpose>
     test if unit is ready
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>scsi_test_unit_ready </function></funcdef>
   <paramdef>struct scsi_device * <parameter>sdev</parameter></paramdef>
   <paramdef>int <parameter>timeout</parameter></paramdef>
   <paramdef>int <parameter>retries</parameter></paramdef>
   <paramdef>struct scsi_sense_hdr * <parameter>sshdr_external</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>sdev</parameter></term>
   <listitem>
    <para>
     scsi device to change the state of.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>timeout</parameter></term>
   <listitem>
    <para>
     command timeout
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>retries</parameter></term>
   <listitem>
    <para>
     number of retries before failing
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>sshdr_external</parameter></term>
   <listitem>
    <para>
     Optional pointer to struct scsi_sense_hdr for
     returning sense. Make sure that this is cleared before passing
     in.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Returns zero if unsuccessful or an error if TUR failed.  For
   removable media, UNIT_ATTENTION sets -&gt;changed flag.
</para>
</refsect1>
</refentry>

<refentry id="API-scsi-device-set-state">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>scsi_device_set_state</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>scsi_device_set_state</refname>
 <refpurpose>
     Take the given device through the device state model.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>scsi_device_set_state </function></funcdef>
   <paramdef>struct scsi_device * <parameter>sdev</parameter></paramdef>
   <paramdef>enum scsi_device_state <parameter>state</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>sdev</parameter></term>
   <listitem>
    <para>
     scsi device to change the state of.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>state</parameter></term>
   <listitem>
    <para>
     state to change to.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Returns zero if unsuccessful or an error if the requested 
   transition is illegal.
</para>
</refsect1>
</refentry>

<refentry id="API-sdev-evt-send">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>sdev_evt_send</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>sdev_evt_send</refname>
 <refpurpose>
     send asserted event to uevent thread
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>sdev_evt_send </function></funcdef>
   <paramdef>struct scsi_device * <parameter>sdev</parameter></paramdef>
   <paramdef>struct scsi_event * <parameter>evt</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>sdev</parameter></term>
   <listitem>
    <para>
     scsi_device event occurred on
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>evt</parameter></term>
   <listitem>
    <para>
     event to send
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Assert scsi device event asynchronously.
</para>
</refsect1>
</refentry>

<refentry id="API-sdev-evt-alloc">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>sdev_evt_alloc</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>sdev_evt_alloc</refname>
 <refpurpose>
     allocate a new scsi event
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct scsi_event * <function>sdev_evt_alloc </function></funcdef>
   <paramdef>enum scsi_device_event <parameter>evt_type</parameter></paramdef>
   <paramdef>gfp_t <parameter>gfpflags</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>evt_type</parameter></term>
   <listitem>
    <para>
     type of event to allocate
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>gfpflags</parameter></term>
   <listitem>
    <para>
     GFP flags for allocation
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Allocates and returns a new scsi_event.
</para>
</refsect1>
</refentry>

<refentry id="API-sdev-evt-send-simple">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>sdev_evt_send_simple</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>sdev_evt_send_simple</refname>
 <refpurpose>
     send asserted event to uevent thread
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>sdev_evt_send_simple </function></funcdef>
   <paramdef>struct scsi_device * <parameter>sdev</parameter></paramdef>
   <paramdef>enum scsi_device_event <parameter>evt_type</parameter></paramdef>
   <paramdef>gfp_t <parameter>gfpflags</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>sdev</parameter></term>
   <listitem>
    <para>
     scsi_device event occurred on
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>evt_type</parameter></term>
   <listitem>
    <para>
     type of event to send
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>gfpflags</parameter></term>
   <listitem>
    <para>
     GFP flags for allocation
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Assert scsi device event asynchronously, given an event type.
</para>
</refsect1>
</refentry>

<refentry id="API-scsi-device-quiesce">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>scsi_device_quiesce</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>scsi_device_quiesce</refname>
 <refpurpose>
     Block user issued commands.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>scsi_device_quiesce </function></funcdef>
   <paramdef>struct scsi_device * <parameter>sdev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>sdev</parameter></term>
   <listitem>
    <para>
     scsi device to quiesce.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This works by trying to transition to the SDEV_QUIESCE state
   (which must be a legal transition).  When the device is in this
   state, only special requests will be accepted, all others will
   be deferred.  Since special requests may also be requeued requests,
   a successful return doesn't guarantee the device will be 
   totally quiescent.
   </para><para>

   Must be called with user context, may sleep.
   </para><para>

   Returns zero if unsuccessful or an error if not.
</para>
</refsect1>
</refentry>

<refentry id="API-scsi-device-resume">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>scsi_device_resume</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>scsi_device_resume</refname>
 <refpurpose>
     Restart user issued commands to a quiesced device.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>scsi_device_resume </function></funcdef>
   <paramdef>struct scsi_device * <parameter>sdev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>sdev</parameter></term>
   <listitem>
    <para>
     scsi device to resume.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Moves the device from quiesced back to running and restarts the
   queues.
   </para><para>

   Must be called with user context, may sleep.
</para>
</refsect1>
</refentry>

<refentry id="API-scsi-internal-device-block">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>scsi_internal_device_block</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>scsi_internal_device_block</refname>
 <refpurpose>
     internal function to put a device temporarily into the SDEV_BLOCK state
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>scsi_internal_device_block </function></funcdef>
   <paramdef>struct scsi_device * <parameter>sdev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>sdev</parameter></term>
   <listitem>
    <para>
     device to block
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Block request made by scsi lld's to temporarily stop all
   scsi commands on the specified device.  Called from interrupt
   or normal process context.
   </para><para>

   Returns zero if successful or error if not
</para>
</refsect1>
<refsect1>
<title>Notes</title>
<para>
   </para><para>

   This routine transitions the device to the SDEV_BLOCK state
   (which must be a legal transition).  When the device is in this
   state, all commands are deferred until the scsi lld reenables
   the device with scsi_device_unblock or device_block_tmo fires.
</para>
</refsect1>
</refentry>

<refentry id="API-scsi-internal-device-unblock">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>scsi_internal_device_unblock</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>scsi_internal_device_unblock</refname>
 <refpurpose>
     resume a device after a block request
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>scsi_internal_device_unblock </function></funcdef>
   <paramdef>struct scsi_device * <parameter>sdev</parameter></paramdef>
   <paramdef>enum scsi_device_state <parameter>new_state</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>sdev</parameter></term>
   <listitem>
    <para>
     device to resume
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>new_state</parameter></term>
   <listitem>
    <para>
     state to set devices to after unblocking
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Called by scsi lld's or the midlayer to restart the device queue
   for the previously suspended scsi device.  Called from interrupt or
   normal process context.
   </para><para>

   Returns zero if successful or error if not.
</para>
</refsect1>
<refsect1>
<title>Notes</title>
<para>
   </para><para>

   This routine transitions the device to the SDEV_RUNNING state
   or to one of the offline states (which must be a legal transition)
   allowing the midlayer to goose the queue for this device.
</para>
</refsect1>
</refentry>

<refentry id="API-scsi-kmap-atomic-sg">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>scsi_kmap_atomic_sg</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>scsi_kmap_atomic_sg</refname>
 <refpurpose>
     find and atomically map an sg-elemnt
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void * <function>scsi_kmap_atomic_sg </function></funcdef>
   <paramdef>struct scatterlist * <parameter>sgl</parameter></paramdef>
   <paramdef>int <parameter>sg_count</parameter></paramdef>
   <paramdef>size_t * <parameter>offset</parameter></paramdef>
   <paramdef>size_t * <parameter>len</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>sgl</parameter></term>
   <listitem>
    <para>
     scatter-gather list
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>sg_count</parameter></term>
   <listitem>
    <para>
     number of segments in sg
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>offset</parameter></term>
   <listitem>
    <para>
     offset in bytes into sg, on return offset into the mapped area
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>len</parameter></term>
   <listitem>
    <para>
     bytes to map, on return number of bytes mapped
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Returns virtual address of the start of the mapped page
</para>
</refsect1>
</refentry>

<refentry id="API-scsi-kunmap-atomic-sg">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>scsi_kunmap_atomic_sg</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>scsi_kunmap_atomic_sg</refname>
 <refpurpose>
     atomically unmap a virtual address, previously mapped with scsi_kmap_atomic_sg
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>scsi_kunmap_atomic_sg </function></funcdef>
   <paramdef>void * <parameter>virt</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>virt</parameter></term>
   <listitem>
    <para>
     virtual address to be unmapped
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

      </sect2>
      <sect2 id="scsi_lib_dma.c">
        <title>drivers/scsi/scsi_lib_dma.c</title>
        <para>
          SCSI library functions depending on DMA
          (map and unmap scatter-gather lists).
        </para>
<!-- drivers/scsi/scsi_lib_dma.c -->
<refentry id="API-scsi-dma-map">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>scsi_dma_map</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>scsi_dma_map</refname>
 <refpurpose>
  perform DMA mapping against command's sg lists
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>scsi_dma_map </function></funcdef>
   <paramdef>struct scsi_cmnd * <parameter>cmd</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>cmd</parameter></term>
   <listitem>
    <para>
     scsi command
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Returns the number of sg lists actually used, zero if the sg lists
   is NULL, or -ENOMEM if the mapping failed.
</para>
</refsect1>
</refentry>

<refentry id="API-scsi-dma-unmap">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>scsi_dma_unmap</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>scsi_dma_unmap</refname>
 <refpurpose>
     unmap command's sg lists mapped by scsi_dma_map
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>scsi_dma_unmap </function></funcdef>
   <paramdef>struct scsi_cmnd * <parameter>cmd</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>cmd</parameter></term>
   <listitem>
    <para>
     scsi command
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

      </sect2>
      <sect2 id="scsi_module.c">
        <title>drivers/scsi/scsi_module.c</title>
        <para>
          The file drivers/scsi/scsi_module.c contains legacy support for
          old-style host templates.  It should never be used by any new driver.
        </para>
      </sect2>
      <sect2 id="scsi_proc.c">
        <title>drivers/scsi/scsi_proc.c</title>
        <para>
          The functions in this file provide an interface between
          the PROC file system and the SCSI device drivers
          It is mainly used for debugging, statistics and to pass
          information directly to the lowlevel driver.

          I.E. plumbing to manage /proc/scsi/*
        </para>
<!-- drivers/scsi/scsi_proc.c -->
<refentry id="API-scsi-proc-hostdir-add">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>scsi_proc_hostdir_add</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>scsi_proc_hostdir_add</refname>
 <refpurpose>
  Create directory in /proc for a scsi host
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>scsi_proc_hostdir_add </function></funcdef>
   <paramdef>struct scsi_host_template * <parameter>sht</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>sht</parameter></term>
   <listitem>
    <para>
     owner of this directory
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Sets sht-&gt;proc_dir to the new directory.
</para>
</refsect1>
</refentry>

<refentry id="API-scsi-proc-hostdir-rm">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>scsi_proc_hostdir_rm</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>scsi_proc_hostdir_rm</refname>
 <refpurpose>
     remove directory in /proc for a scsi host
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>scsi_proc_hostdir_rm </function></funcdef>
   <paramdef>struct scsi_host_template * <parameter>sht</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>sht</parameter></term>
   <listitem>
    <para>
     owner of directory
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-scsi-proc-host-add">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>scsi_proc_host_add</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>scsi_proc_host_add</refname>
 <refpurpose>
     Add entry for this host to appropriate /proc dir
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>scsi_proc_host_add </function></funcdef>
   <paramdef>struct Scsi_Host * <parameter>shost</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>shost</parameter></term>
   <listitem>
    <para>
     host to add
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-scsi-proc-host-rm">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>scsi_proc_host_rm</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>scsi_proc_host_rm</refname>
 <refpurpose>
     remove this host's entry from /proc
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>scsi_proc_host_rm </function></funcdef>
   <paramdef>struct Scsi_Host * <parameter>shost</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>shost</parameter></term>
   <listitem>
    <para>
     which host
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-proc-print-scsidevice">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>proc_print_scsidevice</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>proc_print_scsidevice</refname>
 <refpurpose>
     return data about this host
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>proc_print_scsidevice </function></funcdef>
   <paramdef>struct device * <parameter>dev</parameter></paramdef>
   <paramdef>void * <parameter>data</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     A scsi device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>data</parameter></term>
   <listitem>
    <para>
     <structname>struct seq_file</structname> to output to.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   prints Host, Channel, Id, Lun, Vendor, Model, Rev, Type,
   and revision.
</para>
</refsect1>
</refentry>

<refentry id="API-scsi-add-single-device">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>scsi_add_single_device</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>scsi_add_single_device</refname>
 <refpurpose>
     Respond to user request to probe for/add device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>scsi_add_single_device </function></funcdef>
   <paramdef>uint <parameter>host</parameter></paramdef>
   <paramdef>uint <parameter>channel</parameter></paramdef>
   <paramdef>uint <parameter>id</parameter></paramdef>
   <paramdef>uint <parameter>lun</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>host</parameter></term>
   <listitem>
    <para>
     user-supplied decimal integer
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>channel</parameter></term>
   <listitem>
    <para>
     user-supplied decimal integer
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>id</parameter></term>
   <listitem>
    <para>
     user-supplied decimal integer
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>lun</parameter></term>
   <listitem>
    <para>
     user-supplied decimal integer
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   called by writing <quote>scsi add-single-device</quote> to /proc/scsi/scsi.
   </para><para>

   does <function>scsi_host_lookup</function> and either <function>user_scan</function> if that transport
   type supports it, or else <function>scsi_scan_host_selected</function>
</para>
</refsect1>
<refsect1>
<title>Note</title>
<para>
   this seems to be aimed exclusively at SCSI parallel busses.
</para>
</refsect1>
</refentry>

<refentry id="API-scsi-remove-single-device">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>scsi_remove_single_device</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>scsi_remove_single_device</refname>
 <refpurpose>
     Respond to user request to remove a device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>scsi_remove_single_device </function></funcdef>
   <paramdef>uint <parameter>host</parameter></paramdef>
   <paramdef>uint <parameter>channel</parameter></paramdef>
   <paramdef>uint <parameter>id</parameter></paramdef>
   <paramdef>uint <parameter>lun</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>host</parameter></term>
   <listitem>
    <para>
     user-supplied decimal integer
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>channel</parameter></term>
   <listitem>
    <para>
     user-supplied decimal integer
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>id</parameter></term>
   <listitem>
    <para>
     user-supplied decimal integer
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>lun</parameter></term>
   <listitem>
    <para>
     user-supplied decimal integer
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   called by writing <quote>scsi remove-single-device</quote> to
   /proc/scsi/scsi.  Does a <function>scsi_device_lookup</function> and <function>scsi_remove_device</function>
</para>
</refsect1>
</refentry>

<refentry id="API-proc-scsi-write">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>proc_scsi_write</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>proc_scsi_write</refname>
 <refpurpose>
     handle writes to /proc/scsi/scsi
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>ssize_t <function>proc_scsi_write </function></funcdef>
   <paramdef>struct file * <parameter>file</parameter></paramdef>
   <paramdef>const char __user * <parameter>buf</parameter></paramdef>
   <paramdef>size_t <parameter>length</parameter></paramdef>
   <paramdef>loff_t * <parameter>ppos</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>file</parameter></term>
   <listitem>
    <para>
     not used
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>buf</parameter></term>
   <listitem>
    <para>
     buffer to write
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>length</parameter></term>
   <listitem>
    <para>
     length of buf, at most PAGE_SIZE
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>ppos</parameter></term>
   <listitem>
    <para>
     not used
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   this provides a legacy mechanism to add or remove devices by
   Host, Channel, ID, and Lun.  To use,
   <quote>echo 'scsi add-single-device 0 1 2 3' &gt; /proc/scsi/scsi</quote> or
   <quote>echo 'scsi remove-single-device 0 1 2 3' &gt; /proc/scsi/scsi</quote> with
   <quote>0 1 2 3</quote> replaced by the Host, Channel, Id, and Lun.
</para>
</refsect1>
<refsect1>
<title>Note</title>
<para>
   this seems to be aimed at parallel SCSI. Most modern busses (USB,
   SATA, Firewire, Fibre Channel, etc) dynamically assign these values to
   provide a unique identifier and nothing more.
</para>
</refsect1>
</refentry>

<refentry id="API-proc-scsi-open">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>proc_scsi_open</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>proc_scsi_open</refname>
 <refpurpose>
     glue function
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>proc_scsi_open </function></funcdef>
   <paramdef>struct inode * <parameter>inode</parameter></paramdef>
   <paramdef>struct file * <parameter>file</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>inode</parameter></term>
   <listitem>
    <para>
     not used
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>file</parameter></term>
   <listitem>
    <para>
     passed to <function>single_open</function>
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Associates proc_scsi_show with this file
</para>
</refsect1>
</refentry>

<refentry id="API-scsi-init-procfs">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>scsi_init_procfs</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>scsi_init_procfs</refname>
 <refpurpose>
     create scsi and scsi/scsi in procfs
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>scsi_init_procfs </function></funcdef>
   <paramdef> <parameter>void</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>void</parameter></term>
   <listitem>
    <para>
     no arguments
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-scsi-exit-procfs">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>scsi_exit_procfs</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>scsi_exit_procfs</refname>
 <refpurpose>
     Remove scsi/scsi and scsi from procfs
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>scsi_exit_procfs </function></funcdef>
   <paramdef> <parameter>void</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>void</parameter></term>
   <listitem>
    <para>
     no arguments
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

      </sect2>
      <sect2 id="scsi_netlink.c">
        <title>drivers/scsi/scsi_netlink.c</title>
        <para>
          Infrastructure to provide async events from transports to userspace
          via netlink, using a single NETLINK_SCSITRANSPORT protocol for all
          transports.

          See <ulink url='http://marc.info/?l=linux-scsi&amp;m=115507374832500&amp;w=2'>the
          original patch submission</ulink> for more details.
        </para>
<!-- drivers/scsi/scsi_netlink.c -->
<refentry id="API-scsi-nl-rcv-msg">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>scsi_nl_rcv_msg</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>scsi_nl_rcv_msg</refname>
 <refpurpose>
  Receive message handler.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>scsi_nl_rcv_msg </function></funcdef>
   <paramdef>struct sk_buff * <parameter>skb</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>skb</parameter></term>
   <listitem>
    <para>
     socket receive buffer
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Extracts message from a receive buffer.
   Validates message header and calls appropriate transport message handler
</para>
</refsect1>
</refentry>

<refentry id="API-scsi-netlink-init">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>scsi_netlink_init</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>scsi_netlink_init</refname>
 <refpurpose>
     Called by SCSI subsystem to initialize the SCSI transport netlink interface
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>scsi_netlink_init </function></funcdef>
   <paramdef> <parameter>void</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>void</parameter></term>
   <listitem>
    <para>
     no arguments
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-scsi-netlink-exit">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>scsi_netlink_exit</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>scsi_netlink_exit</refname>
 <refpurpose>
     Called by SCSI subsystem to disable the SCSI transport netlink interface
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>scsi_netlink_exit </function></funcdef>
   <paramdef> <parameter>void</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>void</parameter></term>
   <listitem>
    <para>
     no arguments
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
</para>
</refsect1>
</refentry>

      </sect2>
      <sect2 id="scsi_scan.c">
        <title>drivers/scsi/scsi_scan.c</title>
        <para>
          Scan a host to determine which (if any) devices are attached.

          The general scanning/probing algorithm is as follows, exceptions are
          made to it depending on device specific flags, compilation options,
          and global variable (boot or module load time) settings.

          A specific LUN is scanned via an INQUIRY command; if the LUN has a
          device attached, a scsi_device is allocated and setup for it.

          For every id of every channel on the given host, start by scanning
          LUN 0.  Skip hosts that don't respond at all to a scan of LUN 0.
          Otherwise, if LUN 0 has a device attached, allocate and setup a
          scsi_device for it.  If target is SCSI-3 or up, issue a REPORT LUN,
          and scan all of the LUNs returned by the REPORT LUN; else,
          sequentially scan LUNs up until some maximum is reached, or a LUN is
          seen that cannot have a device attached to it.
        </para>
<!-- drivers/scsi/scsi_scan.c -->
<refentry id="API-scsi-complete-async-scans">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>scsi_complete_async_scans</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>scsi_complete_async_scans</refname>
 <refpurpose>
  Wait for asynchronous scans to complete
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>scsi_complete_async_scans </function></funcdef>
   <paramdef> <parameter>void</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>void</parameter></term>
   <listitem>
    <para>
     no arguments
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   </para><para>

   When this function returns, any host which started scanning before
   this function was called will have finished its scan.  Hosts which
   started scanning after this function was called may or may not have
   finished.
</para>
</refsect1>
</refentry>

<refentry id="API-scsi-unlock-floptical">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>scsi_unlock_floptical</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>scsi_unlock_floptical</refname>
 <refpurpose>
     unlock device via a special MODE SENSE command
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>scsi_unlock_floptical </function></funcdef>
   <paramdef>struct scsi_device * <parameter>sdev</parameter></paramdef>
   <paramdef>unsigned char * <parameter>result</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>sdev</parameter></term>
   <listitem>
    <para>
     scsi device to send command to
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>result</parameter></term>
   <listitem>
    <para>
     area to store the result of the MODE SENSE
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Send a vendor specific MODE SENSE (not a MODE SELECT) command.
   Called for BLIST_KEY devices.
</para>
</refsect1>
</refentry>

<refentry id="API-scsi-alloc-sdev">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>scsi_alloc_sdev</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>scsi_alloc_sdev</refname>
 <refpurpose>
     allocate and setup a scsi_Device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct scsi_device * <function>scsi_alloc_sdev </function></funcdef>
   <paramdef>struct scsi_target * <parameter>starget</parameter></paramdef>
   <paramdef>u64 <parameter>lun</parameter></paramdef>
   <paramdef>void * <parameter>hostdata</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>starget</parameter></term>
   <listitem>
    <para>
     which target to allocate a <structname>scsi_device</structname> for
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>lun</parameter></term>
   <listitem>
    <para>
     which lun
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>hostdata</parameter></term>
   <listitem>
    <para>
     usually NULL and set by -&gt;slave_alloc instead
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Allocate, initialize for io, and return a pointer to a scsi_Device.
   Stores the <parameter>shost</parameter>, <parameter>channel</parameter>, <parameter>id</parameter>, and <parameter>lun</parameter> in the scsi_Device, and
   adds scsi_Device to the appropriate list.
</para>
</refsect1>
<refsect1>
<title>Return value</title>
<para>
   scsi_Device pointer, or NULL on failure.
</para>
</refsect1>
</refentry>

<refentry id="API-scsi-target-reap-ref-release">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>scsi_target_reap_ref_release</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>scsi_target_reap_ref_release</refname>
 <refpurpose>
     remove target from visibility
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>scsi_target_reap_ref_release </function></funcdef>
   <paramdef>struct kref * <parameter>kref</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>kref</parameter></term>
   <listitem>
    <para>
     the reap_ref in the target being released
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Called on last put of reap_ref, which is the indication that no device
   under this target is visible anymore, so render the target invisible in
   sysfs.  Note: we have to be in user context here because the target reaps
   should be done in places where the scsi device visibility is being removed.
</para>
</refsect1>
</refentry>

<refentry id="API-scsi-alloc-target">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>scsi_alloc_target</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>scsi_alloc_target</refname>
 <refpurpose>
     allocate a new or find an existing target
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct scsi_target * <function>scsi_alloc_target </function></funcdef>
   <paramdef>struct device * <parameter>parent</parameter></paramdef>
   <paramdef>int <parameter>channel</parameter></paramdef>
   <paramdef>uint <parameter>id</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>parent</parameter></term>
   <listitem>
    <para>
     parent of the target (need not be a scsi host)
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>channel</parameter></term>
   <listitem>
    <para>
     target channel number (zero if no channels)
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>id</parameter></term>
   <listitem>
    <para>
     target id number
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Return an existing target if one exists, provided it hasn't already
   gone into STARGET_DEL state, otherwise allocate a new target.
   </para><para>

   The target is returned with an incremented reference, so the caller
   is responsible for both reaping and doing a last put
</para>
</refsect1>
</refentry>

<refentry id="API-scsi-target-reap">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>scsi_target_reap</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>scsi_target_reap</refname>
 <refpurpose>
     check to see if target is in use and destroy if not
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>scsi_target_reap </function></funcdef>
   <paramdef>struct scsi_target * <parameter>starget</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>starget</parameter></term>
   <listitem>
    <para>
     target to be checked
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This is used after removing a LUN or doing a last put of the target
   it checks atomically that nothing is using the target and removes
   it if so.
</para>
</refsect1>
</refentry>

<refentry id="API-sanitize-inquiry-string">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>sanitize_inquiry_string</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>sanitize_inquiry_string</refname>
 <refpurpose>
     remove non-graphical chars from an INQUIRY result string
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>sanitize_inquiry_string </function></funcdef>
   <paramdef>unsigned char * <parameter>s</parameter></paramdef>
   <paramdef>int <parameter>len</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>s</parameter></term>
   <listitem>
    <para>
     INQUIRY result string to sanitize
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>len</parameter></term>
   <listitem>
    <para>
     length of the string
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   The SCSI spec says that INQUIRY vendor, product, and revision
   strings must consist entirely of graphic ASCII characters,
   padded on the right with spaces.  Since not all devices obey
   this rule, we will replace non-graphic or non-ASCII characters
   with spaces.  Exception: a NUL character is interpreted as a
   string terminator, so all the following characters are set to
   spaces.
</para>
</refsect1>
</refentry>

<refentry id="API-scsi-probe-lun">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>scsi_probe_lun</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>scsi_probe_lun</refname>
 <refpurpose>
     probe a single LUN using a SCSI INQUIRY
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>scsi_probe_lun </function></funcdef>
   <paramdef>struct scsi_device * <parameter>sdev</parameter></paramdef>
   <paramdef>unsigned char * <parameter>inq_result</parameter></paramdef>
   <paramdef>int <parameter>result_len</parameter></paramdef>
   <paramdef>int * <parameter>bflags</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>sdev</parameter></term>
   <listitem>
    <para>
     scsi_device to probe
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>inq_result</parameter></term>
   <listitem>
    <para>
     area to store the INQUIRY result
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>result_len</parameter></term>
   <listitem>
    <para>
     len of inq_result
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>bflags</parameter></term>
   <listitem>
    <para>
     store any bflags found here
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Probe the lun associated with <parameter>req</parameter> using a standard SCSI INQUIRY;
   </para><para>

   If the INQUIRY is successful, zero is returned and the
   INQUIRY data is in <parameter>inq_result</parameter>; the scsi_level and INQUIRY length
   are copied to the scsi_device any flags value is stored in *<parameter>bflags</parameter>.
</para>
</refsect1>
</refentry>

<refentry id="API-scsi-add-lun">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>scsi_add_lun</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>scsi_add_lun</refname>
 <refpurpose>
     allocate and fully initialze a scsi_device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>scsi_add_lun </function></funcdef>
   <paramdef>struct scsi_device * <parameter>sdev</parameter></paramdef>
   <paramdef>unsigned char * <parameter>inq_result</parameter></paramdef>
   <paramdef>int * <parameter>bflags</parameter></paramdef>
   <paramdef>int <parameter>async</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>sdev</parameter></term>
   <listitem>
    <para>
     holds information to be stored in the new scsi_device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>inq_result</parameter></term>
   <listitem>
    <para>
     holds the result of a previous INQUIRY to the LUN
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>bflags</parameter></term>
   <listitem>
    <para>
     black/white list flag
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>async</parameter></term>
   <listitem>
    <para>
     1 if this device is being scanned asynchronously
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Initialize the scsi_device <parameter>sdev</parameter>.  Optionally set fields based
   on values in *<parameter>bflags</parameter>.
</para>
</refsect1>
<refsect1>
<title>SCSI_SCAN_NO_RESPONSE</title>
<para>
   could not allocate or setup a scsi_device
</para>
</refsect1>
<refsect1>
<title>SCSI_SCAN_LUN_PRESENT</title>
<para>
   a new scsi_device was allocated and initialized
</para>
</refsect1>
</refentry>

<refentry id="API-scsi-inq-str">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>scsi_inq_str</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>scsi_inq_str</refname>
 <refpurpose>
     print INQUIRY data from min to max index, strip trailing whitespace
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>unsigned char * <function>scsi_inq_str </function></funcdef>
   <paramdef>unsigned char * <parameter>buf</parameter></paramdef>
   <paramdef>unsigned char * <parameter>inq</parameter></paramdef>
   <paramdef>unsigned <parameter>first</parameter></paramdef>
   <paramdef>unsigned <parameter>end</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>buf</parameter></term>
   <listitem>
    <para>
     Output buffer with at least end-first+1 bytes of space
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>inq</parameter></term>
   <listitem>
    <para>
     Inquiry buffer (input)
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>first</parameter></term>
   <listitem>
    <para>
     Offset of string into inq
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>end</parameter></term>
   <listitem>
    <para>
     Index after last character in inq
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-scsi-probe-and-add-lun">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>scsi_probe_and_add_lun</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>scsi_probe_and_add_lun</refname>
 <refpurpose>
     probe a LUN, if a LUN is found add it
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>scsi_probe_and_add_lun </function></funcdef>
   <paramdef>struct scsi_target * <parameter>starget</parameter></paramdef>
   <paramdef>u64 <parameter>lun</parameter></paramdef>
   <paramdef>int * <parameter>bflagsp</parameter></paramdef>
   <paramdef>struct scsi_device ** <parameter>sdevp</parameter></paramdef>
   <paramdef>int <parameter>rescan</parameter></paramdef>
   <paramdef>void * <parameter>hostdata</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>starget</parameter></term>
   <listitem>
    <para>
     pointer to target device structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>lun</parameter></term>
   <listitem>
    <para>
     LUN of target device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>bflagsp</parameter></term>
   <listitem>
    <para>
     store bflags here if not NULL
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>sdevp</parameter></term>
   <listitem>
    <para>
     probe the LUN corresponding to this scsi_device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>rescan</parameter></term>
   <listitem>
    <para>
     if nonzero skip some code only needed on first scan
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>hostdata</parameter></term>
   <listitem>
    <para>
     passed to <function>scsi_alloc_sdev</function>
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Call scsi_probe_lun, if a LUN with an attached device is found,
   allocate and set it up by calling scsi_add_lun.
</para>
</refsect1>
<refsect1>
<title>SCSI_SCAN_NO_RESPONSE</title>
<para>
   could not allocate or setup a scsi_device
</para>
</refsect1>
<refsect1>
<title>SCSI_SCAN_TARGET_PRESENT</title>
<para>
   target responded, but no device is
   attached at the LUN
</para>
</refsect1>
<refsect1>
<title>SCSI_SCAN_LUN_PRESENT</title>
<para>
   a new scsi_device was allocated and initialized
</para>
</refsect1>
</refentry>

<refentry id="API-scsi-sequential-lun-scan">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>scsi_sequential_lun_scan</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>scsi_sequential_lun_scan</refname>
 <refpurpose>
     sequentially scan a SCSI target
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>scsi_sequential_lun_scan </function></funcdef>
   <paramdef>struct scsi_target * <parameter>starget</parameter></paramdef>
   <paramdef>int <parameter>bflags</parameter></paramdef>
   <paramdef>int <parameter>scsi_level</parameter></paramdef>
   <paramdef>int <parameter>rescan</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>starget</parameter></term>
   <listitem>
    <para>
     pointer to target structure to scan
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>bflags</parameter></term>
   <listitem>
    <para>
     black/white list flag for LUN 0
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>scsi_level</parameter></term>
   <listitem>
    <para>
     Which version of the standard does this device adhere to
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>rescan</parameter></term>
   <listitem>
    <para>
     passed to <function>scsi_probe_add_lun</function>
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Generally, scan from LUN 1 (LUN 0 is assumed to already have been
   scanned) to some maximum lun until a LUN is found with no device
   attached. Use the bflags to figure out any oddities.
   </para><para>

   Modifies sdevscan-&gt;lun.
</para>
</refsect1>
</refentry>

<refentry id="API-scsi-report-lun-scan">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>scsi_report_lun_scan</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>scsi_report_lun_scan</refname>
 <refpurpose>
     Scan using SCSI REPORT LUN results
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>scsi_report_lun_scan </function></funcdef>
   <paramdef>struct scsi_target * <parameter>starget</parameter></paramdef>
   <paramdef>int <parameter>bflags</parameter></paramdef>
   <paramdef>int <parameter>rescan</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>starget</parameter></term>
   <listitem>
    <para>
     which target
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>bflags</parameter></term>
   <listitem>
    <para>
     Zero or a mix of BLIST_NOLUN, BLIST_REPORTLUN2, or BLIST_NOREPORTLUN
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>rescan</parameter></term>
   <listitem>
    <para>
     nonzero if we can skip code only needed on first scan
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Fast scanning for modern (SCSI-3) devices by sending a REPORT LUN command.
   Scan the resulting list of LUNs by calling scsi_probe_and_add_lun.
   </para><para>

   If BLINK_REPORTLUN2 is set, scan a target that supports more than 8
   LUNs even if it's older than SCSI-3.
   If BLIST_NOREPORTLUN is set, return 1 always.
   If BLIST_NOLUN is set, return 0 always.
   If starget-&gt;no_report_luns is set, return 1 always.
</para>
</refsect1>
<refsect1>
<title>0</title>
<para>
   scan completed (or no memory, so further scanning is futile)
</para>
</refsect1>
<refsect1>
<title>1</title>
<para>
   could not scan with REPORT LUN
</para>
</refsect1>
</refentry>

<refentry id="API-scsi-prep-async-scan">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>scsi_prep_async_scan</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>scsi_prep_async_scan</refname>
 <refpurpose>
     prepare for an async scan
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct async_scan_data * <function>scsi_prep_async_scan </function></funcdef>
   <paramdef>struct Scsi_Host * <parameter>shost</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>shost</parameter></term>
   <listitem>
    <para>
     the host which will be scanned
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Returns</title>
<para>
   a cookie to be passed to <function>scsi_finish_async_scan</function>
   </para><para>

   Tells the midlayer this host is going to do an asynchronous scan.
   It reserves the host's position in the scanning list and ensures
   that other asynchronous scans started after this one won't affect the
   ordering of the discovered devices.
</para>
</refsect1>
</refentry>

<refentry id="API-scsi-finish-async-scan">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>scsi_finish_async_scan</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>scsi_finish_async_scan</refname>
 <refpurpose>
     asynchronous scan has finished
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>scsi_finish_async_scan </function></funcdef>
   <paramdef>struct async_scan_data * <parameter>data</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>data</parameter></term>
   <listitem>
    <para>
     cookie returned from earlier call to <function>scsi_prep_async_scan</function>
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   All the devices currently attached to this host have been found.
   This function announces all the devices it has found to the rest
   of the system.
</para>
</refsect1>
</refentry>

      </sect2>
      <sect2 id="scsi_sysctl.c">
        <title>drivers/scsi/scsi_sysctl.c</title>
        <para>
          Set up the sysctl entry: "/dev/scsi/logging_level"
          (DEV_SCSI_LOGGING_LEVEL) which sets/returns scsi_logging_level.
        </para>
      </sect2>
      <sect2 id="scsi_sysfs.c">
        <title>drivers/scsi/scsi_sysfs.c</title>
        <para>
          SCSI sysfs interface routines.
        </para>
<!-- drivers/scsi/scsi_sysfs.c -->
<refentry id="API-scsi-remove-device">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>scsi_remove_device</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>scsi_remove_device</refname>
 <refpurpose>
  unregister a device from the scsi bus
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>scsi_remove_device </function></funcdef>
   <paramdef>struct scsi_device * <parameter>sdev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>sdev</parameter></term>
   <listitem>
    <para>
     scsi_device to unregister
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-scsi-remove-target">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>scsi_remove_target</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>scsi_remove_target</refname>
 <refpurpose>
     try to remove a target and all its devices
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>scsi_remove_target </function></funcdef>
   <paramdef>struct device * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     generic starget or parent of generic stargets to be removed
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Note</title>
<para>
   This is slightly racy.  It is possible that if the user
   requests the addition of another device then the target won't be
   removed.
</para>
</refsect1>
</refentry>

      </sect2>
      <sect2 id="hosts.c">
        <title>drivers/scsi/hosts.c</title>
        <para>
          mid to lowlevel SCSI driver interface
        </para>
<!-- drivers/scsi/hosts.c -->
<refentry id="API-scsi-host-set-state">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>scsi_host_set_state</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>scsi_host_set_state</refname>
 <refpurpose>
  Take the given host through the host state model.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>scsi_host_set_state </function></funcdef>
   <paramdef>struct Scsi_Host * <parameter>shost</parameter></paramdef>
   <paramdef>enum scsi_host_state <parameter>state</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>shost</parameter></term>
   <listitem>
    <para>
     scsi host to change the state of.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>state</parameter></term>
   <listitem>
    <para>
     state to change to.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Returns zero if unsuccessful or an error if the requested
   transition is illegal.
</para>
</refsect1>
</refentry>

<refentry id="API-scsi-remove-host">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>scsi_remove_host</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>scsi_remove_host</refname>
 <refpurpose>
     remove a scsi host
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>scsi_remove_host </function></funcdef>
   <paramdef>struct Scsi_Host * <parameter>shost</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>shost</parameter></term>
   <listitem>
    <para>
     a pointer to a scsi host to remove
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-scsi-add-host-with-dma">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>scsi_add_host_with_dma</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>scsi_add_host_with_dma</refname>
 <refpurpose>
     add a scsi host with dma device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>scsi_add_host_with_dma </function></funcdef>
   <paramdef>struct Scsi_Host * <parameter>shost</parameter></paramdef>
   <paramdef>struct device * <parameter>dev</parameter></paramdef>
   <paramdef>struct device * <parameter>dma_dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>shost</parameter></term>
   <listitem>
    <para>
     scsi host pointer to add
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     a struct device of type scsi class
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>dma_dev</parameter></term>
   <listitem>
    <para>
     dma device for the host
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Note</title>
<para>
   You rarely need to worry about this unless you're in a
   virtualised host environments, so use the simpler <function>scsi_add_host</function>
   function instead.
</para>
</refsect1>
<refsect1>
<title>Return value</title>
<para>
   </para><para>

   0 on success / != 0 for error
</para>
</refsect1>
</refentry>

<refentry id="API-scsi-host-alloc">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>scsi_host_alloc</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>scsi_host_alloc</refname>
 <refpurpose>
     register a scsi host adapter instance.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct Scsi_Host * <function>scsi_host_alloc </function></funcdef>
   <paramdef>struct scsi_host_template * <parameter>sht</parameter></paramdef>
   <paramdef>int <parameter>privsize</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>sht</parameter></term>
   <listitem>
    <para>
     pointer to scsi host template
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>privsize</parameter></term>
   <listitem>
    <para>
     extra bytes to allocate for driver
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Note</title>
<para>
   Allocate a new Scsi_Host and perform basic initialization.
   The host is not published to the scsi midlayer until scsi_add_host
   is called.
</para>
</refsect1>
<refsect1>
<title>Return value</title>
<para>
   Pointer to a new Scsi_Host
</para>
</refsect1>
</refentry>

<refentry id="API-scsi-host-lookup">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>scsi_host_lookup</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>scsi_host_lookup</refname>
 <refpurpose>
     get a reference to a Scsi_Host by host no
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct Scsi_Host * <function>scsi_host_lookup </function></funcdef>
   <paramdef>unsigned short <parameter>hostnum</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>hostnum</parameter></term>
   <listitem>
    <para>
     host number to locate
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Return value</title>
<para>
   A pointer to located Scsi_Host or NULL.
   </para><para>

   The caller must do a <function>scsi_host_put</function> to drop the reference
   that <function>scsi_host_get</function> took. The <function>put_device</function> below dropped
   the reference from <function>class_find_device</function>.
</para>
</refsect1>
</refentry>

<refentry id="API-scsi-host-get">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>scsi_host_get</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>scsi_host_get</refname>
 <refpurpose>
     inc a Scsi_Host ref count
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct Scsi_Host * <function>scsi_host_get </function></funcdef>
   <paramdef>struct Scsi_Host * <parameter>shost</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>shost</parameter></term>
   <listitem>
    <para>
     Pointer to Scsi_Host to inc.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-scsi-host-put">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>scsi_host_put</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>scsi_host_put</refname>
 <refpurpose>
     dec a Scsi_Host ref count
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>scsi_host_put </function></funcdef>
   <paramdef>struct Scsi_Host * <parameter>shost</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>shost</parameter></term>
   <listitem>
    <para>
     Pointer to Scsi_Host to dec.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-scsi-queue-work">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>scsi_queue_work</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>scsi_queue_work</refname>
 <refpurpose>
     Queue work to the Scsi_Host workqueue.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>scsi_queue_work </function></funcdef>
   <paramdef>struct Scsi_Host * <parameter>shost</parameter></paramdef>
   <paramdef>struct work_struct * <parameter>work</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>shost</parameter></term>
   <listitem>
    <para>
     Pointer to Scsi_Host.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>work</parameter></term>
   <listitem>
    <para>
     Work to queue for execution.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Return value</title>
<para>
   1 - work queued for execution
   0 - work is already queued
   -EINVAL - work queue doesn't exist
</para>
</refsect1>
</refentry>

<refentry id="API-scsi-flush-work">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>scsi_flush_work</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>scsi_flush_work</refname>
 <refpurpose>
     Flush a Scsi_Host's workqueue.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>scsi_flush_work </function></funcdef>
   <paramdef>struct Scsi_Host * <parameter>shost</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>shost</parameter></term>
   <listitem>
    <para>
     Pointer to Scsi_Host.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

      </sect2>
      <sect2 id="constants.c">
        <title>drivers/scsi/constants.c</title>
        <para>
          mid to lowlevel SCSI driver interface
        </para>
<!-- drivers/scsi/constants.c -->
<refentry id="API-scsi-print-status">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>scsi_print_status</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>scsi_print_status</refname>
 <refpurpose>
  print scsi status description
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>scsi_print_status </function></funcdef>
   <paramdef>unsigned char <parameter>scsi_status</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>scsi_status</parameter></term>
   <listitem>
    <para>
     scsi status value
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   If the status is recognized, the description is printed.
   Otherwise <quote>Unknown status</quote> is output. No trailing space.
   If CONFIG_SCSI_CONSTANTS is not set, then print status in hex
   (e.g. <quote>0x2</quote> for Check Condition).
</para>
</refsect1>
</refentry>

      </sect2>
    </sect1>

    <sect1 id="Transport_classes">
      <title>Transport classes</title>
      <para>
        Transport classes are service libraries for drivers in the SCSI
        lower layer, which expose transport attributes in sysfs.
      </para>
      <sect2 id="Fibre_Channel_transport">
        <title>Fibre Channel transport</title>
        <para>
          The file drivers/scsi/scsi_transport_fc.c defines transport attributes
          for Fibre Channel.
        </para>
<!-- drivers/scsi/scsi_transport_fc.c -->
<refentry id="API-fc-get-event-number">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>fc_get_event_number</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>fc_get_event_number</refname>
 <refpurpose>
  Obtain the next sequential FC event number
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>u32 <function>fc_get_event_number </function></funcdef>
   <paramdef> <parameter>void</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>void</parameter></term>
   <listitem>
    <para>
     no arguments
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Notes</title>
<para>
   We could have inlined this, but it would have required fc_event_seq to
   be exposed. For now, live with the subroutine call.
   Atomic used to avoid lock/unlock...
</para>
</refsect1>
</refentry>

<refentry id="API-fc-host-post-event">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>fc_host_post_event</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>fc_host_post_event</refname>
 <refpurpose>
     called to post an even on an fc_host.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>fc_host_post_event </function></funcdef>
   <paramdef>struct Scsi_Host * <parameter>shost</parameter></paramdef>
   <paramdef>u32 <parameter>event_number</parameter></paramdef>
   <paramdef>enum fc_host_event_code <parameter>event_code</parameter></paramdef>
   <paramdef>u32 <parameter>event_data</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>shost</parameter></term>
   <listitem>
    <para>
     host the event occurred on
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>event_number</parameter></term>
   <listitem>
    <para>
     fc event number obtained from <function>get_fc_event_number</function>
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>event_code</parameter></term>
   <listitem>
    <para>
     fc_host event being posted
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>event_data</parameter></term>
   <listitem>
    <para>
     32bits of data for the event being posted
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Notes</title>
<para>
   This routine assumes no locks are held on entry.
</para>
</refsect1>
</refentry>

<refentry id="API-fc-host-post-vendor-event">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>fc_host_post_vendor_event</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>fc_host_post_vendor_event</refname>
 <refpurpose>
     called to post a vendor unique event on an fc_host
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>fc_host_post_vendor_event </function></funcdef>
   <paramdef>struct Scsi_Host * <parameter>shost</parameter></paramdef>
   <paramdef>u32 <parameter>event_number</parameter></paramdef>
   <paramdef>u32 <parameter>data_len</parameter></paramdef>
   <paramdef>char * <parameter>data_buf</parameter></paramdef>
   <paramdef>u64 <parameter>vendor_id</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>shost</parameter></term>
   <listitem>
    <para>
     host the event occurred on
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>event_number</parameter></term>
   <listitem>
    <para>
     fc event number obtained from <function>get_fc_event_number</function>
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>data_len</parameter></term>
   <listitem>
    <para>
     amount, in bytes, of vendor unique data
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>data_buf</parameter></term>
   <listitem>
    <para>
     pointer to vendor unique data
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>vendor_id</parameter></term>
   <listitem>
    <para>
     Vendor id
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Notes</title>
<para>
   This routine assumes no locks are held on entry.
</para>
</refsect1>
</refentry>

<refentry id="API-fc-remove-host">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>fc_remove_host</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>fc_remove_host</refname>
 <refpurpose>
     called to terminate any fc_transport-related elements for a scsi host.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>fc_remove_host </function></funcdef>
   <paramdef>struct Scsi_Host * <parameter>shost</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>shost</parameter></term>
   <listitem>
    <para>
     Which <structname>Scsi_Host</structname>
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This routine is expected to be called immediately preceding the
   a driver's call to <function>scsi_remove_host</function>.
</para>
</refsect1>
<refsect1>
<title>WARNING</title>
<para>
   A driver utilizing the fc_transport, which fails to call
   this routine prior to <function>scsi_remove_host</function>, will leave dangling
   objects in /sys/class/fc_remote_ports. Access to any of these
   objects can result in a system crash !!!
</para>
</refsect1>
<refsect1>
<title>Notes</title>
<para>
   This routine assumes no locks are held on entry.
</para>
</refsect1>
</refentry>

<refentry id="API-fc-remote-port-add">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>fc_remote_port_add</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>fc_remote_port_add</refname>
 <refpurpose>
     notify fc transport of the existence of a remote FC port.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct fc_rport * <function>fc_remote_port_add </function></funcdef>
   <paramdef>struct Scsi_Host * <parameter>shost</parameter></paramdef>
   <paramdef>int <parameter>channel</parameter></paramdef>
   <paramdef>struct fc_rport_identifiers * <parameter>ids</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>shost</parameter></term>
   <listitem>
    <para>
     scsi host the remote port is connected to.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>channel</parameter></term>
   <listitem>
    <para>
     Channel on shost port connected to.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>ids</parameter></term>
   <listitem>
    <para>
     The world wide names, fc address, and FC4 port
     roles for the remote port.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   The LLDD calls this routine to notify the transport of the existence
   of a remote port. The LLDD provides the unique identifiers (wwpn,wwn)
   of the port, it's FC address (port_id), and the FC4 roles that are
   active for the port.
   </para><para>

   For ports that are FCP targets (aka scsi targets), the FC transport
   maintains consistent target id bindings on behalf of the LLDD.
   A consistent target id binding is an assignment of a target id to
   a remote port identifier, which persists while the scsi host is
   attached. The remote port can disappear, then later reappear, and
   it's target id assignment remains the same. This allows for shifts
   in FC addressing (if binding by wwpn or wwnn) with no apparent
   changes to the scsi subsystem which is based on scsi host number and
   target id values.  Bindings are only valid during the attachment of
   the scsi host. If the host detaches, then later re-attaches, target
   id bindings may change.
   </para><para>

   This routine is responsible for returning a remote port structure.
   The routine will search the list of remote ports it maintains
   internally on behalf of consistent target id mappings. If found, the
   remote port structure will be reused. Otherwise, a new remote port
   structure will be allocated.
   </para><para>

   Whenever a remote port is allocated, a new fc_remote_port class
   device is created.
   </para><para>

   Should not be called from interrupt context.
</para>
</refsect1>
<refsect1>
<title>Notes</title>
<para>
   This routine assumes no locks are held on entry.
</para>
</refsect1>
</refentry>

<refentry id="API-fc-remote-port-delete">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>fc_remote_port_delete</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>fc_remote_port_delete</refname>
 <refpurpose>
     notifies the fc transport that a remote port is no longer in existence.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>fc_remote_port_delete </function></funcdef>
   <paramdef>struct fc_rport * <parameter>rport</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>rport</parameter></term>
   <listitem>
    <para>
     The remote port that no longer exists
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   The LLDD calls this routine to notify the transport that a remote
   port is no longer part of the topology. Note: Although a port
   may no longer be part of the topology, it may persist in the remote
   ports displayed by the fc_host. We do this under 2 conditions:
   1) If the port was a scsi target, we delay its deletion by <quote>blocking</quote> it.
   This allows the port to temporarily disappear, then reappear without
   disrupting the SCSI device tree attached to it. During the <quote>blocked</quote>
   period the port will still exist.
   2) If the port was a scsi target and disappears for longer than we
   expect, we'll delete the port and the tear down the SCSI device tree
   attached to it. However, we want to semi-persist the target id assigned
   to that port if it eventually does exist. The port structure will
   remain (although with minimal information) so that the target id
   bindings remails.
   </para><para>

   If the remote port is not an FCP Target, it will be fully torn down
   and deallocated, including the fc_remote_port class device.
   </para><para>

   If the remote port is an FCP Target, the port will be placed in a
   temporary blocked state. From the LLDD's perspective, the rport no
   longer exists. From the SCSI midlayer's perspective, the SCSI target
   exists, but all sdevs on it are blocked from further I/O. The following
   is then expected.
   </para><para>

   If the remote port does not return (signaled by a LLDD call to
   <function>fc_remote_port_add</function>) within the dev_loss_tmo timeout, then the
   scsi target is removed - killing all outstanding i/o and removing the
   scsi devices attached ot it. The port structure will be marked Not
   Present and be partially cleared, leaving only enough information to
   recognize the remote port relative to the scsi target id binding if
   it later appears.  The port will remain as long as there is a valid
   binding (e.g. until the user changes the binding type or unloads the
   scsi host with the binding).
   </para><para>

   If the remote port returns within the dev_loss_tmo value (and matches
   according to the target id binding type), the port structure will be
   reused. If it is no longer a SCSI target, the target will be torn
   down. If it continues to be a SCSI target, then the target will be
   unblocked (allowing i/o to be resumed), and a scan will be activated
   to ensure that all luns are detected.
   </para><para>

   Called from normal process context only - cannot be called from interrupt.
</para>
</refsect1>
<refsect1>
<title>Notes</title>
<para>
   This routine assumes no locks are held on entry.
</para>
</refsect1>
</refentry>

<refentry id="API-fc-remote-port-rolechg">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>fc_remote_port_rolechg</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>fc_remote_port_rolechg</refname>
 <refpurpose>
     notifies the fc transport that the roles on a remote may have changed.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>fc_remote_port_rolechg </function></funcdef>
   <paramdef>struct fc_rport * <parameter>rport</parameter></paramdef>
   <paramdef>u32 <parameter>roles</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>rport</parameter></term>
   <listitem>
    <para>
     The remote port that changed.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>roles</parameter></term>
   <listitem>
    <para>
     New roles for this port.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   The LLDD calls this routine to notify the transport that the
   roles on a remote port may have changed. The largest effect of this is
   if a port now becomes a FCP Target, it must be allocated a
   scsi target id.  If the port is no longer a FCP target, any
   scsi target id value assigned to it will persist in case the
   role changes back to include FCP Target. No changes in the scsi
   midlayer will be invoked if the role changes (in the expectation
   that the role will be resumed. If it doesn't normal error processing
   will take place).
   </para><para>

   Should not be called from interrupt context.
</para>
</refsect1>
<refsect1>
<title>Notes</title>
<para>
   This routine assumes no locks are held on entry.
</para>
</refsect1>
</refentry>

<refentry id="API-fc-block-scsi-eh">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>fc_block_scsi_eh</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>fc_block_scsi_eh</refname>
 <refpurpose>
     Block SCSI eh thread for blocked fc_rport
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>fc_block_scsi_eh </function></funcdef>
   <paramdef>struct scsi_cmnd * <parameter>cmnd</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>cmnd</parameter></term>
   <listitem>
    <para>
     SCSI command that scsi_eh is trying to recover
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This routine can be called from a FC LLD scsi_eh callback. It
   blocks the scsi_eh thread until the fc_rport leaves the
   FC_PORTSTATE_BLOCKED, or the fast_io_fail_tmo fires. This is
   necessary to avoid the scsi_eh failing recovery actions for blocked
   rports which would lead to offlined SCSI devices.
</para>
</refsect1>
<refsect1>
<title>Returns</title>
<para>
   0 if the fc_rport left the state FC_PORTSTATE_BLOCKED.
   FAST_IO_FAIL if the fast_io_fail_tmo fired, this should be
   passed back to scsi_eh.
</para>
</refsect1>
</refentry>

<refentry id="API-fc-vport-create">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>fc_vport_create</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>fc_vport_create</refname>
 <refpurpose>
     Admin App or LLDD requests creation of a vport
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct fc_vport * <function>fc_vport_create </function></funcdef>
   <paramdef>struct Scsi_Host * <parameter>shost</parameter></paramdef>
   <paramdef>int <parameter>channel</parameter></paramdef>
   <paramdef>struct fc_vport_identifiers * <parameter>ids</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>shost</parameter></term>
   <listitem>
    <para>
     scsi host the virtual port is connected to.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>channel</parameter></term>
   <listitem>
    <para>
     channel on shost port connected to.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>ids</parameter></term>
   <listitem>
    <para>
     The world wide names, FC4 port roles, etc for
     the virtual port.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Notes</title>
<para>
   This routine assumes no locks are held on entry.
</para>
</refsect1>
</refentry>

<refentry id="API-fc-vport-terminate">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>fc_vport_terminate</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>fc_vport_terminate</refname>
 <refpurpose>
     Admin App or LLDD requests termination of a vport
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>fc_vport_terminate </function></funcdef>
   <paramdef>struct fc_vport * <parameter>vport</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>vport</parameter></term>
   <listitem>
    <para>
     fc_vport to be terminated
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Calls the LLDD <function>vport_delete</function> function, then deallocates and removes
   the vport from the shost and object tree.
</para>
</refsect1>
<refsect1>
<title>Notes</title>
<para>
   This routine assumes no locks are held on entry.
</para>
</refsect1>
</refentry>

      </sect2>
      <sect2 id="iSCSI_transport">
        <title>iSCSI transport class</title>
        <para>
          The file drivers/scsi/scsi_transport_iscsi.c defines transport
          attributes for the iSCSI class, which sends SCSI packets over TCP/IP
          connections.
        </para>
<!-- drivers/scsi/scsi_transport_iscsi.c -->
<refentry id="API-iscsi-create-flashnode-sess">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>iscsi_create_flashnode_sess</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>iscsi_create_flashnode_sess</refname>
 <refpurpose>
  Add flashnode session entry in sysfs
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct iscsi_bus_flash_session * <function>iscsi_create_flashnode_sess </function></funcdef>
   <paramdef>struct Scsi_Host * <parameter>shost</parameter></paramdef>
   <paramdef>int <parameter>index</parameter></paramdef>
   <paramdef>struct iscsi_transport * <parameter>transport</parameter></paramdef>
   <paramdef>int <parameter>dd_size</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>shost</parameter></term>
   <listitem>
    <para>
     pointer to host data
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>index</parameter></term>
   <listitem>
    <para>
     index of flashnode to add in sysfs
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>transport</parameter></term>
   <listitem>
    <para>
     pointer to transport data
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>dd_size</parameter></term>
   <listitem>
    <para>
     total size to allocate
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Adds a sysfs entry for the flashnode session attributes
</para>
</refsect1>
<refsect1>
<title>Returns</title>
<para>
   pointer to allocated flashnode sess on success
   <constant>NULL</constant> on failure
</para>
</refsect1>
</refentry>

<refentry id="API-iscsi-create-flashnode-conn">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>iscsi_create_flashnode_conn</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>iscsi_create_flashnode_conn</refname>
 <refpurpose>
     Add flashnode conn entry in sysfs
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct iscsi_bus_flash_conn * <function>iscsi_create_flashnode_conn </function></funcdef>
   <paramdef>struct Scsi_Host * <parameter>shost</parameter></paramdef>
   <paramdef>struct iscsi_bus_flash_session * <parameter>fnode_sess</parameter></paramdef>
   <paramdef>struct iscsi_transport * <parameter>transport</parameter></paramdef>
   <paramdef>int <parameter>dd_size</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>shost</parameter></term>
   <listitem>
    <para>
     pointer to host data
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>fnode_sess</parameter></term>
   <listitem>
    <para>
     pointer to the parent flashnode session entry
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>transport</parameter></term>
   <listitem>
    <para>
     pointer to transport data
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>dd_size</parameter></term>
   <listitem>
    <para>
     total size to allocate
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Adds a sysfs entry for the flashnode connection attributes
</para>
</refsect1>
<refsect1>
<title>Returns</title>
<para>
   pointer to allocated flashnode conn on success
   <constant>NULL</constant> on failure
</para>
</refsect1>
</refentry>

<refentry id="API-iscsi-is-flashnode-conn-dev">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>iscsi_is_flashnode_conn_dev</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>iscsi_is_flashnode_conn_dev</refname>
 <refpurpose>
     verify passed device is to be flashnode conn
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>iscsi_is_flashnode_conn_dev </function></funcdef>
   <paramdef>struct device * <parameter>dev</parameter></paramdef>
   <paramdef>void * <parameter>data</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     device to verify
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>data</parameter></term>
   <listitem>
    <para>
     pointer to data containing value to use for verification
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Verifies if the passed device is flashnode conn device
</para>
</refsect1>
<refsect1>
<title>Returns</title>
<para>
   1 on success
   0 on failure
</para>
</refsect1>
</refentry>

<refentry id="API-iscsi-find-flashnode-sess">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>iscsi_find_flashnode_sess</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>iscsi_find_flashnode_sess</refname>
 <refpurpose>
     finds flashnode session entry
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct device * <function>iscsi_find_flashnode_sess </function></funcdef>
   <paramdef>struct Scsi_Host * <parameter>shost</parameter></paramdef>
   <paramdef>void * <parameter>data</parameter></paramdef>
   <paramdef>int (*<parameter>fn</parameter>)
     <funcparams>struct device *dev, void *data</funcparams></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>shost</parameter></term>
   <listitem>
    <para>
     pointer to host data
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>data</parameter></term>
   <listitem>
    <para>
     pointer to data containing value to use for comparison
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>fn</parameter></term>
   <listitem>
    <para>
     function pointer that does actual comparison
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Finds the flashnode session object comparing the data passed using logic
   defined in passed function pointer
</para>
</refsect1>
<refsect1>
<title>Returns</title>
<para>
   pointer to found flashnode session device object on success
   <constant>NULL</constant> on failure
</para>
</refsect1>
</refentry>

<refentry id="API-iscsi-find-flashnode-conn">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>iscsi_find_flashnode_conn</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>iscsi_find_flashnode_conn</refname>
 <refpurpose>
     finds flashnode connection entry
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct device * <function>iscsi_find_flashnode_conn </function></funcdef>
   <paramdef>struct iscsi_bus_flash_session * <parameter>fnode_sess</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>fnode_sess</parameter></term>
   <listitem>
    <para>
     pointer to parent flashnode session entry
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Finds the flashnode connection object comparing the data passed using logic
   defined in passed function pointer
</para>
</refsect1>
<refsect1>
<title>Returns</title>
<para>
   pointer to found flashnode connection device object on success
   <constant>NULL</constant> on failure
</para>
</refsect1>
</refentry>

<refentry id="API-iscsi-destroy-flashnode-sess">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>iscsi_destroy_flashnode_sess</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>iscsi_destroy_flashnode_sess</refname>
 <refpurpose>
     destroy flashnode session entry
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>iscsi_destroy_flashnode_sess </function></funcdef>
   <paramdef>struct iscsi_bus_flash_session * <parameter>fnode_sess</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>fnode_sess</parameter></term>
   <listitem>
    <para>
     pointer to flashnode session entry to be destroyed
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Deletes the flashnode session entry and all children flashnode connection
   entries from sysfs
</para>
</refsect1>
</refentry>

<refentry id="API-iscsi-destroy-all-flashnode">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>iscsi_destroy_all_flashnode</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>iscsi_destroy_all_flashnode</refname>
 <refpurpose>
     destroy all flashnode session entries
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>iscsi_destroy_all_flashnode </function></funcdef>
   <paramdef>struct Scsi_Host * <parameter>shost</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>shost</parameter></term>
   <listitem>
    <para>
     pointer to host data
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Destroys all the flashnode session entries and all corresponding children
   flashnode connection entries from sysfs
</para>
</refsect1>
</refentry>

<refentry id="API-iscsi-scan-finished">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>iscsi_scan_finished</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>iscsi_scan_finished</refname>
 <refpurpose>
     helper to report when running scans are done
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>iscsi_scan_finished </function></funcdef>
   <paramdef>struct Scsi_Host * <parameter>shost</parameter></paramdef>
   <paramdef>unsigned long <parameter>time</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>shost</parameter></term>
   <listitem>
    <para>
     scsi host
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>time</parameter></term>
   <listitem>
    <para>
     scan run time
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This function can be used by drives like qla4xxx to report to the scsi
   layer when the scans it kicked off at module load time are done.
</para>
</refsect1>
</refentry>

<refentry id="API-iscsi-block-scsi-eh">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>iscsi_block_scsi_eh</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>iscsi_block_scsi_eh</refname>
 <refpurpose>
     block scsi eh until session state has transistioned
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>iscsi_block_scsi_eh </function></funcdef>
   <paramdef>struct scsi_cmnd * <parameter>cmd</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>cmd</parameter></term>
   <listitem>
    <para>
     scsi cmd passed to scsi eh handler
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   If the session is down this function will wait for the recovery
   timer to fire or for the session to be logged back in. If the
   recovery timer fires then FAST_IO_FAIL is returned. The caller
   should pass this error value to the scsi eh.
</para>
</refsect1>
</refentry>

<refentry id="API-iscsi-unblock-session">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>iscsi_unblock_session</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>iscsi_unblock_session</refname>
 <refpurpose>
     set a session as logged in and start IO.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>iscsi_unblock_session </function></funcdef>
   <paramdef>struct iscsi_cls_session * <parameter>session</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>session</parameter></term>
   <listitem>
    <para>
     iscsi session
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Mark a session as ready to accept IO.
</para>
</refsect1>
</refentry>

<refentry id="API-iscsi-create-session">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>iscsi_create_session</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>iscsi_create_session</refname>
 <refpurpose>
     create iscsi class session
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct iscsi_cls_session * <function>iscsi_create_session </function></funcdef>
   <paramdef>struct Scsi_Host * <parameter>shost</parameter></paramdef>
   <paramdef>struct iscsi_transport * <parameter>transport</parameter></paramdef>
   <paramdef>int <parameter>dd_size</parameter></paramdef>
   <paramdef>unsigned int <parameter>target_id</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>shost</parameter></term>
   <listitem>
    <para>
     scsi host
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>transport</parameter></term>
   <listitem>
    <para>
     iscsi transport
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>dd_size</parameter></term>
   <listitem>
    <para>
     private driver data size
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>target_id</parameter></term>
   <listitem>
    <para>
     which target
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This can be called from a LLD or iscsi_transport.
</para>
</refsect1>
</refentry>

<refentry id="API-iscsi-destroy-session">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>iscsi_destroy_session</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>iscsi_destroy_session</refname>
 <refpurpose>
     destroy iscsi session
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>iscsi_destroy_session </function></funcdef>
   <paramdef>struct iscsi_cls_session * <parameter>session</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>session</parameter></term>
   <listitem>
    <para>
     iscsi_session
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Can be called by a LLD or iscsi_transport. There must not be
   any running connections.
</para>
</refsect1>
</refentry>

<refentry id="API-iscsi-create-conn">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>iscsi_create_conn</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>iscsi_create_conn</refname>
 <refpurpose>
     create iscsi class connection
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct iscsi_cls_conn * <function>iscsi_create_conn </function></funcdef>
   <paramdef>struct iscsi_cls_session * <parameter>session</parameter></paramdef>
   <paramdef>int <parameter>dd_size</parameter></paramdef>
   <paramdef>uint32_t <parameter>cid</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>session</parameter></term>
   <listitem>
    <para>
     iscsi cls session
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>dd_size</parameter></term>
   <listitem>
    <para>
     private driver data size
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>cid</parameter></term>
   <listitem>
    <para>
     connection id
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This can be called from a LLD or iscsi_transport. The connection
   is child of the session so cid must be unique for all connections
   on the session.
   </para><para>

   Since we do not support MCS, cid will normally be zero. In some cases
   for software iscsi we could be trying to preallocate a connection struct
   in which case there could be two connection structs and cid would be
   non-zero.
</para>
</refsect1>
</refentry>

<refentry id="API-iscsi-destroy-conn">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>iscsi_destroy_conn</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>iscsi_destroy_conn</refname>
 <refpurpose>
     destroy iscsi class connection
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>iscsi_destroy_conn </function></funcdef>
   <paramdef>struct iscsi_cls_conn * <parameter>conn</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>conn</parameter></term>
   <listitem>
    <para>
     iscsi cls session
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This can be called from a LLD or iscsi_transport.
</para>
</refsect1>
</refentry>

<refentry id="API-iscsi-session-event">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>iscsi_session_event</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>iscsi_session_event</refname>
 <refpurpose>
     send session destr. completion event
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>iscsi_session_event </function></funcdef>
   <paramdef>struct iscsi_cls_session * <parameter>session</parameter></paramdef>
   <paramdef>enum iscsi_uevent_e <parameter>event</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>session</parameter></term>
   <listitem>
    <para>
     iscsi class session
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>event</parameter></term>
   <listitem>
    <para>
     type of event
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

      </sect2>
      <sect2 id="SAS_transport">
        <title>Serial Attached SCSI (SAS) transport class</title>
        <para>
          The file drivers/scsi/scsi_transport_sas.c defines transport
          attributes for Serial Attached SCSI, a variant of SATA aimed at
          large high-end systems.
        </para>
        <para>
          The SAS transport class contains common code to deal with SAS HBAs,
          an aproximated representation of SAS topologies in the driver model,
          and various sysfs attributes to expose these topologies and management
          interfaces to userspace.
        </para>
        <para>
          In addition to the basic SCSI core objects this transport class
          introduces two additional intermediate objects:  The SAS PHY
          as represented by struct sas_phy defines an "outgoing" PHY on
          a SAS HBA or Expander, and the SAS remote PHY represented by
          struct sas_rphy defines an "incoming" PHY on a SAS Expander or
          end device.  Note that this is purely a software concept, the
          underlying hardware for a PHY and a remote PHY is the exactly
          the same.
        </para>
        <para>
          There is no concept of a SAS port in this code, users can see
          what PHYs form a wide port based on the port_identifier attribute,
          which is the same for all PHYs in a port.
        </para>
<!-- drivers/scsi/scsi_transport_sas.c -->
<refentry id="API-sas-remove-children">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>sas_remove_children</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>sas_remove_children</refname>
 <refpurpose>
  tear down a devices SAS data structures
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>sas_remove_children </function></funcdef>
   <paramdef>struct device * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     device belonging to the sas object
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Removes all SAS PHYs and remote PHYs for a given object
</para>
</refsect1>
</refentry>

<refentry id="API-sas-remove-host">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>sas_remove_host</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>sas_remove_host</refname>
 <refpurpose>
     tear down a Scsi_Host's SAS data structures
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>sas_remove_host </function></funcdef>
   <paramdef>struct Scsi_Host * <parameter>shost</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>shost</parameter></term>
   <listitem>
    <para>
     Scsi Host that is torn down
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Removes all SAS PHYs and remote PHYs for a given Scsi_Host.
   Must be called just before scsi_remove_host for SAS HBAs.
</para>
</refsect1>
</refentry>

<refentry id="API-sas-tlr-supported">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>sas_tlr_supported</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>sas_tlr_supported</refname>
 <refpurpose>
     checking TLR bit in vpd 0x90
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>unsigned int <function>sas_tlr_supported </function></funcdef>
   <paramdef>struct scsi_device * <parameter>sdev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>sdev</parameter></term>
   <listitem>
    <para>
     scsi device struct
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Check Transport Layer Retries are supported or not.
   If vpd page 0x90 is present, TRL is supported.
</para>
</refsect1>
</refentry>

<refentry id="API-sas-disable-tlr">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>sas_disable_tlr</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>sas_disable_tlr</refname>
 <refpurpose>
     setting TLR flags
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>sas_disable_tlr </function></funcdef>
   <paramdef>struct scsi_device * <parameter>sdev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>sdev</parameter></term>
   <listitem>
    <para>
     scsi device struct
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Seting tlr_enabled flag to 0.
</para>
</refsect1>
</refentry>

<refentry id="API-sas-enable-tlr">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>sas_enable_tlr</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>sas_enable_tlr</refname>
 <refpurpose>
     setting TLR flags
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>sas_enable_tlr </function></funcdef>
   <paramdef>struct scsi_device * <parameter>sdev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>sdev</parameter></term>
   <listitem>
    <para>
     scsi device struct
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Seting tlr_enabled flag 1.
</para>
</refsect1>
</refentry>

<refentry id="API-sas-phy-alloc">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>sas_phy_alloc</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>sas_phy_alloc</refname>
 <refpurpose>
     allocates and initialize a SAS PHY structure
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct sas_phy * <function>sas_phy_alloc </function></funcdef>
   <paramdef>struct device * <parameter>parent</parameter></paramdef>
   <paramdef>int <parameter>number</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>parent</parameter></term>
   <listitem>
    <para>
     Parent device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>number</parameter></term>
   <listitem>
    <para>
     Phy index
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Allocates an SAS PHY structure.  It will be added in the device tree
   below the device specified by <parameter>parent</parameter>, which has to be either a Scsi_Host
   or sas_rphy.
</para>
</refsect1>
<refsect1>
<title>Returns</title>
<para>
   SAS PHY allocated or <constant>NULL</constant> if the allocation failed.
</para>
</refsect1>
</refentry>

<refentry id="API-sas-phy-add">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>sas_phy_add</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>sas_phy_add</refname>
 <refpurpose>
     add a SAS PHY to the device hierarchy
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>sas_phy_add </function></funcdef>
   <paramdef>struct sas_phy * <parameter>phy</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>phy</parameter></term>
   <listitem>
    <para>
     The PHY to be added
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Publishes a SAS PHY to the rest of the system.
</para>
</refsect1>
</refentry>

<refentry id="API-sas-phy-free">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>sas_phy_free</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>sas_phy_free</refname>
 <refpurpose>
     free a SAS PHY
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>sas_phy_free </function></funcdef>
   <paramdef>struct sas_phy * <parameter>phy</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>phy</parameter></term>
   <listitem>
    <para>
     SAS PHY to free
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Frees the specified SAS PHY.
</para>
</refsect1>
<refsect1>
<title>Note</title>
<para>
   This function must only be called on a PHY that has not
   successfully been added using <function>sas_phy_add</function>.
</para>
</refsect1>
</refentry>

<refentry id="API-sas-phy-delete">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>sas_phy_delete</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>sas_phy_delete</refname>
 <refpurpose>
     remove SAS PHY
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>sas_phy_delete </function></funcdef>
   <paramdef>struct sas_phy * <parameter>phy</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>phy</parameter></term>
   <listitem>
    <para>
     SAS PHY to remove
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Removes the specified SAS PHY.  If the SAS PHY has an
   associated remote PHY it is removed before.
</para>
</refsect1>
</refentry>

<refentry id="API-scsi-is-sas-phy">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>scsi_is_sas_phy</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>scsi_is_sas_phy</refname>
 <refpurpose>
     check if a struct device represents a SAS PHY
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>scsi_is_sas_phy </function></funcdef>
   <paramdef>const struct device * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     device to check
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Returns</title>
<para>
   <constant>1</constant> if the device represents a SAS PHY, <constant>0</constant> else
</para>
</refsect1>
</refentry>

<refentry id="API-sas-port-add">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>sas_port_add</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>sas_port_add</refname>
 <refpurpose>
     add a SAS port to the device hierarchy
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>sas_port_add </function></funcdef>
   <paramdef>struct sas_port * <parameter>port</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>port</parameter></term>
   <listitem>
    <para>
     port to be added
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   publishes a port to the rest of the system
</para>
</refsect1>
</refentry>

<refentry id="API-sas-port-free">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>sas_port_free</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>sas_port_free</refname>
 <refpurpose>
     free a SAS PORT
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>sas_port_free </function></funcdef>
   <paramdef>struct sas_port * <parameter>port</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>port</parameter></term>
   <listitem>
    <para>
     SAS PORT to free
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Frees the specified SAS PORT.
</para>
</refsect1>
<refsect1>
<title>Note</title>
<para>
   This function must only be called on a PORT that has not
   successfully been added using <function>sas_port_add</function>.
</para>
</refsect1>
</refentry>

<refentry id="API-sas-port-delete">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>sas_port_delete</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>sas_port_delete</refname>
 <refpurpose>
     remove SAS PORT
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>sas_port_delete </function></funcdef>
   <paramdef>struct sas_port * <parameter>port</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>port</parameter></term>
   <listitem>
    <para>
     SAS PORT to remove
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Removes the specified SAS PORT.  If the SAS PORT has an
   associated phys, unlink them from the port as well.
</para>
</refsect1>
</refentry>

<refentry id="API-scsi-is-sas-port">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>scsi_is_sas_port</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>scsi_is_sas_port</refname>
 <refpurpose>
     check if a struct device represents a SAS port
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>scsi_is_sas_port </function></funcdef>
   <paramdef>const struct device * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     device to check
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Returns</title>
<para>
   <constant>1</constant> if the device represents a SAS Port, <constant>0</constant> else
</para>
</refsect1>
</refentry>

<refentry id="API-sas-port-get-phy">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>sas_port_get_phy</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>sas_port_get_phy</refname>
 <refpurpose>
     try to take a reference on a port member
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct sas_phy * <function>sas_port_get_phy </function></funcdef>
   <paramdef>struct sas_port * <parameter>port</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>port</parameter></term>
   <listitem>
    <para>
     port to check
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-sas-port-add-phy">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>sas_port_add_phy</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>sas_port_add_phy</refname>
 <refpurpose>
     add another phy to a port to form a wide port
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>sas_port_add_phy </function></funcdef>
   <paramdef>struct sas_port * <parameter>port</parameter></paramdef>
   <paramdef>struct sas_phy * <parameter>phy</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>port</parameter></term>
   <listitem>
    <para>
     port to add the phy to
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>phy</parameter></term>
   <listitem>
    <para>
     phy to add
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   When a port is initially created, it is empty (has no phys).  All
   ports must have at least one phy to operated, and all wide ports
   must have at least two.  The current code makes no difference
   between ports and wide ports, but the only object that can be
   connected to a remote device is a port, so ports must be formed on
   all devices with phys if they're connected to anything.
</para>
</refsect1>
</refentry>

<refentry id="API-sas-port-delete-phy">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>sas_port_delete_phy</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>sas_port_delete_phy</refname>
 <refpurpose>
     remove a phy from a port or wide port
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>sas_port_delete_phy </function></funcdef>
   <paramdef>struct sas_port * <parameter>port</parameter></paramdef>
   <paramdef>struct sas_phy * <parameter>phy</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>port</parameter></term>
   <listitem>
    <para>
     port to remove the phy from
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>phy</parameter></term>
   <listitem>
    <para>
     phy to remove
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This operation is used for tearing down ports again.  It must be
   done to every port or wide port before calling sas_port_delete.
</para>
</refsect1>
</refentry>

<refentry id="API-sas-end-device-alloc">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>sas_end_device_alloc</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>sas_end_device_alloc</refname>
 <refpurpose>
     allocate an rphy for an end device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct sas_rphy * <function>sas_end_device_alloc </function></funcdef>
   <paramdef>struct sas_port * <parameter>parent</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>parent</parameter></term>
   <listitem>
    <para>
     which port
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Allocates an SAS remote PHY structure, connected to <parameter>parent</parameter>.
</para>
</refsect1>
<refsect1>
<title>Returns</title>
<para>
   SAS PHY allocated or <constant>NULL</constant> if the allocation failed.
</para>
</refsect1>
</refentry>

<refentry id="API-sas-expander-alloc">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>sas_expander_alloc</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>sas_expander_alloc</refname>
 <refpurpose>
     allocate an rphy for an end device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct sas_rphy * <function>sas_expander_alloc </function></funcdef>
   <paramdef>struct sas_port * <parameter>parent</parameter></paramdef>
   <paramdef>enum sas_device_type <parameter>type</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>parent</parameter></term>
   <listitem>
    <para>
     which port
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>type</parameter></term>
   <listitem>
    <para>
     SAS_EDGE_EXPANDER_DEVICE or SAS_FANOUT_EXPANDER_DEVICE
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Allocates an SAS remote PHY structure, connected to <parameter>parent</parameter>.
</para>
</refsect1>
<refsect1>
<title>Returns</title>
<para>
   SAS PHY allocated or <constant>NULL</constant> if the allocation failed.
</para>
</refsect1>
</refentry>

<refentry id="API-sas-rphy-add">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>sas_rphy_add</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>sas_rphy_add</refname>
 <refpurpose>
     add a SAS remote PHY to the device hierarchy
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>sas_rphy_add </function></funcdef>
   <paramdef>struct sas_rphy * <parameter>rphy</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>rphy</parameter></term>
   <listitem>
    <para>
     The remote PHY to be added
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Publishes a SAS remote PHY to the rest of the system.
</para>
</refsect1>
</refentry>

<refentry id="API-sas-rphy-free">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>sas_rphy_free</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>sas_rphy_free</refname>
 <refpurpose>
     free a SAS remote PHY
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>sas_rphy_free </function></funcdef>
   <paramdef>struct sas_rphy * <parameter>rphy</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>rphy</parameter></term>
   <listitem>
    <para>
     SAS remote PHY to free
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Frees the specified SAS remote PHY.
</para>
</refsect1>
<refsect1>
<title>Note</title>
<para>
   This function must only be called on a remote
   PHY that has not successfully been added using
   <function>sas_rphy_add</function> (or has been <function>sas_rphy_remove</function>'d)
</para>
</refsect1>
</refentry>

<refentry id="API-sas-rphy-delete">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>sas_rphy_delete</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>sas_rphy_delete</refname>
 <refpurpose>
     remove and free SAS remote PHY
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>sas_rphy_delete </function></funcdef>
   <paramdef>struct sas_rphy * <parameter>rphy</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>rphy</parameter></term>
   <listitem>
    <para>
     SAS remote PHY to remove and free
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Removes the specified SAS remote PHY and frees it.
</para>
</refsect1>
</refentry>

<refentry id="API-sas-rphy-unlink">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>sas_rphy_unlink</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>sas_rphy_unlink</refname>
 <refpurpose>
     unlink SAS remote PHY
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>sas_rphy_unlink </function></funcdef>
   <paramdef>struct sas_rphy * <parameter>rphy</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>rphy</parameter></term>
   <listitem>
    <para>
     SAS remote phy to unlink from its parent port
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Removes port reference to an rphy
</para>
</refsect1>
</refentry>

<refentry id="API-sas-rphy-remove">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>sas_rphy_remove</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>sas_rphy_remove</refname>
 <refpurpose>
     remove SAS remote PHY
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>sas_rphy_remove </function></funcdef>
   <paramdef>struct sas_rphy * <parameter>rphy</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>rphy</parameter></term>
   <listitem>
    <para>
     SAS remote phy to remove
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Removes the specified SAS remote PHY.
</para>
</refsect1>
</refentry>

<refentry id="API-scsi-is-sas-rphy">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>scsi_is_sas_rphy</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>scsi_is_sas_rphy</refname>
 <refpurpose>
     check if a struct device represents a SAS remote PHY
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>scsi_is_sas_rphy </function></funcdef>
   <paramdef>const struct device * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     device to check
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Returns</title>
<para>
   <constant>1</constant> if the device represents a SAS remote PHY, <constant>0</constant> else
</para>
</refsect1>
</refentry>

<refentry id="API-sas-attach-transport">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>sas_attach_transport</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>sas_attach_transport</refname>
 <refpurpose>
     instantiate SAS transport template
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct scsi_transport_template * <function>sas_attach_transport </function></funcdef>
   <paramdef>struct sas_function_template * <parameter>ft</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ft</parameter></term>
   <listitem>
    <para>
     SAS transport class function template
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-sas-release-transport">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>sas_release_transport</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>sas_release_transport</refname>
 <refpurpose>
     release SAS transport template instance
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>sas_release_transport </function></funcdef>
   <paramdef>struct scsi_transport_template * <parameter>t</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>t</parameter></term>
   <listitem>
    <para>
     transport template instance
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

      </sect2>
      <sect2 id="SATA_transport">
        <title>SATA transport class</title>
        <para>
          The SATA transport is handled by libata, which has its own book of
          documentation in this directory.
        </para>
      </sect2>
      <sect2 id="SPI_transport">
        <title>Parallel SCSI (SPI) transport class</title>
        <para>
          The file drivers/scsi/scsi_transport_spi.c defines transport
          attributes for traditional (fast/wide/ultra) SCSI busses.
        </para>
<!-- drivers/scsi/scsi_transport_spi.c -->
<refentry id="API-spi-schedule-dv-device">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>spi_schedule_dv_device</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>spi_schedule_dv_device</refname>
 <refpurpose>
  schedule domain validation to occur on the device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>spi_schedule_dv_device </function></funcdef>
   <paramdef>struct scsi_device * <parameter>sdev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>sdev</parameter></term>
   <listitem>
    <para>
     The device to validate
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Identical to <function>spi_dv_device</function> above, except that the DV will be
   scheduled to occur in a workqueue later.  All memory allocations
   are atomic, so may be called from any context including those holding
   SCSI locks.
</para>
</refsect1>
</refentry>

<refentry id="API-spi-display-xfer-agreement">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>spi_display_xfer_agreement</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>spi_display_xfer_agreement</refname>
 <refpurpose>
     Print the current target transfer agreement
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>spi_display_xfer_agreement </function></funcdef>
   <paramdef>struct scsi_target * <parameter>starget</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>starget</parameter></term>
   <listitem>
    <para>
     The target for which to display the agreement
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Each SPI port is required to maintain a transfer agreement for each
   other port on the bus.  This function prints a one-line summary of
   the current agreement; more detailed information is available in sysfs.
</para>
</refsect1>
</refentry>

      </sect2>
      <sect2 id="SRP_transport">
        <title>SCSI RDMA (SRP) transport class</title>
        <para>
          The file drivers/scsi/scsi_transport_srp.c defines transport
          attributes for SCSI over Remote Direct Memory Access.
        </para>
<!-- drivers/scsi/scsi_transport_srp.c -->
<refentry id="API-srp-tmo-valid">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>srp_tmo_valid</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>srp_tmo_valid</refname>
 <refpurpose>
  check timeout combination validity
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>srp_tmo_valid </function></funcdef>
   <paramdef>int <parameter>reconnect_delay</parameter></paramdef>
   <paramdef>int <parameter>fast_io_fail_tmo</parameter></paramdef>
   <paramdef>int <parameter>dev_loss_tmo</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>reconnect_delay</parameter></term>
   <listitem>
    <para>
     Reconnect delay in seconds.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>fast_io_fail_tmo</parameter></term>
   <listitem>
    <para>
     Fast I/O fail timeout in seconds.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>dev_loss_tmo</parameter></term>
   <listitem>
    <para>
     Device loss timeout in seconds.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   The combination of the timeout parameters must be such that SCSI commands
   are finished in a reasonable time. Hence do not allow the fast I/O fail
   timeout to exceed SCSI_DEVICE_BLOCK_MAX_TIMEOUT nor allow dev_loss_tmo to
   exceed that limit if failing I/O fast has been disabled. Furthermore, these
   parameters must be such that multipath can detect failed paths timely.
   Hence do not allow all three parameters to be disabled simultaneously.
</para>
</refsect1>
</refentry>

<refentry id="API-srp-start-tl-fail-timers">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>srp_start_tl_fail_timers</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>srp_start_tl_fail_timers</refname>
 <refpurpose>
     start the transport layer failure timers
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>srp_start_tl_fail_timers </function></funcdef>
   <paramdef>struct srp_rport * <parameter>rport</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>rport</parameter></term>
   <listitem>
    <para>
     SRP target port.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Start the transport layer fast I/O failure and device loss timers. Do not
   modify a timer that was already started.
</para>
</refsect1>
</refentry>

<refentry id="API-srp-reconnect-rport">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>srp_reconnect_rport</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>srp_reconnect_rport</refname>
 <refpurpose>
     reconnect to an SRP target port
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>srp_reconnect_rport </function></funcdef>
   <paramdef>struct srp_rport * <parameter>rport</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>rport</parameter></term>
   <listitem>
    <para>
     SRP target port.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Blocks SCSI command queueing before invoking <function>reconnect</function> such that
   <function>queuecommand</function> won't be invoked concurrently with <function>reconnect</function> from outside
   the SCSI EH. This is important since a <function>reconnect</function> implementation may
   reallocate resources needed by <function>queuecommand</function>.
</para>
</refsect1>
<refsect1>
<title>Notes</title>
<para>
   - This function neither waits until outstanding requests have finished nor
   tries to abort these. It is the responsibility of the <function>reconnect</function>
   function to finish outstanding commands before reconnecting to the target
   port.
   - It is the responsibility of the caller to ensure that the resources
   reallocated by the <function>reconnect</function> function won't be used while this function
   is in progress. One possible strategy is to invoke this function from
   the context of the SCSI EH thread only. Another possible strategy is to
   lock the rport mutex inside each SCSI LLD callback that can be invoked by
   the SCSI EH (the scsi_host_template.eh_*() functions and also the
   scsi_host_template.<function>queuecommand</function> function).
</para>
</refsect1>
</refentry>

<refentry id="API-srp-rport-get">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>srp_rport_get</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>srp_rport_get</refname>
 <refpurpose>
     increment rport reference count
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>srp_rport_get </function></funcdef>
   <paramdef>struct srp_rport * <parameter>rport</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>rport</parameter></term>
   <listitem>
    <para>
     SRP target port.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-srp-rport-put">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>srp_rport_put</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>srp_rport_put</refname>
 <refpurpose>
     decrement rport reference count
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>srp_rport_put </function></funcdef>
   <paramdef>struct srp_rport * <parameter>rport</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>rport</parameter></term>
   <listitem>
    <para>
     SRP target port.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-srp-rport-add">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>srp_rport_add</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>srp_rport_add</refname>
 <refpurpose>
     add a SRP remote port to the device hierarchy
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct srp_rport * <function>srp_rport_add </function></funcdef>
   <paramdef>struct Scsi_Host * <parameter>shost</parameter></paramdef>
   <paramdef>struct srp_rport_identifiers * <parameter>ids</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>shost</parameter></term>
   <listitem>
    <para>
     scsi host the remote port is connected to.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>ids</parameter></term>
   <listitem>
    <para>
     The port id for the remote port.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Publishes a port to the rest of the system.
</para>
</refsect1>
</refentry>

<refentry id="API-srp-rport-del">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>srp_rport_del</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>srp_rport_del</refname>
 <refpurpose>
     remove a SRP remote port
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>srp_rport_del </function></funcdef>
   <paramdef>struct srp_rport * <parameter>rport</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>rport</parameter></term>
   <listitem>
    <para>
     SRP remote port to remove
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Removes the specified SRP remote port.
</para>
</refsect1>
</refentry>

<refentry id="API-srp-remove-host">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>srp_remove_host</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>srp_remove_host</refname>
 <refpurpose>
     tear down a Scsi_Host's SRP data structures
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>srp_remove_host </function></funcdef>
   <paramdef>struct Scsi_Host * <parameter>shost</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>shost</parameter></term>
   <listitem>
    <para>
     Scsi Host that is torn down
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Removes all SRP remote ports for a given Scsi_Host.
   Must be called just before scsi_remove_host for SRP HBAs.
</para>
</refsect1>
</refentry>

<refentry id="API-srp-stop-rport-timers">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>srp_stop_rport_timers</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>srp_stop_rport_timers</refname>
 <refpurpose>
     stop the transport layer recovery timers
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>srp_stop_rport_timers </function></funcdef>
   <paramdef>struct srp_rport * <parameter>rport</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>rport</parameter></term>
   <listitem>
    <para>
     SRP remote port for which to stop the timers.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Must be called after <function>srp_remove_host</function> and <function>scsi_remove_host</function>. The caller
   must hold a reference on the rport (rport-&gt;dev) and on the SCSI host
   (rport-&gt;dev.parent).
</para>
</refsect1>
</refentry>

<refentry id="API-srp-attach-transport">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>srp_attach_transport</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>srp_attach_transport</refname>
 <refpurpose>
     instantiate SRP transport template
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct scsi_transport_template * <function>srp_attach_transport </function></funcdef>
   <paramdef>struct srp_function_template * <parameter>ft</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ft</parameter></term>
   <listitem>
    <para>
     SRP transport class function template
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-srp-release-transport">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>srp_release_transport</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>srp_release_transport</refname>
 <refpurpose>
     release SRP transport template instance
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>srp_release_transport </function></funcdef>
   <paramdef>struct scsi_transport_template * <parameter>t</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>t</parameter></term>
   <listitem>
    <para>
     transport template instance
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

      </sect2>
    </sect1>

  </chapter>

  <chapter id="lower_layer">
    <title>SCSI lower layer</title>
    <sect1 id="hba_drivers">
      <title>Host Bus Adapter transport types</title>
      <para>
        Many modern device controllers use the SCSI command set as a protocol to
        communicate with their devices through many different types of physical
        connections.
      </para>
      <para>
        In SCSI language a bus capable of carrying SCSI commands is
        called a "transport", and a controller connecting to such a bus is
        called a "host bus adapter" (HBA).
      </para>
      <sect2 id="scsi_debug.c">
        <title>Debug transport</title>
        <para>
          The file drivers/scsi/scsi_debug.c simulates a host adapter with a
          variable number of disks (or disk like devices) attached, sharing a
          common amount of RAM.  Does a lot of checking to make sure that we are
          not getting blocks mixed up, and panics the kernel if anything out of
          the ordinary is seen.
        </para>
        <para>
          To be more realistic, the simulated devices have the transport
          attributes of SAS disks.
        </para>
        <para>
          For documentation see
          <ulink url='http://sg.danny.cz/sg/sdebug26.html'>http://sg.danny.cz/sg/sdebug26.html</ulink>
        </para>
<!-- !Edrivers/scsi/scsi_debug.c -->
      </sect2>
      <sect2 id="todo">
        <title>todo</title>
        <para>Parallel (fast/wide/ultra) SCSI, USB, SATA,
        SAS, Fibre Channel, FireWire, ATAPI devices, Infiniband,
        I20, iSCSI, Parallel ports, netlink...
        </para>
      </sect2>
    </sect1>
  </chapter>
</book>
