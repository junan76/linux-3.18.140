<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>struct usb_composite_dev</title><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot"><link rel="home" href="index.html" title="USB Gadget API for Linux"><link rel="up" href="composite.html" title="Composite Device Framework"><link rel="prev" href="API-module-usb-composite-driver.html" title="module_usb_composite_driver"><link rel="next" href="API-config-ep-by-speed.html" title="config_ep_by_speed"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center"><span class="phrase">struct usb_composite_dev</span></th></tr><tr><td width="20%" align="left"><a accesskey="p" href="API-module-usb-composite-driver.html">Prev</a> </td><th width="60%" align="center">Composite Device Framework</th><td width="20%" align="right"> <a accesskey="n" href="API-config-ep-by-speed.html">Next</a></td></tr></table><hr></div><div class="refentry"><a name="API-struct-usb-composite-dev"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>struct usb_composite_dev — 
     represents one composite usb gadget
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><pre class="programlisting">
struct usb_composite_dev {
  struct usb_gadget * gadget;
  struct usb_request * req;
  struct usb_request * os_desc_req;
  struct usb_configuration * config;
  u8 qw_sign[OS_STRING_QW_SIGN_LEN];
  u8 b_vendor_code;
  struct usb_configuration * os_desc_config;
  unsigned int use_os_string:1;
};  </pre></div><div class="refsect1"><a name="idm2326"></a><h2>Members</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term">gadget</span></dt><dd><p>
   read-only, abstracts the gadget's usb peripheral controller
      </p></dd><dt><span class="term">req</span></dt><dd><p>
   used for control responses; buffer is pre-allocated
      </p></dd><dt><span class="term">os_desc_req</span></dt><dd><p>
   used for OS descriptors responses; buffer is pre-allocated
      </p></dd><dt><span class="term">config</span></dt><dd><p>
   the currently active configuration
      </p></dd><dt><span class="term">qw_sign[OS_STRING_QW_SIGN_LEN]</span></dt><dd><p>
   qwSignature part of the OS string
      </p></dd><dt><span class="term">b_vendor_code</span></dt><dd><p>
   bMS_VendorCode part of the OS string
      </p></dd><dt><span class="term">os_desc_config</span></dt><dd><p>
   the configuration to be used with OS descriptors
      </p></dd><dt><span class="term">use_os_string</span></dt><dd><p>
   false by default, interested gadgets set it
      </p></dd></dl></div></div><div class="refsect1"><a name="idm2361"></a><h2>Description</h2><p>
   One of these devices is allocated and initialized before the
   associated device driver's <code class="function">bind</code> is called.
</p></div><div class="refsect1"><a name="idm2365"></a><h2>OPEN ISSUE</h2><p>
   it appears that some WUSB devices will need to be
   built by combining a normal (wired) gadget with a wireless one.
   This revision of the gadget framework should probably try to make
   sure doing that won't hurt too much.
</p></div><div class="refsect1"><a name="idm2368"></a><h2>One notion for how to handle Wireless USB devices involves</h2><p>
   (a) a second gadget here, discovery mechanism TBD, but likely
   needing separate <span class="quote">“<span class="quote">register/unregister WUSB gadget</span>”</span> calls;
   (b) updates to usb_gadget to include flags <span class="quote">“<span class="quote">is it wireless</span>”</span>,
   <span class="quote">“<span class="quote">is it wired</span>”</span>, plus (presumably in a wrapper structure)
   bandgroup and PHY info;
   (c) presumably a wireless_ep wrapping a usb_ep, and reporting
   wireless-specific parameters like maxburst and maxsequence;
   (d) configurations that are specific to wireless links;
   (e) function drivers that understand wireless configs and will
   support wireless for (additional) function instances;
   (f) a function to support association setup (like CBAF), not
   necessarily requiring a wireless adapter;
   (g) composite device setup that can create one or more wireless
   configs, including appropriate association setup support;
   (h) more, TBD.
</p></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="API-module-usb-composite-driver.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="composite.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="API-config-ep-by-speed.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top"><span class="phrase">module_usb_composite_driver</span> </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> <span class="phrase">config_ep_by_speed</span></td></tr></table></div></body></html>
