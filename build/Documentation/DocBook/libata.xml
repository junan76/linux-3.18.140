<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN"
	"http://www.oasis-open.org/docbook/xml/4.1.2/docbookx.dtd" []>

<book id="libataDevGuide">
 <bookinfo>
  <title>libATA Developer's Guide</title>
  
  <authorgroup>
   <author>
    <firstname>Jeff</firstname>
    <surname>Garzik</surname>
   </author>
  </authorgroup>

  <copyright>
   <year>2003-2006</year>
   <holder>Jeff Garzik</holder>
  </copyright>

  <legalnotice>
   <para>
   The contents of this file are subject to the Open
   Software License version 1.1 that can be found at
   <ulink url="http://fedoraproject.org/wiki/Licensing:OSL1.1">http://fedoraproject.org/wiki/Licensing:OSL1.1</ulink>
   and is included herein by reference.
   </para>

   <para>
   Alternatively, the contents of this file may be used under the terms
   of the GNU General Public License version 2 (the "GPL") as distributed
   in the kernel source COPYING file, in which case the provisions of
   the GPL are applicable instead of the above.  If you wish to allow
   the use of your version of this file only under the terms of the
   GPL and not to allow others to use your version of this file under
   the OSL, indicate your decision by deleting the provisions above and
   replace them with the notice and other provisions required by the GPL.
   If you do not delete the provisions above, a recipient may use your
   version of this file under either the OSL or the GPL.
   </para>

  </legalnotice>
 </bookinfo>

<toc></toc>

  <chapter id="libataIntroduction">
     <title>Introduction</title>
  <para>
  libATA is a library used inside the Linux kernel to support ATA host
  controllers and devices.  libATA provides an ATA driver API, class
  transports for ATA and ATAPI devices, and SCSI&lt;-&gt;ATA translation
  for ATA devices according to the T10 SAT specification.
  </para>
  <para>
  This Guide documents the libATA driver API, library functions, library
  internals, and a couple sample ATA low-level drivers.
  </para>
  </chapter>

  <chapter id="libataDriverApi">
     <title>libata Driver API</title>
     <para>
     struct ata_port_operations is defined for every low-level libata
     hardware driver, and it controls how the low-level driver
     interfaces with the ATA and SCSI layers.
     </para>
     <para>
     FIS-based drivers will hook into the system with ->qc_prep() and
     ->qc_issue() high-level hooks.  Hardware which behaves in a manner
     similar to PCI IDE hardware may utilize several generic helpers,
     defining at a bare minimum the bus I/O addresses of the ATA shadow
     register blocks.
     </para>
     <sect1>
        <title>struct ata_port_operations</title>

	<sect2><title>Disable ATA port</title>
	<programlisting>
void (*port_disable) (struct ata_port *);
	</programlisting>

	<para>
	Called from ata_bus_probe() error path, as well as when
	unregistering from the SCSI module (rmmod, hot unplug).
	This function should do whatever needs to be done to take the
	port out of use.  In most cases, ata_port_disable() can be used
	as this hook.
	</para>
	<para>
	Called from ata_bus_probe() on a failed probe.
	Called from ata_scsi_release().
	</para>

	</sect2>

	<sect2><title>Post-IDENTIFY device configuration</title>
	<programlisting>
void (*dev_config) (struct ata_port *, struct ata_device *);
	</programlisting>

	<para>
	Called after IDENTIFY [PACKET] DEVICE is issued to each device
	found.  Typically used to apply device-specific fixups prior to
	issue of SET FEATURES - XFER MODE, and prior to operation.
	</para>
	<para>
	This entry may be specified as NULL in ata_port_operations.
	</para>

	</sect2>

	<sect2><title>Set PIO/DMA mode</title>
	<programlisting>
void (*set_piomode) (struct ata_port *, struct ata_device *);
void (*set_dmamode) (struct ata_port *, struct ata_device *);
void (*post_set_mode) (struct ata_port *);
unsigned int (*mode_filter) (struct ata_port *, struct ata_device *, unsigned int);
	</programlisting>

	<para>
	Hooks called prior to the issue of SET FEATURES - XFER MODE
	command.  The optional ->mode_filter() hook is called when libata
	has built a mask of the possible modes. This is passed to the 
	->mode_filter() function which should return a mask of valid modes
	after filtering those unsuitable due to hardware limits. It is not
	valid to use this interface to add modes.
	</para>
	<para>
	dev->pio_mode and dev->dma_mode are guaranteed to be valid when
	->set_piomode() and when ->set_dmamode() is called. The timings for
	any other drive sharing the cable will also be valid at this point.
	That is the library records the decisions for the modes of each
	drive on a channel before it attempts to set any of them.
	</para>
	<para>
	->post_set_mode() is
	called unconditionally, after the SET FEATURES - XFER MODE
	command completes successfully.
	</para>

	<para>
	->set_piomode() is always called (if present), but
	->set_dma_mode() is only called if DMA is possible.
	</para>

	</sect2>

	<sect2><title>Taskfile read/write</title>
	<programlisting>
void (*sff_tf_load) (struct ata_port *ap, struct ata_taskfile *tf);
void (*sff_tf_read) (struct ata_port *ap, struct ata_taskfile *tf);
	</programlisting>

	<para>
	->tf_load() is called to load the given taskfile into hardware
	registers / DMA buffers.  ->tf_read() is called to read the
	hardware registers / DMA buffers, to obtain the current set of
	taskfile register values.
	Most drivers for taskfile-based hardware (PIO or MMIO) use
	ata_sff_tf_load() and ata_sff_tf_read() for these hooks.
	</para>

	</sect2>

	<sect2><title>PIO data read/write</title>
	<programlisting>
void (*sff_data_xfer) (struct ata_device *, unsigned char *, unsigned int, int);
	</programlisting>

	<para>
All bmdma-style drivers must implement this hook.  This is the low-level
operation that actually copies the data bytes during a PIO data
transfer.
Typically the driver will choose one of ata_sff_data_xfer_noirq(),
ata_sff_data_xfer(), or ata_sff_data_xfer32().
	</para>

	</sect2>

	<sect2><title>ATA command execute</title>
	<programlisting>
void (*sff_exec_command)(struct ata_port *ap, struct ata_taskfile *tf);
	</programlisting>

	<para>
	causes an ATA command, previously loaded with
	->tf_load(), to be initiated in hardware.
	Most drivers for taskfile-based hardware use ata_sff_exec_command()
	for this hook.
	</para>

	</sect2>

	<sect2><title>Per-cmd ATAPI DMA capabilities filter</title>
	<programlisting>
int (*check_atapi_dma) (struct ata_queued_cmd *qc);
	</programlisting>

	<para>
Allow low-level driver to filter ATA PACKET commands, returning a status
indicating whether or not it is OK to use DMA for the supplied PACKET
command.
	</para>
	<para>
	This hook may be specified as NULL, in which case libata will
	assume that atapi dma can be supported.
	</para>

	</sect2>

	<sect2><title>Read specific ATA shadow registers</title>
	<programlisting>
u8   (*sff_check_status)(struct ata_port *ap);
u8   (*sff_check_altstatus)(struct ata_port *ap);
	</programlisting>

	<para>
	Reads the Status/AltStatus ATA shadow register from
	hardware.  On some hardware, reading the Status register has
	the side effect of clearing the interrupt condition.
	Most drivers for taskfile-based hardware use
	ata_sff_check_status() for this hook.
	</para>

	</sect2>

	<sect2><title>Write specific ATA shadow register</title>
	<programlisting>
void (*sff_set_devctl)(struct ata_port *ap, u8 ctl);
	</programlisting>

	<para>
	Write the device control ATA shadow register to the hardware.
	Most drivers don't need to define this.
	</para>

	</sect2>

	<sect2><title>Select ATA device on bus</title>
	<programlisting>
void (*sff_dev_select)(struct ata_port *ap, unsigned int device);
	</programlisting>

	<para>
	Issues the low-level hardware command(s) that causes one of N
	hardware devices to be considered 'selected' (active and
	available for use) on the ATA bus.  This generally has no
	meaning on FIS-based devices.
	</para>
	<para>
	Most drivers for taskfile-based hardware use
	ata_sff_dev_select() for this hook.
	</para>

	</sect2>

	<sect2><title>Private tuning method</title>
	<programlisting>
void (*set_mode) (struct ata_port *ap);
	</programlisting>

	<para>
	By default libata performs drive and controller tuning in
	accordance with the ATA timing rules and also applies blacklists
	and cable limits. Some controllers need special handling and have
	custom tuning rules, typically raid controllers that use ATA
	commands but do not actually do drive timing.
	</para>

	<warning>
	<para>
	This hook should not be used to replace the standard controller
	tuning logic when a controller has quirks. Replacing the default
	tuning logic in that case would bypass handling for drive and
	bridge quirks that may be important to data reliability. If a
	controller needs to filter the mode selection it should use the
	mode_filter hook instead.
	</para>
	</warning>

	</sect2>

	<sect2><title>Control PCI IDE BMDMA engine</title>
	<programlisting>
void (*bmdma_setup) (struct ata_queued_cmd *qc);
void (*bmdma_start) (struct ata_queued_cmd *qc);
void (*bmdma_stop) (struct ata_port *ap);
u8   (*bmdma_status) (struct ata_port *ap);
	</programlisting>

	<para>
When setting up an IDE BMDMA transaction, these hooks arm
(->bmdma_setup), fire (->bmdma_start), and halt (->bmdma_stop)
the hardware's DMA engine.  ->bmdma_status is used to read the standard
PCI IDE DMA Status register.
	</para>

	<para>
These hooks are typically either no-ops, or simply not implemented, in
FIS-based drivers.
	</para>
	<para>
Most legacy IDE drivers use ata_bmdma_setup() for the bmdma_setup()
hook.  ata_bmdma_setup() will write the pointer to the PRD table to
the IDE PRD Table Address register, enable DMA in the DMA Command
register, and call exec_command() to begin the transfer.
	</para>
	<para>
Most legacy IDE drivers use ata_bmdma_start() for the bmdma_start()
hook.  ata_bmdma_start() will write the ATA_DMA_START flag to the DMA
Command register.
	</para>
	<para>
Many legacy IDE drivers use ata_bmdma_stop() for the bmdma_stop()
hook.  ata_bmdma_stop() clears the ATA_DMA_START flag in the DMA
command register.
	</para>
	<para>
Many legacy IDE drivers use ata_bmdma_status() as the bmdma_status() hook.
	</para>

	</sect2>

	<sect2><title>High-level taskfile hooks</title>
	<programlisting>
void (*qc_prep) (struct ata_queued_cmd *qc);
int (*qc_issue) (struct ata_queued_cmd *qc);
	</programlisting>

	<para>
	Higher-level hooks, these two hooks can potentially supercede
	several of the above taskfile/DMA engine hooks.  ->qc_prep is
	called after the buffers have been DMA-mapped, and is typically
	used to populate the hardware's DMA scatter-gather table.
	Most drivers use the standard ata_qc_prep() helper function, but
	more advanced drivers roll their own.
	</para>
	<para>
	->qc_issue is used to make a command active, once the hardware
	and S/G tables have been prepared.  IDE BMDMA drivers use the
	helper function ata_qc_issue_prot() for taskfile protocol-based
	dispatch.  More advanced drivers implement their own ->qc_issue.
	</para>
	<para>
	ata_qc_issue_prot() calls ->tf_load(), ->bmdma_setup(), and
	->bmdma_start() as necessary to initiate a transfer.
	</para>

	</sect2>

	<sect2><title>Exception and probe handling (EH)</title>
	<programlisting>
void (*eng_timeout) (struct ata_port *ap);
void (*phy_reset) (struct ata_port *ap);
	</programlisting>

	<para>
Deprecated.  Use ->error_handler() instead.
	</para>

	<programlisting>
void (*freeze) (struct ata_port *ap);
void (*thaw) (struct ata_port *ap);
	</programlisting>

	<para>
ata_port_freeze() is called when HSM violations or some other
condition disrupts normal operation of the port.  A frozen port
is not allowed to perform any operation until the port is
thawed, which usually follows a successful reset.
	</para>

	<para>
The optional ->freeze() callback can be used for freezing the port
hardware-wise (e.g. mask interrupt and stop DMA engine).  If a
port cannot be frozen hardware-wise, the interrupt handler
must ack and clear interrupts unconditionally while the port
is frozen.
	</para>
	<para>
The optional ->thaw() callback is called to perform the opposite of ->freeze():
prepare the port for normal operation once again.  Unmask interrupts,
start DMA engine, etc.
	</para>

	<programlisting>
void (*error_handler) (struct ata_port *ap);
	</programlisting>

	<para>
->error_handler() is a driver's hook into probe, hotplug, and recovery
and other exceptional conditions.  The primary responsibility of an
implementation is to call ata_do_eh() or ata_bmdma_drive_eh() with a set
of EH hooks as arguments:
	</para>

	<para>
'prereset' hook (may be NULL) is called during an EH reset, before any other actions
are taken.
	</para>

	<para>
'postreset' hook (may be NULL) is called after the EH reset is performed.  Based on
existing conditions, severity of the problem, and hardware capabilities,
	</para>

	<para>
Either 'softreset' (may be NULL) or 'hardreset' (may be NULL) will be
called to perform the low-level EH reset.
	</para>

	<programlisting>
void (*post_internal_cmd) (struct ata_queued_cmd *qc);
	</programlisting>

	<para>
Perform any hardware-specific actions necessary to finish processing
after executing a probe-time or EH-time command via ata_exec_internal().
	</para>

	</sect2>

	<sect2><title>Hardware interrupt handling</title>
	<programlisting>
irqreturn_t (*irq_handler)(int, void *, struct pt_regs *);
void (*irq_clear) (struct ata_port *);
	</programlisting>

	<para>
	->irq_handler is the interrupt handling routine registered with
	the system, by libata.  ->irq_clear is called during probe just
	before the interrupt handler is registered, to be sure hardware
	is quiet.
	</para>
	<para>
	The second argument, dev_instance, should be cast to a pointer
	to struct ata_host_set.
	</para>
	<para>
	Most legacy IDE drivers use ata_sff_interrupt() for the
	irq_handler hook, which scans all ports in the host_set,
	determines which queued command was active (if any), and calls
	ata_sff_host_intr(ap,qc).
	</para>
	<para>
	Most legacy IDE drivers use ata_sff_irq_clear() for the
	irq_clear() hook, which simply clears the interrupt and error
	flags in the DMA status register.
	</para>

	</sect2>

	<sect2><title>SATA phy read/write</title>
	<programlisting>
int (*scr_read) (struct ata_port *ap, unsigned int sc_reg,
		 u32 *val);
int (*scr_write) (struct ata_port *ap, unsigned int sc_reg,
                   u32 val);
	</programlisting>

	<para>
	Read and write standard SATA phy registers.  Currently only used
	if ->phy_reset hook called the sata_phy_reset() helper function.
	sc_reg is one of SCR_STATUS, SCR_CONTROL, SCR_ERROR, or SCR_ACTIVE.
	</para>

	</sect2>

	<sect2><title>Init and shutdown</title>
	<programlisting>
int (*port_start) (struct ata_port *ap);
void (*port_stop) (struct ata_port *ap);
void (*host_stop) (struct ata_host_set *host_set);
	</programlisting>

	<para>
	->port_start() is called just after the data structures for each
	port are initialized.  Typically this is used to alloc per-port
	DMA buffers / tables / rings, enable DMA engines, and similar
	tasks.  Some drivers also use this entry point as a chance to
	allocate driver-private memory for ap->private_data.
	</para>
	<para>
	Many drivers use ata_port_start() as this hook or call
	it from their own port_start() hooks.  ata_port_start()
	allocates space for a legacy IDE PRD table and returns.
	</para>
	<para>
	->port_stop() is called after ->host_stop().  Its sole function
	is to release DMA/memory resources, now that they are no longer
	actively being used.  Many drivers also free driver-private
	data from port at this time.
	</para>
	<para>
	->host_stop() is called after all ->port_stop() calls
have completed.  The hook must finalize hardware shutdown, release DMA
and other resources, etc.
	This hook may be specified as NULL, in which case it is not called.
	</para>

	</sect2>

     </sect1>
  </chapter>

  <chapter id="libataEH">
        <title>Error handling</title>

	<para>
	This chapter describes how errors are handled under libata.
	Readers are advised to read SCSI EH
	(Documentation/scsi/scsi_eh.txt) and ATA exceptions doc first.
	</para>

	<sect1><title>Origins of commands</title>
	<para>
	In libata, a command is represented with struct ata_queued_cmd
	or qc.  qc's are preallocated during port initialization and
	repetitively used for command executions.  Currently only one
	qc is allocated per port but yet-to-be-merged NCQ branch
	allocates one for each tag and maps each qc to NCQ tag 1-to-1.
	</para>
	<para>
	libata commands can originate from two sources - libata itself
	and SCSI midlayer.  libata internal commands are used for
	initialization and error handling.  All normal blk requests
	and commands for SCSI emulation are passed as SCSI commands
	through queuecommand callback of SCSI host template.
	</para>
	</sect1>

	<sect1><title>How commands are issued</title>

	<variablelist>

	<varlistentry><term>Internal commands</term>
	<listitem>
	<para>
	First, qc is allocated and initialized using
	ata_qc_new_init().  Although ata_qc_new_init() doesn't
	implement any wait or retry mechanism when qc is not
	available, internal commands are currently issued only during
	initialization and error recovery, so no other command is
	active and allocation is guaranteed to succeed.
	</para>
	<para>
	Once allocated qc's taskfile is initialized for the command to
	be executed.  qc currently has two mechanisms to notify
	completion.  One is via qc->complete_fn() callback and the
	other is completion qc->waiting.  qc->complete_fn() callback
	is the asynchronous path used by normal SCSI translated
	commands and qc->waiting is the synchronous (issuer sleeps in
	process context) path used by internal commands.
	</para>
	<para>
	Once initialization is complete, host_set lock is acquired
	and the qc is issued.
	</para>
	</listitem>
	</varlistentry>

	<varlistentry><term>SCSI commands</term>
	<listitem>
	<para>
	All libata drivers use ata_scsi_queuecmd() as
	hostt->queuecommand callback.  scmds can either be simulated
	or translated.  No qc is involved in processing a simulated
	scmd.  The result is computed right away and the scmd is
	completed.
	</para>
	<para>
	For a translated scmd, ata_qc_new_init() is invoked to
	allocate a qc and the scmd is translated into the qc.  SCSI
	midlayer's completion notification function pointer is stored
	into qc->scsidone.
	</para>
	<para>
	qc->complete_fn() callback is used for completion
	notification.  ATA commands use ata_scsi_qc_complete() while
	ATAPI commands use atapi_qc_complete().  Both functions end up
	calling qc->scsidone to notify upper layer when the qc is
	finished.  After translation is completed, the qc is issued
	with ata_qc_issue().
	</para>
	<para>
	Note that SCSI midlayer invokes hostt->queuecommand while
	holding host_set lock, so all above occur while holding
	host_set lock.
	</para>
	</listitem>
	</varlistentry>

	</variablelist>
	</sect1>

	<sect1><title>How commands are processed</title>
	<para>
	Depending on which protocol and which controller are used,
	commands are processed differently.  For the purpose of
	discussion, a controller which uses taskfile interface and all
	standard callbacks is assumed.
	</para>
	<para>
	Currently 6 ATA command protocols are used.  They can be
	sorted into the following four categories according to how
	they are processed.
	</para>

	<variablelist>
	   <varlistentry><term>ATA NO DATA or DMA</term>
	   <listitem>
	   <para>
	   ATA_PROT_NODATA and ATA_PROT_DMA fall into this category.
	   These types of commands don't require any software
	   intervention once issued.  Device will raise interrupt on
	   completion.
	   </para>
	   </listitem>
	   </varlistentry>

	   <varlistentry><term>ATA PIO</term>
	   <listitem>
	   <para>
	   ATA_PROT_PIO is in this category.  libata currently
	   implements PIO with polling.  ATA_NIEN bit is set to turn
	   off interrupt and pio_task on ata_wq performs polling and
	   IO.
	   </para>
	   </listitem>
	   </varlistentry>

	   <varlistentry><term>ATAPI NODATA or DMA</term>
	   <listitem>
	   <para>
	   ATA_PROT_ATAPI_NODATA and ATA_PROT_ATAPI_DMA are in this
	   category.  packet_task is used to poll BSY bit after
	   issuing PACKET command.  Once BSY is turned off by the
	   device, packet_task transfers CDB and hands off processing
	   to interrupt handler.
	   </para>
	   </listitem>
	   </varlistentry>

	   <varlistentry><term>ATAPI PIO</term>
	   <listitem>
	   <para>
	   ATA_PROT_ATAPI is in this category.  ATA_NIEN bit is set
	   and, as in ATAPI NODATA or DMA, packet_task submits cdb.
	   However, after submitting cdb, further processing (data
	   transfer) is handed off to pio_task.
	   </para>
	   </listitem>
	   </varlistentry>
	</variablelist>
        </sect1>

	<sect1><title>How commands are completed</title>
	<para>
	Once issued, all qc's are either completed with
	ata_qc_complete() or time out.  For commands which are handled
	by interrupts, ata_host_intr() invokes ata_qc_complete(), and,
	for PIO tasks, pio_task invokes ata_qc_complete().  In error
	cases, packet_task may also complete commands.
	</para>
	<para>
	ata_qc_complete() does the following.
	</para>

	<orderedlist>

	<listitem>
	<para>
	DMA memory is unmapped.
	</para>
	</listitem>

	<listitem>
	<para>
	ATA_QCFLAG_ACTIVE is cleared from qc->flags.
	</para>
	</listitem>

	<listitem>
	<para>
	qc->complete_fn() callback is invoked.  If the return value of
	the callback is not zero.  Completion is short circuited and
	ata_qc_complete() returns.
	</para>
	</listitem>

	<listitem>
	<para>
	__ata_qc_complete() is called, which does
	   <orderedlist>

	   <listitem>
	   <para>
	   qc->flags is cleared to zero.
	   </para>
	   </listitem>

	   <listitem>
	   <para>
	   ap->active_tag and qc->tag are poisoned.
	   </para>
	   </listitem>

	   <listitem>
	   <para>
	   qc->waiting is cleared &amp; completed (in that order).
	   </para>
	   </listitem>

	   <listitem>
	   <para>
	   qc is deallocated by clearing appropriate bit in ap->qactive.
	   </para>
	   </listitem>

	   </orderedlist>
	</para>
	</listitem>

	</orderedlist>

	<para>
	So, it basically notifies upper layer and deallocates qc.  One
	exception is short-circuit path in #3 which is used by
	atapi_qc_complete().
	</para>
	<para>
	For all non-ATAPI commands, whether it fails or not, almost
	the same code path is taken and very little error handling
	takes place.  A qc is completed with success status if it
	succeeded, with failed status otherwise.
	</para>
	<para>
	However, failed ATAPI commands require more handling as
	REQUEST SENSE is needed to acquire sense data.  If an ATAPI
	command fails, ata_qc_complete() is invoked with error status,
	which in turn invokes atapi_qc_complete() via
	qc->complete_fn() callback.
	</para>
	<para>
	This makes atapi_qc_complete() set scmd->result to
	SAM_STAT_CHECK_CONDITION, complete the scmd and return 1.  As
	the sense data is empty but scmd->result is CHECK CONDITION,
	SCSI midlayer will invoke EH for the scmd, and returning 1
	makes ata_qc_complete() to return without deallocating the qc.
	This leads us to ata_scsi_error() with partially completed qc.
	</para>

	</sect1>

	<sect1><title>ata_scsi_error()</title>
	<para>
	ata_scsi_error() is the current transportt->eh_strategy_handler()
	for libata.  As discussed above, this will be entered in two
	cases - timeout and ATAPI error completion.  This function
	calls low level libata driver's eng_timeout() callback, the
	standard callback for which is ata_eng_timeout().  It checks
	if a qc is active and calls ata_qc_timeout() on the qc if so.
	Actual error handling occurs in ata_qc_timeout().
	</para>
	<para>
	If EH is invoked for timeout, ata_qc_timeout() stops BMDMA and
	completes the qc.  Note that as we're currently in EH, we
	cannot call scsi_done.  As described in SCSI EH doc, a
	recovered scmd should be either retried with
	scsi_queue_insert() or finished with scsi_finish_command().
	Here, we override qc->scsidone with scsi_finish_command() and
	calls ata_qc_complete().
	</para>
	<para>
	If EH is invoked due to a failed ATAPI qc, the qc here is
	completed but not deallocated.  The purpose of this
	half-completion is to use the qc as place holder to make EH
	code reach this place.  This is a bit hackish, but it works.
	</para>
	<para>
	Once control reaches here, the qc is deallocated by invoking
	__ata_qc_complete() explicitly.  Then, internal qc for REQUEST
	SENSE is issued.  Once sense data is acquired, scmd is
	finished by directly invoking scsi_finish_command() on the
	scmd.  Note that as we already have completed and deallocated
	the qc which was associated with the scmd, we don't need
	to/cannot call ata_qc_complete() again.
	</para>

	</sect1>

	<sect1><title>Problems with the current EH</title>

	<itemizedlist>

	<listitem>
	<para>
	Error representation is too crude.  Currently any and all
	error conditions are represented with ATA STATUS and ERROR
	registers.  Errors which aren't ATA device errors are treated
	as ATA device errors by setting ATA_ERR bit.  Better error
	descriptor which can properly represent ATA and other
	errors/exceptions is needed.
	</para>
	</listitem>

	<listitem>
	<para>
	When handling timeouts, no action is taken to make device
	forget about the timed out command and ready for new commands.
	</para>
	</listitem>

	<listitem>
	<para>
	EH handling via ata_scsi_error() is not properly protected
	from usual command processing.  On EH entrance, the device is
	not in quiescent state.  Timed out commands may succeed or
	fail any time.  pio_task and atapi_task may still be running.
	</para>
	</listitem>

	<listitem>
	<para>
	Too weak error recovery.  Devices / controllers causing HSM
	mismatch errors and other errors quite often require reset to
	return to known state.  Also, advanced error handling is
	necessary to support features like NCQ and hotplug.
	</para>
	</listitem>

	<listitem>
	<para>
	ATA errors are directly handled in the interrupt handler and
	PIO errors in pio_task.  This is problematic for advanced
	error handling for the following reasons.
	</para>
	<para>
	First, advanced error handling often requires context and
	internal qc execution.
	</para>
	<para>
	Second, even a simple failure (say, CRC error) needs
	information gathering and could trigger complex error handling
	(say, resetting &amp; reconfiguring).  Having multiple code
	paths to gather information, enter EH and trigger actions
	makes life painful.
	</para>
	<para>
	Third, scattered EH code makes implementing low level drivers
	difficult.  Low level drivers override libata callbacks.  If
	EH is scattered over several places, each affected callbacks
	should perform its part of error handling.  This can be error
	prone and painful.
	</para>
	</listitem>

	</itemizedlist>
	</sect1>
  </chapter>

  <chapter id="libataExt">
     <title>libata Library</title>
<!-- drivers/ata/libata-core.c -->
<refentry id="API-ata-link-next">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ata_link_next</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ata_link_next</refname>
 <refpurpose>
  link iteration helper
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct ata_link * <function>ata_link_next </function></funcdef>
   <paramdef>struct ata_link * <parameter>link</parameter></paramdef>
   <paramdef>struct ata_port * <parameter>ap</parameter></paramdef>
   <paramdef>enum ata_link_iter_mode <parameter>mode</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>link</parameter></term>
   <listitem>
    <para>
     the previous link, NULL to start
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>ap</parameter></term>
   <listitem>
    <para>
     ATA port containing links to iterate
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>mode</parameter></term>
   <listitem>
    <para>
     iteration mode, one of ATA_LITER_*
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>LOCKING</title>
<para>
   Host lock or EH context.
</para>
</refsect1>
<refsect1>
<title>RETURNS</title>
<para>
   Pointer to the next link.
</para>
</refsect1>
</refentry>

<refentry id="API-ata-dev-next">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ata_dev_next</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ata_dev_next</refname>
 <refpurpose>
     device iteration helper
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct ata_device * <function>ata_dev_next </function></funcdef>
   <paramdef>struct ata_device * <parameter>dev</parameter></paramdef>
   <paramdef>struct ata_link * <parameter>link</parameter></paramdef>
   <paramdef>enum ata_dev_iter_mode <parameter>mode</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     the previous device, NULL to start
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>link</parameter></term>
   <listitem>
    <para>
     ATA link containing devices to iterate
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>mode</parameter></term>
   <listitem>
    <para>
     iteration mode, one of ATA_DITER_*
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>LOCKING</title>
<para>
   Host lock or EH context.
</para>
</refsect1>
<refsect1>
<title>RETURNS</title>
<para>
   Pointer to the next device.
</para>
</refsect1>
</refentry>

<refentry id="API-atapi-cmd-type">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>atapi_cmd_type</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>atapi_cmd_type</refname>
 <refpurpose>
     Determine ATAPI command type from SCSI opcode
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>atapi_cmd_type </function></funcdef>
   <paramdef>u8 <parameter>opcode</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>opcode</parameter></term>
   <listitem>
    <para>
     SCSI opcode
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Determine ATAPI command type from <parameter>opcode</parameter>.
</para>
</refsect1>
<refsect1>
<title>LOCKING</title>
<para>
   None.
</para>
</refsect1>
<refsect1>
<title>RETURNS</title>
<para>
   ATAPI_{READ|WRITE|READ_CD|PASS_THRU|MISC}
</para>
</refsect1>
</refentry>

<refentry id="API-ata-tf-to-fis">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ata_tf_to_fis</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ata_tf_to_fis</refname>
 <refpurpose>
     Convert ATA taskfile to SATA FIS structure
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>ata_tf_to_fis </function></funcdef>
   <paramdef>const struct ata_taskfile * <parameter>tf</parameter></paramdef>
   <paramdef>u8 <parameter>pmp</parameter></paramdef>
   <paramdef>int <parameter>is_cmd</parameter></paramdef>
   <paramdef>u8 * <parameter>fis</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>tf</parameter></term>
   <listitem>
    <para>
     Taskfile to convert
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>pmp</parameter></term>
   <listitem>
    <para>
     Port multiplier port
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>is_cmd</parameter></term>
   <listitem>
    <para>
     This FIS is for command
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>fis</parameter></term>
   <listitem>
    <para>
     Buffer into which data will output
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Converts a standard ATA taskfile to a Serial ATA
   FIS structure (Register - Host to Device).
</para>
</refsect1>
<refsect1>
<title>LOCKING</title>
<para>
   Inherited from caller.
</para>
</refsect1>
</refentry>

<refentry id="API-ata-tf-from-fis">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ata_tf_from_fis</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ata_tf_from_fis</refname>
 <refpurpose>
     Convert SATA FIS to ATA taskfile
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>ata_tf_from_fis </function></funcdef>
   <paramdef>const u8 * <parameter>fis</parameter></paramdef>
   <paramdef>struct ata_taskfile * <parameter>tf</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>fis</parameter></term>
   <listitem>
    <para>
     Buffer from which data will be input
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>tf</parameter></term>
   <listitem>
    <para>
     Taskfile to output
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Converts a serial ATA FIS structure to a standard ATA taskfile.
</para>
</refsect1>
<refsect1>
<title>LOCKING</title>
<para>
   Inherited from caller.
</para>
</refsect1>
</refentry>

<refentry id="API-ata-pack-xfermask">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ata_pack_xfermask</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ata_pack_xfermask</refname>
 <refpurpose>
     Pack pio, mwdma and udma masks into xfer_mask
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>unsigned long <function>ata_pack_xfermask </function></funcdef>
   <paramdef>unsigned long <parameter>pio_mask</parameter></paramdef>
   <paramdef>unsigned long <parameter>mwdma_mask</parameter></paramdef>
   <paramdef>unsigned long <parameter>udma_mask</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>pio_mask</parameter></term>
   <listitem>
    <para>
     pio_mask
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>mwdma_mask</parameter></term>
   <listitem>
    <para>
     mwdma_mask
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>udma_mask</parameter></term>
   <listitem>
    <para>
     udma_mask
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Pack <parameter>pio_mask</parameter>, <parameter>mwdma_mask</parameter> and <parameter>udma_mask</parameter> into a single
   unsigned int xfer_mask.
</para>
</refsect1>
<refsect1>
<title>LOCKING</title>
<para>
   None.
</para>
</refsect1>
<refsect1>
<title>RETURNS</title>
<para>
   Packed xfer_mask.
</para>
</refsect1>
</refentry>

<refentry id="API-ata-unpack-xfermask">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ata_unpack_xfermask</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ata_unpack_xfermask</refname>
 <refpurpose>
     Unpack xfer_mask into pio, mwdma and udma masks
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>ata_unpack_xfermask </function></funcdef>
   <paramdef>unsigned long <parameter>xfer_mask</parameter></paramdef>
   <paramdef>unsigned long * <parameter>pio_mask</parameter></paramdef>
   <paramdef>unsigned long * <parameter>mwdma_mask</parameter></paramdef>
   <paramdef>unsigned long * <parameter>udma_mask</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>xfer_mask</parameter></term>
   <listitem>
    <para>
     xfer_mask to unpack
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>pio_mask</parameter></term>
   <listitem>
    <para>
     resulting pio_mask
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>mwdma_mask</parameter></term>
   <listitem>
    <para>
     resulting mwdma_mask
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>udma_mask</parameter></term>
   <listitem>
    <para>
     resulting udma_mask
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Unpack <parameter>xfer_mask</parameter> into <parameter>pio_mask</parameter>, <parameter>mwdma_mask</parameter> and <parameter>udma_mask</parameter>.
   Any NULL distination masks will be ignored.
</para>
</refsect1>
</refentry>

<refentry id="API-ata-xfer-mask2mode">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ata_xfer_mask2mode</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ata_xfer_mask2mode</refname>
 <refpurpose>
     Find matching XFER_* for the given xfer_mask
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>u8 <function>ata_xfer_mask2mode </function></funcdef>
   <paramdef>unsigned long <parameter>xfer_mask</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>xfer_mask</parameter></term>
   <listitem>
    <para>
     xfer_mask of interest
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Return matching XFER_* value for <parameter>xfer_mask</parameter>.  Only the highest
   bit of <parameter>xfer_mask</parameter> is considered.
</para>
</refsect1>
<refsect1>
<title>LOCKING</title>
<para>
   None.
</para>
</refsect1>
<refsect1>
<title>RETURNS</title>
<para>
   Matching XFER_* value, 0xff if no match found.
</para>
</refsect1>
</refentry>

<refentry id="API-ata-xfer-mode2mask">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ata_xfer_mode2mask</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ata_xfer_mode2mask</refname>
 <refpurpose>
     Find matching xfer_mask for XFER_*
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>unsigned long <function>ata_xfer_mode2mask </function></funcdef>
   <paramdef>u8 <parameter>xfer_mode</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>xfer_mode</parameter></term>
   <listitem>
    <para>
     XFER_* of interest
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Return matching xfer_mask for <parameter>xfer_mode</parameter>.
</para>
</refsect1>
<refsect1>
<title>LOCKING</title>
<para>
   None.
</para>
</refsect1>
<refsect1>
<title>RETURNS</title>
<para>
   Matching xfer_mask, 0 if no match found.
</para>
</refsect1>
</refentry>

<refentry id="API-ata-xfer-mode2shift">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ata_xfer_mode2shift</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ata_xfer_mode2shift</refname>
 <refpurpose>
     Find matching xfer_shift for XFER_*
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>ata_xfer_mode2shift </function></funcdef>
   <paramdef>unsigned long <parameter>xfer_mode</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>xfer_mode</parameter></term>
   <listitem>
    <para>
     XFER_* of interest
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Return matching xfer_shift for <parameter>xfer_mode</parameter>.
</para>
</refsect1>
<refsect1>
<title>LOCKING</title>
<para>
   None.
</para>
</refsect1>
<refsect1>
<title>RETURNS</title>
<para>
   Matching xfer_shift, -1 if no match found.
</para>
</refsect1>
</refentry>

<refentry id="API-ata-mode-string">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ata_mode_string</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ata_mode_string</refname>
 <refpurpose>
     convert xfer_mask to string
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>const char * <function>ata_mode_string </function></funcdef>
   <paramdef>unsigned long <parameter>xfer_mask</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>xfer_mask</parameter></term>
   <listitem>
    <para>
     mask of bits supported; only highest bit counts.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Determine string which represents the highest speed
   (highest bit in <parameter>modemask</parameter>).
</para>
</refsect1>
<refsect1>
<title>LOCKING</title>
<para>
   None.
</para>
</refsect1>
<refsect1>
<title>RETURNS</title>
<para>
   Constant C string representing highest speed listed in
   <parameter>mode_mask</parameter>, or the constant C string <quote>&lt;n/a&gt;</quote>.
</para>
</refsect1>
</refentry>

<refentry id="API-ata-dev-classify">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ata_dev_classify</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ata_dev_classify</refname>
 <refpurpose>
     determine device type based on ATA-spec signature
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>unsigned int <function>ata_dev_classify </function></funcdef>
   <paramdef>const struct ata_taskfile * <parameter>tf</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>tf</parameter></term>
   <listitem>
    <para>
     ATA taskfile register set for device to be identified
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Determine from taskfile register contents whether a device is
   ATA or ATAPI, as per <quote>Signature and persistence</quote> section
   of ATA/PI spec (volume 1, sect 5.14).
</para>
</refsect1>
<refsect1>
<title>LOCKING</title>
<para>
   None.
</para>
</refsect1>
<refsect1>
<title>RETURNS</title>
<para>
   Device type, <constant>ATA_DEV_ATA</constant>, <constant>ATA_DEV_ATAPI</constant>, <constant>ATA_DEV_PMP</constant> or
   <constant>ATA_DEV_UNKNOWN</constant> the event of failure.
</para>
</refsect1>
</refentry>

<refentry id="API-ata-id-string">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ata_id_string</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ata_id_string</refname>
 <refpurpose>
     Convert IDENTIFY DEVICE page into string
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>ata_id_string </function></funcdef>
   <paramdef>const u16 * <parameter>id</parameter></paramdef>
   <paramdef>unsigned char * <parameter>s</parameter></paramdef>
   <paramdef>unsigned int <parameter>ofs</parameter></paramdef>
   <paramdef>unsigned int <parameter>len</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>id</parameter></term>
   <listitem>
    <para>
     IDENTIFY DEVICE results we will examine
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>s</parameter></term>
   <listitem>
    <para>
     string into which data is output
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>ofs</parameter></term>
   <listitem>
    <para>
     offset into identify device page
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>len</parameter></term>
   <listitem>
    <para>
     length of string to return. must be an even number.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   The strings in the IDENTIFY DEVICE page are broken up into
   16-bit chunks.  Run through the string, and output each
   8-bit chunk linearly, regardless of platform.
</para>
</refsect1>
<refsect1>
<title>LOCKING</title>
<para>
   caller.
</para>
</refsect1>
</refentry>

<refentry id="API-ata-id-c-string">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ata_id_c_string</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ata_id_c_string</refname>
 <refpurpose>
     Convert IDENTIFY DEVICE page into C string
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>ata_id_c_string </function></funcdef>
   <paramdef>const u16 * <parameter>id</parameter></paramdef>
   <paramdef>unsigned char * <parameter>s</parameter></paramdef>
   <paramdef>unsigned int <parameter>ofs</parameter></paramdef>
   <paramdef>unsigned int <parameter>len</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>id</parameter></term>
   <listitem>
    <para>
     IDENTIFY DEVICE results we will examine
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>s</parameter></term>
   <listitem>
    <para>
     string into which data is output
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>ofs</parameter></term>
   <listitem>
    <para>
     offset into identify device page
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>len</parameter></term>
   <listitem>
    <para>
     length of string to return. must be an odd number.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This function is identical to ata_id_string except that it
   trims trailing spaces and terminates the resulting string with
   null.  <parameter>len</parameter> must be actual maximum length (even number) + 1.
</para>
</refsect1>
<refsect1>
<title>LOCKING</title>
<para>
   caller.
</para>
</refsect1>
</refentry>

<refentry id="API-ata-id-xfermask">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ata_id_xfermask</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ata_id_xfermask</refname>
 <refpurpose>
     Compute xfermask from the given IDENTIFY data
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>unsigned long <function>ata_id_xfermask </function></funcdef>
   <paramdef>const u16 * <parameter>id</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>id</parameter></term>
   <listitem>
    <para>
     IDENTIFY data to compute xfer mask from
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Compute the xfermask for this device. This is not as trivial
   as it seems if we must consider early devices correctly.
</para>
</refsect1>
<refsect1>
<title>FIXME</title>
<para>
   pre IDE drive timing (do we care ?).
</para>
</refsect1>
<refsect1>
<title>LOCKING</title>
<para>
   None.
</para>
</refsect1>
<refsect1>
<title>RETURNS</title>
<para>
   Computed xfermask
</para>
</refsect1>
</refentry>

<refentry id="API-ata-pio-need-iordy">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ata_pio_need_iordy</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ata_pio_need_iordy</refname>
 <refpurpose>
     check if iordy needed
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>unsigned int <function>ata_pio_need_iordy </function></funcdef>
   <paramdef>const struct ata_device * <parameter>adev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>adev</parameter></term>
   <listitem>
    <para>
     ATA device
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Check if the current speed of the device requires IORDY. Used
   by various controllers for chip configuration.
</para>
</refsect1>
</refentry>

<refentry id="API-ata-do-dev-read-id">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ata_do_dev_read_id</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ata_do_dev_read_id</refname>
 <refpurpose>
     default ID read method
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>unsigned int <function>ata_do_dev_read_id </function></funcdef>
   <paramdef>struct ata_device * <parameter>dev</parameter></paramdef>
   <paramdef>struct ata_taskfile * <parameter>tf</parameter></paramdef>
   <paramdef>u16 * <parameter>id</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>tf</parameter></term>
   <listitem>
    <para>
     proposed taskfile
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>id</parameter></term>
   <listitem>
    <para>
     data buffer
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Issue the identify taskfile and hand back the buffer containing
   identify data. For some RAID controllers and for pre ATA devices
   this function is wrapped or replaced by the driver
</para>
</refsect1>
</refentry>

<refentry id="API-ata-cable-40wire">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ata_cable_40wire</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ata_cable_40wire</refname>
 <refpurpose>
     return 40 wire cable type
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>ata_cable_40wire </function></funcdef>
   <paramdef>struct ata_port * <parameter>ap</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ap</parameter></term>
   <listitem>
    <para>
     port
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Helper method for drivers which want to hardwire 40 wire cable
   detection.
</para>
</refsect1>
</refentry>

<refentry id="API-ata-cable-80wire">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ata_cable_80wire</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ata_cable_80wire</refname>
 <refpurpose>
     return 80 wire cable type
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>ata_cable_80wire </function></funcdef>
   <paramdef>struct ata_port * <parameter>ap</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ap</parameter></term>
   <listitem>
    <para>
     port
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Helper method for drivers which want to hardwire 80 wire cable
   detection.
</para>
</refsect1>
</refentry>

<refentry id="API-ata-cable-unknown">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ata_cable_unknown</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ata_cable_unknown</refname>
 <refpurpose>
     return unknown PATA cable.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>ata_cable_unknown </function></funcdef>
   <paramdef>struct ata_port * <parameter>ap</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ap</parameter></term>
   <listitem>
    <para>
     port
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Helper method for drivers which have no PATA cable detection.
</para>
</refsect1>
</refentry>

<refentry id="API-ata-cable-ignore">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ata_cable_ignore</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ata_cable_ignore</refname>
 <refpurpose>
     return ignored PATA cable.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>ata_cable_ignore </function></funcdef>
   <paramdef>struct ata_port * <parameter>ap</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ap</parameter></term>
   <listitem>
    <para>
     port
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Helper method for drivers which don't use cable type to limit
   transfer mode.
</para>
</refsect1>
</refentry>

<refentry id="API-ata-cable-sata">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ata_cable_sata</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ata_cable_sata</refname>
 <refpurpose>
     return SATA cable type
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>ata_cable_sata </function></funcdef>
   <paramdef>struct ata_port * <parameter>ap</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ap</parameter></term>
   <listitem>
    <para>
     port
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Helper method for drivers which have SATA cables
</para>
</refsect1>
</refentry>

<refentry id="API-ata-dev-pair">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ata_dev_pair</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ata_dev_pair</refname>
 <refpurpose>
     return other device on cable
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct ata_device * <function>ata_dev_pair </function></funcdef>
   <paramdef>struct ata_device * <parameter>adev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>adev</parameter></term>
   <listitem>
    <para>
     device
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Obtain the other device on the same cable, or if none is
   present NULL is returned
</para>
</refsect1>
</refentry>

<refentry id="API-sata-set-spd">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>sata_set_spd</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>sata_set_spd</refname>
 <refpurpose>
     set SATA spd according to spd limit
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>sata_set_spd </function></funcdef>
   <paramdef>struct ata_link * <parameter>link</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>link</parameter></term>
   <listitem>
    <para>
     Link to set SATA spd for
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Set SATA spd of <parameter>link</parameter> according to sata_spd_limit.
</para>
</refsect1>
<refsect1>
<title>LOCKING</title>
<para>
   Inherited from caller.
</para>
</refsect1>
<refsect1>
<title>RETURNS</title>
<para>
   0 if spd doesn't need to be changed, 1 if spd has been
   changed.  Negative errno if SCR registers are inaccessible.
</para>
</refsect1>
</refentry>

<refentry id="API-ata-timing-cycle2mode">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ata_timing_cycle2mode</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ata_timing_cycle2mode</refname>
 <refpurpose>
     find xfer mode for the specified cycle duration
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>u8 <function>ata_timing_cycle2mode </function></funcdef>
   <paramdef>unsigned int <parameter>xfer_shift</parameter></paramdef>
   <paramdef>int <parameter>cycle</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>xfer_shift</parameter></term>
   <listitem>
    <para>
     ATA_SHIFT_* value for transfer type to examine.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>cycle</parameter></term>
   <listitem>
    <para>
     cycle duration in ns
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Return matching xfer mode for <parameter>cycle</parameter>.  The returned mode is of
   the transfer type specified by <parameter>xfer_shift</parameter>.  If <parameter>cycle</parameter> is too
   slow for <parameter>xfer_shift</parameter>, 0xff is returned.  If <parameter>cycle</parameter> is faster
   than the fastest known mode, the fasted mode is returned.
</para>
</refsect1>
<refsect1>
<title>LOCKING</title>
<para>
   None.
</para>
</refsect1>
<refsect1>
<title>RETURNS</title>
<para>
   Matching xfer_mode, 0xff if no match found.
</para>
</refsect1>
</refentry>

<refentry id="API-ata-do-set-mode">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ata_do_set_mode</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ata_do_set_mode</refname>
 <refpurpose>
     Program timings and issue SET FEATURES - XFER
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>ata_do_set_mode </function></funcdef>
   <paramdef>struct ata_link * <parameter>link</parameter></paramdef>
   <paramdef>struct ata_device ** <parameter>r_failed_dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>link</parameter></term>
   <listitem>
    <para>
     link on which timings will be programmed
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>r_failed_dev</parameter></term>
   <listitem>
    <para>
     out parameter for failed device
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Standard implementation of the function used to tune and set
   ATA device disk transfer mode (PIO3, UDMA6, etc.).  If
   <function>ata_dev_set_mode</function> fails, pointer to the failing device is
   returned in <parameter>r_failed_dev</parameter>.
</para>
</refsect1>
<refsect1>
<title>LOCKING</title>
<para>
   PCI/etc. bus probe sem.
</para>
</refsect1>
<refsect1>
<title>RETURNS</title>
<para>
   0 on success, negative errno otherwise
</para>
</refsect1>
</refentry>

<refentry id="API-ata-wait-after-reset">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ata_wait_after_reset</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ata_wait_after_reset</refname>
 <refpurpose>
     wait for link to become ready after reset
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>ata_wait_after_reset </function></funcdef>
   <paramdef>struct ata_link * <parameter>link</parameter></paramdef>
   <paramdef>unsigned long <parameter>deadline</parameter></paramdef>
   <paramdef>int (*<parameter>check_ready</parameter>)
     <funcparams>struct ata_link *link</funcparams></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>link</parameter></term>
   <listitem>
    <para>
     link to be waited on
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>deadline</parameter></term>
   <listitem>
    <para>
     deadline jiffies for the operation
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>check_ready</parameter></term>
   <listitem>
    <para>
     callback to check link readiness
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Wait for <parameter>link</parameter> to become ready after reset.
</para>
</refsect1>
<refsect1>
<title>LOCKING</title>
<para>
   EH context.
</para>
</refsect1>
<refsect1>
<title>RETURNS</title>
<para>
   0 if <parameter>linke</parameter> is ready before <parameter>deadline</parameter>; otherwise, -errno.
</para>
</refsect1>
</refentry>

<refentry id="API-sata-link-debounce">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>sata_link_debounce</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>sata_link_debounce</refname>
 <refpurpose>
     debounce SATA phy status
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>sata_link_debounce </function></funcdef>
   <paramdef>struct ata_link * <parameter>link</parameter></paramdef>
   <paramdef>const unsigned long * <parameter>params</parameter></paramdef>
   <paramdef>unsigned long <parameter>deadline</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>link</parameter></term>
   <listitem>
    <para>
     ATA link to debounce SATA phy status for
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>params</parameter></term>
   <listitem>
    <para>
     timing parameters { interval, duratinon, timeout } in msec
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>deadline</parameter></term>
   <listitem>
    <para>
     deadline jiffies for the operation
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Make sure SStatus of <parameter>link</parameter> reaches stable state, determined by
   holding the same value where DET is not 1 for <parameter>duration</parameter> polled
   every <parameter>interval</parameter>, before <parameter>timeout</parameter>.  Timeout constraints the
   beginning of the stable state.  Because DET gets stuck at 1 on
   some controllers after hot unplugging, this functions waits
   until timeout then returns 0 if DET is stable at 1.
   </para><para>

   <parameter>timeout</parameter> is further limited by <parameter>deadline</parameter>.  The sooner of the
   two is used.
</para>
</refsect1>
<refsect1>
<title>LOCKING</title>
<para>
   Kernel thread context (may sleep)
</para>
</refsect1>
<refsect1>
<title>RETURNS</title>
<para>
   0 on success, -errno on failure.
</para>
</refsect1>
</refentry>

<refentry id="API-sata-link-resume">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>sata_link_resume</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>sata_link_resume</refname>
 <refpurpose>
     resume SATA link
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>sata_link_resume </function></funcdef>
   <paramdef>struct ata_link * <parameter>link</parameter></paramdef>
   <paramdef>const unsigned long * <parameter>params</parameter></paramdef>
   <paramdef>unsigned long <parameter>deadline</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>link</parameter></term>
   <listitem>
    <para>
     ATA link to resume SATA
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>params</parameter></term>
   <listitem>
    <para>
     timing parameters { interval, duratinon, timeout } in msec
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>deadline</parameter></term>
   <listitem>
    <para>
     deadline jiffies for the operation
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Resume SATA phy <parameter>link</parameter> and debounce it.
</para>
</refsect1>
<refsect1>
<title>LOCKING</title>
<para>
   Kernel thread context (may sleep)
</para>
</refsect1>
<refsect1>
<title>RETURNS</title>
<para>
   0 on success, -errno on failure.
</para>
</refsect1>
</refentry>

<refentry id="API-sata-link-scr-lpm">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>sata_link_scr_lpm</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>sata_link_scr_lpm</refname>
 <refpurpose>
     manipulate SControl IPM and SPM fields
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>sata_link_scr_lpm </function></funcdef>
   <paramdef>struct ata_link * <parameter>link</parameter></paramdef>
   <paramdef>enum ata_lpm_policy <parameter>policy</parameter></paramdef>
   <paramdef>bool <parameter>spm_wakeup</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>link</parameter></term>
   <listitem>
    <para>
     ATA link to manipulate SControl for
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>policy</parameter></term>
   <listitem>
    <para>
     LPM policy to configure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>spm_wakeup</parameter></term>
   <listitem>
    <para>
     initiate LPM transition to active state
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Manipulate the IPM field of the SControl register of <parameter>link</parameter>
   according to <parameter>policy</parameter>.  If <parameter>policy</parameter> is ATA_LPM_MAX_POWER and
   <parameter>spm_wakeup</parameter> is <constant>true</constant>, the SPM field is manipulated to wake up
   the link.  This function also clears PHYRDY_CHG before
   returning.
</para>
</refsect1>
<refsect1>
<title>LOCKING</title>
<para>
   EH context.
</para>
</refsect1>
<refsect1>
<title>RETURNS</title>
<para>
   0 on succes, -errno otherwise.
</para>
</refsect1>
</refentry>

<refentry id="API-ata-std-prereset">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ata_std_prereset</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ata_std_prereset</refname>
 <refpurpose>
     prepare for reset
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>ata_std_prereset </function></funcdef>
   <paramdef>struct ata_link * <parameter>link</parameter></paramdef>
   <paramdef>unsigned long <parameter>deadline</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>link</parameter></term>
   <listitem>
    <para>
     ATA link to be reset
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>deadline</parameter></term>
   <listitem>
    <para>
     deadline jiffies for the operation
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   <parameter>link</parameter> is about to be reset.  Initialize it.  Failure from
   prereset makes libata abort whole reset sequence and give up
   that port, so prereset should be best-effort.  It does its
   best to prepare for reset sequence but if things go wrong, it
   should just whine, not fail.
</para>
</refsect1>
<refsect1>
<title>LOCKING</title>
<para>
   Kernel thread context (may sleep)
</para>
</refsect1>
<refsect1>
<title>RETURNS</title>
<para>
   0 on success, -errno otherwise.
</para>
</refsect1>
</refentry>

<refentry id="API-sata-link-hardreset">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>sata_link_hardreset</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>sata_link_hardreset</refname>
 <refpurpose>
     reset link via SATA phy reset
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>sata_link_hardreset </function></funcdef>
   <paramdef>struct ata_link * <parameter>link</parameter></paramdef>
   <paramdef>const unsigned long * <parameter>timing</parameter></paramdef>
   <paramdef>unsigned long <parameter>deadline</parameter></paramdef>
   <paramdef>bool * <parameter>online</parameter></paramdef>
   <paramdef>int (*<parameter>check_ready</parameter>)
     <funcparams>struct ata_link *</funcparams></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>link</parameter></term>
   <listitem>
    <para>
     link to reset
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>timing</parameter></term>
   <listitem>
    <para>
     timing parameters { interval, duratinon, timeout } in msec
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>deadline</parameter></term>
   <listitem>
    <para>
     deadline jiffies for the operation
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>online</parameter></term>
   <listitem>
    <para>
     optional out parameter indicating link onlineness
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>check_ready</parameter></term>
   <listitem>
    <para>
     optional callback to check link readiness
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   SATA phy-reset <parameter>link</parameter> using DET bits of SControl register.
   After hardreset, link readiness is waited upon using
   <function>ata_wait_ready</function> if <parameter>check_ready</parameter> is specified.  LLDs are
   allowed to not specify <parameter>check_ready</parameter> and wait itself after this
   function returns.  Device classification is LLD's
   responsibility.
   </para><para>

   *<parameter>online</parameter> is set to one iff reset succeeded and <parameter>link</parameter> is online
   after reset.
</para>
</refsect1>
<refsect1>
<title>LOCKING</title>
<para>
   Kernel thread context (may sleep)
</para>
</refsect1>
<refsect1>
<title>RETURNS</title>
<para>
   0 on success, -errno otherwise.
</para>
</refsect1>
</refentry>

<refentry id="API-sata-std-hardreset">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>sata_std_hardreset</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>sata_std_hardreset</refname>
 <refpurpose>
     COMRESET w/o waiting or classification
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>sata_std_hardreset </function></funcdef>
   <paramdef>struct ata_link * <parameter>link</parameter></paramdef>
   <paramdef>unsigned int * <parameter>class</parameter></paramdef>
   <paramdef>unsigned long <parameter>deadline</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>link</parameter></term>
   <listitem>
    <para>
     link to reset
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>class</parameter></term>
   <listitem>
    <para>
     resulting class of attached device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>deadline</parameter></term>
   <listitem>
    <para>
     deadline jiffies for the operation
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Standard SATA COMRESET w/o waiting or classification.
</para>
</refsect1>
<refsect1>
<title>LOCKING</title>
<para>
   Kernel thread context (may sleep)
</para>
</refsect1>
<refsect1>
<title>RETURNS</title>
<para>
   0 if link offline, -EAGAIN if link online, -errno on errors.
</para>
</refsect1>
</refentry>

<refentry id="API-ata-std-postreset">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ata_std_postreset</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ata_std_postreset</refname>
 <refpurpose>
     standard postreset callback
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>ata_std_postreset </function></funcdef>
   <paramdef>struct ata_link * <parameter>link</parameter></paramdef>
   <paramdef>unsigned int * <parameter>classes</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>link</parameter></term>
   <listitem>
    <para>
     the target ata_link
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>classes</parameter></term>
   <listitem>
    <para>
     classes of attached devices
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This function is invoked after a successful reset.  Note that
   the device might have been reset more than once using
   different reset methods before postreset is invoked.
</para>
</refsect1>
<refsect1>
<title>LOCKING</title>
<para>
   Kernel thread context (may sleep)
</para>
</refsect1>
</refentry>

<refentry id="API-ata-dev-set-feature">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ata_dev_set_feature</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ata_dev_set_feature</refname>
 <refpurpose>
     Issue SET FEATURES - SATA FEATURES
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>unsigned int <function>ata_dev_set_feature </function></funcdef>
   <paramdef>struct ata_device * <parameter>dev</parameter></paramdef>
   <paramdef>u8 <parameter>enable</parameter></paramdef>
   <paramdef>u8 <parameter>feature</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     Device to which command will be sent
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>enable</parameter></term>
   <listitem>
    <para>
     Whether to enable or disable the feature
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>feature</parameter></term>
   <listitem>
    <para>
     The sector count represents the feature to set
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Issue SET FEATURES - SATA FEATURES command to device <parameter>dev</parameter>
   on port <parameter>ap</parameter> with sector count
</para>
</refsect1>
<refsect1>
<title>LOCKING</title>
<para>
   PCI/etc. bus probe sem.
</para>
</refsect1>
<refsect1>
<title>RETURNS</title>
<para>
   0 on success, AC_ERR_* mask otherwise.
</para>
</refsect1>
</refentry>

<refentry id="API-ata-std-qc-defer">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ata_std_qc_defer</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ata_std_qc_defer</refname>
 <refpurpose>
     Check whether a qc needs to be deferred
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>ata_std_qc_defer </function></funcdef>
   <paramdef>struct ata_queued_cmd * <parameter>qc</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>qc</parameter></term>
   <listitem>
    <para>
     ATA command in question
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Non-NCQ commands cannot run with any other command, NCQ or
   not.  As upper layer only knows the queue depth, we are
   responsible for maintaining exclusion.  This function checks
   whether a new command <parameter>qc</parameter> can be issued.
</para>
</refsect1>
<refsect1>
<title>LOCKING</title>
<para>
   spin_lock_irqsave(host lock)
</para>
</refsect1>
<refsect1>
<title>RETURNS</title>
<para>
   ATA_DEFER_* if deferring is needed, 0 otherwise.
</para>
</refsect1>
</refentry>

<refentry id="API-ata-sg-init">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ata_sg_init</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ata_sg_init</refname>
 <refpurpose>
     Associate command with scatter-gather table.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>ata_sg_init </function></funcdef>
   <paramdef>struct ata_queued_cmd * <parameter>qc</parameter></paramdef>
   <paramdef>struct scatterlist * <parameter>sg</parameter></paramdef>
   <paramdef>unsigned int <parameter>n_elem</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>qc</parameter></term>
   <listitem>
    <para>
     Command to be associated
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>sg</parameter></term>
   <listitem>
    <para>
     Scatter-gather table.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>n_elem</parameter></term>
   <listitem>
    <para>
     Number of elements in s/g table.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Initialize the data-related elements of queued_cmd <parameter>qc</parameter>
   to point to a scatter-gather table <parameter>sg</parameter>, containing <parameter>n_elem</parameter>
   elements.
</para>
</refsect1>
<refsect1>
<title>LOCKING</title>
<para>
   spin_lock_irqsave(host lock)
</para>
</refsect1>
</refentry>

<refentry id="API-ata-qc-complete">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ata_qc_complete</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ata_qc_complete</refname>
 <refpurpose>
     Complete an active ATA command
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>ata_qc_complete </function></funcdef>
   <paramdef>struct ata_queued_cmd * <parameter>qc</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>qc</parameter></term>
   <listitem>
    <para>
     Command to complete
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Indicate to the mid and upper layers that an ATA command has
   completed, with either an ok or not-ok status.
   </para><para>

   Refrain from calling this function multiple times when
   successfully completing multiple NCQ commands.
   <function>ata_qc_complete_multiple</function> should be used instead, which will
   properly update IRQ expect state.
</para>
</refsect1>
<refsect1>
<title>LOCKING</title>
<para>
   spin_lock_irqsave(host lock)
</para>
</refsect1>
</refentry>

<refentry id="API-ata-qc-complete-multiple">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ata_qc_complete_multiple</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ata_qc_complete_multiple</refname>
 <refpurpose>
     Complete multiple qcs successfully
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>ata_qc_complete_multiple </function></funcdef>
   <paramdef>struct ata_port * <parameter>ap</parameter></paramdef>
   <paramdef>u32 <parameter>qc_active</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ap</parameter></term>
   <listitem>
    <para>
     port in question
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>qc_active</parameter></term>
   <listitem>
    <para>
     new qc_active mask
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Complete in-flight commands.  This functions is meant to be
   called from low-level driver's interrupt routine to complete
   requests normally.  ap-&gt;qc_active and <parameter>qc_active</parameter> is compared
   and commands are completed accordingly.
   </para><para>

   Always use this function when completing multiple NCQ commands
   from IRQ handlers instead of calling <function>ata_qc_complete</function>
   multiple times to keep IRQ expect status properly in sync.
</para>
</refsect1>
<refsect1>
<title>LOCKING</title>
<para>
   spin_lock_irqsave(host lock)
</para>
</refsect1>
<refsect1>
<title>RETURNS</title>
<para>
   Number of completed commands on success, -errno otherwise.
</para>
</refsect1>
</refentry>

<refentry id="API-sata-scr-valid">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>sata_scr_valid</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>sata_scr_valid</refname>
 <refpurpose>
     test whether SCRs are accessible
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>sata_scr_valid </function></funcdef>
   <paramdef>struct ata_link * <parameter>link</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>link</parameter></term>
   <listitem>
    <para>
     ATA link to test SCR accessibility for
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Test whether SCRs are accessible for <parameter>link</parameter>.
</para>
</refsect1>
<refsect1>
<title>LOCKING</title>
<para>
   None.
</para>
</refsect1>
<refsect1>
<title>RETURNS</title>
<para>
   1 if SCRs are accessible, 0 otherwise.
</para>
</refsect1>
</refentry>

<refentry id="API-sata-scr-read">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>sata_scr_read</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>sata_scr_read</refname>
 <refpurpose>
     read SCR register of the specified port
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>sata_scr_read </function></funcdef>
   <paramdef>struct ata_link * <parameter>link</parameter></paramdef>
   <paramdef>int <parameter>reg</parameter></paramdef>
   <paramdef>u32 * <parameter>val</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>link</parameter></term>
   <listitem>
    <para>
     ATA link to read SCR for
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>reg</parameter></term>
   <listitem>
    <para>
     SCR to read
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>val</parameter></term>
   <listitem>
    <para>
     Place to store read value
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Read SCR register <parameter>reg</parameter> of <parameter>link</parameter> into *<parameter>val</parameter>.  This function is
   guaranteed to succeed if <parameter>link</parameter> is ap-&gt;link, the cable type of
   the port is SATA and the port implements -&gt;scr_read.
</para>
</refsect1>
<refsect1>
<title>LOCKING</title>
<para>
   None if <parameter>link</parameter> is ap-&gt;link.  Kernel thread context otherwise.
</para>
</refsect1>
<refsect1>
<title>RETURNS</title>
<para>
   0 on success, negative errno on failure.
</para>
</refsect1>
</refentry>

<refentry id="API-sata-scr-write">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>sata_scr_write</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>sata_scr_write</refname>
 <refpurpose>
     write SCR register of the specified port
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>sata_scr_write </function></funcdef>
   <paramdef>struct ata_link * <parameter>link</parameter></paramdef>
   <paramdef>int <parameter>reg</parameter></paramdef>
   <paramdef>u32 <parameter>val</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>link</parameter></term>
   <listitem>
    <para>
     ATA link to write SCR for
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>reg</parameter></term>
   <listitem>
    <para>
     SCR to write
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>val</parameter></term>
   <listitem>
    <para>
     value to write
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Write <parameter>val</parameter> to SCR register <parameter>reg</parameter> of <parameter>link</parameter>.  This function is
   guaranteed to succeed if <parameter>link</parameter> is ap-&gt;link, the cable type of
   the port is SATA and the port implements -&gt;scr_read.
</para>
</refsect1>
<refsect1>
<title>LOCKING</title>
<para>
   None if <parameter>link</parameter> is ap-&gt;link.  Kernel thread context otherwise.
</para>
</refsect1>
<refsect1>
<title>RETURNS</title>
<para>
   0 on success, negative errno on failure.
</para>
</refsect1>
</refentry>

<refentry id="API-sata-scr-write-flush">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>sata_scr_write_flush</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>sata_scr_write_flush</refname>
 <refpurpose>
     write SCR register of the specified port and flush
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>sata_scr_write_flush </function></funcdef>
   <paramdef>struct ata_link * <parameter>link</parameter></paramdef>
   <paramdef>int <parameter>reg</parameter></paramdef>
   <paramdef>u32 <parameter>val</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>link</parameter></term>
   <listitem>
    <para>
     ATA link to write SCR for
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>reg</parameter></term>
   <listitem>
    <para>
     SCR to write
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>val</parameter></term>
   <listitem>
    <para>
     value to write
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This function is identical to <function>sata_scr_write</function> except that this
   function performs flush after writing to the register.
</para>
</refsect1>
<refsect1>
<title>LOCKING</title>
<para>
   None if <parameter>link</parameter> is ap-&gt;link.  Kernel thread context otherwise.
</para>
</refsect1>
<refsect1>
<title>RETURNS</title>
<para>
   0 on success, negative errno on failure.
</para>
</refsect1>
</refentry>

<refentry id="API-ata-link-online">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ata_link_online</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ata_link_online</refname>
 <refpurpose>
     test whether the given link is online
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>bool <function>ata_link_online </function></funcdef>
   <paramdef>struct ata_link * <parameter>link</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>link</parameter></term>
   <listitem>
    <para>
     ATA link to test
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Test whether <parameter>link</parameter> is online.  This is identical to
   <function>ata_phys_link_online</function> when there's no slave link.  When
   there's a slave link, this function should only be called on
   the master link and will return true if any of M/S links is
   online.
</para>
</refsect1>
<refsect1>
<title>LOCKING</title>
<para>
   None.
</para>
</refsect1>
<refsect1>
<title>RETURNS</title>
<para>
   True if the port online status is available and online.
</para>
</refsect1>
</refentry>

<refentry id="API-ata-link-offline">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ata_link_offline</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ata_link_offline</refname>
 <refpurpose>
     test whether the given link is offline
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>bool <function>ata_link_offline </function></funcdef>
   <paramdef>struct ata_link * <parameter>link</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>link</parameter></term>
   <listitem>
    <para>
     ATA link to test
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Test whether <parameter>link</parameter> is offline.  This is identical to
   <function>ata_phys_link_offline</function> when there's no slave link.  When
   there's a slave link, this function should only be called on
   the master link and will return true if both M/S links are
   offline.
</para>
</refsect1>
<refsect1>
<title>LOCKING</title>
<para>
   None.
</para>
</refsect1>
<refsect1>
<title>RETURNS</title>
<para>
   True if the port offline status is available and offline.
</para>
</refsect1>
</refentry>

<refentry id="API-ata-host-suspend">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ata_host_suspend</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ata_host_suspend</refname>
 <refpurpose>
     suspend host
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>ata_host_suspend </function></funcdef>
   <paramdef>struct ata_host * <parameter>host</parameter></paramdef>
   <paramdef>pm_message_t <parameter>mesg</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>host</parameter></term>
   <listitem>
    <para>
     host to suspend
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>mesg</parameter></term>
   <listitem>
    <para>
     PM message
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Suspend <parameter>host</parameter>.  Actual operation is performed by port suspend.
</para>
</refsect1>
</refentry>

<refentry id="API-ata-host-resume">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ata_host_resume</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ata_host_resume</refname>
 <refpurpose>
     resume host
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>ata_host_resume </function></funcdef>
   <paramdef>struct ata_host * <parameter>host</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>host</parameter></term>
   <listitem>
    <para>
     host to resume
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Resume <parameter>host</parameter>.  Actual operation is performed by port resume.
</para>
</refsect1>
</refentry>

<refentry id="API-ata-host-alloc">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ata_host_alloc</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ata_host_alloc</refname>
 <refpurpose>
     allocate and init basic ATA host resources
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct ata_host * <function>ata_host_alloc </function></funcdef>
   <paramdef>struct device * <parameter>dev</parameter></paramdef>
   <paramdef>int <parameter>max_ports</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     generic device this host is associated with
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>max_ports</parameter></term>
   <listitem>
    <para>
     maximum number of ATA ports associated with this host
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Allocate and initialize basic ATA host resources.  LLD calls
   this function to allocate a host, initializes it fully and
   attaches it using <function>ata_host_register</function>.
   </para><para>

   <parameter>max_ports</parameter> ports are allocated and host-&gt;n_ports is
   initialized to <parameter>max_ports</parameter>.  The caller is allowed to decrease
   host-&gt;n_ports before calling <function>ata_host_register</function>.  The unused
   ports will be automatically freed on registration.
</para>
</refsect1>
<refsect1>
<title>RETURNS</title>
<para>
   Allocate ATA host on success, NULL on failure.
</para>
</refsect1>
<refsect1>
<title>LOCKING</title>
<para>
   Inherited from calling layer (may sleep).
</para>
</refsect1>
</refentry>

<refentry id="API-ata-host-alloc-pinfo">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ata_host_alloc_pinfo</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ata_host_alloc_pinfo</refname>
 <refpurpose>
     alloc host and init with port_info array
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct ata_host * <function>ata_host_alloc_pinfo </function></funcdef>
   <paramdef>struct device * <parameter>dev</parameter></paramdef>
   <paramdef>const struct ata_port_info *const * <parameter>ppi</parameter></paramdef>
   <paramdef>int <parameter>n_ports</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     generic device this host is associated with
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>ppi</parameter></term>
   <listitem>
    <para>
     array of ATA port_info to initialize host with
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>n_ports</parameter></term>
   <listitem>
    <para>
     number of ATA ports attached to this host
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Allocate ATA host and initialize with info from <parameter>ppi</parameter>.  If NULL
   terminated, <parameter>ppi</parameter> may contain fewer entries than <parameter>n_ports</parameter>.  The
   last entry will be used for the remaining ports.
</para>
</refsect1>
<refsect1>
<title>RETURNS</title>
<para>
   Allocate ATA host on success, NULL on failure.
</para>
</refsect1>
<refsect1>
<title>LOCKING</title>
<para>
   Inherited from calling layer (may sleep).
</para>
</refsect1>
</refentry>

<refentry id="API-ata-slave-link-init">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ata_slave_link_init</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ata_slave_link_init</refname>
 <refpurpose>
     initialize slave link
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>ata_slave_link_init </function></funcdef>
   <paramdef>struct ata_port * <parameter>ap</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ap</parameter></term>
   <listitem>
    <para>
     port to initialize slave link for
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Create and initialize slave link for <parameter>ap</parameter>.  This enables slave
   link handling on the port.
   </para><para>

   In libata, a port contains links and a link contains devices.
   There is single host link but if a PMP is attached to it,
   there can be multiple fan-out links.  On SATA, there's usually
   a single device connected to a link but PATA and SATA
   controllers emulating TF based interface can have two - master
   and slave.
   </para><para>

   However, there are a few controllers which don't fit into this
   abstraction too well - SATA controllers which emulate TF
   interface with both master and slave devices but also have
   separate SCR register sets for each device.  These controllers
   need separate links for physical link handling
   (e.g. onlineness, link speed) but should be treated like a
   traditional M/S controller for everything else (e.g. command
   issue, softreset).
   </para><para>

   slave_link is libata's way of handling this class of
   controllers without impacting core layer too much.  For
   anything other than physical link handling, the default host
   link is used for both master and slave.  For physical link
   handling, separate <parameter>ap</parameter>-&gt;slave_link is used.  All dirty details
   are implemented inside libata core layer.  From LLD's POV, the
   only difference is that prereset, hardreset and postreset are
   called once more for the slave link, so the reset sequence
   looks like the following.
   </para><para>

   prereset(M) -&gt; prereset(S) -&gt; hardreset(M) -&gt; hardreset(S) -&gt;
   softreset(M) -&gt; postreset(M) -&gt; postreset(S)
   </para><para>

   Note that softreset is called only for the master.  Softreset
   resets both M/S by definition, so SRST on master should handle
   both (the standard method will work just fine).
</para>
</refsect1>
<refsect1>
<title>LOCKING</title>
<para>
   Should be called before host is registered.
</para>
</refsect1>
<refsect1>
<title>RETURNS</title>
<para>
   0 on success, -errno on failure.
</para>
</refsect1>
</refentry>

<refentry id="API-ata-host-start">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ata_host_start</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ata_host_start</refname>
 <refpurpose>
     start and freeze ports of an ATA host
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>ata_host_start </function></funcdef>
   <paramdef>struct ata_host * <parameter>host</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>host</parameter></term>
   <listitem>
    <para>
     ATA host to start ports for
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Start and then freeze ports of <parameter>host</parameter>.  Started status is
   recorded in host-&gt;flags, so this function can be called
   multiple times.  Ports are guaranteed to get started only
   once.  If host-&gt;ops isn't initialized yet, its set to the
   first non-dummy port ops.
</para>
</refsect1>
<refsect1>
<title>LOCKING</title>
<para>
   Inherited from calling layer (may sleep).
</para>
</refsect1>
<refsect1>
<title>RETURNS</title>
<para>
   0 if all ports are started successfully, -errno otherwise.
</para>
</refsect1>
</refentry>

<refentry id="API-ata-host-init">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ata_host_init</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ata_host_init</refname>
 <refpurpose>
     Initialize a host struct for sas (ipr, libsas)
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>ata_host_init </function></funcdef>
   <paramdef>struct ata_host * <parameter>host</parameter></paramdef>
   <paramdef>struct device * <parameter>dev</parameter></paramdef>
   <paramdef>struct ata_port_operations * <parameter>ops</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>host</parameter></term>
   <listitem>
    <para>
     host to initialize
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     device host is attached to
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>ops</parameter></term>
   <listitem>
    <para>
     port_ops
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-ata-host-register">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ata_host_register</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ata_host_register</refname>
 <refpurpose>
     register initialized ATA host
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>ata_host_register </function></funcdef>
   <paramdef>struct ata_host * <parameter>host</parameter></paramdef>
   <paramdef>struct scsi_host_template * <parameter>sht</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>host</parameter></term>
   <listitem>
    <para>
     ATA host to register
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>sht</parameter></term>
   <listitem>
    <para>
     template for SCSI host
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Register initialized ATA host.  <parameter>host</parameter> is allocated using
   <function>ata_host_alloc</function> and fully initialized by LLD.  This function
   starts ports, registers <parameter>host</parameter> with ATA and SCSI layers and
   probe registered devices.
</para>
</refsect1>
<refsect1>
<title>LOCKING</title>
<para>
   Inherited from calling layer (may sleep).
</para>
</refsect1>
<refsect1>
<title>RETURNS</title>
<para>
   0 on success, -errno otherwise.
</para>
</refsect1>
</refentry>

<refentry id="API-ata-host-activate">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ata_host_activate</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ata_host_activate</refname>
 <refpurpose>
     start host, request IRQ and register it
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>ata_host_activate </function></funcdef>
   <paramdef>struct ata_host * <parameter>host</parameter></paramdef>
   <paramdef>int <parameter>irq</parameter></paramdef>
   <paramdef>irq_handler_t <parameter>irq_handler</parameter></paramdef>
   <paramdef>unsigned long <parameter>irq_flags</parameter></paramdef>
   <paramdef>struct scsi_host_template * <parameter>sht</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>host</parameter></term>
   <listitem>
    <para>
     target ATA host
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>irq</parameter></term>
   <listitem>
    <para>
     IRQ to request
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>irq_handler</parameter></term>
   <listitem>
    <para>
     irq_handler used when requesting IRQ
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>irq_flags</parameter></term>
   <listitem>
    <para>
     irq_flags used when requesting IRQ
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>sht</parameter></term>
   <listitem>
    <para>
     scsi_host_template to use when registering the host
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   After allocating an ATA host and initializing it, most libata
   LLDs perform three steps to activate the host - start host,
   request IRQ and register it.  This helper takes necessasry
   arguments and performs the three steps in one go.
   </para><para>

   An invalid IRQ skips the IRQ registration and expects the host to
   have set polling mode on the port. In this case, <parameter>irq_handler</parameter>
   should be NULL.
</para>
</refsect1>
<refsect1>
<title>LOCKING</title>
<para>
   Inherited from calling layer (may sleep).
</para>
</refsect1>
<refsect1>
<title>RETURNS</title>
<para>
   0 on success, -errno otherwise.
</para>
</refsect1>
</refentry>

<refentry id="API-ata-host-detach">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ata_host_detach</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ata_host_detach</refname>
 <refpurpose>
     Detach all ports of an ATA host
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>ata_host_detach </function></funcdef>
   <paramdef>struct ata_host * <parameter>host</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>host</parameter></term>
   <listitem>
    <para>
     Host to detach
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Detach all ports of <parameter>host</parameter>.
</para>
</refsect1>
<refsect1>
<title>LOCKING</title>
<para>
   Kernel thread context (may sleep).
</para>
</refsect1>
</refentry>

<refentry id="API-ata-pci-remove-one">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ata_pci_remove_one</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ata_pci_remove_one</refname>
 <refpurpose>
     PCI layer callback for device removal
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>ata_pci_remove_one </function></funcdef>
   <paramdef>struct pci_dev * <parameter>pdev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>pdev</parameter></term>
   <listitem>
    <para>
     PCI device that was removed
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   PCI layer indicates to libata via this hook that hot-unplug or
   module unload event has occurred.  Detach all ports.  Resource
   release is handled via devres.
</para>
</refsect1>
<refsect1>
<title>LOCKING</title>
<para>
   Inherited from PCI layer (may sleep).
</para>
</refsect1>
</refentry>

<refentry id="API-ata-platform-remove-one">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ata_platform_remove_one</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ata_platform_remove_one</refname>
 <refpurpose>
     Platform layer callback for device removal
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>ata_platform_remove_one </function></funcdef>
   <paramdef>struct platform_device * <parameter>pdev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>pdev</parameter></term>
   <listitem>
    <para>
     Platform device that was removed
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Platform layer indicates to libata via this hook that hot-unplug or
   module unload event has occurred.  Detach all ports.  Resource
   release is handled via devres.
</para>
</refsect1>
<refsect1>
<title>LOCKING</title>
<para>
   Inherited from platform layer (may sleep).
</para>
</refsect1>
</refentry>

<refentry id="API-ata-msleep">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ata_msleep</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ata_msleep</refname>
 <refpurpose>
     ATA EH owner aware msleep
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>ata_msleep </function></funcdef>
   <paramdef>struct ata_port * <parameter>ap</parameter></paramdef>
   <paramdef>unsigned int <parameter>msecs</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ap</parameter></term>
   <listitem>
    <para>
     ATA port to attribute the sleep to
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>msecs</parameter></term>
   <listitem>
    <para>
     duration to sleep in milliseconds
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Sleeps <parameter>msecs</parameter>.  If the current task is owner of <parameter>ap</parameter>'s EH, the
   ownership is released before going to sleep and reacquired
   after the sleep is complete.  IOW, other ports sharing the
   <parameter>ap</parameter>-&gt;host will be allowed to own the EH while this task is
   sleeping.
</para>
</refsect1>
<refsect1>
<title>LOCKING</title>
<para>
   Might sleep.
</para>
</refsect1>
</refentry>

<refentry id="API-ata-wait-register">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ata_wait_register</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ata_wait_register</refname>
 <refpurpose>
     wait until register value changes
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>u32 <function>ata_wait_register </function></funcdef>
   <paramdef>struct ata_port * <parameter>ap</parameter></paramdef>
   <paramdef>void __iomem * <parameter>reg</parameter></paramdef>
   <paramdef>u32 <parameter>mask</parameter></paramdef>
   <paramdef>u32 <parameter>val</parameter></paramdef>
   <paramdef>unsigned long <parameter>interval</parameter></paramdef>
   <paramdef>unsigned long <parameter>timeout</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ap</parameter></term>
   <listitem>
    <para>
     ATA port to wait register for, can be NULL
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>reg</parameter></term>
   <listitem>
    <para>
     IO-mapped register
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>mask</parameter></term>
   <listitem>
    <para>
     Mask to apply to read register value
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>val</parameter></term>
   <listitem>
    <para>
     Wait condition
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>interval</parameter></term>
   <listitem>
    <para>
     polling interval in milliseconds
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>timeout</parameter></term>
   <listitem>
    <para>
     timeout in milliseconds
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Waiting for some bits of register to change is a common
   operation for ATA controllers.  This function reads 32bit LE
   IO-mapped register <parameter>reg</parameter> and tests for the following condition.
   </para><para>

   (*<parameter>reg</parameter> &amp; mask) != val
   </para><para>

   If the condition is met, it returns; otherwise, the process is
   repeated after <parameter>interval_msec</parameter> until timeout.
</para>
</refsect1>
<refsect1>
<title>LOCKING</title>
<para>
   Kernel thread context (may sleep)
</para>
</refsect1>
<refsect1>
<title>RETURNS</title>
<para>
   The final register value.
</para>
</refsect1>
</refentry>

<refentry id="API-sata-lpm-ignore-phy-events">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>sata_lpm_ignore_phy_events</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>sata_lpm_ignore_phy_events</refname>
 <refpurpose>
     test if PHY event should be ignored
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>bool <function>sata_lpm_ignore_phy_events </function></funcdef>
   <paramdef>struct ata_link * <parameter>link</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>link</parameter></term>
   <listitem>
    <para>
     Link receiving the event
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Test whether the received PHY event has to be ignored or not.
</para>
</refsect1>
<refsect1>
<title>RETURNS</title>
<para>
   True if the event has to be ignored.
</para>
</refsect1>
</refentry>

  </chapter>

  <chapter id="libataInt">
     <title>libata Core Internals</title>
<!-- drivers/ata/libata-core.c -->
<refentry id="API-ata-dev-phys-link">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ata_dev_phys_link</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ata_dev_phys_link</refname>
 <refpurpose>
  find physical link for a device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct ata_link * <function>ata_dev_phys_link </function></funcdef>
   <paramdef>struct ata_device * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     ATA device to look up physical link for
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Look up physical link which <parameter>dev</parameter> is attached to.  Note that
   this is different from <parameter>dev</parameter>-&gt;link only when <parameter>dev</parameter> is on slave
   link.  For all other cases, it's the same as <parameter>dev</parameter>-&gt;link.
</para>
</refsect1>
<refsect1>
<title>LOCKING</title>
<para>
   Don't care.
</para>
</refsect1>
<refsect1>
<title>RETURNS</title>
<para>
   Pointer to the found physical link.
</para>
</refsect1>
</refentry>

<refentry id="API-ata-force-cbl">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ata_force_cbl</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ata_force_cbl</refname>
 <refpurpose>
     force cable type according to libata.force
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>ata_force_cbl </function></funcdef>
   <paramdef>struct ata_port * <parameter>ap</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ap</parameter></term>
   <listitem>
    <para>
     ATA port of interest
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Force cable type according to libata.force and whine about it.
   The last entry which has matching port number is used, so it
   can be specified as part of device force parameters.  For
   example, both <quote>a:40c,1.00:udma4</quote> and <quote>1.00:40c,udma4</quote> have the
   same effect.
</para>
</refsect1>
<refsect1>
<title>LOCKING</title>
<para>
   EH context.
</para>
</refsect1>
</refentry>

<refentry id="API-ata-force-link-limits">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ata_force_link_limits</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ata_force_link_limits</refname>
 <refpurpose>
     force link limits according to libata.force
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>ata_force_link_limits </function></funcdef>
   <paramdef>struct ata_link * <parameter>link</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>link</parameter></term>
   <listitem>
    <para>
     ATA link of interest
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Force link flags and SATA spd limit according to libata.force
   and whine about it.  When only the port part is specified
   (e.g. 1:), the limit applies to all links connected to both
   the host link and all fan-out ports connected via PMP.  If the
   device part is specified as 0 (e.g. 1.00:), it specifies the
   first fan-out link not the host link.  Device number 15 always
   points to the host link whether PMP is attached or not.  If the
   controller has slave link, device number 16 points to it.
</para>
</refsect1>
<refsect1>
<title>LOCKING</title>
<para>
   EH context.
</para>
</refsect1>
</refentry>

<refentry id="API-ata-force-xfermask">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ata_force_xfermask</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ata_force_xfermask</refname>
 <refpurpose>
     force xfermask according to libata.force
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>ata_force_xfermask </function></funcdef>
   <paramdef>struct ata_device * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     ATA device of interest
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Force xfer_mask according to libata.force and whine about it.
   For consistency with link selection, device number 15 selects
   the first device connected to the host link.
</para>
</refsect1>
<refsect1>
<title>LOCKING</title>
<para>
   EH context.
</para>
</refsect1>
</refentry>

<refentry id="API-ata-force-horkage">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ata_force_horkage</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ata_force_horkage</refname>
 <refpurpose>
     force horkage according to libata.force
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>ata_force_horkage </function></funcdef>
   <paramdef>struct ata_device * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     ATA device of interest
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Force horkage according to libata.force and whine about it.
   For consistency with link selection, device number 15 selects
   the first device connected to the host link.
</para>
</refsect1>
<refsect1>
<title>LOCKING</title>
<para>
   EH context.
</para>
</refsect1>
</refentry>

<refentry id="API-ata-rwcmd-protocol">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ata_rwcmd_protocol</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ata_rwcmd_protocol</refname>
 <refpurpose>
     set taskfile r/w commands and protocol
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>ata_rwcmd_protocol </function></funcdef>
   <paramdef>struct ata_taskfile * <parameter>tf</parameter></paramdef>
   <paramdef>struct ata_device * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>tf</parameter></term>
   <listitem>
    <para>
     command to examine and configure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     device tf belongs to
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Examine the device configuration and tf-&gt;flags to calculate
   the proper read/write commands and protocol to use.
</para>
</refsect1>
<refsect1>
<title>LOCKING</title>
<para>
   caller.
</para>
</refsect1>
</refentry>

<refentry id="API-ata-tf-read-block">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ata_tf_read_block</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ata_tf_read_block</refname>
 <refpurpose>
     Read block address from ATA taskfile
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>u64 <function>ata_tf_read_block </function></funcdef>
   <paramdef>struct ata_taskfile * <parameter>tf</parameter></paramdef>
   <paramdef>struct ata_device * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>tf</parameter></term>
   <listitem>
    <para>
     ATA taskfile of interest
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     ATA device <parameter>tf</parameter> belongs to
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>LOCKING</title>
<para>
   None.
   </para><para>

   Read block address from <parameter>tf</parameter>.  This function can handle all
   three address formats - LBA, LBA48 and CHS.  tf-&gt;protocol and
   flags select the address format to use.
</para>
</refsect1>
<refsect1>
<title>RETURNS</title>
<para>
   Block address read from <parameter>tf</parameter>.
</para>
</refsect1>
</refentry>

<refentry id="API-ata-build-rw-tf">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ata_build_rw_tf</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ata_build_rw_tf</refname>
 <refpurpose>
     Build ATA taskfile for given read/write request
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>ata_build_rw_tf </function></funcdef>
   <paramdef>struct ata_taskfile * <parameter>tf</parameter></paramdef>
   <paramdef>struct ata_device * <parameter>dev</parameter></paramdef>
   <paramdef>u64 <parameter>block</parameter></paramdef>
   <paramdef>u32 <parameter>n_block</parameter></paramdef>
   <paramdef>unsigned int <parameter>tf_flags</parameter></paramdef>
   <paramdef>unsigned int <parameter>tag</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>tf</parameter></term>
   <listitem>
    <para>
     Target ATA taskfile
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     ATA device <parameter>tf</parameter> belongs to
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>block</parameter></term>
   <listitem>
    <para>
     Block address
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>n_block</parameter></term>
   <listitem>
    <para>
     Number of blocks
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>tf_flags</parameter></term>
   <listitem>
    <para>
     RW/FUA etc...
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>tag</parameter></term>
   <listitem>
    <para>
     tag
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>LOCKING</title>
<para>
   None.
   </para><para>

   Build ATA taskfile <parameter>tf</parameter> for read/write request described by
   <parameter>block</parameter>, <parameter>n_block</parameter>, <parameter>tf_flags</parameter> and <parameter>tag</parameter> on <parameter>dev</parameter>.
</para>
</refsect1>
<refsect1>
<title>RETURNS</title>
<para>
   </para><para>

   0 on success, -ERANGE if the request is too large for <parameter>dev</parameter>,
   -EINVAL if the request is invalid.
</para>
</refsect1>
</refentry>

<refentry id="API-ata-read-native-max-address">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ata_read_native_max_address</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ata_read_native_max_address</refname>
 <refpurpose>
     Read native max address
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>ata_read_native_max_address </function></funcdef>
   <paramdef>struct ata_device * <parameter>dev</parameter></paramdef>
   <paramdef>u64 * <parameter>max_sectors</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     target device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>max_sectors</parameter></term>
   <listitem>
    <para>
     out parameter for the result native max address
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Perform an LBA48 or LBA28 native size query upon the device in
   question.
</para>
</refsect1>
<refsect1>
<title>RETURNS</title>
<para>
   0 on success, -EACCES if command is aborted by the drive.
   -EIO on other errors.
</para>
</refsect1>
</refentry>

<refentry id="API-ata-set-max-sectors">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ata_set_max_sectors</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ata_set_max_sectors</refname>
 <refpurpose>
     Set max sectors
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>ata_set_max_sectors </function></funcdef>
   <paramdef>struct ata_device * <parameter>dev</parameter></paramdef>
   <paramdef>u64 <parameter>new_sectors</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     target device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>new_sectors</parameter></term>
   <listitem>
    <para>
     new max sectors value to set for the device
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Set max sectors of <parameter>dev</parameter> to <parameter>new_sectors</parameter>.
</para>
</refsect1>
<refsect1>
<title>RETURNS</title>
<para>
   0 on success, -EACCES if command is aborted or denied (due to
   previous non-volatile SET_MAX) by the drive.  -EIO on other
   errors.
</para>
</refsect1>
</refentry>

<refentry id="API-ata-hpa-resize">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ata_hpa_resize</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ata_hpa_resize</refname>
 <refpurpose>
     Resize a device with an HPA set
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>ata_hpa_resize </function></funcdef>
   <paramdef>struct ata_device * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     Device to resize
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Read the size of an LBA28 or LBA48 disk with HPA features and resize
   it if required to the full size of the media. The caller must check
   the drive has the HPA feature set enabled.
</para>
</refsect1>
<refsect1>
<title>RETURNS</title>
<para>
   0 on success, -errno on failure.
</para>
</refsect1>
</refentry>

<refentry id="API-ata-dump-id">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ata_dump_id</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ata_dump_id</refname>
 <refpurpose>
     IDENTIFY DEVICE info debugging output
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>ata_dump_id </function></funcdef>
   <paramdef>const u16 * <parameter>id</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>id</parameter></term>
   <listitem>
    <para>
     IDENTIFY DEVICE page to dump
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Dump selected 16-bit words from the given IDENTIFY DEVICE
   page.
</para>
</refsect1>
<refsect1>
<title>LOCKING</title>
<para>
   caller.
</para>
</refsect1>
</refentry>

<refentry id="API-ata-exec-internal-sg">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ata_exec_internal_sg</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ata_exec_internal_sg</refname>
 <refpurpose>
     execute libata internal command
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>unsigned <function>ata_exec_internal_sg </function></funcdef>
   <paramdef>struct ata_device * <parameter>dev</parameter></paramdef>
   <paramdef>struct ata_taskfile * <parameter>tf</parameter></paramdef>
   <paramdef>const u8 * <parameter>cdb</parameter></paramdef>
   <paramdef>int <parameter>dma_dir</parameter></paramdef>
   <paramdef>struct scatterlist * <parameter>sgl</parameter></paramdef>
   <paramdef>unsigned int <parameter>n_elem</parameter></paramdef>
   <paramdef>unsigned long <parameter>timeout</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     Device to which the command is sent
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>tf</parameter></term>
   <listitem>
    <para>
     Taskfile registers for the command and the result
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>cdb</parameter></term>
   <listitem>
    <para>
     CDB for packet command
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>dma_dir</parameter></term>
   <listitem>
    <para>
     Data transfer direction of the command
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>sgl</parameter></term>
   <listitem>
    <para>
     sg list for the data buffer of the command
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>n_elem</parameter></term>
   <listitem>
    <para>
     Number of sg entries
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>timeout</parameter></term>
   <listitem>
    <para>
     Timeout in msecs (0 for default)
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Executes libata internal command with timeout.  <parameter>tf</parameter> contains
   command on entry and result on return.  Timeout and error
   conditions are reported via return value.  No recovery action
   is taken after a command times out.  It's caller's duty to
   clean up after timeout.
</para>
</refsect1>
<refsect1>
<title>LOCKING</title>
<para>
   None.  Should be called with kernel context, might sleep.
</para>
</refsect1>
<refsect1>
<title>RETURNS</title>
<para>
   Zero on success, AC_ERR_* mask on failure
</para>
</refsect1>
</refentry>

<refentry id="API-ata-exec-internal">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ata_exec_internal</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ata_exec_internal</refname>
 <refpurpose>
     execute libata internal command
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>unsigned <function>ata_exec_internal </function></funcdef>
   <paramdef>struct ata_device * <parameter>dev</parameter></paramdef>
   <paramdef>struct ata_taskfile * <parameter>tf</parameter></paramdef>
   <paramdef>const u8 * <parameter>cdb</parameter></paramdef>
   <paramdef>int <parameter>dma_dir</parameter></paramdef>
   <paramdef>void * <parameter>buf</parameter></paramdef>
   <paramdef>unsigned int <parameter>buflen</parameter></paramdef>
   <paramdef>unsigned long <parameter>timeout</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     Device to which the command is sent
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>tf</parameter></term>
   <listitem>
    <para>
     Taskfile registers for the command and the result
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>cdb</parameter></term>
   <listitem>
    <para>
     CDB for packet command
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>dma_dir</parameter></term>
   <listitem>
    <para>
     Data transfer direction of the command
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>buf</parameter></term>
   <listitem>
    <para>
     Data buffer of the command
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>buflen</parameter></term>
   <listitem>
    <para>
     Length of data buffer
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>timeout</parameter></term>
   <listitem>
    <para>
     Timeout in msecs (0 for default)
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Wrapper around <function>ata_exec_internal_sg</function> which takes simple
   buffer instead of sg list.
</para>
</refsect1>
<refsect1>
<title>LOCKING</title>
<para>
   None.  Should be called with kernel context, might sleep.
</para>
</refsect1>
<refsect1>
<title>RETURNS</title>
<para>
   Zero on success, AC_ERR_* mask on failure
</para>
</refsect1>
</refentry>

<refentry id="API-ata-do-simple-cmd">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ata_do_simple_cmd</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ata_do_simple_cmd</refname>
 <refpurpose>
     execute simple internal command
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>unsigned int <function>ata_do_simple_cmd </function></funcdef>
   <paramdef>struct ata_device * <parameter>dev</parameter></paramdef>
   <paramdef>u8 <parameter>cmd</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     Device to which the command is sent
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>cmd</parameter></term>
   <listitem>
    <para>
     Opcode to execute
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Execute a 'simple' command, that only consists of the opcode
   'cmd' itself, without filling any other registers
</para>
</refsect1>
<refsect1>
<title>LOCKING</title>
<para>
   Kernel thread context (may sleep).
</para>
</refsect1>
<refsect1>
<title>RETURNS</title>
<para>
   Zero on success, AC_ERR_* mask on failure
</para>
</refsect1>
</refentry>

<refentry id="API-ata-pio-mask-no-iordy">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ata_pio_mask_no_iordy</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ata_pio_mask_no_iordy</refname>
 <refpurpose>
     Return the non IORDY mask
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>u32 <function>ata_pio_mask_no_iordy </function></funcdef>
   <paramdef>const struct ata_device * <parameter>adev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>adev</parameter></term>
   <listitem>
    <para>
     ATA device
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Compute the highest mode possible if we are not using iordy. Return
   -1 if no iordy mode is available.
</para>
</refsect1>
</refentry>

<refentry id="API-ata-dev-read-id">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ata_dev_read_id</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ata_dev_read_id</refname>
 <refpurpose>
     Read ID data from the specified device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>ata_dev_read_id </function></funcdef>
   <paramdef>struct ata_device * <parameter>dev</parameter></paramdef>
   <paramdef>unsigned int * <parameter>p_class</parameter></paramdef>
   <paramdef>unsigned int <parameter>flags</parameter></paramdef>
   <paramdef>u16 * <parameter>id</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     target device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>p_class</parameter></term>
   <listitem>
    <para>
     pointer to class of the target device (may be changed)
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>flags</parameter></term>
   <listitem>
    <para>
     ATA_READID_* flags
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>id</parameter></term>
   <listitem>
    <para>
     buffer to read IDENTIFY data into
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Read ID data from the specified device.  ATA_CMD_ID_ATA is
   performed on ATA devices and ATA_CMD_ID_ATAPI on ATAPI
   devices.  This function also issues ATA_CMD_INIT_DEV_PARAMS
   for pre-ATA4 drives.
</para>
</refsect1>
<refsect1>
<title>FIXME</title>
<para>
   ATA_CMD_ID_ATA is optional for early drives and right
   now we abort if we hit that case.
</para>
</refsect1>
<refsect1>
<title>LOCKING</title>
<para>
   Kernel thread context (may sleep)
</para>
</refsect1>
<refsect1>
<title>RETURNS</title>
<para>
   0 on success, -errno otherwise.
</para>
</refsect1>
</refentry>

<refentry id="API-ata-dev-configure">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ata_dev_configure</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ata_dev_configure</refname>
 <refpurpose>
     Configure the specified ATA/ATAPI device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>ata_dev_configure </function></funcdef>
   <paramdef>struct ata_device * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     Target device to configure
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Configure <parameter>dev</parameter> according to <parameter>dev</parameter>-&gt;id.  Generic and low-level
   driver specific fixups are also applied.
</para>
</refsect1>
<refsect1>
<title>LOCKING</title>
<para>
   Kernel thread context (may sleep)
</para>
</refsect1>
<refsect1>
<title>RETURNS</title>
<para>
   0 on success, -errno otherwise
</para>
</refsect1>
</refentry>

<refentry id="API-ata-bus-probe">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ata_bus_probe</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ata_bus_probe</refname>
 <refpurpose>
     Reset and probe ATA bus
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>ata_bus_probe </function></funcdef>
   <paramdef>struct ata_port * <parameter>ap</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ap</parameter></term>
   <listitem>
    <para>
     Bus to probe
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Master ATA bus probing function.  Initiates a hardware-dependent
   bus reset, then attempts to identify any devices found on
   the bus.
</para>
</refsect1>
<refsect1>
<title>LOCKING</title>
<para>
   PCI/etc. bus probe sem.
</para>
</refsect1>
<refsect1>
<title>RETURNS</title>
<para>
   Zero on success, negative errno otherwise.
</para>
</refsect1>
</refentry>

<refentry id="API-sata-print-link-status">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>sata_print_link_status</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>sata_print_link_status</refname>
 <refpurpose>
     Print SATA link status
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>sata_print_link_status </function></funcdef>
   <paramdef>struct ata_link * <parameter>link</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>link</parameter></term>
   <listitem>
    <para>
     SATA link to printk link status about
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This function prints link speed and status of a SATA link.
</para>
</refsect1>
<refsect1>
<title>LOCKING</title>
<para>
   None.
</para>
</refsect1>
</refentry>

<refentry id="API-sata-down-spd-limit">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>sata_down_spd_limit</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>sata_down_spd_limit</refname>
 <refpurpose>
     adjust SATA spd limit downward
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>sata_down_spd_limit </function></funcdef>
   <paramdef>struct ata_link * <parameter>link</parameter></paramdef>
   <paramdef>u32 <parameter>spd_limit</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>link</parameter></term>
   <listitem>
    <para>
     Link to adjust SATA spd limit for
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>spd_limit</parameter></term>
   <listitem>
    <para>
     Additional limit
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Adjust SATA spd limit of <parameter>link</parameter> downward.  Note that this
   function only adjusts the limit.  The change must be applied
   using <function>sata_set_spd</function>.
   </para><para>

   If <parameter>spd_limit</parameter> is non-zero, the speed is limited to equal to or
   lower than <parameter>spd_limit</parameter> if such speed is supported.  If
   <parameter>spd_limit</parameter> is slower than any supported speed, only the lowest
   supported speed is allowed.
</para>
</refsect1>
<refsect1>
<title>LOCKING</title>
<para>
   Inherited from caller.
</para>
</refsect1>
<refsect1>
<title>RETURNS</title>
<para>
   0 on success, negative errno on failure
</para>
</refsect1>
</refentry>

<refentry id="API-sata-set-spd-needed">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>sata_set_spd_needed</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>sata_set_spd_needed</refname>
 <refpurpose>
     is SATA spd configuration needed
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>sata_set_spd_needed </function></funcdef>
   <paramdef>struct ata_link * <parameter>link</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>link</parameter></term>
   <listitem>
    <para>
     Link in question
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Test whether the spd limit in SControl matches
   <parameter>link</parameter>-&gt;sata_spd_limit.  This function is used to determine
   whether hardreset is necessary to apply SATA spd
   configuration.
</para>
</refsect1>
<refsect1>
<title>LOCKING</title>
<para>
   Inherited from caller.
</para>
</refsect1>
<refsect1>
<title>RETURNS</title>
<para>
   1 if SATA spd configuration is needed, 0 otherwise.
</para>
</refsect1>
</refentry>

<refentry id="API-ata-down-xfermask-limit">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ata_down_xfermask_limit</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ata_down_xfermask_limit</refname>
 <refpurpose>
     adjust dev xfer masks downward
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>ata_down_xfermask_limit </function></funcdef>
   <paramdef>struct ata_device * <parameter>dev</parameter></paramdef>
   <paramdef>unsigned int <parameter>sel</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     Device to adjust xfer masks
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>sel</parameter></term>
   <listitem>
    <para>
     ATA_DNXFER_* selector
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Adjust xfer masks of <parameter>dev</parameter> downward.  Note that this function
   does not apply the change.  Invoking <function>ata_set_mode</function> afterwards
   will apply the limit.
</para>
</refsect1>
<refsect1>
<title>LOCKING</title>
<para>
   Inherited from caller.
</para>
</refsect1>
<refsect1>
<title>RETURNS</title>
<para>
   0 on success, negative errno on failure
</para>
</refsect1>
</refentry>

<refentry id="API-ata-wait-ready">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ata_wait_ready</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ata_wait_ready</refname>
 <refpurpose>
     wait for link to become ready
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>ata_wait_ready </function></funcdef>
   <paramdef>struct ata_link * <parameter>link</parameter></paramdef>
   <paramdef>unsigned long <parameter>deadline</parameter></paramdef>
   <paramdef>int (*<parameter>check_ready</parameter>)
     <funcparams>struct ata_link *link</funcparams></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>link</parameter></term>
   <listitem>
    <para>
     link to be waited on
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>deadline</parameter></term>
   <listitem>
    <para>
     deadline jiffies for the operation
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>check_ready</parameter></term>
   <listitem>
    <para>
     callback to check link readiness
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Wait for <parameter>link</parameter> to become ready.  <parameter>check_ready</parameter> should return
   positive number if <parameter>link</parameter> is ready, 0 if it isn't, -ENODEV if
   link doesn't seem to be occupied, other errno for other error
   conditions.
   </para><para>

   Transient -ENODEV conditions are allowed for
   ATA_TMOUT_FF_WAIT.
</para>
</refsect1>
<refsect1>
<title>LOCKING</title>
<para>
   EH context.
</para>
</refsect1>
<refsect1>
<title>RETURNS</title>
<para>
   0 if <parameter>linke</parameter> is ready before <parameter>deadline</parameter>; otherwise, -errno.
</para>
</refsect1>
</refentry>

<refentry id="API-ata-dev-same-device">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ata_dev_same_device</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ata_dev_same_device</refname>
 <refpurpose>
     Determine whether new ID matches configured device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>ata_dev_same_device </function></funcdef>
   <paramdef>struct ata_device * <parameter>dev</parameter></paramdef>
   <paramdef>unsigned int <parameter>new_class</parameter></paramdef>
   <paramdef>const u16 * <parameter>new_id</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     device to compare against
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>new_class</parameter></term>
   <listitem>
    <para>
     class of the new device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>new_id</parameter></term>
   <listitem>
    <para>
     IDENTIFY page of the new device
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Compare <parameter>new_class</parameter> and <parameter>new_id</parameter> against <parameter>dev</parameter> and determine
   whether <parameter>dev</parameter> is the device indicated by <parameter>new_class</parameter> and
   <parameter>new_id</parameter>.
</para>
</refsect1>
<refsect1>
<title>LOCKING</title>
<para>
   None.
</para>
</refsect1>
<refsect1>
<title>RETURNS</title>
<para>
   1 if <parameter>dev</parameter> matches <parameter>new_class</parameter> and <parameter>new_id</parameter>, 0 otherwise.
</para>
</refsect1>
</refentry>

<refentry id="API-ata-dev-reread-id">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ata_dev_reread_id</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ata_dev_reread_id</refname>
 <refpurpose>
     Re-read IDENTIFY data
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>ata_dev_reread_id </function></funcdef>
   <paramdef>struct ata_device * <parameter>dev</parameter></paramdef>
   <paramdef>unsigned int <parameter>readid_flags</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     target ATA device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>readid_flags</parameter></term>
   <listitem>
    <para>
     read ID flags
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Re-read IDENTIFY page and make sure <parameter>dev</parameter> is still attached to
   the port.
</para>
</refsect1>
<refsect1>
<title>LOCKING</title>
<para>
   Kernel thread context (may sleep)
</para>
</refsect1>
<refsect1>
<title>RETURNS</title>
<para>
   0 on success, negative errno otherwise
</para>
</refsect1>
</refentry>

<refentry id="API-ata-dev-revalidate">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ata_dev_revalidate</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ata_dev_revalidate</refname>
 <refpurpose>
     Revalidate ATA device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>ata_dev_revalidate </function></funcdef>
   <paramdef>struct ata_device * <parameter>dev</parameter></paramdef>
   <paramdef>unsigned int <parameter>new_class</parameter></paramdef>
   <paramdef>unsigned int <parameter>readid_flags</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     device to revalidate
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>new_class</parameter></term>
   <listitem>
    <para>
     new class code
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>readid_flags</parameter></term>
   <listitem>
    <para>
     read ID flags
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Re-read IDENTIFY page, make sure <parameter>dev</parameter> is still attached to the
   port and reconfigure it according to the new IDENTIFY page.
</para>
</refsect1>
<refsect1>
<title>LOCKING</title>
<para>
   Kernel thread context (may sleep)
</para>
</refsect1>
<refsect1>
<title>RETURNS</title>
<para>
   0 on success, negative errno otherwise
</para>
</refsect1>
</refentry>

<refentry id="API-ata-is-40wire">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ata_is_40wire</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ata_is_40wire</refname>
 <refpurpose>
     check drive side detection
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>ata_is_40wire </function></funcdef>
   <paramdef>struct ata_device * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     device
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Perform drive side detection decoding, allowing for device vendors
   who can't follow the documentation.
</para>
</refsect1>
</refentry>

<refentry id="API-cable-is-40wire">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>cable_is_40wire</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>cable_is_40wire</refname>
 <refpurpose>
     40/80/SATA decider
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>cable_is_40wire </function></funcdef>
   <paramdef>struct ata_port * <parameter>ap</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ap</parameter></term>
   <listitem>
    <para>
     port to consider
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This function encapsulates the policy for speed management
   in one place. At the moment we don't cache the result but
   there is a good case for setting ap-&gt;cbl to the result when
   we are called with unknown cables (and figuring out if it
   impacts hotplug at all).
   </para><para>

   Return 1 if the cable appears to be 40 wire.
</para>
</refsect1>
</refentry>

<refentry id="API-ata-dev-xfermask">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ata_dev_xfermask</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ata_dev_xfermask</refname>
 <refpurpose>
     Compute supported xfermask of the given device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>ata_dev_xfermask </function></funcdef>
   <paramdef>struct ata_device * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     Device to compute xfermask for
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Compute supported xfermask of <parameter>dev</parameter> and store it in
   dev-&gt;*_mask.  This function is responsible for applying all
   known limits including host controller limits, device
   blacklist, etc...
</para>
</refsect1>
<refsect1>
<title>LOCKING</title>
<para>
   None.
</para>
</refsect1>
</refentry>

<refentry id="API-ata-dev-set-xfermode">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ata_dev_set_xfermode</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ata_dev_set_xfermode</refname>
 <refpurpose>
     Issue SET FEATURES - XFER MODE command
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>unsigned int <function>ata_dev_set_xfermode </function></funcdef>
   <paramdef>struct ata_device * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     Device to which command will be sent
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Issue SET FEATURES - XFER MODE command to device <parameter>dev</parameter>
   on port <parameter>ap</parameter>.
</para>
</refsect1>
<refsect1>
<title>LOCKING</title>
<para>
   PCI/etc. bus probe sem.
</para>
</refsect1>
<refsect1>
<title>RETURNS</title>
<para>
   0 on success, AC_ERR_* mask otherwise.
</para>
</refsect1>
</refentry>

<refentry id="API-ata-dev-init-params">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ata_dev_init_params</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ata_dev_init_params</refname>
 <refpurpose>
     Issue INIT DEV PARAMS command
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>unsigned int <function>ata_dev_init_params </function></funcdef>
   <paramdef>struct ata_device * <parameter>dev</parameter></paramdef>
   <paramdef>u16 <parameter>heads</parameter></paramdef>
   <paramdef>u16 <parameter>sectors</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     Device to which command will be sent
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>heads</parameter></term>
   <listitem>
    <para>
     Number of heads (taskfile parameter)
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>sectors</parameter></term>
   <listitem>
    <para>
     Number of sectors (taskfile parameter)
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>LOCKING</title>
<para>
   Kernel thread context (may sleep)
</para>
</refsect1>
<refsect1>
<title>RETURNS</title>
<para>
   0 on success, AC_ERR_* mask otherwise.
</para>
</refsect1>
</refentry>

<refentry id="API-ata-sg-clean">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ata_sg_clean</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ata_sg_clean</refname>
 <refpurpose>
     Unmap DMA memory associated with command
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>ata_sg_clean </function></funcdef>
   <paramdef>struct ata_queued_cmd * <parameter>qc</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>qc</parameter></term>
   <listitem>
    <para>
     Command containing DMA memory to be released
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Unmap all mapped DMA memory associated with this command.
</para>
</refsect1>
<refsect1>
<title>LOCKING</title>
<para>
   spin_lock_irqsave(host lock)
</para>
</refsect1>
</refentry>

<refentry id="API-atapi-check-dma">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>atapi_check_dma</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>atapi_check_dma</refname>
 <refpurpose>
     Check whether ATAPI DMA can be supported
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>atapi_check_dma </function></funcdef>
   <paramdef>struct ata_queued_cmd * <parameter>qc</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>qc</parameter></term>
   <listitem>
    <para>
     Metadata associated with taskfile to check
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Allow low-level driver to filter ATA PACKET commands, returning
   a status indicating whether or not it is OK to use DMA for the
   supplied PACKET command.
</para>
</refsect1>
<refsect1>
<title>LOCKING</title>
<para>
   spin_lock_irqsave(host lock)
</para>
</refsect1>
<refsect1>
<title>RETURNS</title>
<para>
   0 when ATAPI DMA can be used
   nonzero otherwise
</para>
</refsect1>
</refentry>

<refentry id="API-ata-sg-setup">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ata_sg_setup</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ata_sg_setup</refname>
 <refpurpose>
     DMA-map the scatter-gather table associated with a command.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>ata_sg_setup </function></funcdef>
   <paramdef>struct ata_queued_cmd * <parameter>qc</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>qc</parameter></term>
   <listitem>
    <para>
     Command with scatter-gather table to be mapped.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   DMA-map the scatter-gather table associated with queued_cmd <parameter>qc</parameter>.
</para>
</refsect1>
<refsect1>
<title>LOCKING</title>
<para>
   spin_lock_irqsave(host lock)
</para>
</refsect1>
<refsect1>
<title>RETURNS</title>
<para>
   Zero on success, negative on error.
</para>
</refsect1>
</refentry>

<refentry id="API-swap-buf-le16">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>swap_buf_le16</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>swap_buf_le16</refname>
 <refpurpose>
     swap halves of 16-bit words in place
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>swap_buf_le16 </function></funcdef>
   <paramdef>u16 * <parameter>buf</parameter></paramdef>
   <paramdef>unsigned int <parameter>buf_words</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>buf</parameter></term>
   <listitem>
    <para>
     Buffer to swap
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>buf_words</parameter></term>
   <listitem>
    <para>
     Number of 16-bit words in buffer.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Swap halves of 16-bit words if needed to convert from
   little-endian byte order to native cpu byte order, or
   vice-versa.
</para>
</refsect1>
<refsect1>
<title>LOCKING</title>
<para>
   Inherited from caller.
</para>
</refsect1>
</refentry>

<refentry id="API-ata-qc-new">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ata_qc_new</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ata_qc_new</refname>
 <refpurpose>
     Request an available ATA command, for queueing
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct ata_queued_cmd * <function>ata_qc_new </function></funcdef>
   <paramdef>struct ata_port * <parameter>ap</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ap</parameter></term>
   <listitem>
    <para>
     target port
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Some ATA host controllers may implement a queue depth which is less
   than ATA_MAX_QUEUE. So we shouldn't allocate a tag which is beyond
   the hardware limitation.
</para>
</refsect1>
<refsect1>
<title>LOCKING</title>
<para>
   None.
</para>
</refsect1>
</refentry>

<refentry id="API-ata-qc-new-init">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ata_qc_new_init</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ata_qc_new_init</refname>
 <refpurpose>
     Request an available ATA command, and initialize it
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct ata_queued_cmd * <function>ata_qc_new_init </function></funcdef>
   <paramdef>struct ata_device * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     Device from whom we request an available command structure
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>LOCKING</title>
<para>
   None.
</para>
</refsect1>
</refentry>

<refentry id="API-ata-qc-free">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ata_qc_free</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ata_qc_free</refname>
 <refpurpose>
     free unused ata_queued_cmd
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>ata_qc_free </function></funcdef>
   <paramdef>struct ata_queued_cmd * <parameter>qc</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>qc</parameter></term>
   <listitem>
    <para>
     Command to complete
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Designed to free unused ata_queued_cmd object
   in case something prevents using it.
</para>
</refsect1>
<refsect1>
<title>LOCKING</title>
<para>
   spin_lock_irqsave(host lock)
</para>
</refsect1>
</refentry>

<refentry id="API-ata-qc-issue">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ata_qc_issue</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ata_qc_issue</refname>
 <refpurpose>
     issue taskfile to device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>ata_qc_issue </function></funcdef>
   <paramdef>struct ata_queued_cmd * <parameter>qc</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>qc</parameter></term>
   <listitem>
    <para>
     command to issue to device
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Prepare an ATA command to submission to device.
   This includes mapping the data into a DMA-able
   area, filling in the S/G table, and finally
   writing the taskfile to hardware, starting the command.
</para>
</refsect1>
<refsect1>
<title>LOCKING</title>
<para>
   spin_lock_irqsave(host lock)
</para>
</refsect1>
</refentry>

<refentry id="API-ata-phys-link-online">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ata_phys_link_online</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ata_phys_link_online</refname>
 <refpurpose>
     test whether the given link is online
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>bool <function>ata_phys_link_online </function></funcdef>
   <paramdef>struct ata_link * <parameter>link</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>link</parameter></term>
   <listitem>
    <para>
     ATA link to test
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Test whether <parameter>link</parameter> is online.  Note that this function returns
   0 if online status of <parameter>link</parameter> cannot be obtained, so
   ata_link_online(link) != !ata_link_offline(link).
</para>
</refsect1>
<refsect1>
<title>LOCKING</title>
<para>
   None.
</para>
</refsect1>
<refsect1>
<title>RETURNS</title>
<para>
   True if the port online status is available and online.
</para>
</refsect1>
</refentry>

<refentry id="API-ata-phys-link-offline">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ata_phys_link_offline</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ata_phys_link_offline</refname>
 <refpurpose>
     test whether the given link is offline
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>bool <function>ata_phys_link_offline </function></funcdef>
   <paramdef>struct ata_link * <parameter>link</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>link</parameter></term>
   <listitem>
    <para>
     ATA link to test
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Test whether <parameter>link</parameter> is offline.  Note that this function
   returns 0 if offline status of <parameter>link</parameter> cannot be obtained, so
   ata_link_online(link) != !ata_link_offline(link).
</para>
</refsect1>
<refsect1>
<title>LOCKING</title>
<para>
   None.
</para>
</refsect1>
<refsect1>
<title>RETURNS</title>
<para>
   True if the port offline status is available and offline.
</para>
</refsect1>
</refentry>

<refentry id="API-ata-dev-init">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ata_dev_init</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ata_dev_init</refname>
 <refpurpose>
     Initialize an ata_device structure
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>ata_dev_init </function></funcdef>
   <paramdef>struct ata_device * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     Device structure to initialize
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Initialize <parameter>dev</parameter> in preparation for probing.
</para>
</refsect1>
<refsect1>
<title>LOCKING</title>
<para>
   Inherited from caller.
</para>
</refsect1>
</refentry>

<refentry id="API-ata-link-init">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ata_link_init</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ata_link_init</refname>
 <refpurpose>
     Initialize an ata_link structure
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>ata_link_init </function></funcdef>
   <paramdef>struct ata_port * <parameter>ap</parameter></paramdef>
   <paramdef>struct ata_link * <parameter>link</parameter></paramdef>
   <paramdef>int <parameter>pmp</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ap</parameter></term>
   <listitem>
    <para>
     ATA port link is attached to
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>link</parameter></term>
   <listitem>
    <para>
     Link structure to initialize
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>pmp</parameter></term>
   <listitem>
    <para>
     Port multiplier port number
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Initialize <parameter>link</parameter>.
</para>
</refsect1>
<refsect1>
<title>LOCKING</title>
<para>
   Kernel thread context (may sleep)
</para>
</refsect1>
</refentry>

<refentry id="API-sata-link-init-spd">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>sata_link_init_spd</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>sata_link_init_spd</refname>
 <refpurpose>
     Initialize link-&gt;sata_spd_limit
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>sata_link_init_spd </function></funcdef>
   <paramdef>struct ata_link * <parameter>link</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>link</parameter></term>
   <listitem>
    <para>
     Link to configure sata_spd_limit for
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Initialize <parameter>link</parameter>-&gt;[hw_]sata_spd_limit to the currently
   configured value.
</para>
</refsect1>
<refsect1>
<title>LOCKING</title>
<para>
   Kernel thread context (may sleep).
</para>
</refsect1>
<refsect1>
<title>RETURNS</title>
<para>
   0 on success, -errno on failure.
</para>
</refsect1>
</refentry>

<refentry id="API-ata-port-alloc">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ata_port_alloc</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ata_port_alloc</refname>
 <refpurpose>
     allocate and initialize basic ATA port resources
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct ata_port * <function>ata_port_alloc </function></funcdef>
   <paramdef>struct ata_host * <parameter>host</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>host</parameter></term>
   <listitem>
    <para>
     ATA host this allocated port belongs to
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Allocate and initialize basic ATA port resources.
</para>
</refsect1>
<refsect1>
<title>RETURNS</title>
<para>
   Allocate ATA port on success, NULL on failure.
</para>
</refsect1>
<refsect1>
<title>LOCKING</title>
<para>
   Inherited from calling layer (may sleep).
</para>
</refsect1>
</refentry>

<refentry id="API-ata-finalize-port-ops">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ata_finalize_port_ops</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ata_finalize_port_ops</refname>
 <refpurpose>
     finalize ata_port_operations
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>ata_finalize_port_ops </function></funcdef>
   <paramdef>struct ata_port_operations * <parameter>ops</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ops</parameter></term>
   <listitem>
    <para>
     ata_port_operations to finalize
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   An ata_port_operations can inherit from another ops and that
   ops can again inherit from another.  This can go on as many
   times as necessary as long as there is no loop in the
   inheritance chain.
   </para><para>

   Ops tables are finalized when the host is started.  NULL or
   unspecified entries are inherited from the closet ancestor
   which has the method and the entry is populated with it.
   After finalization, the ops table directly points to all the
   methods and -&gt;inherits is no longer necessary and cleared.
   </para><para>

   Using ATA_OP_NULL, inheriting ops can force a method to NULL.
</para>
</refsect1>
<refsect1>
<title>LOCKING</title>
<para>
   None.
</para>
</refsect1>
</refentry>

<refentry id="API-ata-port-detach">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ata_port_detach</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ata_port_detach</refname>
 <refpurpose>
     Detach ATA port in prepration of device removal
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>ata_port_detach </function></funcdef>
   <paramdef>struct ata_port * <parameter>ap</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ap</parameter></term>
   <listitem>
    <para>
     ATA port to be detached
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Detach all ATA devices and the associated SCSI devices of <parameter>ap</parameter>;
   then, remove the associated SCSI host.  <parameter>ap</parameter> is guaranteed to
   be quiescent on return from this function.
</para>
</refsect1>
<refsect1>
<title>LOCKING</title>
<para>
   Kernel thread context (may sleep).
</para>
</refsect1>
</refentry>

  </chapter>

  <chapter id="libataScsiInt">
     <title>libata SCSI translation/emulation</title>
<!-- drivers/ata/libata-scsi.c -->
<refentry id="API-ata-std-bios-param">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ata_std_bios_param</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ata_std_bios_param</refname>
 <refpurpose>
  generic bios head/sector/cylinder calculator used by sd.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>ata_std_bios_param </function></funcdef>
   <paramdef>struct scsi_device * <parameter>sdev</parameter></paramdef>
   <paramdef>struct block_device * <parameter>bdev</parameter></paramdef>
   <paramdef>sector_t <parameter>capacity</parameter></paramdef>
   <paramdef>int <parameter>geom[]</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>sdev</parameter></term>
   <listitem>
    <para>
     SCSI device for which BIOS geometry is to be determined
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>bdev</parameter></term>
   <listitem>
    <para>
     block device associated with <parameter>sdev</parameter>
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>capacity</parameter></term>
   <listitem>
    <para>
     capacity of SCSI device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>geom[]</parameter></term>
   <listitem>
    <para>
     location to which geometry will be output
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Generic bios head/sector/cylinder calculator
   used by sd. Most BIOSes nowadays expect a XXX/255/16  (CHS)
   mapping. Some situations may arise where the disk is not
   bootable if this is not used.
</para>
</refsect1>
<refsect1>
<title>LOCKING</title>
<para>
   Defined by the SCSI layer.  We don't really care.
</para>
</refsect1>
<refsect1>
<title>RETURNS</title>
<para>
   Zero.
</para>
</refsect1>
</refentry>

<refentry id="API-ata-scsi-unlock-native-capacity">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ata_scsi_unlock_native_capacity</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ata_scsi_unlock_native_capacity</refname>
 <refpurpose>
     unlock native capacity
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>ata_scsi_unlock_native_capacity </function></funcdef>
   <paramdef>struct scsi_device * <parameter>sdev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>sdev</parameter></term>
   <listitem>
    <para>
     SCSI device to adjust device capacity for
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This function is called if a partition on <parameter>sdev</parameter> extends beyond
   the end of the device.  It requests EH to unlock HPA.
</para>
</refsect1>
<refsect1>
<title>LOCKING</title>
<para>
   Defined by the SCSI layer.  Might sleep.
</para>
</refsect1>
</refentry>

<refentry id="API-ata-scsi-slave-config">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ata_scsi_slave_config</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ata_scsi_slave_config</refname>
 <refpurpose>
     Set SCSI device attributes
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>ata_scsi_slave_config </function></funcdef>
   <paramdef>struct scsi_device * <parameter>sdev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>sdev</parameter></term>
   <listitem>
    <para>
     SCSI device to examine
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This is called before we actually start reading
   and writing to the device, to configure certain
   SCSI mid-layer behaviors.
</para>
</refsect1>
<refsect1>
<title>LOCKING</title>
<para>
   Defined by SCSI layer.  We don't really care.
</para>
</refsect1>
</refentry>

<refentry id="API-ata-scsi-slave-destroy">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ata_scsi_slave_destroy</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ata_scsi_slave_destroy</refname>
 <refpurpose>
     SCSI device is about to be destroyed
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>ata_scsi_slave_destroy </function></funcdef>
   <paramdef>struct scsi_device * <parameter>sdev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>sdev</parameter></term>
   <listitem>
    <para>
     SCSI device to be destroyed
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   <parameter>sdev</parameter> is about to be destroyed for hot/warm unplugging.  If
   this unplugging was initiated by libata as indicated by NULL
   dev-&gt;sdev, this function doesn't have to do anything.
   Otherwise, SCSI layer initiated warm-unplug is in progress.
   Clear dev-&gt;sdev, schedule the device for ATA detach and invoke
   EH.
</para>
</refsect1>
<refsect1>
<title>LOCKING</title>
<para>
   Defined by SCSI layer.  We don't really care.
</para>
</refsect1>
</refentry>

<refentry id="API---ata-change-queue-depth">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>__ata_change_queue_depth</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>__ata_change_queue_depth</refname>
 <refpurpose>
     helper for ata_scsi_change_queue_depth
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>__ata_change_queue_depth </function></funcdef>
   <paramdef>struct ata_port * <parameter>ap</parameter></paramdef>
   <paramdef>struct scsi_device * <parameter>sdev</parameter></paramdef>
   <paramdef>int <parameter>queue_depth</parameter></paramdef>
   <paramdef>int <parameter>reason</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ap</parameter></term>
   <listitem>
    <para>
     ATA port to which the device change the queue depth
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>sdev</parameter></term>
   <listitem>
    <para>
     SCSI device to configure queue depth for
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>queue_depth</parameter></term>
   <listitem>
    <para>
     new queue depth
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>reason</parameter></term>
   <listitem>
    <para>
     calling context
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   libsas and libata have different approaches for associating a sdev to
   its ata_port.
</para>
</refsect1>
</refentry>

<refentry id="API-ata-scsi-change-queue-depth">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ata_scsi_change_queue_depth</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ata_scsi_change_queue_depth</refname>
 <refpurpose>
     SCSI callback for queue depth config
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>ata_scsi_change_queue_depth </function></funcdef>
   <paramdef>struct scsi_device * <parameter>sdev</parameter></paramdef>
   <paramdef>int <parameter>queue_depth</parameter></paramdef>
   <paramdef>int <parameter>reason</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>sdev</parameter></term>
   <listitem>
    <para>
     SCSI device to configure queue depth for
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>queue_depth</parameter></term>
   <listitem>
    <para>
     new queue depth
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>reason</parameter></term>
   <listitem>
    <para>
     calling context
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This is libata standard hostt-&gt;change_queue_depth callback.
   SCSI will call into this callback when user tries to set queue
   depth via sysfs.
</para>
</refsect1>
<refsect1>
<title>LOCKING</title>
<para>
   SCSI layer (we don't care)
</para>
</refsect1>
<refsect1>
<title>RETURNS</title>
<para>
   Newly configured queue depth.
</para>
</refsect1>
</refentry>

<refentry id="API-ata-scsi-queuecmd">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ata_scsi_queuecmd</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ata_scsi_queuecmd</refname>
 <refpurpose>
     Issue SCSI cdb to libata-managed device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>ata_scsi_queuecmd </function></funcdef>
   <paramdef>struct Scsi_Host * <parameter>shost</parameter></paramdef>
   <paramdef>struct scsi_cmnd * <parameter>cmd</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>shost</parameter></term>
   <listitem>
    <para>
     SCSI host of command to be sent
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>cmd</parameter></term>
   <listitem>
    <para>
     SCSI command to be sent
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   In some cases, this function translates SCSI commands into
   ATA taskfiles, and queues the taskfiles to be sent to
   hardware.  In other cases, this function simulates a
   SCSI device by evaluating and responding to certain
   SCSI commands.  This creates the overall effect of
   ATA and ATAPI devices appearing as SCSI devices.
</para>
</refsect1>
<refsect1>
<title>LOCKING</title>
<para>
   ATA host lock
</para>
</refsect1>
<refsect1>
<title>RETURNS</title>
<para>
   Return value from <function>__ata_scsi_queuecmd</function> if <parameter>cmd</parameter> can be queued,
   0 otherwise.
</para>
</refsect1>
</refentry>

<refentry id="API-ata-scsi-simulate">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ata_scsi_simulate</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ata_scsi_simulate</refname>
 <refpurpose>
     simulate SCSI command on ATA device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>ata_scsi_simulate </function></funcdef>
   <paramdef>struct ata_device * <parameter>dev</parameter></paramdef>
   <paramdef>struct scsi_cmnd * <parameter>cmd</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     the target device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>cmd</parameter></term>
   <listitem>
    <para>
     SCSI command being sent to device.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Interprets and directly executes a select list of SCSI commands
   that can be handled internally.
</para>
</refsect1>
<refsect1>
<title>LOCKING</title>
<para>
   spin_lock_irqsave(host lock)
</para>
</refsect1>
</refentry>

<refentry id="API-ata-sas-port-alloc">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ata_sas_port_alloc</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ata_sas_port_alloc</refname>
 <refpurpose>
     Allocate port for a SAS attached SATA device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct ata_port * <function>ata_sas_port_alloc </function></funcdef>
   <paramdef>struct ata_host * <parameter>host</parameter></paramdef>
   <paramdef>struct ata_port_info * <parameter>port_info</parameter></paramdef>
   <paramdef>struct Scsi_Host * <parameter>shost</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>host</parameter></term>
   <listitem>
    <para>
     ATA host container for all SAS ports
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>port_info</parameter></term>
   <listitem>
    <para>
     Information from low-level host driver
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>shost</parameter></term>
   <listitem>
    <para>
     SCSI host that the scsi device is attached to
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>LOCKING</title>
<para>
   PCI/etc. bus probe sem.
</para>
</refsect1>
<refsect1>
<title>RETURNS</title>
<para>
   ata_port pointer on success / NULL on failure.
</para>
</refsect1>
</refentry>

<refentry id="API-ata-sas-port-start">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ata_sas_port_start</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ata_sas_port_start</refname>
 <refpurpose>
     Set port up for dma.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>ata_sas_port_start </function></funcdef>
   <paramdef>struct ata_port * <parameter>ap</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ap</parameter></term>
   <listitem>
    <para>
     Port to initialize
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Called just after data structures for each port are
   initialized.
   </para><para>

   May be used as the <function>port_start</function> entry in ata_port_operations.
</para>
</refsect1>
<refsect1>
<title>LOCKING</title>
<para>
   Inherited from caller.
</para>
</refsect1>
</refentry>

<refentry id="API-ata-sas-port-stop">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ata_sas_port_stop</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ata_sas_port_stop</refname>
 <refpurpose>
     Undo <function>ata_sas_port_start</function>
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>ata_sas_port_stop </function></funcdef>
   <paramdef>struct ata_port * <parameter>ap</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ap</parameter></term>
   <listitem>
    <para>
     Port to shut down
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   May be used as the <function>port_stop</function> entry in ata_port_operations.
</para>
</refsect1>
<refsect1>
<title>LOCKING</title>
<para>
   Inherited from caller.
</para>
</refsect1>
</refentry>

<refentry id="API-ata-sas-async-probe">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ata_sas_async_probe</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ata_sas_async_probe</refname>
 <refpurpose>
     simply schedule probing and return
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>ata_sas_async_probe </function></funcdef>
   <paramdef>struct ata_port * <parameter>ap</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ap</parameter></term>
   <listitem>
    <para>
     Port to probe
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   For batch scheduling of probe for sas attached ata devices, assumes
   the port has already been through <function>ata_sas_port_init</function>
</para>
</refsect1>
</refentry>

<refentry id="API-ata-sas-port-init">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ata_sas_port_init</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ata_sas_port_init</refname>
 <refpurpose>
     Initialize a SATA device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>ata_sas_port_init </function></funcdef>
   <paramdef>struct ata_port * <parameter>ap</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ap</parameter></term>
   <listitem>
    <para>
     SATA port to initialize
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>LOCKING</title>
<para>
   PCI/etc. bus probe sem.
</para>
</refsect1>
<refsect1>
<title>RETURNS</title>
<para>
   Zero on success, non-zero on error.
</para>
</refsect1>
</refentry>

<refentry id="API-ata-sas-port-destroy">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ata_sas_port_destroy</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ata_sas_port_destroy</refname>
 <refpurpose>
     Destroy a SATA port allocated by ata_sas_port_alloc
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>ata_sas_port_destroy </function></funcdef>
   <paramdef>struct ata_port * <parameter>ap</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ap</parameter></term>
   <listitem>
    <para>
     SATA port to destroy
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-ata-sas-slave-configure">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ata_sas_slave_configure</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ata_sas_slave_configure</refname>
 <refpurpose>
     Default slave_config routine for libata devices
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>ata_sas_slave_configure </function></funcdef>
   <paramdef>struct scsi_device * <parameter>sdev</parameter></paramdef>
   <paramdef>struct ata_port * <parameter>ap</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>sdev</parameter></term>
   <listitem>
    <para>
     SCSI device to configure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>ap</parameter></term>
   <listitem>
    <para>
     ATA port to which SCSI device is attached
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>RETURNS</title>
<para>
   Zero.
</para>
</refsect1>
</refentry>

<refentry id="API-ata-sas-queuecmd">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ata_sas_queuecmd</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ata_sas_queuecmd</refname>
 <refpurpose>
     Issue SCSI cdb to libata-managed device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>ata_sas_queuecmd </function></funcdef>
   <paramdef>struct scsi_cmnd * <parameter>cmd</parameter></paramdef>
   <paramdef>struct ata_port * <parameter>ap</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>cmd</parameter></term>
   <listitem>
    <para>
     SCSI command to be sent
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>ap</parameter></term>
   <listitem>
    <para>
     ATA port to which the command is being sent
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>RETURNS</title>
<para>
   Return value from <function>__ata_scsi_queuecmd</function> if <parameter>cmd</parameter> can be queued,
   0 otherwise.
</para>
</refsect1>
</refentry>

<!-- drivers/ata/libata-scsi.c -->
<refentry id="API-ata-get-identity">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ata_get_identity</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ata_get_identity</refname>
 <refpurpose>
  Handler for HDIO_GET_IDENTITY ioctl
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>ata_get_identity </function></funcdef>
   <paramdef>struct ata_port * <parameter>ap</parameter></paramdef>
   <paramdef>struct scsi_device * <parameter>sdev</parameter></paramdef>
   <paramdef>void __user * <parameter>arg</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ap</parameter></term>
   <listitem>
    <para>
     target port
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>sdev</parameter></term>
   <listitem>
    <para>
     SCSI device to get identify data for
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>arg</parameter></term>
   <listitem>
    <para>
     User buffer area for identify data
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>LOCKING</title>
<para>
   Defined by the SCSI layer.  We don't really care.
</para>
</refsect1>
<refsect1>
<title>RETURNS</title>
<para>
   Zero on success, negative errno on error.
</para>
</refsect1>
</refentry>

<refentry id="API-ata-cmd-ioctl">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ata_cmd_ioctl</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ata_cmd_ioctl</refname>
 <refpurpose>
     Handler for HDIO_DRIVE_CMD ioctl
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>ata_cmd_ioctl </function></funcdef>
   <paramdef>struct scsi_device * <parameter>scsidev</parameter></paramdef>
   <paramdef>void __user * <parameter>arg</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>scsidev</parameter></term>
   <listitem>
    <para>
     Device to which we are issuing command
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>arg</parameter></term>
   <listitem>
    <para>
     User provided data for issuing command
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>LOCKING</title>
<para>
   Defined by the SCSI layer.  We don't really care.
</para>
</refsect1>
<refsect1>
<title>RETURNS</title>
<para>
   Zero on success, negative errno on error.
</para>
</refsect1>
</refentry>

<refentry id="API-ata-task-ioctl">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ata_task_ioctl</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ata_task_ioctl</refname>
 <refpurpose>
     Handler for HDIO_DRIVE_TASK ioctl
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>ata_task_ioctl </function></funcdef>
   <paramdef>struct scsi_device * <parameter>scsidev</parameter></paramdef>
   <paramdef>void __user * <parameter>arg</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>scsidev</parameter></term>
   <listitem>
    <para>
     Device to which we are issuing command
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>arg</parameter></term>
   <listitem>
    <para>
     User provided data for issuing command
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>LOCKING</title>
<para>
   Defined by the SCSI layer.  We don't really care.
</para>
</refsect1>
<refsect1>
<title>RETURNS</title>
<para>
   Zero on success, negative errno on error.
</para>
</refsect1>
</refentry>

<refentry id="API-ata-scsi-qc-new">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ata_scsi_qc_new</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ata_scsi_qc_new</refname>
 <refpurpose>
     acquire new ata_queued_cmd reference
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct ata_queued_cmd * <function>ata_scsi_qc_new </function></funcdef>
   <paramdef>struct ata_device * <parameter>dev</parameter></paramdef>
   <paramdef>struct scsi_cmnd * <parameter>cmd</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     ATA device to which the new command is attached
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>cmd</parameter></term>
   <listitem>
    <para>
     SCSI command that originated this ATA command
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Obtain a reference to an unused ata_queued_cmd structure,
   which is the basic libata structure representing a single
   ATA command sent to the hardware.
   </para><para>

   If a command was available, fill in the SCSI-specific
   portions of the structure with information on the
   current command.
</para>
</refsect1>
<refsect1>
<title>LOCKING</title>
<para>
   spin_lock_irqsave(host lock)
</para>
</refsect1>
<refsect1>
<title>RETURNS</title>
<para>
   Command allocated, or <constant>NULL</constant> if none available.
</para>
</refsect1>
</refentry>

<refentry id="API-ata-dump-status">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ata_dump_status</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ata_dump_status</refname>
 <refpurpose>
     user friendly display of error info
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>ata_dump_status </function></funcdef>
   <paramdef>unsigned <parameter>id</parameter></paramdef>
   <paramdef>struct ata_taskfile * <parameter>tf</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>id</parameter></term>
   <listitem>
    <para>
     id of the port in question
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>tf</parameter></term>
   <listitem>
    <para>
     ptr to filled out taskfile
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Decode and dump the ATA error/status registers for the user so
   that they have some idea what really happened at the non
   make-believe layer.
</para>
</refsect1>
<refsect1>
<title>LOCKING</title>
<para>
   inherited from caller
</para>
</refsect1>
</refentry>

<refentry id="API-ata-to-sense-error">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ata_to_sense_error</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ata_to_sense_error</refname>
 <refpurpose>
     convert ATA error to SCSI error
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>ata_to_sense_error </function></funcdef>
   <paramdef>unsigned <parameter>id</parameter></paramdef>
   <paramdef>u8 <parameter>drv_stat</parameter></paramdef>
   <paramdef>u8 <parameter>drv_err</parameter></paramdef>
   <paramdef>u8 * <parameter>sk</parameter></paramdef>
   <paramdef>u8 * <parameter>asc</parameter></paramdef>
   <paramdef>u8 * <parameter>ascq</parameter></paramdef>
   <paramdef>int <parameter>verbose</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>id</parameter></term>
   <listitem>
    <para>
     ATA device number
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>drv_stat</parameter></term>
   <listitem>
    <para>
     value contained in ATA status register
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>drv_err</parameter></term>
   <listitem>
    <para>
     value contained in ATA error register
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>sk</parameter></term>
   <listitem>
    <para>
     the sense key we'll fill out
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>asc</parameter></term>
   <listitem>
    <para>
     the additional sense code we'll fill out
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>ascq</parameter></term>
   <listitem>
    <para>
     the additional sense code qualifier we'll fill out
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>verbose</parameter></term>
   <listitem>
    <para>
     be verbose
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Converts an ATA error into a SCSI error.  Fill out pointers to
   SK, ASC, and ASCQ bytes for later use in fixed or descriptor
   format sense blocks.
</para>
</refsect1>
<refsect1>
<title>LOCKING</title>
<para>
   spin_lock_irqsave(host lock)
</para>
</refsect1>
</refentry>

<refentry id="API-ata-gen-ata-sense">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ata_gen_ata_sense</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ata_gen_ata_sense</refname>
 <refpurpose>
     generate a SCSI fixed sense block
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>ata_gen_ata_sense </function></funcdef>
   <paramdef>struct ata_queued_cmd * <parameter>qc</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>qc</parameter></term>
   <listitem>
    <para>
     Command that we are erroring out
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Generate sense block for a failed ATA command <parameter>qc</parameter>.  Descriptor
   format is used to accommodate LBA48 block address.
</para>
</refsect1>
<refsect1>
<title>LOCKING</title>
<para>
   None.
</para>
</refsect1>
</refentry>

<refentry id="API-atapi-drain-needed">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>atapi_drain_needed</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>atapi_drain_needed</refname>
 <refpurpose>
     Check whether data transfer may overflow
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>atapi_drain_needed </function></funcdef>
   <paramdef>struct request * <parameter>rq</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>rq</parameter></term>
   <listitem>
    <para>
     request to be checked
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   ATAPI commands which transfer variable length data to host
   might overflow due to application error or hardare bug.  This
   function checks whether overflow should be drained and ignored
   for <parameter>request</parameter>.
</para>
</refsect1>
<refsect1>
<title>LOCKING</title>
<para>
   None.
</para>
</refsect1>
<refsect1>
<title>RETURNS</title>
<para>
   1 if ; otherwise, 0.
</para>
</refsect1>
</refentry>

<refentry id="API-ata-scsi-start-stop-xlat">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ata_scsi_start_stop_xlat</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ata_scsi_start_stop_xlat</refname>
 <refpurpose>
     Translate SCSI START STOP UNIT command
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>unsigned int <function>ata_scsi_start_stop_xlat </function></funcdef>
   <paramdef>struct ata_queued_cmd * <parameter>qc</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>qc</parameter></term>
   <listitem>
    <para>
     Storage for translated ATA taskfile
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Sets up an ATA taskfile to issue STANDBY (to stop) or READ VERIFY
   (to start). Perhaps these commands should be preceded by
   CHECK POWER MODE to see what power mode the device is already in.
   [See SAT revision 5 at www.t10.org]
</para>
</refsect1>
<refsect1>
<title>LOCKING</title>
<para>
   spin_lock_irqsave(host lock)
</para>
</refsect1>
<refsect1>
<title>RETURNS</title>
<para>
   Zero on success, non-zero on error.
</para>
</refsect1>
</refentry>

<refentry id="API-ata-scsi-flush-xlat">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ata_scsi_flush_xlat</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ata_scsi_flush_xlat</refname>
 <refpurpose>
     Translate SCSI SYNCHRONIZE CACHE command
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>unsigned int <function>ata_scsi_flush_xlat </function></funcdef>
   <paramdef>struct ata_queued_cmd * <parameter>qc</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>qc</parameter></term>
   <listitem>
    <para>
     Storage for translated ATA taskfile
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Sets up an ATA taskfile to issue FLUSH CACHE or
   FLUSH CACHE EXT.
</para>
</refsect1>
<refsect1>
<title>LOCKING</title>
<para>
   spin_lock_irqsave(host lock)
</para>
</refsect1>
<refsect1>
<title>RETURNS</title>
<para>
   Zero on success, non-zero on error.
</para>
</refsect1>
</refentry>

<refentry id="API-scsi-6-lba-len">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>scsi_6_lba_len</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>scsi_6_lba_len</refname>
 <refpurpose>
     Get LBA and transfer length
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>scsi_6_lba_len </function></funcdef>
   <paramdef>const u8 * <parameter>cdb</parameter></paramdef>
   <paramdef>u64 * <parameter>plba</parameter></paramdef>
   <paramdef>u32 * <parameter>plen</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>cdb</parameter></term>
   <listitem>
    <para>
     SCSI command to translate
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>plba</parameter></term>
   <listitem>
    <para>
     the LBA
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>plen</parameter></term>
   <listitem>
    <para>
     the transfer length
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Calculate LBA and transfer length for 6-byte commands.
</para>
</refsect1>
</refentry>

<refentry id="API-scsi-10-lba-len">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>scsi_10_lba_len</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>scsi_10_lba_len</refname>
 <refpurpose>
     Get LBA and transfer length
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>scsi_10_lba_len </function></funcdef>
   <paramdef>const u8 * <parameter>cdb</parameter></paramdef>
   <paramdef>u64 * <parameter>plba</parameter></paramdef>
   <paramdef>u32 * <parameter>plen</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>cdb</parameter></term>
   <listitem>
    <para>
     SCSI command to translate
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>plba</parameter></term>
   <listitem>
    <para>
     the LBA
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>plen</parameter></term>
   <listitem>
    <para>
     the transfer length
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Calculate LBA and transfer length for 10-byte commands.
</para>
</refsect1>
</refentry>

<refentry id="API-scsi-16-lba-len">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>scsi_16_lba_len</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>scsi_16_lba_len</refname>
 <refpurpose>
     Get LBA and transfer length
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>scsi_16_lba_len </function></funcdef>
   <paramdef>const u8 * <parameter>cdb</parameter></paramdef>
   <paramdef>u64 * <parameter>plba</parameter></paramdef>
   <paramdef>u32 * <parameter>plen</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>cdb</parameter></term>
   <listitem>
    <para>
     SCSI command to translate
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>plba</parameter></term>
   <listitem>
    <para>
     the LBA
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>plen</parameter></term>
   <listitem>
    <para>
     the transfer length
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Calculate LBA and transfer length for 16-byte commands.
</para>
</refsect1>
</refentry>

<refentry id="API-ata-scsi-verify-xlat">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ata_scsi_verify_xlat</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ata_scsi_verify_xlat</refname>
 <refpurpose>
     Translate SCSI VERIFY command into an ATA one
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>unsigned int <function>ata_scsi_verify_xlat </function></funcdef>
   <paramdef>struct ata_queued_cmd * <parameter>qc</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>qc</parameter></term>
   <listitem>
    <para>
     Storage for translated ATA taskfile
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Converts SCSI VERIFY command to an ATA READ VERIFY command.
</para>
</refsect1>
<refsect1>
<title>LOCKING</title>
<para>
   spin_lock_irqsave(host lock)
</para>
</refsect1>
<refsect1>
<title>RETURNS</title>
<para>
   Zero on success, non-zero on error.
</para>
</refsect1>
</refentry>

<refentry id="API-ata-scsi-rw-xlat">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ata_scsi_rw_xlat</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ata_scsi_rw_xlat</refname>
 <refpurpose>
     Translate SCSI r/w command into an ATA one
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>unsigned int <function>ata_scsi_rw_xlat </function></funcdef>
   <paramdef>struct ata_queued_cmd * <parameter>qc</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>qc</parameter></term>
   <listitem>
    <para>
     Storage for translated ATA taskfile
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Converts any of six SCSI read/write commands into the
   ATA counterpart, including starting sector (LBA),
   sector count, and taking into account the device's LBA48
   support.
   </para><para>

   Commands <constant>READ_6</constant>, <constant>READ_10</constant>, <constant>READ_16</constant>, <constant>WRITE_6</constant>, <constant>WRITE_10</constant>, and
   <constant>WRITE_16</constant> are currently supported.
</para>
</refsect1>
<refsect1>
<title>LOCKING</title>
<para>
   spin_lock_irqsave(host lock)
</para>
</refsect1>
<refsect1>
<title>RETURNS</title>
<para>
   Zero on success, non-zero on error.
</para>
</refsect1>
</refentry>

<refentry id="API-ata-scsi-translate">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ata_scsi_translate</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ata_scsi_translate</refname>
 <refpurpose>
     Translate then issue SCSI command to ATA device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>ata_scsi_translate </function></funcdef>
   <paramdef>struct ata_device * <parameter>dev</parameter></paramdef>
   <paramdef>struct scsi_cmnd * <parameter>cmd</parameter></paramdef>
   <paramdef>ata_xlat_func_t <parameter>xlat_func</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     ATA device to which the command is addressed
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>cmd</parameter></term>
   <listitem>
    <para>
     SCSI command to execute
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>xlat_func</parameter></term>
   <listitem>
    <para>
     Actor which translates <parameter>cmd</parameter> to an ATA taskfile
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Our -&gt;<function>queuecommand</function> function has decided that the SCSI
   command issued can be directly translated into an ATA
   command, rather than handled internally.
   </para><para>

   This function sets up an ata_queued_cmd structure for the
   SCSI command, and sends that ata_queued_cmd to the hardware.
   </para><para>

   The xlat_func argument (actor) returns 0 if ready to execute
   ATA command, else 1 to finish translation. If 1 is returned
   then cmd-&gt;result (and possibly cmd-&gt;sense_buffer) are assumed
   to be set reflecting an error condition or clean (early)
   termination.
</para>
</refsect1>
<refsect1>
<title>LOCKING</title>
<para>
   spin_lock_irqsave(host lock)
</para>
</refsect1>
<refsect1>
<title>RETURNS</title>
<para>
   0 on success, SCSI_ML_QUEUE_DEVICE_BUSY if the command
   needs to be deferred.
</para>
</refsect1>
</refentry>

<refentry id="API-ata-scsi-rbuf-get">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ata_scsi_rbuf_get</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ata_scsi_rbuf_get</refname>
 <refpurpose>
     Map response buffer.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void * <function>ata_scsi_rbuf_get </function></funcdef>
   <paramdef>struct scsi_cmnd * <parameter>cmd</parameter></paramdef>
   <paramdef>bool <parameter>copy_in</parameter></paramdef>
   <paramdef>unsigned long * <parameter>flags</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>cmd</parameter></term>
   <listitem>
    <para>
     SCSI command containing buffer to be mapped.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>copy_in</parameter></term>
   <listitem>
    <para>
     copy in from user buffer
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>flags</parameter></term>
   <listitem>
    <para>
     unsigned long variable to store irq enable status
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Prepare buffer for simulated SCSI commands.
</para>
</refsect1>
<refsect1>
<title>LOCKING</title>
<para>
   spin_lock_irqsave(ata_scsi_rbuf_lock) on success
</para>
</refsect1>
<refsect1>
<title>RETURNS</title>
<para>
   Pointer to response buffer.
</para>
</refsect1>
</refentry>

<refentry id="API-ata-scsi-rbuf-put">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ata_scsi_rbuf_put</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ata_scsi_rbuf_put</refname>
 <refpurpose>
     Unmap response buffer.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>ata_scsi_rbuf_put </function></funcdef>
   <paramdef>struct scsi_cmnd * <parameter>cmd</parameter></paramdef>
   <paramdef>bool <parameter>copy_out</parameter></paramdef>
   <paramdef>unsigned long * <parameter>flags</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>cmd</parameter></term>
   <listitem>
    <para>
     SCSI command containing buffer to be unmapped.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>copy_out</parameter></term>
   <listitem>
    <para>
     copy out result
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>flags</parameter></term>
   <listitem>
    <para>
     <parameter>flags</parameter> passed to <function>ata_scsi_rbuf_get</function>
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Returns rbuf buffer.  The result is copied to <parameter>cmd</parameter>'s buffer if
   <parameter>copy_back</parameter> is true.
</para>
</refsect1>
<refsect1>
<title>LOCKING</title>
<para>
   Unlocks ata_scsi_rbuf_lock.
</para>
</refsect1>
</refentry>

<refentry id="API-ata-scsi-rbuf-fill">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ata_scsi_rbuf_fill</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ata_scsi_rbuf_fill</refname>
 <refpurpose>
     wrapper for SCSI command simulators
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>ata_scsi_rbuf_fill </function></funcdef>
   <paramdef>struct ata_scsi_args * <parameter>args</parameter></paramdef>
   <paramdef>unsigned int (*<parameter>actor</parameter>)
     <funcparams>struct ata_scsi_args *args, u8 *rbuf</funcparams></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>args</parameter></term>
   <listitem>
    <para>
     device IDENTIFY data / SCSI command of interest.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>actor</parameter></term>
   <listitem>
    <para>
     Callback hook for desired SCSI command simulator
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Takes care of the hard work of simulating a SCSI command...
   Mapping the response buffer, calling the command's handler,
   and handling the handler's return value.  This return value
   indicates whether the handler wishes the SCSI command to be
   completed successfully (0), or not (in which case cmd-&gt;result
   and sense buffer are assumed to be set).
</para>
</refsect1>
<refsect1>
<title>LOCKING</title>
<para>
   spin_lock_irqsave(host lock)
</para>
</refsect1>
</refentry>

<refentry id="API-ata-scsiop-inq-std">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ata_scsiop_inq_std</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ata_scsiop_inq_std</refname>
 <refpurpose>
     Simulate INQUIRY command
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>unsigned int <function>ata_scsiop_inq_std </function></funcdef>
   <paramdef>struct ata_scsi_args * <parameter>args</parameter></paramdef>
   <paramdef>u8 * <parameter>rbuf</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>args</parameter></term>
   <listitem>
    <para>
     device IDENTIFY data / SCSI command of interest.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>rbuf</parameter></term>
   <listitem>
    <para>
     Response buffer, to which simulated SCSI cmd output is sent.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Returns standard device identification data associated
   with non-VPD INQUIRY command output.
</para>
</refsect1>
<refsect1>
<title>LOCKING</title>
<para>
   spin_lock_irqsave(host lock)
</para>
</refsect1>
</refentry>

<refentry id="API-ata-scsiop-inq-00">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ata_scsiop_inq_00</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ata_scsiop_inq_00</refname>
 <refpurpose>
     Simulate INQUIRY VPD page 0, list of pages
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>unsigned int <function>ata_scsiop_inq_00 </function></funcdef>
   <paramdef>struct ata_scsi_args * <parameter>args</parameter></paramdef>
   <paramdef>u8 * <parameter>rbuf</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>args</parameter></term>
   <listitem>
    <para>
     device IDENTIFY data / SCSI command of interest.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>rbuf</parameter></term>
   <listitem>
    <para>
     Response buffer, to which simulated SCSI cmd output is sent.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Returns list of inquiry VPD pages available.
</para>
</refsect1>
<refsect1>
<title>LOCKING</title>
<para>
   spin_lock_irqsave(host lock)
</para>
</refsect1>
</refentry>

<refentry id="API-ata-scsiop-inq-80">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ata_scsiop_inq_80</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ata_scsiop_inq_80</refname>
 <refpurpose>
     Simulate INQUIRY VPD page 80, device serial number
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>unsigned int <function>ata_scsiop_inq_80 </function></funcdef>
   <paramdef>struct ata_scsi_args * <parameter>args</parameter></paramdef>
   <paramdef>u8 * <parameter>rbuf</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>args</parameter></term>
   <listitem>
    <para>
     device IDENTIFY data / SCSI command of interest.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>rbuf</parameter></term>
   <listitem>
    <para>
     Response buffer, to which simulated SCSI cmd output is sent.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Returns ATA device serial number.
</para>
</refsect1>
<refsect1>
<title>LOCKING</title>
<para>
   spin_lock_irqsave(host lock)
</para>
</refsect1>
</refentry>

<refentry id="API-ata-scsiop-inq-83">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ata_scsiop_inq_83</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ata_scsiop_inq_83</refname>
 <refpurpose>
     Simulate INQUIRY VPD page 83, device identity
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>unsigned int <function>ata_scsiop_inq_83 </function></funcdef>
   <paramdef>struct ata_scsi_args * <parameter>args</parameter></paramdef>
   <paramdef>u8 * <parameter>rbuf</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>args</parameter></term>
   <listitem>
    <para>
     device IDENTIFY data / SCSI command of interest.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>rbuf</parameter></term>
   <listitem>
    <para>
     Response buffer, to which simulated SCSI cmd output is sent.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Yields two logical unit device identification designators</title>
<para>
   - vendor specific ASCII containing the ATA serial number
   - SAT defined <quote>t10 vendor id based</quote> containing ASCII vendor
   name (<quote>ATA     </quote>), model and serial numbers.
</para>
</refsect1>
<refsect1>
<title>LOCKING</title>
<para>
   spin_lock_irqsave(host lock)
</para>
</refsect1>
</refentry>

<refentry id="API-ata-scsiop-inq-89">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ata_scsiop_inq_89</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ata_scsiop_inq_89</refname>
 <refpurpose>
     Simulate INQUIRY VPD page 89, ATA info
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>unsigned int <function>ata_scsiop_inq_89 </function></funcdef>
   <paramdef>struct ata_scsi_args * <parameter>args</parameter></paramdef>
   <paramdef>u8 * <parameter>rbuf</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>args</parameter></term>
   <listitem>
    <para>
     device IDENTIFY data / SCSI command of interest.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>rbuf</parameter></term>
   <listitem>
    <para>
     Response buffer, to which simulated SCSI cmd output is sent.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Yields SAT-specified ATA VPD page.
</para>
</refsect1>
<refsect1>
<title>LOCKING</title>
<para>
   spin_lock_irqsave(host lock)
</para>
</refsect1>
</refentry>

<refentry id="API-ata-scsiop-noop">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ata_scsiop_noop</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ata_scsiop_noop</refname>
 <refpurpose>
     Command handler that simply returns success.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>unsigned int <function>ata_scsiop_noop </function></funcdef>
   <paramdef>struct ata_scsi_args * <parameter>args</parameter></paramdef>
   <paramdef>u8 * <parameter>rbuf</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>args</parameter></term>
   <listitem>
    <para>
     device IDENTIFY data / SCSI command of interest.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>rbuf</parameter></term>
   <listitem>
    <para>
     Response buffer, to which simulated SCSI cmd output is sent.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   No operation.  Simply returns success to caller, to indicate
   that the caller should successfully complete this SCSI command.
</para>
</refsect1>
<refsect1>
<title>LOCKING</title>
<para>
   spin_lock_irqsave(host lock)
</para>
</refsect1>
</refentry>

<refentry id="API-modecpy">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>modecpy</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>modecpy</refname>
 <refpurpose>
     Prepare response for MODE SENSE
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>modecpy </function></funcdef>
   <paramdef>u8 * <parameter>dest</parameter></paramdef>
   <paramdef>const u8 * <parameter>src</parameter></paramdef>
   <paramdef>int <parameter>n</parameter></paramdef>
   <paramdef>bool <parameter>changeable</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dest</parameter></term>
   <listitem>
    <para>
     output buffer
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>src</parameter></term>
   <listitem>
    <para>
     data being copied
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>n</parameter></term>
   <listitem>
    <para>
     length of mode page
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>changeable</parameter></term>
   <listitem>
    <para>
     whether changeable parameters are requested
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Generate a generic MODE SENSE page for either current or changeable
   parameters.
</para>
</refsect1>
<refsect1>
<title>LOCKING</title>
<para>
   None.
</para>
</refsect1>
</refentry>

<refentry id="API-ata-msense-caching">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ata_msense_caching</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ata_msense_caching</refname>
 <refpurpose>
     Simulate MODE SENSE caching info page
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>unsigned int <function>ata_msense_caching </function></funcdef>
   <paramdef>u16 * <parameter>id</parameter></paramdef>
   <paramdef>u8 * <parameter>buf</parameter></paramdef>
   <paramdef>bool <parameter>changeable</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>id</parameter></term>
   <listitem>
    <para>
     device IDENTIFY data
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>buf</parameter></term>
   <listitem>
    <para>
     output buffer
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>changeable</parameter></term>
   <listitem>
    <para>
     whether changeable parameters are requested
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Generate a caching info page, which conditionally indicates
   write caching to the SCSI layer, depending on device
   capabilities.
</para>
</refsect1>
<refsect1>
<title>LOCKING</title>
<para>
   None.
</para>
</refsect1>
</refentry>

<refentry id="API-ata-msense-ctl-mode">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ata_msense_ctl_mode</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ata_msense_ctl_mode</refname>
 <refpurpose>
     Simulate MODE SENSE control mode page
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>unsigned int <function>ata_msense_ctl_mode </function></funcdef>
   <paramdef>u8 * <parameter>buf</parameter></paramdef>
   <paramdef>bool <parameter>changeable</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>buf</parameter></term>
   <listitem>
    <para>
     output buffer
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>changeable</parameter></term>
   <listitem>
    <para>
     whether changeable parameters are requested
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Generate a generic MODE SENSE control mode page.
</para>
</refsect1>
<refsect1>
<title>LOCKING</title>
<para>
   None.
</para>
</refsect1>
</refentry>

<refentry id="API-ata-msense-rw-recovery">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ata_msense_rw_recovery</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ata_msense_rw_recovery</refname>
 <refpurpose>
     Simulate MODE SENSE r/w error recovery page
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>unsigned int <function>ata_msense_rw_recovery </function></funcdef>
   <paramdef>u8 * <parameter>buf</parameter></paramdef>
   <paramdef>bool <parameter>changeable</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>buf</parameter></term>
   <listitem>
    <para>
     output buffer
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>changeable</parameter></term>
   <listitem>
    <para>
     whether changeable parameters are requested
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Generate a generic MODE SENSE r/w error recovery page.
</para>
</refsect1>
<refsect1>
<title>LOCKING</title>
<para>
   None.
</para>
</refsect1>
</refentry>

<refentry id="API-ata-scsiop-mode-sense">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ata_scsiop_mode_sense</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ata_scsiop_mode_sense</refname>
 <refpurpose>
     Simulate MODE SENSE 6, 10 commands
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>unsigned int <function>ata_scsiop_mode_sense </function></funcdef>
   <paramdef>struct ata_scsi_args * <parameter>args</parameter></paramdef>
   <paramdef>u8 * <parameter>rbuf</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>args</parameter></term>
   <listitem>
    <para>
     device IDENTIFY data / SCSI command of interest.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>rbuf</parameter></term>
   <listitem>
    <para>
     Response buffer, to which simulated SCSI cmd output is sent.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Simulate MODE SENSE commands. Assume this is invoked for direct
   access devices (e.g. disks) only. There should be no block
   descriptor for other device types.
</para>
</refsect1>
<refsect1>
<title>LOCKING</title>
<para>
   spin_lock_irqsave(host lock)
</para>
</refsect1>
</refentry>

<refentry id="API-ata-scsiop-read-cap">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ata_scsiop_read_cap</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ata_scsiop_read_cap</refname>
 <refpurpose>
     Simulate READ CAPACITY[ 16] commands
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>unsigned int <function>ata_scsiop_read_cap </function></funcdef>
   <paramdef>struct ata_scsi_args * <parameter>args</parameter></paramdef>
   <paramdef>u8 * <parameter>rbuf</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>args</parameter></term>
   <listitem>
    <para>
     device IDENTIFY data / SCSI command of interest.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>rbuf</parameter></term>
   <listitem>
    <para>
     Response buffer, to which simulated SCSI cmd output is sent.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Simulate READ CAPACITY commands.
</para>
</refsect1>
<refsect1>
<title>LOCKING</title>
<para>
   None.
</para>
</refsect1>
</refentry>

<refentry id="API-ata-scsiop-report-luns">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ata_scsiop_report_luns</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ata_scsiop_report_luns</refname>
 <refpurpose>
     Simulate REPORT LUNS command
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>unsigned int <function>ata_scsiop_report_luns </function></funcdef>
   <paramdef>struct ata_scsi_args * <parameter>args</parameter></paramdef>
   <paramdef>u8 * <parameter>rbuf</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>args</parameter></term>
   <listitem>
    <para>
     device IDENTIFY data / SCSI command of interest.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>rbuf</parameter></term>
   <listitem>
    <para>
     Response buffer, to which simulated SCSI cmd output is sent.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Simulate REPORT LUNS command.
</para>
</refsect1>
<refsect1>
<title>LOCKING</title>
<para>
   spin_lock_irqsave(host lock)
</para>
</refsect1>
</refentry>

<refentry id="API-atapi-xlat">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>atapi_xlat</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>atapi_xlat</refname>
 <refpurpose>
     Initialize PACKET taskfile
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>unsigned int <function>atapi_xlat </function></funcdef>
   <paramdef>struct ata_queued_cmd * <parameter>qc</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>qc</parameter></term>
   <listitem>
    <para>
     command structure to be initialized
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>LOCKING</title>
<para>
   spin_lock_irqsave(host lock)
</para>
</refsect1>
<refsect1>
<title>RETURNS</title>
<para>
   Zero on success, non-zero on failure.
</para>
</refsect1>
</refentry>

<refentry id="API-ata-scsi-find-dev">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ata_scsi_find_dev</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ata_scsi_find_dev</refname>
 <refpurpose>
     lookup ata_device from scsi_cmnd
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct ata_device * <function>ata_scsi_find_dev </function></funcdef>
   <paramdef>struct ata_port * <parameter>ap</parameter></paramdef>
   <paramdef>const struct scsi_device * <parameter>scsidev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ap</parameter></term>
   <listitem>
    <para>
     ATA port to which the device is attached
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>scsidev</parameter></term>
   <listitem>
    <para>
     SCSI device from which we derive the ATA device
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Given various information provided in struct scsi_cmnd,
   map that onto an ATA bus, and using that mapping
   determine which ata_device is associated with the
   SCSI command to be sent.
</para>
</refsect1>
<refsect1>
<title>LOCKING</title>
<para>
   spin_lock_irqsave(host lock)
</para>
</refsect1>
<refsect1>
<title>RETURNS</title>
<para>
   Associated ATA device, or <constant>NULL</constant> if not found.
</para>
</refsect1>
</refentry>

<refentry id="API-ata-scsi-pass-thru">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ata_scsi_pass_thru</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ata_scsi_pass_thru</refname>
 <refpurpose>
     convert ATA pass-thru CDB to taskfile
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>unsigned int <function>ata_scsi_pass_thru </function></funcdef>
   <paramdef>struct ata_queued_cmd * <parameter>qc</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>qc</parameter></term>
   <listitem>
    <para>
     command structure to be initialized
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Handles either 12 or 16-byte versions of the CDB.
</para>
</refsect1>
<refsect1>
<title>RETURNS</title>
<para>
   Zero on success, non-zero on failure.
</para>
</refsect1>
</refentry>

<refentry id="API-ata-mselect-caching">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ata_mselect_caching</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ata_mselect_caching</refname>
 <refpurpose>
     Simulate MODE SELECT for caching info page
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>ata_mselect_caching </function></funcdef>
   <paramdef>struct ata_queued_cmd * <parameter>qc</parameter></paramdef>
   <paramdef>const u8 * <parameter>buf</parameter></paramdef>
   <paramdef>int <parameter>len</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>qc</parameter></term>
   <listitem>
    <para>
     Storage for translated ATA taskfile
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>buf</parameter></term>
   <listitem>
    <para>
     input buffer
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>len</parameter></term>
   <listitem>
    <para>
     number of valid bytes in the input buffer
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Prepare a taskfile to modify caching information for the device.
</para>
</refsect1>
<refsect1>
<title>LOCKING</title>
<para>
   None.
</para>
</refsect1>
</refentry>

<refentry id="API-ata-scsi-mode-select-xlat">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ata_scsi_mode_select_xlat</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ata_scsi_mode_select_xlat</refname>
 <refpurpose>
     Simulate MODE SELECT 6, 10 commands
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>unsigned int <function>ata_scsi_mode_select_xlat </function></funcdef>
   <paramdef>struct ata_queued_cmd * <parameter>qc</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>qc</parameter></term>
   <listitem>
    <para>
     Storage for translated ATA taskfile
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Converts a MODE SELECT command to an ATA SET FEATURES taskfile.
   Assume this is invoked for direct access devices (e.g. disks) only.
   There should be no block descriptor for other device types.
</para>
</refsect1>
<refsect1>
<title>LOCKING</title>
<para>
   spin_lock_irqsave(host lock)
</para>
</refsect1>
</refentry>

<refentry id="API-ata-get-xlat-func">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ata_get_xlat_func</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ata_get_xlat_func</refname>
 <refpurpose>
     check if SCSI to ATA translation is possible
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>ata_xlat_func_t <function>ata_get_xlat_func </function></funcdef>
   <paramdef>struct ata_device * <parameter>dev</parameter></paramdef>
   <paramdef>u8 <parameter>cmd</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     ATA device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>cmd</parameter></term>
   <listitem>
    <para>
     SCSI command opcode to consider
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Look up the SCSI command given, and determine whether the
   SCSI command is to be translated or simulated.
</para>
</refsect1>
<refsect1>
<title>RETURNS</title>
<para>
   Pointer to translation function if possible, <constant>NULL</constant> if not.
</para>
</refsect1>
</refentry>

<refentry id="API-ata-scsi-dump-cdb">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ata_scsi_dump_cdb</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ata_scsi_dump_cdb</refname>
 <refpurpose>
     dump SCSI command contents to dmesg
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>ata_scsi_dump_cdb </function></funcdef>
   <paramdef>struct ata_port * <parameter>ap</parameter></paramdef>
   <paramdef>struct scsi_cmnd * <parameter>cmd</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ap</parameter></term>
   <listitem>
    <para>
     ATA port to which the command was being sent
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>cmd</parameter></term>
   <listitem>
    <para>
     SCSI command to dump
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Prints the contents of a SCSI command via <function>printk</function>.
</para>
</refsect1>
</refentry>

<refentry id="API-ata-scsi-offline-dev">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ata_scsi_offline_dev</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ata_scsi_offline_dev</refname>
 <refpurpose>
     offline attached SCSI device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>ata_scsi_offline_dev </function></funcdef>
   <paramdef>struct ata_device * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     ATA device to offline attached SCSI device for
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This function is called from <function>ata_eh_hotplug</function> and responsible
   for taking the SCSI device attached to <parameter>dev</parameter> offline.  This
   function is called with host lock which protects dev-&gt;sdev
   against clearing.
</para>
</refsect1>
<refsect1>
<title>LOCKING</title>
<para>
   spin_lock_irqsave(host lock)
</para>
</refsect1>
<refsect1>
<title>RETURNS</title>
<para>
   1 if attached SCSI device exists, 0 otherwise.
</para>
</refsect1>
</refentry>

<refentry id="API-ata-scsi-remove-dev">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ata_scsi_remove_dev</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ata_scsi_remove_dev</refname>
 <refpurpose>
     remove attached SCSI device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>ata_scsi_remove_dev </function></funcdef>
   <paramdef>struct ata_device * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     ATA device to remove attached SCSI device for
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This function is called from <function>ata_eh_scsi_hotplug</function> and
   responsible for removing the SCSI device attached to <parameter>dev</parameter>.
</para>
</refsect1>
<refsect1>
<title>LOCKING</title>
<para>
   Kernel thread context (may sleep).
</para>
</refsect1>
</refentry>

<refentry id="API-ata-scsi-media-change-notify">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ata_scsi_media_change_notify</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ata_scsi_media_change_notify</refname>
 <refpurpose>
     send media change event
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>ata_scsi_media_change_notify </function></funcdef>
   <paramdef>struct ata_device * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     Pointer to the disk device with media change event
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Tell the block layer to send a media change notification
   event.
</para>
</refsect1>
<refsect1>
<title>LOCKING</title>
<para>
   spin_lock_irqsave(host lock)
</para>
</refsect1>
</refentry>

<refentry id="API-ata-scsi-hotplug">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ata_scsi_hotplug</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ata_scsi_hotplug</refname>
 <refpurpose>
     SCSI part of hotplug
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>ata_scsi_hotplug </function></funcdef>
   <paramdef>struct work_struct * <parameter>work</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>work</parameter></term>
   <listitem>
    <para>
     Pointer to ATA port to perform SCSI hotplug on
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Perform SCSI part of hotplug.  It's executed from a separate
   workqueue after EH completes.  This is necessary because SCSI
   hot plugging requires working EH and hot unplugging is
   synchronized with hot plugging with a mutex.
</para>
</refsect1>
<refsect1>
<title>LOCKING</title>
<para>
   Kernel thread context (may sleep).
</para>
</refsect1>
</refentry>

<refentry id="API-ata-scsi-user-scan">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ata_scsi_user_scan</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ata_scsi_user_scan</refname>
 <refpurpose>
     indication for user-initiated bus scan
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>ata_scsi_user_scan </function></funcdef>
   <paramdef>struct Scsi_Host * <parameter>shost</parameter></paramdef>
   <paramdef>unsigned int <parameter>channel</parameter></paramdef>
   <paramdef>unsigned int <parameter>id</parameter></paramdef>
   <paramdef>u64 <parameter>lun</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>shost</parameter></term>
   <listitem>
    <para>
     SCSI host to scan
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>channel</parameter></term>
   <listitem>
    <para>
     Channel to scan
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>id</parameter></term>
   <listitem>
    <para>
     ID to scan
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>lun</parameter></term>
   <listitem>
    <para>
     LUN to scan
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This function is called when user explicitly requests bus
   scan.  Set probe pending flag and invoke EH.
</para>
</refsect1>
<refsect1>
<title>LOCKING</title>
<para>
   SCSI layer (we don't care)
</para>
</refsect1>
<refsect1>
<title>RETURNS</title>
<para>
   Zero.
</para>
</refsect1>
</refentry>

<refentry id="API-ata-scsi-dev-rescan">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ata_scsi_dev_rescan</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ata_scsi_dev_rescan</refname>
 <refpurpose>
     initiate <function>scsi_rescan_device</function>
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>ata_scsi_dev_rescan </function></funcdef>
   <paramdef>struct work_struct * <parameter>work</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>work</parameter></term>
   <listitem>
    <para>
     Pointer to ATA port to perform <function>scsi_rescan_device</function>
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   After ATA pass thru (SAT) commands are executed successfully,
   libata need to propagate the changes to SCSI layer.
</para>
</refsect1>
<refsect1>
<title>LOCKING</title>
<para>
   Kernel thread context (may sleep).
</para>
</refsect1>
</refentry>

  </chapter>

  <chapter id="ataExceptions">
     <title>ATA errors and exceptions</title>

  <para>
  This chapter tries to identify what error/exception conditions exist
  for ATA/ATAPI devices and describe how they should be handled in
  implementation-neutral way.
  </para>

  <para>
  The term 'error' is used to describe conditions where either an
  explicit error condition is reported from device or a command has
  timed out.
  </para>

  <para>
  The term 'exception' is either used to describe exceptional
  conditions which are not errors (say, power or hotplug events), or
  to describe both errors and non-error exceptional conditions.  Where
  explicit distinction between error and exception is necessary, the
  term 'non-error exception' is used.
  </para>

  <sect1 id="excat">
     <title>Exception categories</title>
     <para>
     Exceptions are described primarily with respect to legacy
     taskfile + bus master IDE interface.  If a controller provides
     other better mechanism for error reporting, mapping those into
     categories described below shouldn't be difficult.
     </para>

     <para>
     In the following sections, two recovery actions - reset and
     reconfiguring transport - are mentioned.  These are described
     further in <xref linkend="exrec"/>.
     </para>

     <sect2 id="excatHSMviolation">
        <title>HSM violation</title>
        <para>
        This error is indicated when STATUS value doesn't match HSM
        requirement during issuing or execution any ATA/ATAPI command.
        </para>

	<itemizedlist>
	<title>Examples</title>

        <listitem>
	<para>
	ATA_STATUS doesn't contain !BSY &amp;&amp; DRDY &amp;&amp; !DRQ while trying
	to issue a command.
        </para>
	</listitem>

        <listitem>
	<para>
	!BSY &amp;&amp; !DRQ during PIO data transfer.
        </para>
	</listitem>

        <listitem>
	<para>
	DRQ on command completion.
        </para>
	</listitem>

        <listitem>
	<para>
	!BSY &amp;&amp; ERR after CDB transfer starts but before the
        last byte of CDB is transferred.  ATA/ATAPI standard states
        that &quot;The device shall not terminate the PACKET command
        with an error before the last byte of the command packet has
        been written&quot; in the error outputs description of PACKET
        command and the state diagram doesn't include such
        transitions.
	</para>
	</listitem>

	</itemizedlist>

	<para>
	In these cases, HSM is violated and not much information
	regarding the error can be acquired from STATUS or ERROR
	register.  IOW, this error can be anything - driver bug,
	faulty device, controller and/or cable.
	</para>

	<para>
	As HSM is violated, reset is necessary to restore known state.
	Reconfiguring transport for lower speed might be helpful too
	as transmission errors sometimes cause this kind of errors.
	</para>
     </sect2>
     
     <sect2 id="excatDevErr">
        <title>ATA/ATAPI device error (non-NCQ / non-CHECK CONDITION)</title>

	<para>
	These are errors detected and reported by ATA/ATAPI devices
	indicating device problems.  For this type of errors, STATUS
	and ERROR register values are valid and describe error
	condition.  Note that some of ATA bus errors are detected by
	ATA/ATAPI devices and reported using the same mechanism as
	device errors.  Those cases are described later in this
	section.
	</para>

	<para>
	For ATA commands, this type of errors are indicated by !BSY
	&amp;&amp; ERR during command execution and on completion.
	</para>

	<para>For ATAPI commands,</para>

	<itemizedlist>

	<listitem>
	<para>
	!BSY &amp;&amp; ERR &amp;&amp; ABRT right after issuing PACKET
	indicates that PACKET command is not supported and falls in
	this category.
	</para>
	</listitem>

	<listitem>
	<para>
	!BSY &amp;&amp; ERR(==CHK) &amp;&amp; !ABRT after the last
	byte of CDB is transferred indicates CHECK CONDITION and
	doesn't fall in this category.
	</para>
	</listitem>

	<listitem>
	<para>
	!BSY &amp;&amp; ERR(==CHK) &amp;&amp; ABRT after the last byte
        of CDB is transferred *probably* indicates CHECK CONDITION and
        doesn't fall in this category.
	</para>
	</listitem>

	</itemizedlist>

	<para>
	Of errors detected as above, the followings are not ATA/ATAPI
	device errors but ATA bus errors and should be handled
	according to <xref linkend="excatATAbusErr"/>.
	</para>

	<variablelist>

	   <varlistentry>
	   <term>CRC error during data transfer</term>
	   <listitem>
	   <para>
	   This is indicated by ICRC bit in the ERROR register and
	   means that corruption occurred during data transfer.  Up to
	   ATA/ATAPI-7, the standard specifies that this bit is only
	   applicable to UDMA transfers but ATA/ATAPI-8 draft revision
	   1f says that the bit may be applicable to multiword DMA and
	   PIO.
	   </para>
	   </listitem>
	   </varlistentry>

	   <varlistentry>
	   <term>ABRT error during data transfer or on completion</term>
	   <listitem>
	   <para>
	   Up to ATA/ATAPI-7, the standard specifies that ABRT could be
	   set on ICRC errors and on cases where a device is not able
	   to complete a command.  Combined with the fact that MWDMA
	   and PIO transfer errors aren't allowed to use ICRC bit up to
	   ATA/ATAPI-7, it seems to imply that ABRT bit alone could
	   indicate transfer errors.
	   </para>
	   <para>
	   However, ATA/ATAPI-8 draft revision 1f removes the part
	   that ICRC errors can turn on ABRT.  So, this is kind of
	   gray area.  Some heuristics are needed here.
	   </para>
	   </listitem>
	   </varlistentry>

	</variablelist>

	<para>
	ATA/ATAPI device errors can be further categorized as follows.
	</para>

	<variablelist>

	   <varlistentry>
	   <term>Media errors</term>
	   <listitem>
	   <para>
	   This is indicated by UNC bit in the ERROR register.  ATA
	   devices reports UNC error only after certain number of
	   retries cannot recover the data, so there's nothing much
	   else to do other than notifying upper layer.
	   </para>
	   <para>
	   READ and WRITE commands report CHS or LBA of the first
	   failed sector but ATA/ATAPI standard specifies that the
	   amount of transferred data on error completion is
	   indeterminate, so we cannot assume that sectors preceding
	   the failed sector have been transferred and thus cannot
	   complete those sectors successfully as SCSI does.
	   </para>
	   </listitem>
	   </varlistentry>

	   <varlistentry>
	   <term>Media changed / media change requested error</term>
	   <listitem>
	   <para>
	   &lt;&lt;TODO: fill here&gt;&gt;
	   </para>
	   </listitem>
	   </varlistentry>

	   <varlistentry><term>Address error</term>
	   <listitem>
	   <para>
	   This is indicated by IDNF bit in the ERROR register.
	   Report to upper layer.
	   </para>
	   </listitem>
	   </varlistentry>

	   <varlistentry><term>Other errors</term>
	   <listitem>
	   <para>
	   This can be invalid command or parameter indicated by ABRT
	   ERROR bit or some other error condition.  Note that ABRT
	   bit can indicate a lot of things including ICRC and Address
	   errors.  Heuristics needed.
	   </para>
	   </listitem>
	   </varlistentry>

	</variablelist>

	<para>
	Depending on commands, not all STATUS/ERROR bits are
	applicable.  These non-applicable bits are marked with
	&quot;na&quot; in the output descriptions but up to ATA/ATAPI-7
	no definition of &quot;na&quot; can be found.  However,
	ATA/ATAPI-8 draft revision 1f describes &quot;N/A&quot; as
	follows.
	</para>

	<blockquote>
	<variablelist>
	   <varlistentry><term>3.2.3.3a N/A</term>
	   <listitem>
	   <para>
	   A keyword the indicates a field has no defined value in
	   this standard and should not be checked by the host or
	   device. N/A fields should be cleared to zero.
	   </para>
	   </listitem>
	   </varlistentry>
	</variablelist>
	</blockquote>

	<para>
	So, it seems reasonable to assume that &quot;na&quot; bits are
	cleared to zero by devices and thus need no explicit masking.
	</para>

     </sect2>

     <sect2 id="excatATAPIcc">
        <title>ATAPI device CHECK CONDITION</title>

	<para>
	ATAPI device CHECK CONDITION error is indicated by set CHK bit
	(ERR bit) in the STATUS register after the last byte of CDB is
	transferred for a PACKET command.  For this kind of errors,
	sense data should be acquired to gather information regarding
	the errors.  REQUEST SENSE packet command should be used to
	acquire sense data.
	</para>

	<para>
	Once sense data is acquired, this type of errors can be
	handled similarly to other SCSI errors.  Note that sense data
	may indicate ATA bus error (e.g. Sense Key 04h HARDWARE ERROR
	&amp;&amp; ASC/ASCQ 47h/00h SCSI PARITY ERROR).  In such
	cases, the error should be considered as an ATA bus error and
	handled according to <xref linkend="excatATAbusErr"/>.
	</para>

     </sect2>

     <sect2 id="excatNCQerr">
        <title>ATA device error (NCQ)</title>

	<para>
	NCQ command error is indicated by cleared BSY and set ERR bit
	during NCQ command phase (one or more NCQ commands
	outstanding).  Although STATUS and ERROR registers will
	contain valid values describing the error, READ LOG EXT is
	required to clear the error condition, determine which command
	has failed and acquire more information.
	</para>

	<para>
	READ LOG EXT Log Page 10h reports which tag has failed and
	taskfile register values describing the error.  With this
	information the failed command can be handled as a normal ATA
	command error as in <xref linkend="excatDevErr"/> and all
	other in-flight commands must be retried.  Note that this
	retry should not be counted - it's likely that commands
	retried this way would have completed normally if it were not
	for the failed command.
	</para>

	<para>
	Note that ATA bus errors can be reported as ATA device NCQ
	errors.  This should be handled as described in <xref
	linkend="excatATAbusErr"/>.
	</para>

	<para>
	If READ LOG EXT Log Page 10h fails or reports NQ, we're
	thoroughly screwed.  This condition should be treated
	according to <xref linkend="excatHSMviolation"/>.
	</para>

     </sect2>

     <sect2 id="excatATAbusErr">
        <title>ATA bus error</title>

	<para>
	ATA bus error means that data corruption occurred during
	transmission over ATA bus (SATA or PATA).  This type of errors
	can be indicated by
	</para>

	<itemizedlist>

	<listitem>
	<para>
	ICRC or ABRT error as described in <xref linkend="excatDevErr"/>.
	</para>
	</listitem>

	<listitem>
	<para>
	Controller-specific error completion with error information
	indicating transmission error.
	</para>
	</listitem>

	<listitem>
	<para>
	On some controllers, command timeout.  In this case, there may
	be a mechanism to determine that the timeout is due to
	transmission error.
	</para>
	</listitem>

	<listitem>
	<para>
	Unknown/random errors, timeouts and all sorts of weirdities.
	</para>
	</listitem>

	</itemizedlist>

	<para>
	As described above, transmission errors can cause wide variety
	of symptoms ranging from device ICRC error to random device
	lockup, and, for many cases, there is no way to tell if an
	error condition is due to transmission error or not;
	therefore, it's necessary to employ some kind of heuristic
	when dealing with errors and timeouts.  For example,
	encountering repetitive ABRT errors for known supported
	command is likely to indicate ATA bus error.
	</para>

	<para>
	Once it's determined that ATA bus errors have possibly
	occurred, lowering ATA bus transmission speed is one of
	actions which may alleviate the problem.  See <xref
	linkend="exrecReconf"/> for more information.
	</para>

     </sect2>

     <sect2 id="excatPCIbusErr">
        <title>PCI bus error</title>

	<para>
	Data corruption or other failures during transmission over PCI
	(or other system bus).  For standard BMDMA, this is indicated
	by Error bit in the BMDMA Status register.  This type of
	errors must be logged as it indicates something is very wrong
	with the system.  Resetting host controller is recommended.
	</para>

     </sect2>

     <sect2 id="excatLateCompletion">
        <title>Late completion</title>

	<para>
	This occurs when timeout occurs and the timeout handler finds
	out that the timed out command has completed successfully or
	with error.  This is usually caused by lost interrupts.  This
	type of errors must be logged.  Resetting host controller is
	recommended.
	</para>

     </sect2>

     <sect2 id="excatUnknown">
        <title>Unknown error (timeout)</title>

	<para>
	This is when timeout occurs and the command is still
	processing or the host and device are in unknown state.  When
	this occurs, HSM could be in any valid or invalid state.  To
	bring the device to known state and make it forget about the
	timed out command, resetting is necessary.  The timed out
	command may be retried.
	</para>

	<para>
	Timeouts can also be caused by transmission errors.  Refer to
	<xref linkend="excatATAbusErr"/> for more details.
	</para>

     </sect2>

     <sect2 id="excatHoplugPM">
        <title>Hotplug and power management exceptions</title>

	<para>
	&lt;&lt;TODO: fill here&gt;&gt;
	</para>

     </sect2>

  </sect1>

  <sect1 id="exrec">
     <title>EH recovery actions</title>

     <para>
     This section discusses several important recovery actions.
     </para>

     <sect2 id="exrecClr">
        <title>Clearing error condition</title>

	<para>
	Many controllers require its error registers to be cleared by
	error handler.  Different controllers may have different
	requirements.
	</para>

	<para>
	For SATA, it's strongly recommended to clear at least SError
	register during error handling.
	</para>
     </sect2>

     <sect2 id="exrecRst">
        <title>Reset</title>

	<para>
	During EH, resetting is necessary in the following cases.
	</para>

	<itemizedlist>

	<listitem>
	<para>
	HSM is in unknown or invalid state
	</para>
	</listitem>

	<listitem>
	<para>
	HBA is in unknown or invalid state
	</para>
	</listitem>

	<listitem>
	<para>
	EH needs to make HBA/device forget about in-flight commands
	</para>
	</listitem>

	<listitem>
	<para>
	HBA/device behaves weirdly
	</para>
	</listitem>

	</itemizedlist>

	<para>
	Resetting during EH might be a good idea regardless of error
	condition to improve EH robustness.  Whether to reset both or
	either one of HBA and device depends on situation but the
	following scheme is recommended.
	</para>

	<itemizedlist>

	<listitem>
	<para>
	When it's known that HBA is in ready state but ATA/ATAPI
	device is in unknown state, reset only device.
	</para>
	</listitem>

	<listitem>
	<para>
	If HBA is in unknown state, reset both HBA and device.
	</para>
	</listitem>

	</itemizedlist>

	<para>
	HBA resetting is implementation specific.  For a controller
	complying to taskfile/BMDMA PCI IDE, stopping active DMA
	transaction may be sufficient iff BMDMA state is the only HBA
	context.  But even mostly taskfile/BMDMA PCI IDE complying
	controllers may have implementation specific requirements and
	mechanism to reset themselves.  This must be addressed by
	specific drivers.
	</para>

	<para>
	OTOH, ATA/ATAPI standard describes in detail ways to reset
	ATA/ATAPI devices.
	</para>

	<variablelist>

	   <varlistentry><term>PATA hardware reset</term>
	   <listitem>
	   <para>
	   This is hardware initiated device reset signalled with
	   asserted PATA RESET- signal.  There is no standard way to
	   initiate hardware reset from software although some
	   hardware provides registers that allow driver to directly
	   tweak the RESET- signal.
	   </para>
	   </listitem>
	   </varlistentry>

	   <varlistentry><term>Software reset</term>
	   <listitem>
	   <para>
	   This is achieved by turning CONTROL SRST bit on for at
	   least 5us.  Both PATA and SATA support it but, in case of
	   SATA, this may require controller-specific support as the
	   second Register FIS to clear SRST should be transmitted
	   while BSY bit is still set.  Note that on PATA, this resets
	   both master and slave devices on a channel.
	   </para>
	   </listitem>
	   </varlistentry>

	   <varlistentry><term>EXECUTE DEVICE DIAGNOSTIC command</term>
	   <listitem>
	   <para>
	   Although ATA/ATAPI standard doesn't describe exactly, EDD
	   implies some level of resetting, possibly similar level
	   with software reset.  Host-side EDD protocol can be handled
	   with normal command processing and most SATA controllers
	   should be able to handle EDD's just like other commands.
	   As in software reset, EDD affects both devices on a PATA
	   bus.
	   </para>
	   <para>
	   Although EDD does reset devices, this doesn't suit error
	   handling as EDD cannot be issued while BSY is set and it's
	   unclear how it will act when device is in unknown/weird
	   state.
	   </para>
	   </listitem>
	   </varlistentry>

	   <varlistentry><term>ATAPI DEVICE RESET command</term>
	   <listitem>
	   <para>
	   This is very similar to software reset except that reset
	   can be restricted to the selected device without affecting
	   the other device sharing the cable.
	   </para>
	   </listitem>
	   </varlistentry>

	   <varlistentry><term>SATA phy reset</term>
	   <listitem>
	   <para>
	   This is the preferred way of resetting a SATA device.  In
	   effect, it's identical to PATA hardware reset.  Note that
	   this can be done with the standard SCR Control register.
	   As such, it's usually easier to implement than software
	   reset.
	   </para>
	   </listitem>
	   </varlistentry>

	</variablelist>

	<para>
	One more thing to consider when resetting devices is that
	resetting clears certain configuration parameters and they
	need to be set to their previous or newly adjusted values
	after reset.
	</para>

	<para>
	Parameters affected are.
	</para>

	<itemizedlist>

	<listitem>
	<para>
	CHS set up with INITIALIZE DEVICE PARAMETERS (seldom used)
	</para>
	</listitem>

	<listitem>
	<para>
	Parameters set with SET FEATURES including transfer mode setting
	</para>
	</listitem>

	<listitem>
	<para>
	Block count set with SET MULTIPLE MODE
	</para>
	</listitem>

	<listitem>
	<para>
	Other parameters (SET MAX, MEDIA LOCK...)
	</para>
	</listitem>

	</itemizedlist>

	<para>
	ATA/ATAPI standard specifies that some parameters must be
	maintained across hardware or software reset, but doesn't
	strictly specify all of them.  Always reconfiguring needed
	parameters after reset is required for robustness.  Note that
	this also applies when resuming from deep sleep (power-off).
	</para>

	<para>
	Also, ATA/ATAPI standard requires that IDENTIFY DEVICE /
	IDENTIFY PACKET DEVICE is issued after any configuration
	parameter is updated or a hardware reset and the result used
	for further operation.  OS driver is required to implement
	revalidation mechanism to support this.
	</para>

     </sect2>

     <sect2 id="exrecReconf">
        <title>Reconfigure transport</title>

	<para>
	For both PATA and SATA, a lot of corners are cut for cheap
	connectors, cables or controllers and it's quite common to see
	high transmission error rate.  This can be mitigated by
	lowering transmission speed.
	</para>

	<para>
	The following is a possible scheme Jeff Garzik suggested.
	</para>

	<blockquote>
	<para>
	If more than $N (3?) transmission errors happen in 15 minutes,
	</para>	
	<itemizedlist>
	<listitem>
	<para>
	if SATA, decrease SATA PHY speed.  if speed cannot be decreased,
	</para>
	</listitem>
	<listitem>
	<para>
	decrease UDMA xfer speed.  if at UDMA0, switch to PIO4,
	</para>
	</listitem>
	<listitem>
	<para>
	decrease PIO xfer speed.  if at PIO3, complain, but continue
	</para>
	</listitem>
	</itemizedlist>
	</blockquote>

     </sect2>

  </sect1>

  </chapter>

  <chapter id="PiixInt">
     <title>ata_piix Internals</title>
<!-- drivers/ata/ata_piix.c -->
<refentry id="API-ich-pata-cable-detect">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ich_pata_cable_detect</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ich_pata_cable_detect</refname>
 <refpurpose>
  Probe host controller cable detect info
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>ich_pata_cable_detect </function></funcdef>
   <paramdef>struct ata_port * <parameter>ap</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ap</parameter></term>
   <listitem>
    <para>
     Port for which cable detect info is desired
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Read 80c cable indicator from ATA PCI device's PCI config
   register.  This register is normally set by firmware (BIOS).
</para>
</refsect1>
<refsect1>
<title>LOCKING</title>
<para>
   None (inherited from caller).
</para>
</refsect1>
</refentry>

<refentry id="API-piix-pata-prereset">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>piix_pata_prereset</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>piix_pata_prereset</refname>
 <refpurpose>
     prereset for PATA host controller
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>piix_pata_prereset </function></funcdef>
   <paramdef>struct ata_link * <parameter>link</parameter></paramdef>
   <paramdef>unsigned long <parameter>deadline</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>link</parameter></term>
   <listitem>
    <para>
     Target link
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>deadline</parameter></term>
   <listitem>
    <para>
     deadline jiffies for the operation
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>LOCKING</title>
<para>
   None (inherited from caller).
</para>
</refsect1>
</refentry>

<refentry id="API-piix-set-piomode">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>piix_set_piomode</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>piix_set_piomode</refname>
 <refpurpose>
     Initialize host controller PATA PIO timings
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>piix_set_piomode </function></funcdef>
   <paramdef>struct ata_port * <parameter>ap</parameter></paramdef>
   <paramdef>struct ata_device * <parameter>adev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ap</parameter></term>
   <listitem>
    <para>
     Port whose timings we are configuring
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>adev</parameter></term>
   <listitem>
    <para>
     Drive in question
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Set PIO mode for device, in host controller PCI config space.
</para>
</refsect1>
<refsect1>
<title>LOCKING</title>
<para>
   None (inherited from caller).
</para>
</refsect1>
</refentry>

<refentry id="API-do-pata-set-dmamode">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>do_pata_set_dmamode</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>do_pata_set_dmamode</refname>
 <refpurpose>
     Initialize host controller PATA PIO timings
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>do_pata_set_dmamode </function></funcdef>
   <paramdef>struct ata_port * <parameter>ap</parameter></paramdef>
   <paramdef>struct ata_device * <parameter>adev</parameter></paramdef>
   <paramdef>int <parameter>isich</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ap</parameter></term>
   <listitem>
    <para>
     Port whose timings we are configuring
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>adev</parameter></term>
   <listitem>
    <para>
     Drive in question
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>isich</parameter></term>
   <listitem>
    <para>
     set if the chip is an ICH device
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Set UDMA mode for device, in host controller PCI config space.
</para>
</refsect1>
<refsect1>
<title>LOCKING</title>
<para>
   None (inherited from caller).
</para>
</refsect1>
</refentry>

<refentry id="API-piix-set-dmamode">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>piix_set_dmamode</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>piix_set_dmamode</refname>
 <refpurpose>
     Initialize host controller PATA DMA timings
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>piix_set_dmamode </function></funcdef>
   <paramdef>struct ata_port * <parameter>ap</parameter></paramdef>
   <paramdef>struct ata_device * <parameter>adev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ap</parameter></term>
   <listitem>
    <para>
     Port whose timings we are configuring
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>adev</parameter></term>
   <listitem>
    <para>
     um
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Set MW/UDMA mode for device, in host controller PCI config space.
</para>
</refsect1>
<refsect1>
<title>LOCKING</title>
<para>
   None (inherited from caller).
</para>
</refsect1>
</refentry>

<refentry id="API-ich-set-dmamode">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ich_set_dmamode</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ich_set_dmamode</refname>
 <refpurpose>
     Initialize host controller PATA DMA timings
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>ich_set_dmamode </function></funcdef>
   <paramdef>struct ata_port * <parameter>ap</parameter></paramdef>
   <paramdef>struct ata_device * <parameter>adev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ap</parameter></term>
   <listitem>
    <para>
     Port whose timings we are configuring
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>adev</parameter></term>
   <listitem>
    <para>
     um
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Set MW/UDMA mode for device, in host controller PCI config space.
</para>
</refsect1>
<refsect1>
<title>LOCKING</title>
<para>
   None (inherited from caller).
</para>
</refsect1>
</refentry>

<refentry id="API-piix-check-450nx-errata">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>piix_check_450nx_errata</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>piix_check_450nx_errata</refname>
 <refpurpose>
     Check for problem 450NX setup
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>piix_check_450nx_errata </function></funcdef>
   <paramdef>struct pci_dev * <parameter>ata_dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ata_dev</parameter></term>
   <listitem>
    <para>
     the PCI device to check
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Check for the present of 450NX errata #19 and errata #25. If
   they are found return an error code so we can turn off DMA
</para>
</refsect1>
</refentry>

<refentry id="API-piix-init-one">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>piix_init_one</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>piix_init_one</refname>
 <refpurpose>
     Register PIIX ATA PCI device with kernel services
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>piix_init_one </function></funcdef>
   <paramdef>struct pci_dev * <parameter>pdev</parameter></paramdef>
   <paramdef>const struct pci_device_id * <parameter>ent</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>pdev</parameter></term>
   <listitem>
    <para>
     PCI device to register
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>ent</parameter></term>
   <listitem>
    <para>
     Entry in piix_pci_tbl matching with <parameter>pdev</parameter>
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Called from kernel PCI layer.  We probe for combined mode (sigh),
   and then hand over control to libata, for it to do the rest.
</para>
</refsect1>
<refsect1>
<title>LOCKING</title>
<para>
   Inherited from PCI layer (may sleep).
</para>
</refsect1>
<refsect1>
<title>RETURNS</title>
<para>
   Zero on success, or -ERRNO value.
</para>
</refsect1>
</refentry>

  </chapter>

  <chapter id="SILInt">
     <title>sata_sil Internals</title>
<!-- drivers/ata/sata_sil.c -->
<refentry id="API-sil-set-mode">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>sil_set_mode</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>sil_set_mode</refname>
 <refpurpose>
  wrap set_mode functions
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>sil_set_mode </function></funcdef>
   <paramdef>struct ata_link * <parameter>link</parameter></paramdef>
   <paramdef>struct ata_device ** <parameter>r_failed</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>link</parameter></term>
   <listitem>
    <para>
     link to set up
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>r_failed</parameter></term>
   <listitem>
    <para>
     returned device when we fail
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Wrap the libata method for device setup as after the setup we need
   to inspect the results and do some configuration work
</para>
</refsect1>
</refentry>

<refentry id="API-sil-dev-config">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>sil_dev_config</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>sil_dev_config</refname>
 <refpurpose>
     Apply device/host-specific errata fixups
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>sil_dev_config </function></funcdef>
   <paramdef>struct ata_device * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     Device to be examined
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   After the IDENTIFY [PACKET] DEVICE step is complete, and a
   device is known to be present, this function is called.
   We apply two errata fixups which are specific to Silicon Image,
   a Seagate and a Maxtor fixup.
   </para><para>

   For certain Seagate devices, we must limit the maximum sectors
   to under 8K.
   </para><para>

   For certain Maxtor devices, we must not program the drive
   beyond udma5.
   </para><para>

   Both fixups are unfairly pessimistic.  As soon as I get more
   information on these errata, I will create a more exhaustive
   list, and apply the fixups to only the specific
   devices/hosts/firmwares that need it.
   </para><para>

   20040111 - Seagate drives affected by the Mod15Write bug are blacklisted
   The Maxtor quirk is in the blacklist, but I'm keeping the original
   pessimistic fix for the following reasons...
   - There seems to be less info on it, only one device gleaned off the
   Windows	driver, maybe only one is affected.  More info would be greatly
   appreciated.
   - But then again UDMA5 is hardly anything to complain about
</para>
</refsect1>
</refentry>

  </chapter>

  <chapter id="libataThanks">
     <title>Thanks</title>
  <para>
  The bulk of the ATA knowledge comes thanks to long conversations with
  Andre Hedrick (www.linux-ide.org), and long hours pondering the ATA
  and SCSI specifications.
  </para>
  <para>
  Thanks to Alan Cox for pointing out similarities 
  between SATA and SCSI, and in general for motivation to hack on
  libata.
  </para>
  <para>
  libata's device detection
  method, ata_pio_devchk, and in general all the early probing was
  based on extensive study of Hale Landis's probe/reset code in his
  ATADRVR driver (www.ata-atapi.com).
  </para>
  </chapter>

</book>
