<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>Memory Management and Command Submission</title><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot"><link rel="home" href="index.html" title="Linux DRM Developer's Guide"><link rel="up" href="drmI915.html" title="Chapter 4. drm/i915 Intel GFX Driver"><link rel="prev" href="drmI915.html" title="Chapter 4. drm/i915 Intel GFX Driver"><link rel="next" href="API-i915-cmd-parser-init-ring.html" title="i915_cmd_parser_init_ring"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Memory Management and Command Submission</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="drmI915.html">Prev</a> </td><th width="60%" align="center">Chapter 4. drm/i915 Intel GFX Driver</th><td width="20%" align="right"> <a accesskey="n" href="API-i915-cmd-parser-init-ring.html">Next</a></td></tr></table><hr></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idm16146"></a>Memory Management and Command Submission</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="ch04s02.html#idm16149">Batchbuffer Parsing</a></span></dt><dt><span class="sect2"><a href="ch04s02.html#idm16360">Logical Rings, Logical Ring Contexts and Execlists</a></span></dt></dl></div><p>
	This sections covers all things related to the GEM implementation in the
	i915 driver.
      </p><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm16149"></a>Batchbuffer Parsing</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="refentrytitle"><a href="API-i915-cmd-parser-init-ring.html"><span class="phrase">i915_cmd_parser_init_ring</span></a></span><span class="refpurpose"> — 
  set cmd parser related fields for a ringbuffer
 </span></dt><dt><span class="refentrytitle"><a href="API-i915-cmd-parser-fini-ring.html"><span class="phrase">i915_cmd_parser_fini_ring</span></a></span><span class="refpurpose"> — 
     clean up cmd parser related fields
 </span></dt><dt><span class="refentrytitle"><a href="API-i915-needs-cmd-parser.html"><span class="phrase">i915_needs_cmd_parser</span></a></span><span class="refpurpose"> — 
     should a given ring use software command parsing?
 </span></dt><dt><span class="refentrytitle"><a href="API-i915-parse-cmds.html"><span class="phrase">i915_parse_cmds</span></a></span><span class="refpurpose"> — 
     parse a submitted batch buffer for privilege violations
 </span></dt><dt><span class="refentrytitle"><a href="API-i915-cmd-parser-get-version.html"><span class="phrase">i915_cmd_parser_get_version</span></a></span><span class="refpurpose"> — 
     get the cmd parser version number
 </span></dt></dl></div><p>
   </p><p>
   Motivation:
   Certain OpenGL features (e.g. transform feedback, performance monitoring)
   require userspace code to submit batches containing commands such as
   MI_LOAD_REGISTER_IMM to access various registers. Unfortunately, some
   generations of the hardware will noop these commands in <span class="quote">“<span class="quote">unsecure</span>”</span> batches
   (which includes all userspace batches submitted via i915) even though the
   commands may be safe and represent the intended programming model of the
   device.
   </p><p>
   The software command parser is similar in operation to the command parsing
   done in hardware for unsecure batches. However, the software parser allows
   some operations that would be noop'd by hardware, if the parser determines
   the operation is safe, and submits the batch as <span class="quote">“<span class="quote">secure</span>”</span> to prevent hardware
   parsing.
   </p><p>
   Threats:
   At a high level, the hardware (and software) checks attempt to prevent
   granting userspace undue privileges. There are three categories of privilege.
   </p><p>
   First, commands which are explicitly defined as privileged or which should
   only be used by the kernel driver. The parser generally rejects such
   commands, though it may allow some from the drm master process.
   </p><p>
   Second, commands which access registers. To support correct/enhanced
   userspace functionality, particularly certain OpenGL extensions, the parser
   provides a whitelist of registers which userspace may safely access (for both
   normal and drm master processes).
   </p><p>
   Third, commands which access privileged memory (i.e. GGTT, HWS page, etc).
   The parser always rejects such commands.
   </p><p>
   The majority of the problematic commands fall in the MI_* range, with only a
   few specific commands on each ring (e.g. PIPE_CONTROL and MI_FLUSH_DW).
   </p><p>
   Implementation:
   Each ring maintains tables of commands and registers which the parser uses in
   scanning batch buffers submitted to that ring.
   </p><p>
   Since the set of commands that the parser must check for is significantly
   smaller than the number of commands supported, the parser tables contain only
   those commands required by the parser. This generally works because command
   opcode ranges have standard command length encodings. So for commands that
   the parser does not need to check, it can easily skip them. This is
   implementated via a per-ring length decoding vfunc.
   </p><p>
   Unfortunately, there are a number of commands that do not follow the standard
   length encoding for their opcode range, primarily amongst the MI_* commands.
   To handle this, the parser provides a way to define explicit <span class="quote">“<span class="quote">skip</span>”</span> entries
   in the per-ring command tables.
   </p><p>
   Other command table entries map fairly directly to high level categories
   mentioned above: rejected, master-only, register whitelist. The parser
   implements a number of checks, including the privileged memory checks, via a
   general bitmasking mechanism.
</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm16360"></a>Logical Rings, Logical Ring Contexts and Execlists</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="refentrytitle"><a href="API-intel-sanitize-enable-execlists.html"><span class="phrase">intel_sanitize_enable_execlists</span></a></span><span class="refpurpose"> — 
  sanitize i915.enable_execlists
 </span></dt><dt><span class="refentrytitle"><a href="API-intel-execlists-ctx-id.html"><span class="phrase">intel_execlists_ctx_id</span></a></span><span class="refpurpose"> — 
     get the Execlists Context ID
 </span></dt><dt><span class="refentrytitle"><a href="API-intel-execlists-handle-ctx-events.html"><span class="phrase">intel_execlists_handle_ctx_events</span></a></span><span class="refpurpose"> — 
     handle Context Switch interrupts
 </span></dt><dt><span class="refentrytitle"><a href="API-intel-execlists-submission.html"><span class="phrase">intel_execlists_submission</span></a></span><span class="refpurpose"> — 
     submit a batchbuffer for execution, Execlists style
 </span></dt><dt><span class="refentrytitle"><a href="API-intel-logical-ring-advance-and-submit.html"><span class="phrase">intel_logical_ring_advance_and_submit</span></a></span><span class="refpurpose"> — 
     advance the tail and submit the workload
 </span></dt><dt><span class="refentrytitle"><a href="API-intel-logical-ring-begin.html"><span class="phrase">intel_logical_ring_begin</span></a></span><span class="refpurpose"> — 
     prepare the logical ringbuffer to accept some commands
 </span></dt><dt><span class="refentrytitle"><a href="API-intel-logical-ring-cleanup.html"><span class="phrase">intel_logical_ring_cleanup</span></a></span><span class="refpurpose"> — 
     deallocate the Engine Command Streamer
 </span></dt><dt><span class="refentrytitle"><a href="API-intel-logical-rings-init.html"><span class="phrase">intel_logical_rings_init</span></a></span><span class="refpurpose"> — 
     allocate, populate and init the Engine Command Streamers
 </span></dt><dt><span class="refentrytitle"><a href="API-intel-lr-context-free.html"><span class="phrase">intel_lr_context_free</span></a></span><span class="refpurpose"> — 
     free the LRC specific bits of a context
 </span></dt><dt><span class="refentrytitle"><a href="API-intel-lr-context-deferred-create.html"><span class="phrase">intel_lr_context_deferred_create</span></a></span><span class="refpurpose"> — 
     create the LRC specific bits of a context
 </span></dt></dl></div><p>
   </p><p>
   Motivation:
   GEN8 brings an expansion of the HW contexts: <span class="quote">“<span class="quote">Logical Ring Contexts</span>”</span>.
   These expanded contexts enable a number of new abilities, especially
   <span class="quote">“<span class="quote">Execlists</span>”</span> (also implemented in this file).
   </p><p>
   One of the main differences with the legacy HW contexts is that logical
   ring contexts incorporate many more things to the context's state, like
   PDPs or ringbuffer control registers:
   </p><p>
   The reason why PDPs are included in the context is straightforward: as
   PPGTTs (per-process GTTs) are actually per-context, having the PDPs
   contained there mean you don't need to do a ppgtt-&gt;switch_mm yourself,
   instead, the GPU will do it for you on the context switch.
   </p><p>
   But, what about the ringbuffer control registers (head, tail, etc..)?
   shouldn't we just need a set of those per engine command streamer? This is
   where the name <span class="quote">“<span class="quote">Logical Rings</span>”</span> starts to make sense: by virtualizing the
   rings, the engine cs shifts to a new <span class="quote">“<span class="quote">ring buffer</span>”</span> with every context
   switch. When you want to submit a workload to the GPU you: A) choose your
   context, B) find its appropriate virtualized ring, C) write commands to it
   and then, finally, D) tell the GPU to switch to that context.
   </p><p>
   Instead of the legacy MI_SET_CONTEXT, the way you tell the GPU to switch
   to a contexts is via a context execution list, ergo <span class="quote">“<span class="quote">Execlists</span>”</span>.
   </p><p>
   LRC implementation:
   Regarding the creation of contexts, we have:
   </p><p>
   - One global default context.
   - One local default context for each opened fd.
   - One local extra context for each context create ioctl call.
   </p><p>
   Now that ringbuffers belong per-context (and not per-engine, like before)
   and that contexts are uniquely tied to a given engine (and not reusable,
   like before) we need:
   </p><p>
   - One ringbuffer per-engine inside each context.
   - One backing object per-engine inside each context.
   </p><p>
   The global default context starts its life with these new objects fully
   allocated and populated. The local default context for each opened fd is
   more complex, because we don't know at creation time which engine is going
   to use them. To handle this, we have implemented a deferred creation of LR
   contexts:
   </p><p>
   The local context starts its life as a hollow or blank holder, that only
   gets populated for a given engine once we receive an execbuffer. If later
   on we receive another execbuffer ioctl for the same context but a different
   engine, we allocate/populate a new ringbuffer and context backing object and
   so on.
   </p><p>
   Finally, regarding local contexts created using the ioctl call: as they are
   only allowed with the render ring, we can allocate &amp; populate them right
   away (no need to defer anything, at least for now).
   </p><p>
   Execlists implementation:
   Execlists are the new method by which, on gen8+ hardware, workloads are
   submitted for execution (as opposed to the legacy, ringbuffer-based, method).
   This method works as follows:
   </p><p>
   When a request is committed, its commands (the BB start and any leading or
   trailing commands, like the seqno breadcrumbs) are placed in the ringbuffer
   for the appropriate context. The tail pointer in the hardware context is not
   updated at this time, but instead, kept by the driver in the ringbuffer
   structure. A structure representing this request is added to a request queue
   for the appropriate engine: this structure contains a copy of the context's
   tail after the request was written to the ring buffer and a pointer to the
   context itself.
   </p><p>
   If the engine's request queue was empty before the request was added, the
   queue is processed immediately. Otherwise the queue will be processed during
   a context switch interrupt. In any case, elements on the queue will get sent
   (in pairs) to the GPU's ExecLists Submit Port (ELSP, for short) with a
   globally unique 20-bits submission ID.
   </p><p>
   When execution of a request completes, the GPU updates the context status
   buffer with a context complete event and generates a context switch interrupt.
   During the interrupt handling, the driver examines the events in the buffer:
   for each context complete event, if the announced ID matches that on the head
   of the request queue, then that request is retired and removed from the queue.
   </p><p>
   After processing, if any requests were retired and the queue is not empty
   then a new execution list can be submitted. The two requests at the front of
   the queue are next to be submitted but since a context may not occur twice in
   an execution list, if subsequent requests have the same ID as the first then
   the two requests must be combined. This is done simply by discarding requests
   at the head of the queue until either only one requests is left (in which case
   we use a NULL second context) or the first two requests have unique IDs.
   </p><p>
   By always executing the first two requests in the queue the driver ensures
   that the GPU is kept as busy as possible. In the case where a single context
   completes but a second context is still executing, the request for this second
   context will be at the head of the queue when we remove the first one. This
   request will then be resubmitted along with a new request for a different context,
   which will cause the hardware to continue executing the second request and queue
   the new request (the GPU detects the condition of a context getting preempted
   with the same context and optimizes the context switch flow by not doing
   preemption, but just sampling the new tail pointer).
   </p><p>
</p></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="drmI915.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="drmI915.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="API-i915-cmd-parser-init-ring.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Chapter 4. drm/i915 Intel GFX Driver </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> <span class="phrase">i915_cmd_parser_init_ring</span></td></tr></table></div></body></html>
