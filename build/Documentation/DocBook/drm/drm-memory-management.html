<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>Memory management</title><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot"><link rel="home" href="index.html" title="Linux DRM Developer's Guide"><link rel="up" href="drmInternals.html" title="Chapter 2. DRM Internals"><link rel="prev" href="API-drm-dev-set-unique.html" title="drm_dev_set_unique"><link rel="next" href="API-drm-gem-object-init.html" title="drm_gem_object_init"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Memory management</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="API-drm-dev-set-unique.html">Prev</a> </td><th width="60%" align="center">Chapter 2. DRM Internals</th><td width="20%" align="right"> <a accesskey="n" href="API-drm-gem-object-init.html">Next</a></td></tr></table><hr></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="drm-memory-management"></a>Memory management</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="drm-memory-management.html#idm752">The Translation Table Manager (TTM)</a></span></dt><dt><span class="sect2"><a href="drm-memory-management.html#drm-gem">The Graphics Execution Manager (GEM)</a></span></dt><dt><span class="sect2"><a href="drm-memory-management.html#idm1433">VMA Offset Manager</a></span></dt><dt><span class="sect2"><a href="drm-memory-management.html#drm-prime-support">PRIME Buffer Sharing</a></span></dt><dt><span class="sect2"><a href="drm-memory-management.html#idm2305">PRIME Function References</a></span></dt><dt><span class="sect2"><a href="drm-memory-management.html#idm2669">DRM MM Range Allocator</a></span></dt><dt><span class="sect2"><a href="drm-memory-management.html#idm2693">DRM MM Range Allocator Function References</a></span></dt></dl></div><p>
      Modern Linux systems require large amount of graphics memory to store
      frame buffers, textures, vertices and other graphics-related data. Given
      the very dynamic nature of many of that data, managing graphics memory
      efficiently is thus crucial for the graphics stack and plays a central
      role in the DRM infrastructure.
    </p><p>
      The DRM core includes two memory managers, namely Translation Table Maps
      (TTM) and Graphics Execution Manager (GEM). TTM was the first DRM memory
      manager to be developed and tried to be a one-size-fits-them all
      solution. It provides a single userspace API to accommodate the need of
      all hardware, supporting both Unified Memory Architecture (UMA) devices
      and devices with dedicated video RAM (i.e. most discrete video cards).
      This resulted in a large, complex piece of code that turned out to be
      hard to use for driver development.
    </p><p>
      GEM started as an Intel-sponsored project in reaction to TTM's
      complexity. Its design philosophy is completely different: instead of
      providing a solution to every graphics memory-related problems, GEM
      identified common code between drivers and created a support library to
      share it. GEM has simpler initialization and execution requirements than
      TTM, but has no video RAM management capabilities and is thus limited to
      UMA devices.
    </p><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm752"></a>The Translation Table Manager (TTM)</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect3"><a href="drm-memory-management.html#idm755">TTM initialization</a></span></dt></dl></div><p>
	TTM design background and information belongs here.
      </p><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="idm755"></a>TTM initialization</h4></div></div></div><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Warning</h3><p>This section is outdated.</p></div><p>
          Drivers wishing to support TTM must fill out a drm_bo_driver
          structure. The structure contains several fields with function
          pointers for initializing the TTM, allocating and freeing memory,
          waiting for command completion and fence synchronization, and memory
          migration. See the radeon_ttm.c file for an example of usage.
	</p><p>
	  The ttm_global_reference structure is made up of several fields:
	</p><pre class="programlisting">
	  struct ttm_global_reference {
	  	enum ttm_global_types global_type;
	  	size_t size;
	  	void *object;
	  	int (*init) (struct ttm_global_reference *);
	  	void (*release) (struct ttm_global_reference *);
	  };
	</pre><p>
	  There should be one global reference structure for your memory
	  manager as a whole, and there will be others for each object
	  created by the memory manager at runtime.  Your global TTM should
	  have a type of TTM_GLOBAL_TTM_MEM.  The size field for the global
	  object should be sizeof(struct ttm_mem_global), and the init and
	  release hooks should point at your driver-specific init and
	  release routines, which probably eventually call
	  ttm_mem_global_init and ttm_mem_global_release, respectively.
	</p><p>
	  Once your global TTM accounting structure is set up and initialized
	  by calling ttm_global_item_ref() on it,
	  you need to create a buffer object TTM to
	  provide a pool for buffer object allocation by clients and the
	  kernel itself.  The type of this object should be TTM_GLOBAL_TTM_BO,
	  and its size should be sizeof(struct ttm_bo_global).  Again,
	  driver-specific init and release functions may be provided,
	  likely eventually calling ttm_bo_global_init() and
	  ttm_bo_global_release(), respectively.  Also, like the previous
	  object, ttm_global_item_ref() is used to create an initial reference
	  count for the TTM, which will call your initialization function.
	</p></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="drm-gem"></a>The Graphics Execution Manager (GEM)</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect3"><a href="drm-memory-management.html#idm777">GEM Initialization</a></span></dt><dt><span class="sect3"><a href="drm-memory-management.html#idm784">GEM Objects Creation</a></span></dt><dt><span class="sect3"><a href="drm-memory-management.html#idm809">GEM Objects Lifetime</a></span></dt><dt><span class="sect3"><a href="drm-memory-management.html#idm828">GEM Objects Naming</a></span></dt><dt><span class="sect3"><a href="drm-memory-management.html#drm-gem-objects-mapping">GEM Objects Mapping</a></span></dt><dt><span class="sect3"><a href="drm-memory-management.html#idm872">Memory Coherency</a></span></dt><dt><span class="sect3"><a href="drm-memory-management.html#idm875">Command Execution</a></span></dt><dt><span class="sect3"><a href="drm-memory-management.html#idm878">GEM Function Reference</a></span></dt></dl></div><p>
        The GEM design approach has resulted in a memory manager that doesn't
        provide full coverage of all (or even all common) use cases in its
        userspace or kernel API. GEM exposes a set of standard memory-related
        operations to userspace and a set of helper functions to drivers, and let
        drivers implement hardware-specific operations with their own private API.
      </p><p>
        The GEM userspace API is described in the
        <a class="ulink" href="http://lwn.net/Articles/283798/" target="_top"><em class="citetitle">GEM - the Graphics
        Execution Manager</em></a> article on LWN. While slightly
        outdated, the document provides a good overview of the GEM API principles.
        Buffer allocation and read and write operations, described as part of the
        common GEM API, are currently implemented using driver-specific ioctls.
      </p><p>
        GEM is data-agnostic. It manages abstract buffer objects without knowing
        what individual buffers contain. APIs that require knowledge of buffer
        contents or purpose, such as buffer allocation or synchronization
        primitives, are thus outside of the scope of GEM and must be implemented
        using driver-specific ioctls.
      </p><p>
	On a fundamental level, GEM involves several operations:
	</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">Memory allocation and freeing</li><li class="listitem">Command execution</li><li class="listitem">Aperture management at command execution time</li></ul></div><p>
	Buffer object allocation is relatively straightforward and largely
        provided by Linux's shmem layer, which provides memory to back each
        object.
      </p><p>
        Device-specific operations, such as command execution, pinning, buffer
	read &amp; write, mapping, and domain ownership transfers are left to
        driver-specific ioctls.
      </p><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="idm777"></a>GEM Initialization</h4></div></div></div><p>
          Drivers that use GEM must set the DRIVER_GEM bit in the struct
          <span class="structname">drm_driver</span>
          <em class="structfield"><code>driver_features</code></em> field. The DRM core will
          then automatically initialize the GEM core before calling the
          <code class="methodname">load</code> operation. Behind the scene, this will
          create a DRM Memory Manager object which provides an address space
          pool for object allocation.
        </p><p>
          In a KMS configuration, drivers need to allocate and initialize a
          command ring buffer following core GEM initialization if required by
          the hardware. UMA devices usually have what is called a "stolen"
          memory region, which provides space for the initial framebuffer and
          large, contiguous memory regions required by the device. This space is
          typically not managed by GEM, and must be initialized separately into
          its own DRM MM object.
        </p></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="idm784"></a>GEM Objects Creation</h4></div></div></div><p>
          GEM splits creation of GEM objects and allocation of the memory that
          backs them in two distinct operations.
        </p><p>
          GEM objects are represented by an instance of struct
          <span class="structname">drm_gem_object</span>. Drivers usually need to extend
          GEM objects with private information and thus create a driver-specific
          GEM object structure type that embeds an instance of struct
          <span class="structname">drm_gem_object</span>.
        </p><p>
          To create a GEM object, a driver allocates memory for an instance of its
          specific GEM object type and initializes the embedded struct
          <span class="structname">drm_gem_object</span> with a call to
          <code class="function">drm_gem_object_init</code>. The function takes a pointer to
          the DRM device, a pointer to the GEM object and the buffer object size
          in bytes.
        </p><p>
          GEM uses shmem to allocate anonymous pageable memory.
          <code class="function">drm_gem_object_init</code> will create an shmfs file of
          the requested size and store it into the struct
          <span class="structname">drm_gem_object</span> <em class="structfield"><code>filp</code></em>
          field. The memory is used as either main storage for the object when the
          graphics hardware uses system memory directly or as a backing store
          otherwise.
        </p><p>
          Drivers are responsible for the actual physical pages allocation by
          calling <code class="function">shmem_read_mapping_page_gfp</code> for each page.
          Note that they can decide to allocate pages when initializing the GEM
          object, or to delay allocation until the memory is needed (for instance
          when a page fault occurs as a result of a userspace memory access or
          when the driver needs to start a DMA transfer involving the memory).
        </p><p>
          Anonymous pageable memory allocation is not always desired, for instance
          when the hardware requires physically contiguous system memory as is
          often the case in embedded devices. Drivers can create GEM objects with
          no shmfs backing (called private GEM objects) by initializing them with
          a call to <code class="function">drm_gem_private_object_init</code> instead of
          <code class="function">drm_gem_object_init</code>. Storage for private GEM
          objects must be managed by drivers.
        </p><p>
          Drivers that do not need to extend GEM objects with private information
          can call the <code class="function">drm_gem_object_alloc</code> function to
          allocate and initialize a struct <span class="structname">drm_gem_object</span>
          instance. The GEM core will call the optional driver
          <code class="methodname">gem_init_object</code> operation after initializing
          the GEM object with <code class="function">drm_gem_object_init</code>.
          </p><pre class="synopsis">int (*gem_init_object) (struct drm_gem_object *obj);</pre><p>
        </p><p>
          No alloc-and-init function exists for private GEM objects.
        </p></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="idm809"></a>GEM Objects Lifetime</h4></div></div></div><p>
          All GEM objects are reference-counted by the GEM core. References can be
          acquired and release by <code class="function">calling drm_gem_object_reference</code>
          and <code class="function">drm_gem_object_unreference</code> respectively. The
          caller must hold the <span class="structname">drm_device</span>
          <em class="structfield"><code>struct_mutex</code></em> lock. As a convenience, GEM
          provides the <code class="function">drm_gem_object_reference_unlocked</code> and
          <code class="function">drm_gem_object_unreference_unlocked</code> functions that
          can be called without holding the lock.
        </p><p>
          When the last reference to a GEM object is released the GEM core calls
          the <span class="structname">drm_driver</span>
          <code class="methodname">gem_free_object</code> operation. That operation is
          mandatory for GEM-enabled drivers and must free the GEM object and all
          associated resources.
        </p><p>
          </p><pre class="synopsis">void (*gem_free_object) (struct drm_gem_object *obj);</pre><p>
          Drivers are responsible for freeing all GEM object resources, including
          the resources created by the GEM core. If an mmap offset has been
          created for the object (in which case
          <span class="structname">drm_gem_object</span>::<em class="structfield"><code>map_list</code></em>::<em class="structfield"><code>map</code></em>
          is not NULL) it must be freed by a call to
          <code class="function">drm_gem_free_mmap_offset</code>. The shmfs backing store
          must be released by calling <code class="function">drm_gem_object_release</code>
          (that function can safely be called if no shmfs backing store has been
          created).
        </p></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="idm828"></a>GEM Objects Naming</h4></div></div></div><p>
          Communication between userspace and the kernel refers to GEM objects
          using local handles, global names or, more recently, file descriptors.
          All of those are 32-bit integer values; the usual Linux kernel limits
          apply to the file descriptors.
        </p><p>
          GEM handles are local to a DRM file. Applications get a handle to a GEM
          object through a driver-specific ioctl, and can use that handle to refer
          to the GEM object in other standard or driver-specific ioctls. Closing a
          DRM file handle frees all its GEM handles and dereferences the
          associated GEM objects.
        </p><p>
          To create a handle for a GEM object drivers call
          <code class="function">drm_gem_handle_create</code>. The function takes a pointer
          to the DRM file and the GEM object and returns a locally unique handle.
          When the handle is no longer needed drivers delete it with a call to
          <code class="function">drm_gem_handle_delete</code>. Finally the GEM object
          associated with a handle can be retrieved by a call to
          <code class="function">drm_gem_object_lookup</code>.
        </p><p>
          Handles don't take ownership of GEM objects, they only take a reference
          to the object that will be dropped when the handle is destroyed. To
          avoid leaking GEM objects, drivers must make sure they drop the
          reference(s) they own (such as the initial reference taken at object
          creation time) as appropriate, without any special consideration for the
          handle. For example, in the particular case of combined GEM object and
          handle creation in the implementation of the
          <code class="methodname">dumb_create</code> operation, drivers must drop the
          initial reference to the GEM object before returning the handle.
        </p><p>
          GEM names are similar in purpose to handles but are not local to DRM
          files. They can be passed between processes to reference a GEM object
          globally. Names can't be used directly to refer to objects in the DRM
          API, applications must convert handles to names and names to handles
          using the DRM_IOCTL_GEM_FLINK and DRM_IOCTL_GEM_OPEN ioctls
          respectively. The conversion is handled by the DRM core without any
          driver-specific support.
        </p><p>
	  GEM also supports buffer sharing with dma-buf file descriptors through
	  PRIME. GEM-based drivers must use the provided helpers functions to
	  implement the exporting and importing correctly. See <a class="xref" href="drm-memory-management.html#drm-prime-support" title="PRIME Buffer Sharing">the section called “PRIME Buffer Sharing”</a>.
	  Since sharing file descriptors is inherently more secure than the
	  easily guessable and global GEM names it is the preferred buffer
	  sharing mechanism. Sharing buffers through GEM names is only supported
	  for legacy userspace. Furthermore PRIME also allows cross-device
	  buffer sharing since it is based on dma-bufs.
	</p></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="drm-gem-objects-mapping"></a>GEM Objects Mapping</h4></div></div></div><p>
          Because mapping operations are fairly heavyweight GEM favours
          read/write-like access to buffers, implemented through driver-specific
          ioctls, over mapping buffers to userspace. However, when random access
          to the buffer is needed (to perform software rendering for instance),
          direct access to the object can be more efficient.
        </p><p>
          The mmap system call can't be used directly to map GEM objects, as they
          don't have their own file handle. Two alternative methods currently
          co-exist to map GEM objects to userspace. The first method uses a
          driver-specific ioctl to perform the mapping operation, calling
          <code class="function">do_mmap</code> under the hood. This is often considered
          dubious, seems to be discouraged for new GEM-enabled drivers, and will
          thus not be described here.
        </p><p>
          The second method uses the mmap system call on the DRM file handle.
          </p><pre class="synopsis">void *mmap(void *addr, size_t length, int prot, int flags, int fd,
             off_t offset);</pre><p>
          DRM identifies the GEM object to be mapped by a fake offset passed
          through the mmap offset argument. Prior to being mapped, a GEM object
          must thus be associated with a fake offset. To do so, drivers must call
          <code class="function">drm_gem_create_mmap_offset</code> on the object. The
          function allocates a fake offset range from a pool and stores the
          offset divided by PAGE_SIZE in
          <code class="literal">obj-&gt;map_list.hash.key</code>. Care must be taken not to
          call <code class="function">drm_gem_create_mmap_offset</code> if a fake offset
          has already been allocated for the object. This can be tested by
          <code class="literal">obj-&gt;map_list.map</code> being non-NULL.
        </p><p>
          Once allocated, the fake offset value
          (<code class="literal">obj-&gt;map_list.hash.key &lt;&lt; PAGE_SHIFT</code>)
          must be passed to the application in a driver-specific way and can then
          be used as the mmap offset argument.
        </p><p>
          The GEM core provides a helper method <code class="function">drm_gem_mmap</code>
          to handle object mapping. The method can be set directly as the mmap
          file operation handler. It will look up the GEM object based on the
          offset value and set the VMA operations to the
          <span class="structname">drm_driver</span> <em class="structfield"><code>gem_vm_ops</code></em>
          field. Note that <code class="function">drm_gem_mmap</code> doesn't map memory to
          userspace, but relies on the driver-provided fault handler to map pages
          individually.
        </p><p>
          To use <code class="function">drm_gem_mmap</code>, drivers must fill the struct
          <span class="structname">drm_driver</span> <em class="structfield"><code>gem_vm_ops</code></em>
          field with a pointer to VM operations.
        </p><p>
          </p><pre class="synopsis">struct vm_operations_struct *gem_vm_ops

  struct vm_operations_struct {
          void (*open)(struct vm_area_struct * area);
          void (*close)(struct vm_area_struct * area);
          int (*fault)(struct vm_area_struct *vma, struct vm_fault *vmf);
  };</pre><p>
        </p><p>
          The <code class="methodname">open</code> and <code class="methodname">close</code>
          operations must update the GEM object reference count. Drivers can use
          the <code class="function">drm_gem_vm_open</code> and
          <code class="function">drm_gem_vm_close</code> helper functions directly as open
          and close handlers.
        </p><p>
          The fault operation handler is responsible for mapping individual pages
          to userspace when a page fault occurs. Depending on the memory
          allocation scheme, drivers can allocate pages at fault time, or can
          decide to allocate memory for the GEM object at the time the object is
          created.
        </p><p>
          Drivers that want to map the GEM object upfront instead of handling page
          faults can implement their own mmap file operation handler.
        </p></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="idm872"></a>Memory Coherency</h4></div></div></div><p>
          When mapped to the device or used in a command buffer, backing pages
          for an object are flushed to memory and marked write combined so as to
          be coherent with the GPU. Likewise, if the CPU accesses an object
          after the GPU has finished rendering to the object, then the object
          must be made coherent with the CPU's view of memory, usually involving
          GPU cache flushing of various kinds. This core CPU&lt;-&gt;GPU
          coherency management is provided by a device-specific ioctl, which
          evaluates an object's current domain and performs any necessary
          flushing or synchronization to put the object into the desired
          coherency domain (note that the object may be busy, i.e. an active
          render target; in that case, setting the domain blocks the client and
          waits for rendering to complete before performing any necessary
          flushing operations).
        </p></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="idm875"></a>Command Execution</h4></div></div></div><p>
	  Perhaps the most important GEM function for GPU devices is providing a
          command execution interface to clients. Client programs construct
          command buffers containing references to previously allocated memory
          objects, and then submit them to GEM. At that point, GEM takes care to
          bind all the objects into the GTT, execute the buffer, and provide
          necessary synchronization between clients accessing the same buffers.
          This often involves evicting some objects from the GTT and re-binding
          others (a fairly expensive operation), and providing relocation
          support which hides fixed GTT offsets from clients. Clients must take
          care not to submit command buffers that reference more objects than
          can fit in the GTT; otherwise, GEM will reject them and no rendering
          will occur. Similarly, if several objects in the buffer require fence
          registers to be allocated for correct rendering (e.g. 2D blits on
          pre-965 chips), care must be taken not to require more fence registers
          than are available to the client. Such resource management should be
          abstracted from the client in libdrm.
        </p></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="idm878"></a>GEM Function Reference</h4></div></div></div></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm1433"></a>VMA Offset Manager</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="refentrytitle"><a href="API-drm-vma-offset-manager-init.html"><span class="phrase">drm_vma_offset_manager_init</span></a></span><span class="refpurpose"> — 
  Initialize new offset-manager
 </span></dt><dt><span class="refentrytitle"><a href="API-drm-vma-offset-manager-destroy.html"><span class="phrase">drm_vma_offset_manager_destroy</span></a></span><span class="refpurpose"> — 
     Destroy offset manager
 </span></dt><dt><span class="refentrytitle"><a href="API-drm-vma-offset-lookup.html"><span class="phrase">drm_vma_offset_lookup</span></a></span><span class="refpurpose"> — 
     Find node in offset space
 </span></dt><dt><span class="refentrytitle"><a href="API-drm-vma-offset-lookup-locked.html"><span class="phrase">drm_vma_offset_lookup_locked</span></a></span><span class="refpurpose"> — 
     Find node in offset space
 </span></dt><dt><span class="refentrytitle"><a href="API-drm-vma-offset-add.html"><span class="phrase">drm_vma_offset_add</span></a></span><span class="refpurpose"> — 
     Add offset node to manager
 </span></dt><dt><span class="refentrytitle"><a href="API-drm-vma-offset-remove.html"><span class="phrase">drm_vma_offset_remove</span></a></span><span class="refpurpose"> — 
     Remove offset node from manager
 </span></dt><dt><span class="refentrytitle"><a href="API-drm-vma-node-allow.html"><span class="phrase">drm_vma_node_allow</span></a></span><span class="refpurpose"> — 
     Add open-file to list of allowed users
 </span></dt><dt><span class="refentrytitle"><a href="API-drm-vma-node-revoke.html"><span class="phrase">drm_vma_node_revoke</span></a></span><span class="refpurpose"> — 
     Remove open-file from list of allowed users
 </span></dt><dt><span class="refentrytitle"><a href="API-drm-vma-node-is-allowed.html"><span class="phrase">drm_vma_node_is_allowed</span></a></span><span class="refpurpose"> — 
     Check whether an open-file is granted access
 </span></dt><dt><span class="refentrytitle"><a href="API-drm-vma-offset-exact-lookup.html"><span class="phrase">drm_vma_offset_exact_lookup</span></a></span><span class="refpurpose"> — 
  Look up node by exact address
 </span></dt><dt><span class="refentrytitle"><a href="API-drm-vma-offset-lock-lookup.html"><span class="phrase">drm_vma_offset_lock_lookup</span></a></span><span class="refpurpose"> — 
     Lock lookup for extended private use
 </span></dt><dt><span class="refentrytitle"><a href="API-drm-vma-offset-unlock-lookup.html"><span class="phrase">drm_vma_offset_unlock_lookup</span></a></span><span class="refpurpose"> — 
     Unlock lookup for extended private use
 </span></dt><dt><span class="refentrytitle"><a href="API-drm-vma-node-reset.html"><span class="phrase">drm_vma_node_reset</span></a></span><span class="refpurpose"> — 
     Initialize or reset node object
 </span></dt><dt><span class="refentrytitle"><a href="API-drm-vma-node-start.html"><span class="phrase">drm_vma_node_start</span></a></span><span class="refpurpose"> — 
     Return start address for page-based addressing
 </span></dt><dt><span class="refentrytitle"><a href="API-drm-vma-node-size.html"><span class="phrase">drm_vma_node_size</span></a></span><span class="refpurpose"> — 
     Return size (page-based)
 </span></dt><dt><span class="refentrytitle"><a href="API-drm-vma-node-has-offset.html"><span class="phrase">drm_vma_node_has_offset</span></a></span><span class="refpurpose"> — 
     Check whether node is added to offset manager
 </span></dt><dt><span class="refentrytitle"><a href="API-drm-vma-node-offset-addr.html"><span class="phrase">drm_vma_node_offset_addr</span></a></span><span class="refpurpose"> — 
     Return sanitized offset for user-space mmaps
 </span></dt><dt><span class="refentrytitle"><a href="API-drm-vma-node-unmap.html"><span class="phrase">drm_vma_node_unmap</span></a></span><span class="refpurpose"> — 
     Unmap offset node
 </span></dt><dt><span class="refentrytitle"><a href="API-drm-vma-node-verify-access.html"><span class="phrase">drm_vma_node_verify_access</span></a></span><span class="refpurpose"> — 
     Access verification helper for TTM
 </span></dt></dl></div><p>
   </p><p>
   The vma-manager is responsible to map arbitrary driver-dependent memory
   regions into the linear user address-space. It provides offsets to the
   caller which can then be used on the address_space of the drm-device. It
   takes care to not overlap regions, size them appropriately and to not
   confuse mm-core by inconsistent fake vm_pgoff fields.
   Drivers shouldn't use this for object placement in VMEM. This manager should
   only be used to manage mappings into linear user-space VMs.
   </p><p>
   We use drm_mm as backend to manage object allocations. But it is highly
   optimized for alloc/free calls, not lookups. Hence, we use an rb-tree to
   speed up offset lookups.
   </p><p>
   You must not use multiple offset managers on a single address_space.
   Otherwise, mm-core will be unable to tear down memory mappings as the VM will
   no longer be linear. Please use VM_NONLINEAR in that case and implement your
   own offset managers.
   </p><p>
   This offset manager works on page-based addresses. That is, every argument
   and return code (with the exception of <code class="function">drm_vma_node_offset_addr</code>) is given
   in number of pages, not number of bytes. That means, object sizes and offsets
   must always be page-aligned (as usual).
   If you want to get a valid byte-based user-space address for a given offset,
   please see <code class="function">drm_vma_node_offset_addr</code>.
   </p><p>
   Additionally to offset management, the vma offset manager also handles access
   management. For every open-file context that is allowed to access a given
   node, you must call <code class="function">drm_vma_node_allow</code>. Otherwise, an <code class="function">mmap</code> call on this
   open-file with the offset of the node will fail with -EACCES. To revoke
   access again, use <code class="function">drm_vma_node_revoke</code>. However, the caller is responsible
   for destroying already existing mappings, if required.
</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="drm-prime-support"></a>PRIME Buffer Sharing</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect3"><a href="drm-memory-management.html#idm2268">Overview and Driver Interface</a></span></dt><dt><span class="sect3"><a href="drm-memory-management.html#idm2285">PRIME Helper Functions</a></span></dt></dl></div><p>
	  PRIME is the cross device buffer sharing framework in drm, originally
	  created for the OPTIMUS range of multi-gpu platforms. To userspace
	  PRIME buffers are dma-buf based file descriptors.
	</p><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="idm2268"></a>Overview and Driver Interface</h4></div></div></div><p>
	    Similar to GEM global names, PRIME file descriptors are
	    also used to share buffer objects across processes. They offer
	    additional security: as file descriptors must be explicitly sent over
	    UNIX domain sockets to be shared between applications, they can't be
	    guessed like the globally unique GEM names.
	  </p><p>
	    Drivers that support the PRIME
	    API must set the DRIVER_PRIME bit in the struct
	    <span class="structname">drm_driver</span>
	    <em class="structfield"><code>driver_features</code></em> field, and implement the
	    <code class="methodname">prime_handle_to_fd</code> and
	    <code class="methodname">prime_fd_to_handle</code> operations.
	  </p><p>
	    </p><pre class="synopsis">int (*prime_handle_to_fd)(struct drm_device *dev,
			  struct drm_file *file_priv, uint32_t handle,
			  uint32_t flags, int *prime_fd);
int (*prime_fd_to_handle)(struct drm_device *dev,
			  struct drm_file *file_priv, int prime_fd,
			  uint32_t *handle);</pre><p>
	    Those two operations convert a handle to a PRIME file descriptor and
	    vice versa. Drivers must use the kernel dma-buf buffer sharing framework
	    to manage the PRIME file descriptors. Similar to the mode setting
	    API PRIME is agnostic to the underlying buffer object manager, as
	    long as handles are 32bit unsigned integers.
	  </p><p>
	    While non-GEM drivers must implement the operations themselves, GEM
	    drivers must use the <code class="function">drm_gem_prime_handle_to_fd</code>
	    and <code class="function">drm_gem_prime_fd_to_handle</code> helper functions.
	    Those helpers rely on the driver
	    <code class="methodname">gem_prime_export</code> and
	    <code class="methodname">gem_prime_import</code> operations to create a dma-buf
	    instance from a GEM object (dma-buf exporter role) and to create a GEM
	    object from a dma-buf instance (dma-buf importer role).
	  </p><p>
	    </p><pre class="synopsis">struct dma_buf * (*gem_prime_export)(struct drm_device *dev,
				     struct drm_gem_object *obj,
				     int flags);
struct drm_gem_object * (*gem_prime_import)(struct drm_device *dev,
					    struct dma_buf *dma_buf);</pre><p>
	    These two operations are mandatory for GEM drivers that support
	    PRIME.
	  </p></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="idm2285"></a>PRIME Helper Functions</h4></div></div></div><p>
   </p><p>
   Drivers can implement <em class="parameter"><code>gem_prime_export</code></em> and <em class="parameter"><code>gem_prime_import</code></em> in terms of
   simpler APIs by using the helper functions <em class="parameter"><code>drm_gem_prime_export</code></em> and
   <em class="parameter"><code>drm_gem_prime_import</code></em>.  These functions implement dma-buf support in terms of
   five lower-level driver callbacks:
   </p><p>
   Export callbacks:
   </p><p>
   - <em class="parameter"><code>gem_prime_pin</code></em> (optional): prepare a GEM object for exporting
   </p><p>
   - <em class="parameter"><code>gem_prime_get_sg_table</code></em>: provide a scatter/gather table of pinned pages
   </p><p>
   - <em class="parameter"><code>gem_prime_vmap</code></em>: vmap a buffer exported by your driver
   </p><p>
   - <em class="parameter"><code>gem_prime_vunmap</code></em>: vunmap a buffer exported by your driver
   </p><p>
   Import callback:
   </p><p>
   - <em class="parameter"><code>gem_prime_import_sg_table</code></em> (import): produce a GEM object from another
   driver's scatter/gather table
</p></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm2305"></a>PRIME Function References</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="refentrytitle"><a href="API-drm-gem-dmabuf-release.html"><span class="phrase">drm_gem_dmabuf_release</span></a></span><span class="refpurpose"> — 
  dma_buf release implementation for GEM
 </span></dt><dt><span class="refentrytitle"><a href="API-drm-gem-prime-export.html"><span class="phrase">drm_gem_prime_export</span></a></span><span class="refpurpose"> — 
     helper library implemention of the export callback
 </span></dt><dt><span class="refentrytitle"><a href="API-drm-gem-prime-handle-to-fd.html"><span class="phrase">drm_gem_prime_handle_to_fd</span></a></span><span class="refpurpose"> — 
     PRIME export function for GEM drivers
 </span></dt><dt><span class="refentrytitle"><a href="API-drm-gem-prime-import.html"><span class="phrase">drm_gem_prime_import</span></a></span><span class="refpurpose"> — 
     helper library implemention of the import callback
 </span></dt><dt><span class="refentrytitle"><a href="API-drm-gem-prime-fd-to-handle.html"><span class="phrase">drm_gem_prime_fd_to_handle</span></a></span><span class="refpurpose"> — 
     PRIME import function for GEM drivers
 </span></dt><dt><span class="refentrytitle"><a href="API-drm-prime-pages-to-sg.html"><span class="phrase">drm_prime_pages_to_sg</span></a></span><span class="refpurpose"> — 
     converts a page array into an sg list
 </span></dt><dt><span class="refentrytitle"><a href="API-drm-prime-sg-to-page-addr-arrays.html"><span class="phrase">drm_prime_sg_to_page_addr_arrays</span></a></span><span class="refpurpose"> — 
     convert an sg table into a page array
 </span></dt><dt><span class="refentrytitle"><a href="API-drm-prime-gem-destroy.html"><span class="phrase">drm_prime_gem_destroy</span></a></span><span class="refpurpose"> — 
     helper to clean up a PRIME-imported GEM object
 </span></dt></dl></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm2669"></a>DRM MM Range Allocator</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect3"><a href="drm-memory-management.html#idm2671">Overview</a></span></dt><dt><span class="sect3"><a href="drm-memory-management.html#idm2684">LRU Scan/Eviction Support</a></span></dt></dl></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="idm2671"></a>Overview</h4></div></div></div><p>
   </p><p>
   drm_mm provides a simple range allocator. The drivers are free to use the
   resource allocator from the linux core if it suits them, the upside of drm_mm
   is that it's in the DRM core. Which means that it's easier to extend for
   some of the crazier special purpose needs of gpus.
   </p><p>
   The main data struct is <span class="structname">drm_mm</span>, allocations are tracked in <span class="structname">drm_mm_node</span>.
   Drivers are free to embed either of them into their own suitable
   datastructures. drm_mm itself will not do any allocations of its own, so if
   drivers choose not to embed nodes they need to still allocate them
   themselves.
   </p><p>
   The range allocator also supports reservation of preallocated blocks. This is
   useful for taking over initial mode setting configurations from the firmware,
   where an object needs to be created which exactly matches the firmware's
   scanout target. As long as the range is still free it can be inserted anytime
   after the allocator is initialized, which helps with avoiding looped
   depencies in the driver load sequence.
   </p><p>
   drm_mm maintains a stack of most recently freed holes, which of all
   simplistic datastructures seems to be a fairly decent approach to clustering
   allocations and avoiding too much fragmentation. This means free space
   searches are O(num_holes). Given that all the fancy features drm_mm supports
   something better would be fairly complex and since gfx thrashing is a fairly
   steep cliff not a real concern. Removing a node again is O(1).
   </p><p>
   drm_mm supports a few features: Alignment and range restrictions can be
   supplied. Further more every <span class="structname">drm_mm_node</span> has a color value (which is just an
   opaqua unsigned long) which in conjunction with a driver callback can be used
   to implement sophisticated placement restrictions. The i915 DRM driver uses
   this to implement guard pages between incompatible caching domains in the
   graphics TT.
   </p><p>
   Two behaviors are supported for searching and allocating: bottom-up and top-down.
   The default is bottom-up. Top-down allocation can be used if the memory area
   has different restrictions, or just to reduce fragmentation.
   </p><p>
   Finally iteration helpers to walk all nodes and all holes are provided as are
   some basic allocator dumpers for debugging.
</p></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="idm2684"></a>LRU Scan/Eviction Support</h4></div></div></div><p>
   </p><p>
   Very often GPUs need to have continuous allocations for a given object. When
   evicting objects to make space for a new one it is therefore not most
   efficient when we simply start to select all objects from the tail of an LRU
   until there's a suitable hole: Especially for big objects or nodes that
   otherwise have special allocation constraints there's a good chance we evict
   lots of (smaller) objects unecessarily.
   </p><p>
   The DRM range allocator supports this use-case through the scanning
   interfaces. First a scan operation needs to be initialized with
   <code class="function">drm_mm_init_scan</code> or <code class="function">drm_mm_init_scan_with_range</code>. The the driver adds
   objects to the roaster (probably by walking an LRU list, but this can be
   freely implemented) until a suitable hole is found or there's no further
   evitable object.
   </p><p>
   The the driver must walk through all objects again in exactly the reverse
   order to restore the allocator state. Note that while the allocator is used
   in the scan mode no other operation is allowed.
   </p><p>
   Finally the driver evicts all objects selected in the scan. Adding and
   removing an object is O(1), and since freeing a node is also O(1) the overall
   complexity is O(scanned_objects). So like the free stack which needs to be
   walked before a scan operation even begins this is linear in the number of
   objects. It doesn't seem to hurt badly.
</p></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm2693"></a>DRM MM Range Allocator Function References</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="refentrytitle"><a href="API-drm-mm-reserve-node.html"><span class="phrase">drm_mm_reserve_node</span></a></span><span class="refpurpose"> — 
  insert an pre-initialized node
 </span></dt><dt><span class="refentrytitle"><a href="API-drm-mm-insert-node-generic.html"><span class="phrase">drm_mm_insert_node_generic</span></a></span><span class="refpurpose"> — 
     search for space and insert <em class="parameter"><code>node</code></em>
 </span></dt><dt><span class="refentrytitle"><a href="API-drm-mm-insert-node-in-range-generic.html"><span class="phrase">drm_mm_insert_node_in_range_generic</span></a></span><span class="refpurpose"> — 
     ranged search for space and insert <em class="parameter"><code>node</code></em>
 </span></dt><dt><span class="refentrytitle"><a href="API-drm-mm-remove-node.html"><span class="phrase">drm_mm_remove_node</span></a></span><span class="refpurpose"> — 
     Remove a memory node from the allocator.
 </span></dt><dt><span class="refentrytitle"><a href="API-drm-mm-replace-node.html"><span class="phrase">drm_mm_replace_node</span></a></span><span class="refpurpose"> — 
     move an allocation from <em class="parameter"><code>old</code></em> to <em class="parameter"><code>new</code></em>
 </span></dt><dt><span class="refentrytitle"><a href="API-drm-mm-init-scan.html"><span class="phrase">drm_mm_init_scan</span></a></span><span class="refpurpose"> — 
     initialize lru scanning
 </span></dt><dt><span class="refentrytitle"><a href="API-drm-mm-init-scan-with-range.html"><span class="phrase">drm_mm_init_scan_with_range</span></a></span><span class="refpurpose"> — 
     initialize range-restricted lru scanning
 </span></dt><dt><span class="refentrytitle"><a href="API-drm-mm-scan-add-block.html"><span class="phrase">drm_mm_scan_add_block</span></a></span><span class="refpurpose"> — 
     add a node to the scan list
 </span></dt><dt><span class="refentrytitle"><a href="API-drm-mm-scan-remove-block.html"><span class="phrase">drm_mm_scan_remove_block</span></a></span><span class="refpurpose"> — 
     remove a node from the scan list
 </span></dt><dt><span class="refentrytitle"><a href="API-drm-mm-clean.html"><span class="phrase">drm_mm_clean</span></a></span><span class="refpurpose"> — 
     checks whether an allocator is clean
 </span></dt><dt><span class="refentrytitle"><a href="API-drm-mm-init.html"><span class="phrase">drm_mm_init</span></a></span><span class="refpurpose"> — 
     initialize a drm-mm allocator
 </span></dt><dt><span class="refentrytitle"><a href="API-drm-mm-takedown.html"><span class="phrase">drm_mm_takedown</span></a></span><span class="refpurpose"> — 
     clean up a drm_mm allocator
 </span></dt><dt><span class="refentrytitle"><a href="API-drm-mm-debug-table.html"><span class="phrase">drm_mm_debug_table</span></a></span><span class="refpurpose"> — 
     dump allocator state to dmesg
 </span></dt><dt><span class="refentrytitle"><a href="API-drm-mm-dump-table.html"><span class="phrase">drm_mm_dump_table</span></a></span><span class="refpurpose"> — 
     dump allocator state to a seq_file
 </span></dt><dt><span class="refentrytitle"><a href="API-drm-mm-node-allocated.html"><span class="phrase">drm_mm_node_allocated</span></a></span><span class="refpurpose"> — 
  checks whether a node is allocated
 </span></dt><dt><span class="refentrytitle"><a href="API-drm-mm-initialized.html"><span class="phrase">drm_mm_initialized</span></a></span><span class="refpurpose"> — 
     checks whether an allocator is initialized
 </span></dt><dt><span class="refentrytitle"><a href="API-drm-mm-hole-node-start.html"><span class="phrase">drm_mm_hole_node_start</span></a></span><span class="refpurpose"> — 
     computes the start of the hole following <em class="parameter"><code>node</code></em>
 </span></dt><dt><span class="refentrytitle"><a href="API-drm-mm-hole-node-end.html"><span class="phrase">drm_mm_hole_node_end</span></a></span><span class="refpurpose"> — 
     computes the end of the hole following <em class="parameter"><code>node</code></em>
 </span></dt><dt><span class="refentrytitle"><a href="API-drm-mm-for-each-node.html"><span class="phrase">drm_mm_for_each_node</span></a></span><span class="refpurpose"> — 
     iterator to walk over all allocated nodes
 </span></dt><dt><span class="refentrytitle"><a href="API-drm-mm-for-each-hole.html"><span class="phrase">drm_mm_for_each_hole</span></a></span><span class="refpurpose"> — 
     iterator to walk over all holes
 </span></dt><dt><span class="refentrytitle"><a href="API-drm-mm-insert-node.html"><span class="phrase">drm_mm_insert_node</span></a></span><span class="refpurpose"> — 
     search for space and insert <em class="parameter"><code>node</code></em>
 </span></dt><dt><span class="refentrytitle"><a href="API-drm-mm-insert-node-in-range.html"><span class="phrase">drm_mm_insert_node_in_range</span></a></span><span class="refpurpose"> — 
     ranged search for space and insert <em class="parameter"><code>node</code></em>
 </span></dt></dl></div></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="API-drm-dev-set-unique.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="drmInternals.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="API-drm-gem-object-init.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top"><span class="phrase">drm_dev_set_unique</span> </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> <span class="phrase">drm_gem_object_init</span></td></tr></table></div></body></html>
