<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>Chapter 2. DRM Internals</title><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot"><link rel="home" href="index.html" title="Linux DRM Developer's Guide"><link rel="up" href="drmCore.html" title="Part I. DRM Core"><link rel="prev" href="drmIntroduction.html" title="Chapter 1. Introduction"><link rel="next" href="API-drm-pci-alloc.html" title="drm_pci_alloc"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Chapter 2. DRM Internals</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="drmIntroduction.html">Prev</a> </td><th width="60%" align="center">Part I. DRM Core</th><td width="20%" align="right"> <a accesskey="n" href="API-drm-pci-alloc.html">Next</a></td></tr></table><hr></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="drmInternals"></a>Chapter 2. DRM Internals</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="sect1"><a href="drmInternals.html#idm59">Driver Initialization</a></span></dt><dd><dl><dt><span class="sect2"><a href="drmInternals.html#idm71">Driver Information</a></span></dt><dt><span class="sect2"><a href="drmInternals.html#idm135">Device Registration</a></span></dt><dt><span class="sect2"><a href="drmInternals.html#idm686">Driver Load</a></span></dt></dl></dd><dt><span class="sect1"><a href="drm-memory-management.html">Memory management</a></span></dt><dd><dl><dt><span class="sect2"><a href="drm-memory-management.html#idm752">The Translation Table Manager (TTM)</a></span></dt><dt><span class="sect2"><a href="drm-memory-management.html#drm-gem">The Graphics Execution Manager (GEM)</a></span></dt><dt><span class="sect2"><a href="drm-memory-management.html#idm1433">VMA Offset Manager</a></span></dt><dt><span class="sect2"><a href="drm-memory-management.html#drm-prime-support">PRIME Buffer Sharing</a></span></dt><dt><span class="sect2"><a href="drm-memory-management.html#idm2305">PRIME Function References</a></span></dt><dt><span class="sect2"><a href="drm-memory-management.html#idm2669">DRM MM Range Allocator</a></span></dt><dt><span class="sect2"><a href="drm-memory-management.html#idm2693">DRM MM Range Allocator Function References</a></span></dt></dl></dd><dt><span class="sect1"><a href="drm-mode-setting.html">Mode Setting</a></span></dt><dd><dl><dt><span class="sect2"><a href="drm-mode-setting.html#idm3767">Display Modes Function Reference</a></span></dt><dt><span class="sect2"><a href="drm-mode-setting.html#idm4852">Frame Buffer Creation</a></span></dt><dt><span class="sect2"><a href="drm-mode-setting.html#idm4892">Dumb Buffer Objects</a></span></dt><dt><span class="sect2"><a href="drm-mode-setting.html#idm4921">Output Polling</a></span></dt><dt><span class="sect2"><a href="drm-mode-setting.html#idm4926">Locking</a></span></dt></dl></dd><dt><span class="sect1"><a href="drm-kms-init.html">KMS Initialization and Cleanup</a></span></dt><dd><dl><dt><span class="sect2"><a href="drm-kms-init.html#idm4934">CRTCs (struct <span class="structname">drm_crtc</span>)</a></span></dt><dt><span class="sect2"><a href="drm-kms-init.html#idm5000">Planes (struct <span class="structname">drm_plane</span>)</a></span></dt><dt><span class="sect2"><a href="drm-kms-init.html#idm5041">Encoders (struct <span class="structname">drm_encoder</span>)</a></span></dt><dt><span class="sect2"><a href="drm-kms-init.html#idm5074">Connectors (struct <span class="structname">drm_connector</span>)</a></span></dt><dt><span class="sect2"><a href="drm-kms-init.html#idm5200">Cleanup</a></span></dt><dt><span class="sect2"><a href="drm-kms-init.html#idm5213">Output discovery and initialization example</a></span></dt><dt><span class="sect2"><a href="drm-kms-init.html#idm5217">KMS API Functions</a></span></dt><dt><span class="sect2"><a href="drm-kms-init.html#idm7707">KMS Locking</a></span></dt></dl></dd><dt><span class="sect1"><a href="ch02s05.html">Mode Setting Helper Functions</a></span></dt><dd><dl><dt><span class="sect2"><a href="ch02s05.html#idm8369">Helper Functions</a></span></dt><dt><span class="sect2"><a href="ch02s05.html#idm8405">CRTC Helper Operations</a></span></dt><dt><span class="sect2"><a href="ch02s05.html#idm8436">Encoder Helper Operations</a></span></dt><dt><span class="sect2"><a href="ch02s05.html#idm8453">Connector Helper Operations</a></span></dt><dt><span class="sect2"><a href="ch02s05.html#idm8603">Modeset Helper Functions Reference</a></span></dt><dt><span class="sect2"><a href="ch02s05.html#idm8963">Output Probing Helper Functions Reference</a></span></dt><dt><span class="sect2"><a href="ch02s05.html#idm9274">fbdev Helper Functions Reference</a></span></dt><dt><span class="sect2"><a href="ch02s05.html#idm9920">Display Port Helper Functions Reference</a></span></dt><dt><span class="sect2"><a href="ch02s05.html#idm10514">Display Port MST Helper Functions Reference</a></span></dt><dt><span class="sect2"><a href="ch02s05.html#idm11455">EDID Helper Functions Reference</a></span></dt><dt><span class="sect2"><a href="ch02s05.html#idm12283">Rectangle Utilities Reference</a></span></dt><dt><span class="sect2"><a href="ch02s05.html#idm13139">Flip-work Helper Reference</a></span></dt><dt><span class="sect2"><a href="ch02s05.html#idm13352">HDMI Infoframes Helper Reference</a></span></dt><dt><span class="sect2"><a href="ch02s05.html#idm13779">Plane Helper Reference</a></span></dt></dl></dd><dt><span class="sect1"><a href="drm-kms-properties.html">KMS Properties</a></span></dt><dd><dl><dt><span class="sect2"><a href="drm-kms-properties.html#idm14213">Existing KMS Properties</a></span></dt></dl></dd><dt><span class="sect1"><a href="drm-vertical-blank.html">Vertical Blanking</a></span></dt><dd><dl><dt><span class="sect2"><a href="drm-vertical-blank.html#idm14950">Vertical Blanking and Interrupt Handling Functions Reference</a></span></dt></dl></dd><dt><span class="sect1"><a href="ch02s08.html">Open/Close, File Operations and IOCTLs</a></span></dt><dd><dl><dt><span class="sect2"><a href="ch02s08.html#idm15927">Open and Close</a></span></dt><dt><span class="sect2"><a href="ch02s08.html#idm15955">File Operations</a></span></dt><dt><span class="sect2"><a href="ch02s08.html#idm15977">IOCTLs</a></span></dt></dl></dd><dt><span class="sect1"><a href="ch02s09.html">Legacy Support Code</a></span></dt><dd><dl><dt><span class="sect2"><a href="ch02s09.html#idm16006">Legacy Suspend/Resume</a></span></dt><dt><span class="sect2"><a href="ch02s09.html#idm16013">Legacy DMA Services</a></span></dt></dl></dd></dl></div><p>
      This chapter documents DRM internals relevant to driver authors
      and developers working to add support for the latest features to
      existing drivers.
    </p><p>
      First, we go over some typical driver initialization
      requirements, like setting up command buffers, creating an
      initial output configuration, and initializing core services.
      Subsequent sections cover core internals in more detail,
      providing implementation notes and examples.
    </p><p>
      The DRM layer provides several services to graphics drivers,
      many of them driven by the application interfaces it provides
      through libdrm, the library that wraps most of the DRM ioctls.
      These include vblank event handling, memory
      management, output management, framebuffer management, command
      submission &amp; fencing, suspend/resume support, and DMA
      services.
    </p><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idm59"></a>Driver Initialization</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="drmInternals.html#idm71">Driver Information</a></span></dt><dt><span class="sect2"><a href="drmInternals.html#idm135">Device Registration</a></span></dt><dt><span class="sect2"><a href="drmInternals.html#idm686">Driver Load</a></span></dt></dl></div><p>
      At the core of every DRM driver is a <span class="structname">drm_driver</span>
      structure. Drivers typically statically initialize a drm_driver structure,
      and then pass it to one of the <code class="function">drm_*_init()</code> functions
      to register it with the DRM subsystem.
    </p><p>
      Newer drivers that no longer require a <span class="structname">drm_bus</span>
      structure can alternatively use the low-level device initialization and
      registration functions such as <code class="function">drm_dev_alloc()</code> and
      <code class="function">drm_dev_register()</code> directly.
    </p><p>
      The <span class="structname">drm_driver</span> structure contains static
      information that describes the driver and features it supports, and
      pointers to methods that the DRM core will call to implement the DRM API.
      We will first go through the <span class="structname">drm_driver</span> static
      information fields, and will then describe individual operations in
      details as they get used in later sections.
    </p><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm71"></a>Driver Information</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect3"><a href="drmInternals.html#idm73">Driver Features</a></span></dt><dt><span class="sect3"><a href="drmInternals.html#idm124">Major, Minor and Patchlevel</a></span></dt><dt><span class="sect3"><a href="drmInternals.html#idm129">Name, Description and Date</a></span></dt></dl></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="idm73"></a>Driver Features</h4></div></div></div><p>
          Drivers inform the DRM core about their requirements and supported
          features by setting appropriate flags in the
          <em class="structfield"><code>driver_features</code></em> field. Since those flags
          influence the DRM core behaviour since registration time, most of them
          must be set to registering the <span class="structname">drm_driver</span>
          instance.
        </p><pre class="synopsis">u32 driver_features;</pre><div class="variablelist"><p class="title"><b>Driver Feature Flags</b></p><dl class="variablelist"><dt><span class="term">DRIVER_USE_AGP</span></dt><dd><p>
              Driver uses AGP interface, the DRM core will manage AGP resources.
            </p></dd><dt><span class="term">DRIVER_REQUIRE_AGP</span></dt><dd><p>
              Driver needs AGP interface to function. AGP initialization failure
              will become a fatal error.
            </p></dd><dt><span class="term">DRIVER_PCI_DMA</span></dt><dd><p>
              Driver is capable of PCI DMA, mapping of PCI DMA buffers to
              userspace will be enabled. Deprecated.
            </p></dd><dt><span class="term">DRIVER_SG</span></dt><dd><p>
              Driver can perform scatter/gather DMA, allocation and mapping of
              scatter/gather buffers will be enabled. Deprecated.
            </p></dd><dt><span class="term">DRIVER_HAVE_DMA</span></dt><dd><p>
              Driver supports DMA, the userspace DMA API will be supported.
              Deprecated.
            </p></dd><dt><span class="term">DRIVER_HAVE_IRQ, </span><span class="term">DRIVER_IRQ_SHARED</span></dt><dd><p>
              DRIVER_HAVE_IRQ indicates whether the driver has an IRQ handler
              managed by the DRM Core. The core will support simple IRQ handler
              installation when the flag is set. The installation process is
              described in <a class="xref" href="drmInternals.html#drm-irq-registration" title="IRQ Registration">the section called “IRQ Registration”</a>.</p><p>DRIVER_IRQ_SHARED indicates whether the device &amp; handler
              support shared IRQs (note that this is required of PCI  drivers).
            </p></dd><dt><span class="term">DRIVER_GEM</span></dt><dd><p>
              Driver use the GEM memory manager.
            </p></dd><dt><span class="term">DRIVER_MODESET</span></dt><dd><p>
              Driver supports mode setting interfaces (KMS).
            </p></dd><dt><span class="term">DRIVER_PRIME</span></dt><dd><p>
              Driver implements DRM PRIME buffer sharing.
            </p></dd><dt><span class="term">DRIVER_RENDER</span></dt><dd><p>
              Driver supports dedicated render nodes.
            </p></dd></dl></div></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="idm124"></a>Major, Minor and Patchlevel</h4></div></div></div><pre class="synopsis">int major;
int minor;
int patchlevel;</pre><p>
          The DRM core identifies driver versions by a major, minor and patch
          level triplet. The information is printed to the kernel log at
          initialization time and passed to userspace through the
          DRM_IOCTL_VERSION ioctl.
        </p><p>
          The major and minor numbers are also used to verify the requested driver
          API version passed to DRM_IOCTL_SET_VERSION. When the driver API changes
          between minor versions, applications can call DRM_IOCTL_SET_VERSION to
          select a specific version of the API. If the requested major isn't equal
          to the driver major, or the requested minor is larger than the driver
          minor, the DRM_IOCTL_SET_VERSION call will return an error. Otherwise
          the driver's set_version() method will be called with the requested
          version.
        </p></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="idm129"></a>Name, Description and Date</h4></div></div></div><pre class="synopsis">char *name;
char *desc;
char *date;</pre><p>
          The driver name is printed to the kernel log at initialization time,
          used for IRQ registration and passed to userspace through
          DRM_IOCTL_VERSION.
        </p><p>
          The driver description is a purely informative string passed to
          userspace through the DRM_IOCTL_VERSION ioctl and otherwise unused by
          the kernel.
        </p><p>
          The driver date, formatted as YYYYMMDD, is meant to identify the date of
          the latest modification to the driver. However, as most drivers fail to
          update it, its value is mostly useless. The DRM core prints it to the
          kernel log at initialization time and passes it to userspace through the
          DRM_IOCTL_VERSION ioctl.
        </p></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm135"></a>Device Registration</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="refentrytitle"><a href="API-drm-pci-alloc.html"><span class="phrase">drm_pci_alloc</span></a></span><span class="refpurpose"> — 
  Allocate a PCI consistent memory block, for DMA.
 </span></dt><dt><span class="refentrytitle"><a href="API-drm-pci-free.html"><span class="phrase">drm_pci_free</span></a></span><span class="refpurpose"> — 
     Free a PCI consistent memory block
 </span></dt><dt><span class="refentrytitle"><a href="API-drm-get-pci-dev.html"><span class="phrase">drm_get_pci_dev</span></a></span><span class="refpurpose"> — 
     Register a PCI device with the DRM subsystem
 </span></dt><dt><span class="refentrytitle"><a href="API-drm-pci-init.html"><span class="phrase">drm_pci_init</span></a></span><span class="refpurpose"> — 
     Register matching PCI devices with the DRM subsystem
 </span></dt><dt><span class="refentrytitle"><a href="API-drm-pci-exit.html"><span class="phrase">drm_pci_exit</span></a></span><span class="refpurpose"> — 
     Unregister matching PCI devices from the DRM subsystem
 </span></dt><dt><span class="refentrytitle"><a href="API-drm-platform-init.html"><span class="phrase">drm_platform_init</span></a></span><span class="refpurpose"> — 
  Register a platform device with the DRM subsystem
 </span></dt><dt><span class="refentrytitle"><a href="API-drm-put-dev.html"><span class="phrase">drm_put_dev</span></a></span><span class="refpurpose"> — 
  Unregister and release a DRM device
 </span></dt><dt><span class="refentrytitle"><a href="API-drm-dev-alloc.html"><span class="phrase">drm_dev_alloc</span></a></span><span class="refpurpose"> — 
     Allocate new DRM device
 </span></dt><dt><span class="refentrytitle"><a href="API-drm-dev-ref.html"><span class="phrase">drm_dev_ref</span></a></span><span class="refpurpose"> — 
     Take reference of a DRM device
 </span></dt><dt><span class="refentrytitle"><a href="API-drm-dev-unref.html"><span class="phrase">drm_dev_unref</span></a></span><span class="refpurpose"> — 
     Drop reference of a DRM device
 </span></dt><dt><span class="refentrytitle"><a href="API-drm-dev-register.html"><span class="phrase">drm_dev_register</span></a></span><span class="refpurpose"> — 
     Register DRM device
 </span></dt><dt><span class="refentrytitle"><a href="API-drm-dev-unregister.html"><span class="phrase">drm_dev_unregister</span></a></span><span class="refpurpose"> — 
     Unregister DRM device
 </span></dt><dt><span class="refentrytitle"><a href="API-drm-dev-set-unique.html"><span class="phrase">drm_dev_set_unique</span></a></span><span class="refpurpose"> — 
     Set the unique name of a DRM device
 </span></dt></dl></div><p>
        A number of functions are provided to help with device registration.
        The functions deal with PCI and platform devices, respectively.
      </p><p>
        New drivers that no longer rely on the services provided by the
        <span class="structname">drm_bus</span> structure can call the low-level
        device registration functions directly. The
        <code class="function">drm_dev_alloc()</code> function can be used to allocate
        and initialize a new <span class="structname">drm_device</span> structure.
        Drivers will typically want to perform some additional setup on this
        structure, such as allocating driver-specific data and storing a
        pointer to it in the DRM device's <em class="structfield"><code>dev_private</code></em>
        field. Drivers should also set the device's unique name using the
        <code class="function">drm_dev_set_unique()</code> function. After it has been
        set up a device can be registered with the DRM subsystem by calling
        <code class="function">drm_dev_register()</code>. This will cause the device to
        be exposed to userspace and will call the driver's
        <em class="structfield"><code>.load()</code></em> implementation. When a device is
        removed, the DRM device can safely be unregistered and freed by calling
        <code class="function">drm_dev_unregister()</code> followed by a call to
        <code class="function">drm_dev_unref()</code>.
      </p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm686"></a>Driver Load</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect3"><a href="drmInternals.html#idm703">Driver Private Data</a></span></dt><dt><span class="sect3"><a href="drmInternals.html#drm-irq-registration">IRQ Registration</a></span></dt><dt><span class="sect3"><a href="drmInternals.html#idm740">Memory Manager Initialization</a></span></dt><dt><span class="sect3"><a href="drmInternals.html#idm744">Miscellaneous Device Configuration</a></span></dt></dl></div><p>
        The <code class="methodname">load</code> method is the driver and device
        initialization entry point. The method is responsible for allocating and
	initializing driver private data, performing resource allocation and
	mapping (e.g. acquiring
        clocks, mapping registers or allocating command buffers), initializing
        the memory manager (<a class="xref" href="drm-memory-management.html" title="Memory management">the section called “Memory management”</a>), installing
        the IRQ handler (<a class="xref" href="drmInternals.html#drm-irq-registration" title="IRQ Registration">the section called “IRQ Registration”</a>), setting up
        vertical blanking handling (<a class="xref" href="drm-vertical-blank.html" title="Vertical Blanking">the section called “Vertical Blanking”</a>), mode
	setting (<a class="xref" href="drm-mode-setting.html" title="Mode Setting">the section called “Mode Setting”</a>) and initial output
	configuration (<a class="xref" href="drm-kms-init.html" title="KMS Initialization and Cleanup">the section called “KMS Initialization and Cleanup”</a>).
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
        If compatibility is a concern (e.g. with drivers converted over from
        User Mode Setting to Kernel Mode Setting), care must be taken to prevent
        device initialization and control that is incompatible with currently
        active userspace drivers. For instance, if user level mode setting
        drivers are in use, it would be problematic to perform output discovery
        &amp; configuration at load time. Likewise, if user-level drivers
        unaware of memory management are in use, memory management and command
        buffer setup may need to be omitted. These requirements are
        driver-specific, and care needs to be taken to keep both old and new
        applications and libraries working.
      </p></div><pre class="synopsis">int (*load) (struct drm_device *, unsigned long flags);</pre><p>
        The method takes two arguments, a pointer to the newly created
	<span class="structname">drm_device</span> and flags. The flags are used to
	pass the <em class="structfield"><code>driver_data</code></em> field of the device id
	corresponding to the device passed to <code class="function">drm_*_init()</code>.
	Only PCI devices currently use this, USB and platform DRM drivers have
	their <code class="methodname">load</code> method called with flags to 0.
      </p><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="idm703"></a>Driver Private Data</h4></div></div></div><p>
          The driver private hangs off the main
          <span class="structname">drm_device</span> structure and can be used for
          tracking various device-specific bits of information, like register
          offsets, command buffer status, register state for suspend/resume, etc.
          At load time, a driver may simply allocate one and set
          <span class="structname">drm_device</span>.<em class="structfield"><code>dev_priv</code></em>
          appropriately; it should be freed and
          <span class="structname">drm_device</span>.<em class="structfield"><code>dev_priv</code></em>
          set to NULL when the driver is unloaded.
        </p></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="drm-irq-registration"></a>IRQ Registration</h4></div></div></div><p>
          The DRM core tries to facilitate IRQ handler registration and
          unregistration by providing <code class="function">drm_irq_install</code> and
          <code class="function">drm_irq_uninstall</code> functions. Those functions only
          support a single interrupt per device, devices that use more than one
          IRQs need to be handled manually.
        </p><div class="sect4"><div class="titlepage"><div><div><h5 class="title"><a name="idm716"></a>Managed IRQ Registration</h5></div></div></div><p>
            <code class="function">drm_irq_install</code> starts by calling the
            <code class="methodname">irq_preinstall</code> driver operation. The operation
            is optional and must make sure that the interrupt will not get fired by
            clearing all pending interrupt flags or disabling the interrupt.
          </p><p>
            The passed-in IRQ will then be requested by a call to
            <code class="function">request_irq</code>. If the DRIVER_IRQ_SHARED driver
            feature flag is set, a shared (IRQF_SHARED) IRQ handler will be
            requested.
          </p><p>
            The IRQ handler function must be provided as the mandatory irq_handler
            driver operation. It will get passed directly to
            <code class="function">request_irq</code> and thus has the same prototype as all
            IRQ handlers. It will get called with a pointer to the DRM device as the
            second argument.
          </p><p>
            Finally the function calls the optional
            <code class="methodname">irq_postinstall</code> driver operation. The operation
            usually enables interrupts (excluding the vblank interrupt, which is
            enabled separately), but drivers may choose to enable/disable interrupts
            at a different time.
          </p><p>
            <code class="function">drm_irq_uninstall</code> is similarly used to uninstall an
            IRQ handler. It starts by waking up all processes waiting on a vblank
            interrupt to make sure they don't hang, and then calls the optional
            <code class="methodname">irq_uninstall</code> driver operation. The operation
            must disable all hardware interrupts. Finally the function frees the IRQ
            by calling <code class="function">free_irq</code>.
          </p></div><div class="sect4"><div class="titlepage"><div><div><h5 class="title"><a name="idm731"></a>Manual IRQ Registration</h5></div></div></div><p>
            Drivers that require multiple interrupt handlers can't use the managed
            IRQ registration functions. In that case IRQs must be registered and
            unregistered manually (usually with the <code class="function">request_irq</code>
            and <code class="function">free_irq</code> functions, or their devm_* equivalent).
          </p><p>
            When manually registering IRQs, drivers must not set the DRIVER_HAVE_IRQ
            driver feature flag, and must not provide the
	    <code class="methodname">irq_handler</code> driver operation. They must set the
	    <span class="structname">drm_device</span> <em class="structfield"><code>irq_enabled</code></em>
	    field to 1 upon registration of the IRQs, and clear it to 0 after
	    unregistering the IRQs.
          </p></div></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="idm740"></a>Memory Manager Initialization</h4></div></div></div><p>
          Every DRM driver requires a memory manager which must be initialized at
          load time. DRM currently contains two memory managers, the Translation
          Table Manager (TTM) and the Graphics Execution Manager (GEM).
          This document describes the use of the GEM memory manager only. See
          <a class="xref" href="drm-memory-management.html" title="Memory management">the section called “Memory management”</a> for details.
        </p></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="idm744"></a>Miscellaneous Device Configuration</h4></div></div></div><p>
          Another task that may be necessary for PCI devices during configuration
          is mapping the video BIOS. On many devices, the VBIOS describes device
          configuration, LCD panel timings (if any), and contains flags indicating
          device state. Mapping the BIOS can be done using the pci_map_rom() call,
          a convenience function that takes care of mapping the actual ROM,
          whether it has been shadowed into memory (typically at address 0xc0000)
          or exists on the PCI device in the ROM BAR. Note that after the ROM has
          been mapped and any necessary information has been extracted, it should
          be unmapped; on many devices, the ROM address decoder is shared with
          other BARs, so leaving it mapped could cause undesired behaviour like
          hangs or memory corruption.
  
        </p></div></div></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="drmIntroduction.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="drmCore.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="API-drm-pci-alloc.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Chapter 1. Introduction </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> <span class="phrase">drm_pci_alloc</span></td></tr></table></div></body></html>
