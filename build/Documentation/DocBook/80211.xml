<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE set PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN"
	"http://www.oasis-open.org/docbook/xml/4.1.2/docbookx.dtd" []>
<set>
  <setinfo>
    <title>The 802.11 subsystems &ndash; for kernel developers</title>
    <subtitle>
      Explaining wireless 802.11 networking in the Linux kernel
    </subtitle>

    <copyright>
      <year>2007-2009</year>
      <holder>Johannes Berg</holder>
    </copyright>

    <authorgroup>
      <author>
        <firstname>Johannes</firstname>
        <surname>Berg</surname>
        <affiliation>
          <address><email>johannes@sipsolutions.net</email></address>
        </affiliation>
      </author>
    </authorgroup>

    <legalnotice>
      <para>
        This documentation is free software; you can redistribute
        it and/or modify it under the terms of the GNU General Public
        License version 2 as published by the Free Software Foundation.
      </para>
      <para>
        This documentation is distributed in the hope that it will be
        useful, but WITHOUT ANY WARRANTY; without even the implied
        warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
        See the GNU General Public License for more details.
      </para>
      <para>
        You should have received a copy of the GNU General Public
        License along with this documentation; if not, write to the Free
        Software Foundation, Inc., 59 Temple Place, Suite 330, Boston,
        MA 02111-1307 USA
      </para>
      <para>
        For more details see the file COPYING in the source
        distribution of Linux.
      </para>
    </legalnotice>

    <abstract>
      <para>
        These books attempt to give a description of the
        various subsystems that play a role in 802.11 wireless
        networking in Linux. Since these books are for kernel
        developers they attempts to document the structures
        and functions used in the kernel as well as giving a
        higher-level overview.
      </para>
      <para>
	The reader is expected to be familiar with the 802.11
	standard as published by the IEEE in 802.11-2007 (or
	possibly later versions). References to this standard
	will be given as "802.11-2007 8.1.5".
      </para>
    </abstract>
  </setinfo>
  <book id="cfg80211-developers-guide">
    <bookinfo>
      <title>The cfg80211 subsystem</title>

      <abstract>
<para>
   </para><para>
   cfg80211 is the configuration API for 802.11 devices in Linux. It bridges
   userspace and drivers, and offers some utility functionality associated
   with 802.11. cfg80211 must, directly or indirectly via mac80211, be used
   by all modern wireless drivers in Linux, so that they offer a consistent
   API through nl80211. For backward compatibility, cfg80211 also offers
   wireless extensions to userspace, but hides them from drivers completely.
   </para><para>
   Additionally, cfg80211 contains code to help enforce regulatory spectrum
   use restrictions.
</para>

      </abstract>
    </bookinfo>
      <chapter>
      <title>Device registration</title>
<para>
   </para><para>
   In order for a driver to use cfg80211, it must register the hardware device
   with cfg80211. This happens through a number of hardware capability structs
   described below.
   </para><para>
   The fundamental structure for each device is the 'wiphy', of which each
   instance describes a physical wireless device connected to the system. Each
   such wiphy can have zero, one, or many virtual interfaces associated with
   it, which need to be identified as such by pointing the network interface's
   <parameter>ieee80211_ptr</parameter> pointer to a <structname>struct wireless_dev</structname> which further describes
   the wireless part of the interface, normally this struct is embedded in the
   network interface's private data area. Drivers can optionally allow creating
   or destroying virtual interfaces on the fly, but without at least one or the
   ability to create some the wireless device isn't useful.
   </para><para>
   Each wiphy structure contains device capability information, and also has
   a pointer to the various operations the driver offers. The definitions and
   structures here describe these capabilities in detail.
</para>

<refentry id="API-enum-ieee80211-band">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>enum ieee80211_band</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>enum ieee80211_band</refname>
 <refpurpose>
  supported frequency bands
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
enum ieee80211_band {
  IEEE80211_BAND_2GHZ,
  IEEE80211_BAND_5GHZ,
  IEEE80211_BAND_60GHZ,
  IEEE80211_NUM_BANDS
};  </programlisting>
</refsynopsisdiv>
<refsect1>
 <title>Constants</title>
  <variablelist>
    <varlistentry>      <term>IEEE80211_BAND_2GHZ</term>
      <listitem><para>
2.4GHz ISM band
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>IEEE80211_BAND_5GHZ</term>
      <listitem><para>
around 5GHz band (4.9-5.7)
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>IEEE80211_BAND_60GHZ</term>
      <listitem><para>
around 60 GHz band (58.32 - 64.80 GHz)
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>IEEE80211_NUM_BANDS</term>
      <listitem><para>
number of defined bands
      </para></listitem>
    </varlistentry>
  </variablelist>
</refsect1>
<refsect1>
<title>Device registration</title>
<para>
   </para><para>

   The bands are assigned this way because the supported
   bitrates differ in these bands.
</para>
</refsect1>
</refentry>

<refentry id="API-enum-ieee80211-channel-flags">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>enum ieee80211_channel_flags</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>enum ieee80211_channel_flags</refname>
 <refpurpose>
  channel flags
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
enum ieee80211_channel_flags {
  IEEE80211_CHAN_DISABLED,
  IEEE80211_CHAN_NO_IR,
  IEEE80211_CHAN_RADAR,
  IEEE80211_CHAN_NO_HT40PLUS,
  IEEE80211_CHAN_NO_HT40MINUS,
  IEEE80211_CHAN_NO_OFDM,
  IEEE80211_CHAN_NO_80MHZ,
  IEEE80211_CHAN_NO_160MHZ,
  IEEE80211_CHAN_INDOOR_ONLY,
  IEEE80211_CHAN_GO_CONCURRENT,
  IEEE80211_CHAN_NO_20MHZ,
  IEEE80211_CHAN_NO_10MHZ
};  </programlisting>
</refsynopsisdiv>
<refsect1>
 <title>Constants</title>
  <variablelist>
    <varlistentry>      <term>IEEE80211_CHAN_DISABLED</term>
      <listitem><para>
This channel is disabled.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>IEEE80211_CHAN_NO_IR</term>
      <listitem><para>
do not initiate radiation, this includes
sending probe requests or beaconing.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>IEEE80211_CHAN_RADAR</term>
      <listitem><para>
Radar detection is required on this channel.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>IEEE80211_CHAN_NO_HT40PLUS</term>
      <listitem><para>
extension channel above this channel
is not permitted.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>IEEE80211_CHAN_NO_HT40MINUS</term>
      <listitem><para>
extension channel below this channel
is not permitted.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>IEEE80211_CHAN_NO_OFDM</term>
      <listitem><para>
OFDM is not allowed on this channel.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>IEEE80211_CHAN_NO_80MHZ</term>
      <listitem><para>
If the driver supports 80 MHz on the band,
this flag indicates that an 80 MHz channel cannot use this
channel as the control or any of the secondary channels.
This may be due to the driver or due to regulatory bandwidth
restrictions.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>IEEE80211_CHAN_NO_160MHZ</term>
      <listitem><para>
If the driver supports 160 MHz on the band,
this flag indicates that an 160 MHz channel cannot use this
channel as the control or any of the secondary channels.
This may be due to the driver or due to regulatory bandwidth
restrictions.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>IEEE80211_CHAN_INDOOR_ONLY</term>
      <listitem><para>
see <constant>NL80211_FREQUENCY_ATTR_INDOOR_ONLY</constant>
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>IEEE80211_CHAN_GO_CONCURRENT</term>
      <listitem><para>
see <constant>NL80211_FREQUENCY_ATTR_GO_CONCURRENT</constant>
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>IEEE80211_CHAN_NO_20MHZ</term>
      <listitem><para>
20 MHz bandwidth is not permitted
on this channel.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>IEEE80211_CHAN_NO_10MHZ</term>
      <listitem><para>
10 MHz bandwidth is not permitted
on this channel.
      </para></listitem>
    </varlistentry>
  </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   </para><para>

   Channel flags set by the regulatory control code.
</para>
</refsect1>
</refentry>

<refentry id="API-struct-ieee80211-channel">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct ieee80211_channel</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct ieee80211_channel</refname>
 <refpurpose>
  channel definition
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct ieee80211_channel {
  enum ieee80211_band band;
  u16 center_freq;
  u16 hw_value;
  u32 flags;
  int max_antenna_gain;
  int max_power;
  int max_reg_power;
  bool beacon_found;
  u32 orig_flags;
  int orig_mag;
  int orig_mpwr;
  enum nl80211_dfs_state dfs_state;
  unsigned long dfs_state_entered;
  unsigned int dfs_cac_ms;
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>band</term>
      <listitem><para>
band this channel belongs to.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>center_freq</term>
      <listitem><para>
center frequency in MHz
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>hw_value</term>
      <listitem><para>
hardware-specific value for the channel
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>flags</term>
      <listitem><para>
channel flags from <structname>enum</structname> ieee80211_channel_flags.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>max_antenna_gain</term>
      <listitem><para>
maximum antenna gain in dBi
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>max_power</term>
      <listitem><para>
maximum transmission power (in dBm)
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>max_reg_power</term>
      <listitem><para>
maximum regulatory transmission power (in dBm)
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>beacon_found</term>
      <listitem><para>
helper to regulatory code to indicate when a beacon
has been found on this channel. Use <function>regulatory_hint_found_beacon</function>
to enable this, this is useful only on 5 GHz band.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>orig_flags</term>
      <listitem><para>
channel flags at registration time, used by regulatory
code to support devices with additional restrictions
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>orig_mag</term>
      <listitem><para>
internal use
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>orig_mpwr</term>
      <listitem><para>
internal use
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>dfs_state</term>
      <listitem><para>
current state of this channel. Only relevant if radar is required
on this channel.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>dfs_state_entered</term>
      <listitem><para>
timestamp (jiffies) when the dfs state was entered.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>dfs_cac_ms</term>
      <listitem><para>
DFS CAC time in milliseconds, this is valid for DFS channels.
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
<refsect1>
<title>Description</title>
<para>
   </para><para>

   This structure describes a single channel for use
   with cfg80211.
</para>
</refsect1>
</refentry>

<refentry id="API-enum-ieee80211-rate-flags">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>enum ieee80211_rate_flags</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>enum ieee80211_rate_flags</refname>
 <refpurpose>
  rate flags
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
enum ieee80211_rate_flags {
  IEEE80211_RATE_SHORT_PREAMBLE,
  IEEE80211_RATE_MANDATORY_A,
  IEEE80211_RATE_MANDATORY_B,
  IEEE80211_RATE_MANDATORY_G,
  IEEE80211_RATE_ERP_G,
  IEEE80211_RATE_SUPPORTS_5MHZ,
  IEEE80211_RATE_SUPPORTS_10MHZ
};  </programlisting>
</refsynopsisdiv>
<refsect1>
 <title>Constants</title>
  <variablelist>
    <varlistentry>      <term>IEEE80211_RATE_SHORT_PREAMBLE</term>
      <listitem><para>
Hardware can send with short
preamble on this bitrate; only relevant in 2.4GHz band and
with CCK rates.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>IEEE80211_RATE_MANDATORY_A</term>
      <listitem><para>
This bitrate is a mandatory rate
when used with 802.11a (on the 5 GHz band); filled by the
core code when registering the wiphy.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>IEEE80211_RATE_MANDATORY_B</term>
      <listitem><para>
This bitrate is a mandatory rate
when used with 802.11b (on the 2.4 GHz band); filled by the
core code when registering the wiphy.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>IEEE80211_RATE_MANDATORY_G</term>
      <listitem><para>
This bitrate is a mandatory rate
when used with 802.11g (on the 2.4 GHz band); filled by the
core code when registering the wiphy.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>IEEE80211_RATE_ERP_G</term>
      <listitem><para>
This is an ERP rate in 802.11g mode.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>IEEE80211_RATE_SUPPORTS_5MHZ</term>
      <listitem><para>
Rate can be used in 5 MHz mode
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>IEEE80211_RATE_SUPPORTS_10MHZ</term>
      <listitem><para>
Rate can be used in 10 MHz mode
      </para></listitem>
    </varlistentry>
  </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   </para><para>

   Hardware/specification flags for rates. These are structured
   in a way that allows using the same bitrate structure for
   different bands/PHY modes.
</para>
</refsect1>
</refentry>

<refentry id="API-struct-ieee80211-rate">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct ieee80211_rate</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct ieee80211_rate</refname>
 <refpurpose>
  bitrate definition
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct ieee80211_rate {
  u32 flags;
  u16 bitrate;
  u16 hw_value;
  u16 hw_value_short;
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>flags</term>
      <listitem><para>
rate-specific flags
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>bitrate</term>
      <listitem><para>
bitrate in units of 100 Kbps
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>hw_value</term>
      <listitem><para>
driver/hardware value for this rate
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>hw_value_short</term>
      <listitem><para>
driver/hardware value for this rate when
short preamble is used
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
<refsect1>
<title>Description</title>
<para>
   </para><para>

   This structure describes a bitrate that an 802.11 PHY can
   operate with. The two values <parameter>hw_value</parameter> and <parameter>hw_value_short</parameter>
   are only for driver use when pointers to this structure are
   passed around.
</para>
</refsect1>
</refentry>

<refentry id="API-struct-ieee80211-sta-ht-cap">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct ieee80211_sta_ht_cap</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct ieee80211_sta_ht_cap</refname>
 <refpurpose>
  STA's HT capabilities
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct ieee80211_sta_ht_cap {
  u16 cap;
  bool ht_supported;
  u8 ampdu_factor;
  u8 ampdu_density;
  struct ieee80211_mcs_info mcs;
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>cap</term>
      <listitem><para>
HT capabilities map as described in 802.11n spec
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>ht_supported</term>
      <listitem><para>
is HT supported by the STA
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>ampdu_factor</term>
      <listitem><para>
Maximum A-MPDU length factor
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>ampdu_density</term>
      <listitem><para>
Minimum A-MPDU spacing
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>mcs</term>
      <listitem><para>
Supported MCS rates
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
<refsect1>
<title>Description</title>
<para>
   </para><para>

   This structure describes most essential parameters needed
   to describe 802.11n HT capabilities for an STA.
</para>
</refsect1>
</refentry>

<refentry id="API-struct-ieee80211-supported-band">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct ieee80211_supported_band</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct ieee80211_supported_band</refname>
 <refpurpose>
  frequency band definition
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct ieee80211_supported_band {
  struct ieee80211_channel * channels;
  struct ieee80211_rate * bitrates;
  enum ieee80211_band band;
  int n_channels;
  int n_bitrates;
  struct ieee80211_sta_ht_cap ht_cap;
  struct ieee80211_sta_vht_cap vht_cap;
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>channels</term>
      <listitem><para>
Array of channels the hardware can operate in
in this band.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>bitrates</term>
      <listitem><para>
Array of bitrates the hardware can operate with
in this band. Must be sorted to give a valid <quote>supported
rates</quote> IE, i.e. CCK rates first, then OFDM.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>band</term>
      <listitem><para>
the band this structure represents
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>n_channels</term>
      <listitem><para>
Number of channels in <parameter>channels</parameter>
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>n_bitrates</term>
      <listitem><para>
Number of bitrates in <parameter>bitrates</parameter>
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>ht_cap</term>
      <listitem><para>
HT capabilities in this band
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>vht_cap</term>
      <listitem><para>
VHT capabilities in this band
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
<refsect1>
<title>Description</title>
<para>
   </para><para>

   This structure describes a frequency band a wiphy
   is able to operate in.
</para>
</refsect1>
</refentry>

<refentry id="API-enum-cfg80211-signal-type">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>enum cfg80211_signal_type</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>enum cfg80211_signal_type</refname>
 <refpurpose>
  signal type
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
enum cfg80211_signal_type {
  CFG80211_SIGNAL_TYPE_NONE,
  CFG80211_SIGNAL_TYPE_MBM,
  CFG80211_SIGNAL_TYPE_UNSPEC
};  </programlisting>
</refsynopsisdiv>
<refsect1>
 <title>Constants</title>
  <variablelist>
    <varlistentry>      <term>CFG80211_SIGNAL_TYPE_NONE</term>
      <listitem><para>
no signal strength information available
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>CFG80211_SIGNAL_TYPE_MBM</term>
      <listitem><para>
signal strength in mBm (100*dBm)
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>CFG80211_SIGNAL_TYPE_UNSPEC</term>
      <listitem><para>
signal strength, increasing from 0 through 100
      </para></listitem>
    </varlistentry>
  </variablelist>
</refsect1>
</refentry>

<refentry id="API-enum-wiphy-params-flags">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>enum wiphy_params_flags</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>enum wiphy_params_flags</refname>
 <refpurpose>
  set_wiphy_params bitfield values
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
enum wiphy_params_flags {
  WIPHY_PARAM_RETRY_SHORT,
  WIPHY_PARAM_RETRY_LONG,
  WIPHY_PARAM_FRAG_THRESHOLD,
  WIPHY_PARAM_RTS_THRESHOLD,
  WIPHY_PARAM_COVERAGE_CLASS,
  WIPHY_PARAM_DYN_ACK
};  </programlisting>
</refsynopsisdiv>
<refsect1>
 <title>Constants</title>
  <variablelist>
    <varlistentry>      <term>WIPHY_PARAM_RETRY_SHORT</term>
      <listitem><para>
wiphy-&gt;retry_short has changed
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>WIPHY_PARAM_RETRY_LONG</term>
      <listitem><para>
wiphy-&gt;retry_long has changed
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>WIPHY_PARAM_FRAG_THRESHOLD</term>
      <listitem><para>
wiphy-&gt;frag_threshold has changed
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>WIPHY_PARAM_RTS_THRESHOLD</term>
      <listitem><para>
wiphy-&gt;rts_threshold has changed
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>WIPHY_PARAM_COVERAGE_CLASS</term>
      <listitem><para>
coverage class changed
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>WIPHY_PARAM_DYN_ACK</term>
      <listitem><para>
dynack has been enabled
      </para></listitem>
    </varlistentry>
  </variablelist>
</refsect1>
</refentry>

<refentry id="API-enum-wiphy-flags">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>enum wiphy_flags</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>enum wiphy_flags</refname>
 <refpurpose>
  wiphy capability flags
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
enum wiphy_flags {
  WIPHY_FLAG_SUPPORTS_WMM_ADMISSION,
  WIPHY_FLAG_NETNS_OK,
  WIPHY_FLAG_PS_ON_BY_DEFAULT,
  WIPHY_FLAG_4ADDR_AP,
  WIPHY_FLAG_4ADDR_STATION,
  WIPHY_FLAG_CONTROL_PORT_PROTOCOL,
  WIPHY_FLAG_IBSS_RSN,
  WIPHY_FLAG_MESH_AUTH,
  WIPHY_FLAG_SUPPORTS_SCHED_SCAN,
  WIPHY_FLAG_SUPPORTS_FW_ROAM,
  WIPHY_FLAG_AP_UAPSD,
  WIPHY_FLAG_SUPPORTS_TDLS,
  WIPHY_FLAG_TDLS_EXTERNAL_SETUP,
  WIPHY_FLAG_HAVE_AP_SME,
  WIPHY_FLAG_REPORTS_OBSS,
  WIPHY_FLAG_AP_PROBE_RESP_OFFLOAD,
  WIPHY_FLAG_OFFCHAN_TX,
  WIPHY_FLAG_HAS_REMAIN_ON_CHANNEL,
  WIPHY_FLAG_SUPPORTS_5_10_MHZ,
  WIPHY_FLAG_HAS_CHANNEL_SWITCH
};  </programlisting>
</refsynopsisdiv>
<refsect1>
 <title>Constants</title>
  <variablelist>
    <varlistentry>      <term>WIPHY_FLAG_SUPPORTS_WMM_ADMISSION</term>
      <listitem><para>
the device supports setting up WMM
TSPEC sessions (TID aka TSID 0-7) with the NL80211_CMD_ADD_TX_TS
command. Standard IEEE 802.11 TSPEC setup is not yet supported, it
needs to be able to handle Block-Ack agreements and other things.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>WIPHY_FLAG_NETNS_OK</term>
      <listitem><para>
if not set, do not allow changing the netns of this
wiphy at all
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>WIPHY_FLAG_PS_ON_BY_DEFAULT</term>
      <listitem><para>
if set to true, powersave will be enabled
by default -- this flag will be set depending on the kernel's default
on <function>wiphy_new</function>, but can be changed by the driver if it has a good
reason to override the default
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>WIPHY_FLAG_4ADDR_AP</term>
      <listitem><para>
supports 4addr mode even on AP (with a single station
on a VLAN interface)
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>WIPHY_FLAG_4ADDR_STATION</term>
      <listitem><para>
supports 4addr mode even as a station
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>WIPHY_FLAG_CONTROL_PORT_PROTOCOL</term>
      <listitem><para>
This device supports setting the
control port protocol ethertype. The device also honours the
control_port_no_encrypt flag.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>WIPHY_FLAG_IBSS_RSN</term>
      <listitem><para>
The device supports IBSS RSN.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>WIPHY_FLAG_MESH_AUTH</term>
      <listitem><para>
The device supports mesh authentication by routing
auth frames to userspace. See <parameter>NL80211_MESH_SETUP_USERSPACE_AUTH</parameter>.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>WIPHY_FLAG_SUPPORTS_SCHED_SCAN</term>
      <listitem><para>
The device supports scheduled scans.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>WIPHY_FLAG_SUPPORTS_FW_ROAM</term>
      <listitem><para>
The device supports roaming feature in the
firmware.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>WIPHY_FLAG_AP_UAPSD</term>
      <listitem><para>
The device supports uapsd on AP.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>WIPHY_FLAG_SUPPORTS_TDLS</term>
      <listitem><para>
The device supports TDLS (802.11z) operation.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>WIPHY_FLAG_TDLS_EXTERNAL_SETUP</term>
      <listitem><para>
The device does not handle TDLS (802.11z)
link setup/discovery operations internally. Setup, discovery and
teardown packets should be sent through the <parameter>NL80211_CMD_TDLS_MGMT</parameter>
command. When this flag is not set, <parameter>NL80211_CMD_TDLS_OPER</parameter> should be
used for asking the driver/firmware to perform a TDLS operation.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>WIPHY_FLAG_HAVE_AP_SME</term>
      <listitem><para>
device integrates AP SME
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>WIPHY_FLAG_REPORTS_OBSS</term>
      <listitem><para>
the device will report beacons from other BSSes
when there are virtual interfaces in AP mode by calling
<function>cfg80211_report_obss_beacon</function>.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>WIPHY_FLAG_AP_PROBE_RESP_OFFLOAD</term>
      <listitem><para>
When operating as an AP, the device
responds to probe-requests in hardware.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>WIPHY_FLAG_OFFCHAN_TX</term>
      <listitem><para>
Device supports direct off-channel TX.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>WIPHY_FLAG_HAS_REMAIN_ON_CHANNEL</term>
      <listitem><para>
Device supports remain-on-channel call.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>WIPHY_FLAG_SUPPORTS_5_10_MHZ</term>
      <listitem><para>
Device supports 5 MHz and 10 MHz channels.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>WIPHY_FLAG_HAS_CHANNEL_SWITCH</term>
      <listitem><para>
Device supports channel switch in
beaconing mode (AP, IBSS, Mesh, ...).
      </para></listitem>
    </varlistentry>
  </variablelist>
</refsect1>
</refentry>

<refentry id="API-struct-wiphy">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct wiphy</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct wiphy</refname>
 <refpurpose>
  wireless hardware description
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct wiphy {
  u8 perm_addr[ETH_ALEN];
  u8 addr_mask[ETH_ALEN];
  struct mac_address * addresses;
  const struct ieee80211_txrx_stypes * mgmt_stypes;
  const struct ieee80211_iface_combination * iface_combinations;
  int n_iface_combinations;
  u16 software_iftypes;
  u16 n_addresses;
  u16 interface_modes;
  u16 max_acl_mac_addrs;
  u32 flags;
  u32 regulatory_flags;
  u32 features;
  u32 ap_sme_capa;
  enum cfg80211_signal_type signal_type;
  int bss_priv_size;
  u8 max_scan_ssids;
  u8 max_sched_scan_ssids;
  u8 max_match_sets;
  u16 max_scan_ie_len;
  u16 max_sched_scan_ie_len;
  int n_cipher_suites;
  const u32 * cipher_suites;
  u8 retry_short;
  u8 retry_long;
  u32 frag_threshold;
  u32 rts_threshold;
  u8 coverage_class;
  char fw_version[ETHTOOL_FWVERS_LEN];
  u32 hw_version;
#ifdef CONFIG_PM
  const struct wiphy_wowlan_support * wowlan;
  struct cfg80211_wowlan * wowlan_config;
#endif
  u16 max_remain_on_channel_duration;
  u8 max_num_pmkids;
  u32 available_antennas_tx;
  u32 available_antennas_rx;
  u32 probe_resp_offload;
  const u8 * extended_capabilities;
  const u8 * extended_capabilities_mask;
  u8 extended_capabilities_len;
  const void * privid;
  struct ieee80211_supported_band * bands[IEEE80211_NUM_BANDS];
  void (* reg_notifier) (struct wiphy *wiphy,struct regulatory_request *request);
  const struct ieee80211_regdomain __rcu * regd;
  struct device dev;
  bool registered;
  struct dentry * debugfsdir;
  const struct ieee80211_ht_cap * ht_capa_mod_mask;
  const struct ieee80211_vht_cap * vht_capa_mod_mask;
#ifdef CONFIG_NET_NS
  struct net * _net;
#endif
#ifdef CONFIG_CFG80211_WEXT
  const struct iw_handler_def * wext;
#endif
  const struct wiphy_coalesce_support * coalesce;
  const struct wiphy_vendor_command * vendor_commands;
  const struct nl80211_vendor_cmd_info * vendor_events;
  int n_vendor_commands;
  int n_vendor_events;
  u16 max_ap_assoc_sta;
  u8 max_num_csa_counters;
  u8 max_adj_channel_rssi_comp;
  char priv[0];
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>perm_addr[ETH_ALEN]</term>
      <listitem><para>
permanent MAC address of this device
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>addr_mask[ETH_ALEN]</term>
      <listitem><para>
If the device supports multiple MAC addresses by masking,
set this to a mask with variable bits set to 1, e.g. if the last
four bits are variable then set it to 00-00-00-00-00-0f. The actual
variable bits shall be determined by the interfaces added, with
interfaces not matching the mask being rejected to be brought up.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>addresses</term>
      <listitem><para>
If the device has more than one address, set this pointer
to a list of addresses (6 bytes each). The first one will be used
by default for perm_addr. In this case, the mask should be set to
all-zeroes. In this case it is assumed that the device can handle
the same number of arbitrary MAC addresses.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>mgmt_stypes</term>
      <listitem><para>
bitmasks of frame subtypes that can be subscribed to or
transmitted through nl80211, points to an array indexed by interface
type
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>iface_combinations</term>
      <listitem><para>
Valid interface combinations array, should not
list single interface types.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>n_iface_combinations</term>
      <listitem><para>
number of entries in <parameter>iface_combinations</parameter> array.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>software_iftypes</term>
      <listitem><para>
bitmask of software interface types, these are not
subject to any restrictions since they are purely managed in SW.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>n_addresses</term>
      <listitem><para>
number of addresses in <parameter>addresses</parameter>.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>interface_modes</term>
      <listitem><para>
bitmask of interfaces types valid for this wiphy,
must be set by driver
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>max_acl_mac_addrs</term>
      <listitem><para>
Maximum number of MAC addresses that the device
supports for ACL.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>flags</term>
      <listitem><para>
wiphy flags, see <structname>enum</structname> wiphy_flags
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>regulatory_flags</term>
      <listitem><para>
wiphy regulatory flags, see
<structname>enum</structname> ieee80211_regulatory_flags
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>features</term>
      <listitem><para>
features advertised to nl80211, see <structname>enum</structname> nl80211_feature_flags.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>ap_sme_capa</term>
      <listitem><para>
AP SME capabilities, flags from <structname>enum</structname> nl80211_ap_sme_features.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>signal_type</term>
      <listitem><para>
signal type reported in <structname>struct cfg80211_bss</structname>.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>bss_priv_size</term>
      <listitem><para>
each BSS struct has private data allocated with it,
this variable determines its size
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>max_scan_ssids</term>
      <listitem><para>
maximum number of SSIDs the device can scan for in
any given scan
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>max_sched_scan_ssids</term>
      <listitem><para>
maximum number of SSIDs the device can scan
for in any given scheduled scan
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>max_match_sets</term>
      <listitem><para>
maximum number of match sets the device can handle
when performing a scheduled scan, 0 if filtering is not
supported.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>max_scan_ie_len</term>
      <listitem><para>
maximum length of user-controlled IEs device can
add to probe request frames transmitted during a scan, must not
include fixed IEs like supported rates
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>max_sched_scan_ie_len</term>
      <listitem><para>
same as max_scan_ie_len, but for scheduled
scans
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>n_cipher_suites</term>
      <listitem><para>
number of supported cipher suites
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>cipher_suites</term>
      <listitem><para>
supported cipher suites
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>retry_short</term>
      <listitem><para>
Retry limit for short frames (dot11ShortRetryLimit)
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>retry_long</term>
      <listitem><para>
Retry limit for long frames (dot11LongRetryLimit)
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>frag_threshold</term>
      <listitem><para>
Fragmentation threshold (dot11FragmentationThreshold);
-1 = fragmentation disabled, only odd values &gt;= 256 used
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>rts_threshold</term>
      <listitem><para>
RTS threshold (dot11RTSThreshold); -1 = RTS/CTS disabled
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>coverage_class</term>
      <listitem><para>
current coverage class
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>fw_version[ETHTOOL_FWVERS_LEN]</term>
      <listitem><para>
firmware version for ethtool reporting
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>hw_version</term>
      <listitem><para>
hardware version for ethtool reporting
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>wowlan</term>
      <listitem><para>
WoWLAN support information
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>wowlan_config</term>
      <listitem><para>
current WoWLAN configuration; this should usually not be
used since access to it is necessarily racy, use the parameter passed
to the <function>suspend</function> operation instead.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>max_remain_on_channel_duration</term>
      <listitem><para>
Maximum time a remain-on-channel operation
may request, if implemented.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>max_num_pmkids</term>
      <listitem><para>
maximum number of PMKIDs supported by device
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>available_antennas_tx</term>
      <listitem><para>
bitmap of antennas which are available to be
configured as TX antennas. Antenna configuration commands will be
rejected unless this or <parameter>available_antennas_rx</parameter> is set.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>available_antennas_rx</term>
      <listitem><para>
bitmap of antennas which are available to be
configured as RX antennas. Antenna configuration commands will be
rejected unless this or <parameter>available_antennas_tx</parameter> is set.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>probe_resp_offload</term>
      <listitem><para>
Bitmap of supported protocols for probe response offloading.
See <structname>enum</structname> nl80211_probe_resp_offload_support_attr. Only valid
when the wiphy flag <parameter>WIPHY_FLAG_AP_PROBE_RESP_OFFLOAD</parameter> is set.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>extended_capabilities</term>
      <listitem><para>
extended capabilities supported by the driver,
additional capabilities might be supported by userspace; these are
the 802.11 extended capabilities (<quote>Extended Capabilities element</quote>)
and are in the same format as in the information element. See
802.11-2012 8.4.2.29 for the defined fields.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>extended_capabilities_mask</term>
      <listitem><para>
mask of the valid values
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>extended_capabilities_len</term>
      <listitem><para>
length of the extended capabilities
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>privid</term>
      <listitem><para>
a pointer that drivers can use to identify if an arbitrary
wiphy is theirs, e.g. in global notifiers
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>bands[IEEE80211_NUM_BANDS]</term>
      <listitem><para>
information about bands/channels supported by this device
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>reg_notifier</term>
      <listitem><para>
the driver's regulatory notification callback,
note that if your driver uses <function>wiphy_apply_custom_regulatory</function>
the reg_notifier's request can be passed as NULL
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>regd</term>
      <listitem><para>
the driver's regulatory domain, if one was requested via
the <function>regulatory_hint</function> API. This can be used by the driver
on the <function>reg_notifier</function> if it chooses to ignore future
regulatory domain changes caused by other drivers.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>dev</term>
      <listitem><para>
(virtual) struct device for this wiphy
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>registered</term>
      <listitem><para>
helps synchronize suspend/resume with wiphy unregister
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>debugfsdir</term>
      <listitem><para>
debugfs directory used for this wiphy, will be renamed
automatically on wiphy renames
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>ht_capa_mod_mask</term>
      <listitem><para>
Specify what ht_cap values can be over-ridden.
If null, then none can be over-ridden.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>vht_capa_mod_mask</term>
      <listitem><para>
Specify what VHT capabilities can be over-ridden.
If null, then none can be over-ridden.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>_net</term>
      <listitem><para>
the network namespace this wiphy currently lives in
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>wext</term>
      <listitem><para>
wireless extension handlers
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>coalesce</term>
      <listitem><para>
packet coalescing support information
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>vendor_commands</term>
      <listitem><para>
array of vendor commands supported by the hardware
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>vendor_events</term>
      <listitem><para>
array of vendor events supported by the hardware
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>n_vendor_commands</term>
      <listitem><para>
number of vendor commands
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>n_vendor_events</term>
      <listitem><para>
number of vendor events
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>max_ap_assoc_sta</term>
      <listitem><para>
maximum number of associated stations supported in AP mode
(including P2P GO) or 0 to indicate no such limit is advertised. The
driver is allowed to advertise a theoretical limit that it can reach in
some cases, but may not always reach.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>max_num_csa_counters</term>
      <listitem><para>
Number of supported csa_counters in beacons
and probe responses.  This value should be set if the driver
wishes to limit the number of csa counters. Default (0) means
infinite.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>max_adj_channel_rssi_comp</term>
      <listitem><para>
max offset of between the channel on which the
frame was sent and the channel on which the frame was heard for which
the reported rssi is still valid. If a driver is able to compensate the
low rssi when a frame is heard on different channel, then it should set
this variable to the maximal offset for which it can compensate.
This value should be set in MHz.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>priv[0]</term>
      <listitem><para>
driver private data (sized according to <function>wiphy_new</function> parameter)
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
</refentry>

<refentry id="API-struct-wireless-dev">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct wireless_dev</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct wireless_dev</refname>
 <refpurpose>
  wireless device state
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct wireless_dev {
  struct wiphy * wiphy;
  enum nl80211_iftype iftype;
  struct list_head list;
  struct net_device * netdev;
  u32 identifier;
  struct list_head mgmt_registrations;
  spinlock_t mgmt_registrations_lock;
  struct mutex mtx;
  bool use_4addr;
  bool p2p_started;
  u8 address[ETH_ALEN];
  u8 ssid[IEEE80211_MAX_SSID_LEN];
  u8 ssid_len;
  u8 mesh_id_len;
  u8 mesh_id_up_len;
  struct cfg80211_conn * conn;
  struct cfg80211_cached_keys * connect_keys;
  struct list_head event_list;
  spinlock_t event_lock;
  struct cfg80211_internal_bss * current_bss;
  struct cfg80211_chan_def preset_chandef;
  struct cfg80211_chan_def chandef;
  bool ibss_fixed;
  bool ibss_dfs_possible;
  bool ps;
  int ps_timeout;
  int beacon_interval;
  u32 ap_unexpected_nlportid;
  bool cac_started;
  unsigned long cac_start_time;
  unsigned int cac_time_ms;
  u32 owner_nlportid;
#ifdef CONFIG_CFG80211_WEXT
  struct wext;
#endif
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>wiphy</term>
      <listitem><para>
pointer to hardware description
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>iftype</term>
      <listitem><para>
interface type
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>list</term>
      <listitem><para>
(private) Used to collect the interfaces
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>netdev</term>
      <listitem><para>
(private) Used to reference back to the netdev, may be <constant>NULL</constant>
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>identifier</term>
      <listitem><para>
(private) Identifier used in nl80211 to identify this
wireless device if it has no netdev
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>mgmt_registrations</term>
      <listitem><para>
list of registrations for management frames
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>mgmt_registrations_lock</term>
      <listitem><para>
lock for the list
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>mtx</term>
      <listitem><para>
mutex used to lock data in this struct, may be used by drivers
and some API functions require it held
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>use_4addr</term>
      <listitem><para>
indicates 4addr mode is used on this interface, must be
set by driver (if supported) on add_interface BEFORE registering the
netdev and may otherwise be used by driver read-only, will be update
by cfg80211 on change_interface
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>p2p_started</term>
      <listitem><para>
true if this is a P2P Device that has been started
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>address[ETH_ALEN]</term>
      <listitem><para>
The address for this device, valid only if <parameter>netdev</parameter> is <constant>NULL</constant>
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>ssid[IEEE80211_MAX_SSID_LEN]</term>
      <listitem><para>
(private) Used by the internal configuration code
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>ssid_len</term>
      <listitem><para>
(private) Used by the internal configuration code
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>mesh_id_len</term>
      <listitem><para>
(private) Used by the internal configuration code
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>mesh_id_up_len</term>
      <listitem><para>
(private) Used by the internal configuration code
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>conn</term>
      <listitem><para>
(private) cfg80211 software SME connection state machine data
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>connect_keys</term>
      <listitem><para>
(private) keys to set after connection is established
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>event_list</term>
      <listitem><para>
(private) list for internal event processing
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>event_lock</term>
      <listitem><para>
(private) lock for event list
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>current_bss</term>
      <listitem><para>
(private) Used by the internal configuration code
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>preset_chandef</term>
      <listitem><para>
(private) Used by the internal configuration code to
track the channel to be used for AP later
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>chandef</term>
      <listitem><para>
(private) Used by the internal configuration code to track
the user-set channel definition.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>ibss_fixed</term>
      <listitem><para>
(private) IBSS is using fixed BSSID
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>ibss_dfs_possible</term>
      <listitem><para>
(private) IBSS may change to a DFS channel
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>ps</term>
      <listitem><para>
powersave mode is enabled
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>ps_timeout</term>
      <listitem><para>
dynamic powersave timeout
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>beacon_interval</term>
      <listitem><para>
beacon interval used on this device for transmitting
beacons, 0 when not valid
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>ap_unexpected_nlportid</term>
      <listitem><para>
(private) netlink port ID of application
registered for unexpected class 3 frames (AP mode)
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>cac_started</term>
      <listitem><para>
true if DFS channel availability check has been started
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>cac_start_time</term>
      <listitem><para>
timestamp (jiffies) when the dfs state was entered.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>cac_time_ms</term>
      <listitem><para>
CAC time in ms
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>owner_nlportid</term>
      <listitem><para>
(private) owner socket port ID
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>wext</term>
      <listitem><para>
(private) Used by the internal wireless extensions compat code
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
<refsect1>
<title>Description</title>
<para>
   </para><para>

   For netdevs, this structure must be allocated by the driver
   that uses the ieee80211_ptr field in struct net_device (this
   is intentional so it can be allocated along with the netdev.)
   It need not be registered then as netdev registration will
   be intercepted by cfg80211 to see the new wireless device.
   </para><para>

   For non-netdev uses, it must also be allocated by the driver
   in response to the cfg80211 callbacks that require it, as
   there's no netdev registration in that case it may not be
   allocated outside of callback operations that return it.
</para>
</refsect1>
</refentry>

<refentry id="API-wiphy-new">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>wiphy_new</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>wiphy_new</refname>
 <refpurpose>
  create a new wiphy for use with cfg80211
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct wiphy * <function>wiphy_new </function></funcdef>
   <paramdef>const struct cfg80211_ops * <parameter>ops</parameter></paramdef>
   <paramdef>int <parameter>sizeof_priv</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ops</parameter></term>
   <listitem>
    <para>
     The configuration operations for this device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>sizeof_priv</parameter></term>
   <listitem>
    <para>
     The size of the private area to allocate
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Create a new wiphy and associate the given operations with it.
   <parameter>sizeof_priv</parameter> bytes are allocated for private use.
</para>
</refsect1>
<refsect1>
<title>Return</title>
<para>
   A pointer to the new wiphy. This pointer must be
   assigned to each netdev's ieee80211_ptr for proper operation.
</para>
</refsect1>
</refentry>

<refentry id="API-wiphy-register">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>wiphy_register</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>wiphy_register</refname>
 <refpurpose>
  register a wiphy with cfg80211
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>wiphy_register </function></funcdef>
   <paramdef>struct wiphy * <parameter>wiphy</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>wiphy</parameter></term>
   <listitem>
    <para>
     The wiphy to register.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Return</title>
<para>
   A non-negative wiphy index or a negative error code.
</para>
</refsect1>
</refentry>

<refentry id="API-wiphy-unregister">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>wiphy_unregister</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>wiphy_unregister</refname>
 <refpurpose>
  deregister a wiphy from cfg80211
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>wiphy_unregister </function></funcdef>
   <paramdef>struct wiphy * <parameter>wiphy</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>wiphy</parameter></term>
   <listitem>
    <para>
     The wiphy to unregister.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   After this call, no more requests can be made with this priv
   pointer, but the call may sleep to wait for an outstanding
   request that is being handled.
</para>
</refsect1>
</refentry>

<refentry id="API-wiphy-free">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>wiphy_free</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>wiphy_free</refname>
 <refpurpose>
  free wiphy
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>wiphy_free </function></funcdef>
   <paramdef>struct wiphy * <parameter>wiphy</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>wiphy</parameter></term>
   <listitem>
    <para>
     The wiphy to free
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>


<refentry id="API-wiphy-name">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>wiphy_name</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>wiphy_name</refname>
 <refpurpose>
  get wiphy name
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>const char * <function>wiphy_name </function></funcdef>
   <paramdef>const struct wiphy * <parameter>wiphy</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>wiphy</parameter></term>
   <listitem>
    <para>
     The wiphy whose name to return
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Return</title>
<para>
   The name of <parameter>wiphy</parameter>.
</para>
</refsect1>
</refentry>

<refentry id="API-wiphy-dev">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>wiphy_dev</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>wiphy_dev</refname>
 <refpurpose>
  get wiphy dev pointer
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct device * <function>wiphy_dev </function></funcdef>
   <paramdef>struct wiphy * <parameter>wiphy</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>wiphy</parameter></term>
   <listitem>
    <para>
     The wiphy whose device struct to look up
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Return</title>
<para>
   The dev of <parameter>wiphy</parameter>.
</para>
</refsect1>
</refentry>

<refentry id="API-wiphy-priv">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>wiphy_priv</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>wiphy_priv</refname>
 <refpurpose>
  return priv from wiphy
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void * <function>wiphy_priv </function></funcdef>
   <paramdef>struct wiphy * <parameter>wiphy</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>wiphy</parameter></term>
   <listitem>
    <para>
     the wiphy whose priv pointer to return
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Return</title>
<para>
   The priv of <parameter>wiphy</parameter>.
</para>
</refsect1>
</refentry>

<refentry id="API-priv-to-wiphy">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>priv_to_wiphy</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>priv_to_wiphy</refname>
 <refpurpose>
  return the wiphy containing the priv
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct wiphy * <function>priv_to_wiphy </function></funcdef>
   <paramdef>void * <parameter>priv</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>priv</parameter></term>
   <listitem>
    <para>
     a pointer previously returned by wiphy_priv
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Return</title>
<para>
   The wiphy of <parameter>priv</parameter>.
</para>
</refsect1>
</refentry>

<refentry id="API-set-wiphy-dev">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>set_wiphy_dev</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>set_wiphy_dev</refname>
 <refpurpose>
  set device pointer for wiphy
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>set_wiphy_dev </function></funcdef>
   <paramdef>struct wiphy * <parameter>wiphy</parameter></paramdef>
   <paramdef>struct device * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>wiphy</parameter></term>
   <listitem>
    <para>
     The wiphy whose device to bind
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     The device to parent it to
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-wdev-priv">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>wdev_priv</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>wdev_priv</refname>
 <refpurpose>
  return wiphy priv from wireless_dev
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void * <function>wdev_priv </function></funcdef>
   <paramdef>struct wireless_dev * <parameter>wdev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>wdev</parameter></term>
   <listitem>
    <para>
     The wireless device whose wiphy's priv pointer to return
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Return</title>
<para>
   The wiphy priv of <parameter>wdev</parameter>.
</para>
</refsect1>
</refentry>

<refentry id="API-struct-ieee80211-iface-limit">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct ieee80211_iface_limit</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct ieee80211_iface_limit</refname>
 <refpurpose>
  limit on certain interface types
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct ieee80211_iface_limit {
  u16 max;
  u16 types;
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>max</term>
      <listitem><para>
maximum number of interfaces of these types
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>types</term>
      <listitem><para>
interface types (bits)
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
</refentry>

<refentry id="API-struct-ieee80211-iface-combination">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct ieee80211_iface_combination</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct ieee80211_iface_combination</refname>
 <refpurpose>
  possible interface combination
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct ieee80211_iface_combination {
  const struct ieee80211_iface_limit * limits;
  u32 num_different_channels;
  u16 max_interfaces;
  u8 n_limits;
  bool beacon_int_infra_match;
  u8 radar_detect_widths;
  u8 radar_detect_regions;
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>limits</term>
      <listitem><para>
limits for the given interface types
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>num_different_channels</term>
      <listitem><para>
can use up to this many different channels
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>max_interfaces</term>
      <listitem><para>
maximum number of interfaces in total allowed in this
group
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>n_limits</term>
      <listitem><para>
number of limitations
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>beacon_int_infra_match</term>
      <listitem><para>
In this combination, the beacon intervals
between infrastructure and AP types must match. This is required
only in special cases.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>radar_detect_widths</term>
      <listitem><para>
bitmap of channel widths supported for radar detection
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>radar_detect_regions</term>
      <listitem><para>
bitmap of regions supported for radar detection
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
<refsect1>
<title>Description</title>
<para>
   With this structure the driver can describe which interface
   combinations it supports concurrently.
</para>
</refsect1>
<refsect1>
<title>Examples</title>
<informalexample><programlisting>

   1. Allow #STA &lt;= 1, #AP &lt;= 1, matching BI, channels = 1, 2 total:

    struct ieee80211_iface_limit limits1[] = {
   	{ .max = 1, .types = BIT(NL80211_IFTYPE_STATION), },
   	{ .max = 1, .types = BIT(NL80211_IFTYPE_AP}, },
    };
    struct ieee80211_iface_combination combination1 = {
   	.limits = limits1,
   	.n_limits = ARRAY_SIZE(limits1),
   	.max_interfaces = 2,
   	.beacon_int_infra_match = true,
    };


   2. Allow #{AP, P2P-GO} &lt;= 8, channels = 1, 8 total:

    struct ieee80211_iface_limit limits2[] = {
   	{ .max = 8, .types = BIT(NL80211_IFTYPE_AP) |
   			     BIT(NL80211_IFTYPE_P2P_GO), },
    };
    struct ieee80211_iface_combination combination2 = {
   	.limits = limits2,
   	.n_limits = ARRAY_SIZE(limits2),
   	.max_interfaces = 8,
   	.num_different_channels = 1,
    };


   3. Allow #STA &lt;= 1, #{P2P-client,P2P-GO} &lt;= 3 on two channels, 4 total.

   This allows for an infrastructure connection and three P2P connections.

    struct ieee80211_iface_limit limits3[] = {
   	{ .max = 1, .types = BIT(NL80211_IFTYPE_STATION), },
   	{ .max = 3, .types = BIT(NL80211_IFTYPE_P2P_GO) |
   			     BIT(NL80211_IFTYPE_P2P_CLIENT), },
    };
    struct ieee80211_iface_combination combination3 = {
   	.limits = limits3,
   	.n_limits = ARRAY_SIZE(limits3),
   	.max_interfaces = 4,
   	.num_different_channels = 2,
    };
</programlisting></informalexample>
</refsect1>
</refentry>

<refentry id="API-cfg80211-check-combinations">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>cfg80211_check_combinations</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>cfg80211_check_combinations</refname>
 <refpurpose>
  check interface combinations
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>cfg80211_check_combinations </function></funcdef>
   <paramdef>struct wiphy * <parameter>wiphy</parameter></paramdef>
   <paramdef>const int <parameter>num_different_channels</parameter></paramdef>
   <paramdef>const u8 <parameter>radar_detect</parameter></paramdef>
   <paramdef>const int <parameter>iftype_num[NUM_NL80211_IFTYPES]</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>wiphy</parameter></term>
   <listitem>
    <para>
     the wiphy
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>num_different_channels</parameter></term>
   <listitem>
    <para>
     the number of different channels we want
     to use for verification
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>radar_detect</parameter></term>
   <listitem>
    <para>
     a bitmap where each bit corresponds to a channel
     width where radar detection is needed, as in the definition of
     <structname>struct ieee80211_iface_combination</structname>.<parameter>radar_detect_widths</parameter>
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>iftype_num[NUM_NL80211_IFTYPES]</parameter></term>
   <listitem>
    <para>
     array with the numbers of interfaces of each interface
     type.  The index is the interface type as specified in <structname>enum</structname>
     nl80211_iftype.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This function can be called by the driver to check whether a
   combination of interfaces and their types are allowed according to
   the interface combinations.
</para>
</refsect1>
</refentry>

      </chapter>
      <chapter>
      <title>Actions and configuration</title>
<para>
   </para><para>
   Each wireless device and each virtual interface offer a set of configuration
   operations and other actions that are invoked by userspace. Each of these
   actions is described in the operations structure, and the parameters these
   operations use are described separately.
   </para><para>
   Additionally, some operations are asynchronous and expect to get status
   information via some functions that drivers need to call.
   </para><para>
   Scanning and BSS list handling with its associated functionality is described
   in a separate chapter.
</para>

<refentry id="API-struct-cfg80211-ops">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct cfg80211_ops</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct cfg80211_ops</refname>
 <refpurpose>
  backend description for wireless configuration
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct cfg80211_ops {
  int (* suspend) (struct wiphy *wiphy, struct cfg80211_wowlan *wow);
  int (* resume) (struct wiphy *wiphy);
  void (* set_wakeup) (struct wiphy *wiphy, bool enabled);
  struct wireless_dev * (* add_virtual_intf) (struct wiphy *wiphy,const char *name,enum nl80211_iftype type,u32 *flags,struct vif_params *params);
  int (* del_virtual_intf) (struct wiphy *wiphy,struct wireless_dev *wdev);
  int (* change_virtual_intf) (struct wiphy *wiphy,struct net_device *dev,enum nl80211_iftype type, u32 *flags,struct vif_params *params);
  int (* add_key) (struct wiphy *wiphy, struct net_device *netdev,u8 key_index, bool pairwise, const u8 *mac_addr,struct key_params *params);
  int (* get_key) (struct wiphy *wiphy, struct net_device *netdev,u8 key_index, bool pairwise, const u8 *mac_addr,void *cookie,void (*callback);
  int (* del_key) (struct wiphy *wiphy, struct net_device *netdev,u8 key_index, bool pairwise, const u8 *mac_addr);
  int (* set_default_key) (struct wiphy *wiphy,struct net_device *netdev,u8 key_index, bool unicast, bool multicast);
  int (* set_default_mgmt_key) (struct wiphy *wiphy,struct net_device *netdev,u8 key_index);
  int (* start_ap) (struct wiphy *wiphy, struct net_device *dev,struct cfg80211_ap_settings *settings);
  int (* change_beacon) (struct wiphy *wiphy, struct net_device *dev,struct cfg80211_beacon_data *info);
  int (* stop_ap) (struct wiphy *wiphy, struct net_device *dev);
  int (* add_station) (struct wiphy *wiphy, struct net_device *dev,const u8 *mac,struct station_parameters *params);
  int (* del_station) (struct wiphy *wiphy, struct net_device *dev,const u8 *mac);
  int (* change_station) (struct wiphy *wiphy, struct net_device *dev,const u8 *mac,struct station_parameters *params);
  int (* get_station) (struct wiphy *wiphy, struct net_device *dev,const u8 *mac, struct station_info *sinfo);
  int (* dump_station) (struct wiphy *wiphy, struct net_device *dev,int idx, u8 *mac, struct station_info *sinfo);
  int (* add_mpath) (struct wiphy *wiphy, struct net_device *dev,const u8 *dst, const u8 *next_hop);
  int (* del_mpath) (struct wiphy *wiphy, struct net_device *dev,const u8 *dst);
  int (* change_mpath) (struct wiphy *wiphy, struct net_device *dev,const u8 *dst, const u8 *next_hop);
  int (* get_mpath) (struct wiphy *wiphy, struct net_device *dev,u8 *dst, u8 *next_hop, struct mpath_info *pinfo);
  int (* dump_mpath) (struct wiphy *wiphy, struct net_device *dev,int idx, u8 *dst, u8 *next_hop,struct mpath_info *pinfo);
  int (* get_mesh_config) (struct wiphy *wiphy,struct net_device *dev,struct mesh_config *conf);
  int (* update_mesh_config) (struct wiphy *wiphy,struct net_device *dev, u32 mask,const struct mesh_config *nconf);
  int (* join_mesh) (struct wiphy *wiphy, struct net_device *dev,const struct mesh_config *conf,const struct mesh_setup *setup);
  int (* leave_mesh) (struct wiphy *wiphy, struct net_device *dev);
  int (* change_bss) (struct wiphy *wiphy, struct net_device *dev,struct bss_parameters *params);
  int (* set_txq_params) (struct wiphy *wiphy, struct net_device *dev,struct ieee80211_txq_params *params);
  int (* libertas_set_mesh_channel) (struct wiphy *wiphy,struct net_device *dev,struct ieee80211_channel *chan);
  int (* set_monitor_channel) (struct wiphy *wiphy,struct cfg80211_chan_def *chandef);
  int (* scan) (struct wiphy *wiphy,struct cfg80211_scan_request *request);
  int (* auth) (struct wiphy *wiphy, struct net_device *dev,struct cfg80211_auth_request *req);
  int (* assoc) (struct wiphy *wiphy, struct net_device *dev,struct cfg80211_assoc_request *req);
  int (* deauth) (struct wiphy *wiphy, struct net_device *dev,struct cfg80211_deauth_request *req);
  int (* disassoc) (struct wiphy *wiphy, struct net_device *dev,struct cfg80211_disassoc_request *req);
  int (* connect) (struct wiphy *wiphy, struct net_device *dev,struct cfg80211_connect_params *sme);
  int (* disconnect) (struct wiphy *wiphy, struct net_device *dev,u16 reason_code);
  int (* join_ibss) (struct wiphy *wiphy, struct net_device *dev,struct cfg80211_ibss_params *params);
  int (* leave_ibss) (struct wiphy *wiphy, struct net_device *dev);
  int (* set_mcast_rate) (struct wiphy *wiphy, struct net_device *dev,int rate[IEEE80211_NUM_BANDS]);
  int (* set_wiphy_params) (struct wiphy *wiphy, u32 changed);
  int (* set_tx_power) (struct wiphy *wiphy, struct wireless_dev *wdev,enum nl80211_tx_power_setting type, int mbm);
  int (* get_tx_power) (struct wiphy *wiphy, struct wireless_dev *wdev,int *dbm);
  int (* set_wds_peer) (struct wiphy *wiphy, struct net_device *dev,const u8 *addr);
  void (* rfkill_poll) (struct wiphy *wiphy);
#ifdef CONFIG_NL80211_TESTMODE
  int (* testmode_cmd) (struct wiphy *wiphy, struct wireless_dev *wdev,void *data, int len);
  int (* testmode_dump) (struct wiphy *wiphy, struct sk_buff *skb,struct netlink_callback *cb,void *data, int len);
#endif
  int (* set_bitrate_mask) (struct wiphy *wiphy,struct net_device *dev,const u8 *peer,const struct cfg80211_bitrate_mask *mask);
  int (* dump_survey) (struct wiphy *wiphy, struct net_device *netdev,int idx, struct survey_info *info);
  int (* set_pmksa) (struct wiphy *wiphy, struct net_device *netdev,struct cfg80211_pmksa *pmksa);
  int (* del_pmksa) (struct wiphy *wiphy, struct net_device *netdev,struct cfg80211_pmksa *pmksa);
  int (* flush_pmksa) (struct wiphy *wiphy, struct net_device *netdev);
  int (* remain_on_channel) (struct wiphy *wiphy,struct wireless_dev *wdev,struct ieee80211_channel *chan,unsigned int duration,u64 *cookie);
  int (* cancel_remain_on_channel) (struct wiphy *wiphy,struct wireless_dev *wdev,u64 cookie);
  int (* mgmt_tx) (struct wiphy *wiphy, struct wireless_dev *wdev,struct cfg80211_mgmt_tx_params *params,u64 *cookie);
  int (* mgmt_tx_cancel_wait) (struct wiphy *wiphy,struct wireless_dev *wdev,u64 cookie);
  int (* set_power_mgmt) (struct wiphy *wiphy, struct net_device *dev,bool enabled, int timeout);
  int (* set_cqm_rssi_config) (struct wiphy *wiphy,struct net_device *dev,s32 rssi_thold, u32 rssi_hyst);
  int (* set_cqm_txe_config) (struct wiphy *wiphy,struct net_device *dev,u32 rate, u32 pkts, u32 intvl);
  void (* mgmt_frame_register) (struct wiphy *wiphy,struct wireless_dev *wdev,u16 frame_type, bool reg);
  int (* set_antenna) (struct wiphy *wiphy, u32 tx_ant, u32 rx_ant);
  int (* get_antenna) (struct wiphy *wiphy, u32 *tx_ant, u32 *rx_ant);
  int (* sched_scan_start) (struct wiphy *wiphy,struct net_device *dev,struct cfg80211_sched_scan_request *request);
  int (* sched_scan_stop) (struct wiphy *wiphy, struct net_device *dev);
  int (* set_rekey_data) (struct wiphy *wiphy, struct net_device *dev,struct cfg80211_gtk_rekey_data *data);
  int (* tdls_mgmt) (struct wiphy *wiphy, struct net_device *dev,const u8 *peer, u8 action_code,  u8 dialog_token,u16 status_code, u32 peer_capability,bool initiator, const u8 *buf, size_t len);
  int (* tdls_oper) (struct wiphy *wiphy, struct net_device *dev,const u8 *peer, enum nl80211_tdls_operation oper);
  int (* probe_client) (struct wiphy *wiphy, struct net_device *dev,const u8 *peer, u64 *cookie);
  int (* set_noack_map) (struct wiphy *wiphy,struct net_device *dev,u16 noack_map);
  int (* get_channel) (struct wiphy *wiphy,struct wireless_dev *wdev,struct cfg80211_chan_def *chandef);
  int (* start_p2p_device) (struct wiphy *wiphy,struct wireless_dev *wdev);
  void (* stop_p2p_device) (struct wiphy *wiphy,struct wireless_dev *wdev);
  int (* set_mac_acl) (struct wiphy *wiphy, struct net_device *dev,const struct cfg80211_acl_data *params);
  int (* start_radar_detection) (struct wiphy *wiphy,struct net_device *dev,struct cfg80211_chan_def *chandef,u32 cac_time_ms);
  int (* update_ft_ies) (struct wiphy *wiphy, struct net_device *dev,struct cfg80211_update_ft_ies_params *ftie);
  int (* crit_proto_start) (struct wiphy *wiphy,struct wireless_dev *wdev,enum nl80211_crit_proto_id protocol,u16 duration);
  void (* crit_proto_stop) (struct wiphy *wiphy,struct wireless_dev *wdev);
  int (* set_coalesce) (struct wiphy *wiphy,struct cfg80211_coalesce *coalesce);
  int (* channel_switch) (struct wiphy *wiphy,struct net_device *dev,struct cfg80211_csa_settings *params);
  int (* set_qos_map) (struct wiphy *wiphy,struct net_device *dev,struct cfg80211_qos_map *qos_map);
  int (* set_ap_chanwidth) (struct wiphy *wiphy, struct net_device *dev,struct cfg80211_chan_def *chandef);
  int (* add_tx_ts) (struct wiphy *wiphy, struct net_device *dev,u8 tsid, const u8 *peer, u8 user_prio,u16 admitted_time);
  int (* del_tx_ts) (struct wiphy *wiphy, struct net_device *dev,u8 tsid, const u8 *peer);
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>suspend</term>
      <listitem><para>
wiphy device needs to be suspended. The variable <parameter>wow</parameter> will
be <constant>NULL</constant> or contain the enabled Wake-on-Wireless triggers that are
configured for the device.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>resume</term>
      <listitem><para>
wiphy device needs to be resumed
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>set_wakeup</term>
      <listitem><para>
Called when WoWLAN is enabled/disabled, use this callback
to call <function>device_set_wakeup_enable</function> to enable/disable wakeup from
the device.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>add_virtual_intf</term>
      <listitem><para>
create a new virtual interface with the given name,
must set the struct wireless_dev's iftype. Beware: You must create
the new netdev in the wiphy's network namespace! Returns the struct
wireless_dev, or an ERR_PTR. For P2P device wdevs, the driver must
also set the address member in the wdev.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>del_virtual_intf</term>
      <listitem><para>
remove the virtual interface
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>change_virtual_intf</term>
      <listitem><para>
change type/configuration of virtual interface,
keep the struct wireless_dev's iftype updated.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>add_key</term>
      <listitem><para>
add a key with the given parameters. <parameter>mac_addr</parameter> will be <constant>NULL</constant>
when adding a group key.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>get_key</term>
      <listitem><para>
get information about the key with the given parameters.
<parameter>mac_addr</parameter> will be <constant>NULL</constant> when requesting information for a group
key. All pointers given to the <parameter>callback</parameter> function need not be valid
after it returns. This function should return an error if it is
not possible to retrieve the key, -ENOENT if it doesn't exist.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>del_key</term>
      <listitem><para>
remove a key given the <parameter>mac_addr</parameter> (<constant>NULL</constant> for a group key)
and <parameter>key_index</parameter>, return -ENOENT if the key doesn't exist.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>set_default_key</term>
      <listitem><para>
set the default key on an interface
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>set_default_mgmt_key</term>
      <listitem><para>
set the default management frame key on an interface
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>start_ap</term>
      <listitem><para>
Start acting in AP mode defined by the parameters.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>change_beacon</term>
      <listitem><para>
Change the beacon parameters for an access point mode
interface. This should reject the call when AP mode wasn't started.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>stop_ap</term>
      <listitem><para>
Stop being an AP, including stopping beaconing.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>add_station</term>
      <listitem><para>
Add a new station.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>del_station</term>
      <listitem><para>
Remove a station; <parameter>mac</parameter> may be NULL to remove all stations.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>change_station</term>
      <listitem><para>
Modify a given station. Note that flags changes are not much
validated in cfg80211, in particular the auth/assoc/authorized flags
might come to the driver in invalid combinations -- make sure to check
them, also against the existing state! Drivers must call
<function>cfg80211_check_station_change</function> to validate the information.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>get_station</term>
      <listitem><para>
get station information for the station identified by <parameter>mac</parameter>
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>dump_station</term>
      <listitem><para>
dump station callback -- resume dump at index <parameter>idx</parameter>
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>add_mpath</term>
      <listitem><para>
add a fixed mesh path
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>del_mpath</term>
      <listitem><para>
delete a given mesh path
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>change_mpath</term>
      <listitem><para>
change a given mesh path
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>get_mpath</term>
      <listitem><para>
get a mesh path for the given parameters
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>dump_mpath</term>
      <listitem><para>
dump mesh path callback -- resume dump at index <parameter>idx</parameter>
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>get_mesh_config</term>
      <listitem><para>
Get the current mesh configuration
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>update_mesh_config</term>
      <listitem><para>
Update mesh parameters on a running mesh.
The mask is a bitfield which tells us which parameters to
set, and which to leave alone.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>join_mesh</term>
      <listitem><para>
join the mesh network with the specified parameters
(invoked with the wireless_dev mutex held)
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>leave_mesh</term>
      <listitem><para>
leave the current mesh network
(invoked with the wireless_dev mutex held)
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>change_bss</term>
      <listitem><para>
Modify parameters for a given BSS.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>set_txq_params</term>
      <listitem><para>
Set TX queue parameters
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>libertas_set_mesh_channel</term>
      <listitem><para>
Only for backward compatibility for libertas,
as it doesn't implement join_mesh and needs to set the channel to
join the mesh instead.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>set_monitor_channel</term>
      <listitem><para>
Set the monitor mode channel for the device. If other
interfaces are active this callback should reject the configuration.
If no interfaces are active or the device is down, the channel should
be stored for when a monitor interface becomes active.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>scan</term>
      <listitem><para>
Request to do a scan. If returning zero, the scan request is given
the driver, and will be valid until passed to <function>cfg80211_scan_done</function>.
For scan results, call <function>cfg80211_inform_bss</function>; you can call this outside
the scan/scan_done bracket too.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>auth</term>
      <listitem><para>
Request to authenticate with the specified peer
(invoked with the wireless_dev mutex held)
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>assoc</term>
      <listitem><para>
Request to (re)associate with the specified peer
(invoked with the wireless_dev mutex held)
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>deauth</term>
      <listitem><para>
Request to deauthenticate from the specified peer
(invoked with the wireless_dev mutex held)
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>disassoc</term>
      <listitem><para>
Request to disassociate from the specified peer
(invoked with the wireless_dev mutex held)
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>connect</term>
      <listitem><para>
Connect to the ESS with the specified parameters. When connected,
call <function>cfg80211_connect_result</function> with status code <constant>WLAN_STATUS_SUCCESS</constant>.
If the connection fails for some reason, call <function>cfg80211_connect_result</function>
with the status from the AP.
(invoked with the wireless_dev mutex held)
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>disconnect</term>
      <listitem><para>
Disconnect from the BSS/ESS.
(invoked with the wireless_dev mutex held)
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>join_ibss</term>
      <listitem><para>
Join the specified IBSS (or create if necessary). Once done, call
<function>cfg80211_ibss_joined</function>, also call that function when changing BSSID due
to a merge.
(invoked with the wireless_dev mutex held)
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>leave_ibss</term>
      <listitem><para>
Leave the IBSS.
(invoked with the wireless_dev mutex held)
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>set_mcast_rate</term>
      <listitem><para>
Set the specified multicast rate (only if vif is in ADHOC or
MESH mode)
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>set_wiphy_params</term>
      <listitem><para>
Notify that wiphy parameters have changed;
<parameter>changed</parameter> bitfield (see <structname>enum</structname> wiphy_params_flags) describes which values
have changed. The actual parameter values are available in
struct wiphy. If returning an error, no value should be changed.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>set_tx_power</term>
      <listitem><para>
set the transmit power according to the parameters,
the power passed is in mBm, to get dBm use <function>MBM_TO_DBM</function>. The
wdev may be <constant>NULL</constant> if power was set for the wiphy, and will
always be <constant>NULL</constant> unless the driver supports per-vif TX power
(as advertised by the nl80211 feature flag.)
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>get_tx_power</term>
      <listitem><para>
store the current TX power into the dbm variable;
return 0 if successful
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>set_wds_peer</term>
      <listitem><para>
set the WDS peer for a WDS interface
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>rfkill_poll</term>
      <listitem><para>
polls the hw rfkill line, use cfg80211 reporting
functions to adjust rfkill hw state
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>testmode_cmd</term>
      <listitem><para>
run a test mode command; <parameter>wdev</parameter> may be <constant>NULL</constant>
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>testmode_dump</term>
      <listitem><para>
Implement a test mode dump. The cb-&gt;args[2] and up may be
used by the function, but 0 and 1 must not be touched. Additionally,
return error codes other than -ENOBUFS and -ENOENT will terminate the
dump and return to userspace with an error, so be careful. If any data
was passed in from userspace then the data/len arguments will be present
and point to the data contained in <constant>NL80211_ATTR_TESTDATA</constant>.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>set_bitrate_mask</term>
      <listitem><para>
set the bitrate mask configuration
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>dump_survey</term>
      <listitem><para>
get site survey information.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>set_pmksa</term>
      <listitem><para>
Cache a PMKID for a BSSID. This is mostly useful for fullmac
devices running firmwares capable of generating the (re) association
RSN IE. It allows for faster roaming between WPA2 BSSIDs.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>del_pmksa</term>
      <listitem><para>
Delete a cached PMKID.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>flush_pmksa</term>
      <listitem><para>
Flush all cached PMKIDs.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>remain_on_channel</term>
      <listitem><para>
Request the driver to remain awake on the specified
channel for the specified duration to complete an off-channel
operation (e.g., public action frame exchange). When the driver is
ready on the requested channel, it must indicate this with an event
notification by calling <function>cfg80211_ready_on_channel</function>.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>cancel_remain_on_channel</term>
      <listitem><para>
Cancel an on-going remain-on-channel operation.
This allows the operation to be terminated prior to timeout based on
the duration value.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>mgmt_tx</term>
      <listitem><para>
Transmit a management frame.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>mgmt_tx_cancel_wait</term>
      <listitem><para>
Cancel the wait time from transmitting a management
frame on another channel
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>set_power_mgmt</term>
      <listitem><para>
Configure WLAN power management. A timeout value of -1
allows the driver to adjust the dynamic ps timeout value.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>set_cqm_rssi_config</term>
      <listitem><para>
Configure connection quality monitor RSSI threshold.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>set_cqm_txe_config</term>
      <listitem><para>
Configure connection quality monitor TX error
thresholds.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>mgmt_frame_register</term>
      <listitem><para>
Notify driver that a management frame type was
registered. Note that this callback may not sleep, and cannot run
concurrently with itself.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>set_antenna</term>
      <listitem><para>
Set antenna configuration (tx_ant, rx_ant) on the device.
Parameters are bitmaps of allowed antennas to use for TX/RX. Drivers may
reject TX/RX mask combinations they cannot support by returning -EINVAL
(also see nl80211.h <parameter>NL80211_ATTR_WIPHY_ANTENNA_TX</parameter>).
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>get_antenna</term>
      <listitem><para>
Get current antenna configuration from device (tx_ant, rx_ant).
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>sched_scan_start</term>
      <listitem><para>
Tell the driver to start a scheduled scan.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>sched_scan_stop</term>
      <listitem><para>
Tell the driver to stop an ongoing scheduled scan. This
call must stop the scheduled scan and be ready for starting a new one
before it returns, i.e. <parameter>sched_scan_start</parameter> may be called immediately
after that again and should not fail in that case. The driver should
not call <function>cfg80211_sched_scan_stopped</function> for a requested stop (when this
method returns 0.)
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>set_rekey_data</term>
      <listitem><para>
give the data necessary for GTK rekeying to the driver
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>tdls_mgmt</term>
      <listitem><para>
Transmit a TDLS management frame.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>tdls_oper</term>
      <listitem><para>
Perform a high-level TDLS operation (e.g. TDLS link setup).
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>probe_client</term>
      <listitem><para>
probe an associated client, must return a cookie that it
later passes to <function>cfg80211_probe_status</function>.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>set_noack_map</term>
      <listitem><para>
Set the NoAck Map for the TIDs.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>get_channel</term>
      <listitem><para>
Get the current operating channel for the virtual interface.
For monitor interfaces, it should return <constant>NULL</constant> unless there's a single
current monitoring channel.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>start_p2p_device</term>
      <listitem><para>
Start the given P2P device.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>stop_p2p_device</term>
      <listitem><para>
Stop the given P2P device.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>set_mac_acl</term>
      <listitem><para>
Sets MAC address control list in AP and P2P GO mode.
Parameters include ACL policy, an array of MAC address of stations
and the number of MAC addresses. If there is already a list in driver
this new list replaces the existing one. Driver has to clear its ACL
when number of MAC addresses entries is passed as 0. Drivers which
advertise the support for MAC based ACL have to implement this callback.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>start_radar_detection</term>
      <listitem><para>
Start radar detection in the driver.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>update_ft_ies</term>
      <listitem><para>
Provide updated Fast BSS Transition information to the
driver. If the SME is in the driver/firmware, this information can be
used in building Authentication and Reassociation Request frames.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>crit_proto_start</term>
      <listitem><para>
Indicates a critical protocol needs more link reliability
for a given duration (milliseconds). The protocol is provided so the
driver can take the most appropriate actions.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>crit_proto_stop</term>
      <listitem><para>
Indicates critical protocol no longer needs increased link
reliability. This operation can not fail.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>set_coalesce</term>
      <listitem><para>
Set coalesce parameters.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>channel_switch</term>
      <listitem><para>
initiate channel-switch procedure (with CSA). Driver is
responsible for veryfing if the switch is possible. Since this is
inherently tricky driver may decide to disconnect an interface later
with <function>cfg80211_stop_iface</function>. This doesn't mean driver can accept
everything. It should do it's best to verify requests and reject them
as soon as possible.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>set_qos_map</term>
      <listitem><para>
Set QoS mapping information to the driver
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>set_ap_chanwidth</term>
      <listitem><para>
Set the AP (including P2P GO) mode channel width for the
given interface This is used e.g. for dynamic HT 20/40 MHz channel width
changes during the lifetime of the BSS.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>add_tx_ts</term>
      <listitem><para>
validate (if admitted_time is 0) or add a TX TS to the device
with the given parameters; action frame exchange has been handled by
userspace so this just has to modify the TX path to take the TS into
account.
If the admitted time is 0 just validate the parameters to make sure
the session can be created at all; it is valid to just always return
success for that but that may result in inefficient behaviour (handshake
with the peer followed by immediate teardown when the addition is later
rejected)
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>del_tx_ts</term>
      <listitem><para>
remove an existing TX TS
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
<refsect1>
<title>Description</title>
<para>
   </para><para>

   This struct is registered by fullmac card drivers and/or wireless stacks
   in order to handle configuration requests on their interfaces.
   </para><para>

   All callbacks except where otherwise noted should return 0
   on success or a negative error code.
   </para><para>

   All operations are currently invoked under rtnl for consistency with the
   wireless extensions but this is subject to reevaluation as soon as this
   code is used more widely and we have a first user without wext.
</para>
</refsect1>
</refentry>

<refentry id="API-struct-vif-params">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct vif_params</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct vif_params</refname>
 <refpurpose>
  describes virtual interface parameters
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct vif_params {
  int use_4addr;
  u8 macaddr[ETH_ALEN];
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>use_4addr</term>
      <listitem><para>
use 4-address frames
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>macaddr[ETH_ALEN]</term>
      <listitem><para>
address to use for this virtual interface. This will only
be used for non-netdevice interfaces. If this parameter is set
to zero address the driver may determine the address as needed.
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
</refentry>

<refentry id="API-struct-key-params">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct key_params</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct key_params</refname>
 <refpurpose>
  key information
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct key_params {
  const u8 * key;
  const u8 * seq;
  int key_len;
  int seq_len;
  u32 cipher;
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>key</term>
      <listitem><para>
key material
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>seq</term>
      <listitem><para>
sequence counter (IV/PN) for TKIP and CCMP keys, only used
with the <function>get_key</function> callback, must be in little endian,
length given by <parameter>seq_len</parameter>.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>key_len</term>
      <listitem><para>
length of key material
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>seq_len</term>
      <listitem><para>
length of <parameter>seq</parameter>.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>cipher</term>
      <listitem><para>
cipher suite selector
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
<refsect1>
<title>Description</title>
<para>
   </para><para>

   Information about a key
</para>
</refsect1>
</refentry>

<refentry id="API-enum-survey-info-flags">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>enum survey_info_flags</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>enum survey_info_flags</refname>
 <refpurpose>
  survey information flags
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
enum survey_info_flags {
  SURVEY_INFO_NOISE_DBM,
  SURVEY_INFO_IN_USE,
  SURVEY_INFO_CHANNEL_TIME,
  SURVEY_INFO_CHANNEL_TIME_BUSY,
  SURVEY_INFO_CHANNEL_TIME_EXT_BUSY,
  SURVEY_INFO_CHANNEL_TIME_RX,
  SURVEY_INFO_CHANNEL_TIME_TX
};  </programlisting>
</refsynopsisdiv>
<refsect1>
 <title>Constants</title>
  <variablelist>
    <varlistentry>      <term>SURVEY_INFO_NOISE_DBM</term>
      <listitem><para>
noise (in dBm) was filled in
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>SURVEY_INFO_IN_USE</term>
      <listitem><para>
channel is currently being used
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>SURVEY_INFO_CHANNEL_TIME</term>
      <listitem><para>
channel active time (in ms) was filled in
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>SURVEY_INFO_CHANNEL_TIME_BUSY</term>
      <listitem><para>
channel busy time was filled in
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>SURVEY_INFO_CHANNEL_TIME_EXT_BUSY</term>
      <listitem><para>
extension channel busy time was filled in
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>SURVEY_INFO_CHANNEL_TIME_RX</term>
      <listitem><para>
channel receive time was filled in
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>SURVEY_INFO_CHANNEL_TIME_TX</term>
      <listitem><para>
channel transmit time was filled in
      </para></listitem>
    </varlistentry>
  </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Used by the driver to indicate which info in <structname>struct survey_info</structname>
   it has filled in during the <function>get_survey</function>.
</para>
</refsect1>
</refentry>

<refentry id="API-struct-survey-info">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct survey_info</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct survey_info</refname>
 <refpurpose>
  channel survey response
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct survey_info {
  struct ieee80211_channel * channel;
  u64 channel_time;
  u64 channel_time_busy;
  u64 channel_time_ext_busy;
  u64 channel_time_rx;
  u64 channel_time_tx;
  u32 filled;
  s8 noise;
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>channel</term>
      <listitem><para>
the channel this survey record reports, mandatory
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>channel_time</term>
      <listitem><para>
amount of time in ms the radio spent on the channel
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>channel_time_busy</term>
      <listitem><para>
amount of time the primary channel was sensed busy
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>channel_time_ext_busy</term>
      <listitem><para>
amount of time the extension channel was sensed busy
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>channel_time_rx</term>
      <listitem><para>
amount of time the radio spent receiving data
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>channel_time_tx</term>
      <listitem><para>
amount of time the radio spent transmitting data
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>filled</term>
      <listitem><para>
bitflag of flags from <structname>enum</structname> survey_info_flags
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>noise</term>
      <listitem><para>
channel noise in dBm. This and all following fields are
optional
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
<refsect1>
<title>Description</title>
<para>
   Used by <function>dump_survey</function> to report back per-channel survey information.
   </para><para>

   This structure can later be expanded with things like
   channel duty cycle etc.
</para>
</refsect1>
</refentry>

<refentry id="API-struct-cfg80211-beacon-data">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct cfg80211_beacon_data</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct cfg80211_beacon_data</refname>
 <refpurpose>
  beacon data
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct cfg80211_beacon_data {
  const u8 * head;
  const u8 * tail;
  const u8 * beacon_ies;
  const u8 * proberesp_ies;
  const u8 * assocresp_ies;
  const u8 * probe_resp;
  size_t head_len;
  size_t tail_len;
  size_t beacon_ies_len;
  size_t proberesp_ies_len;
  size_t assocresp_ies_len;
  size_t probe_resp_len;
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>head</term>
      <listitem><para>
head portion of beacon (before TIM IE)
or <constant>NULL</constant> if not changed
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>tail</term>
      <listitem><para>
tail portion of beacon (after TIM IE)
or <constant>NULL</constant> if not changed
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>beacon_ies</term>
      <listitem><para>
extra information element(s) to add into Beacon frames or <constant>NULL</constant>
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>proberesp_ies</term>
      <listitem><para>
extra information element(s) to add into Probe Response
frames or <constant>NULL</constant>
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>assocresp_ies</term>
      <listitem><para>
extra information element(s) to add into (Re)Association
Response frames or <constant>NULL</constant>
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>probe_resp</term>
      <listitem><para>
probe response template (AP mode only)
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>head_len</term>
      <listitem><para>
length of <parameter>head</parameter>
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>tail_len</term>
      <listitem><para>
length of <parameter>tail</parameter>
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>beacon_ies_len</term>
      <listitem><para>
length of beacon_ies in octets
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>proberesp_ies_len</term>
      <listitem><para>
length of proberesp_ies in octets
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>assocresp_ies_len</term>
      <listitem><para>
length of assocresp_ies in octets
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>probe_resp_len</term>
      <listitem><para>
length of probe response template (<parameter>probe_resp</parameter>)
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
</refentry>

<refentry id="API-struct-cfg80211-ap-settings">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct cfg80211_ap_settings</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct cfg80211_ap_settings</refname>
 <refpurpose>
  AP configuration
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct cfg80211_ap_settings {
  struct cfg80211_chan_def chandef;
  struct cfg80211_beacon_data beacon;
  int beacon_interval;
  int dtim_period;
  const u8 * ssid;
  size_t ssid_len;
  enum nl80211_hidden_ssid hidden_ssid;
  struct cfg80211_crypto_settings crypto;
  bool privacy;
  enum nl80211_auth_type auth_type;
  enum nl80211_smps_mode smps_mode;
  int inactivity_timeout;
  u8 p2p_ctwindow;
  bool p2p_opp_ps;
  const struct cfg80211_acl_data * acl;
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>chandef</term>
      <listitem><para>
defines the channel to use
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>beacon</term>
      <listitem><para>
beacon data
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>beacon_interval</term>
      <listitem><para>
beacon interval
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>dtim_period</term>
      <listitem><para>
DTIM period
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>ssid</term>
      <listitem><para>
SSID to be used in the BSS (note: may be <constant>NULL</constant> if not provided from
user space)
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>ssid_len</term>
      <listitem><para>
length of <parameter>ssid</parameter>
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>hidden_ssid</term>
      <listitem><para>
whether to hide the SSID in Beacon/Probe Response frames
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>crypto</term>
      <listitem><para>
crypto settings
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>privacy</term>
      <listitem><para>
the BSS uses privacy
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>auth_type</term>
      <listitem><para>
Authentication type (algorithm)
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>smps_mode</term>
      <listitem><para>
SMPS mode
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>inactivity_timeout</term>
      <listitem><para>
time in seconds to determine station's inactivity.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>p2p_ctwindow</term>
      <listitem><para>
P2P CT Window
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>p2p_opp_ps</term>
      <listitem><para>
P2P opportunistic PS
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>acl</term>
      <listitem><para>
ACL configuration used by the drivers which has support for
MAC address based access control
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
<refsect1>
<title>Description</title>
<para>
   </para><para>

   Used to configure an AP interface.
</para>
</refsect1>
</refentry>

<refentry id="API-struct-station-parameters">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct station_parameters</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct station_parameters</refname>
 <refpurpose>
  station parameters
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct station_parameters {
  const u8 * supported_rates;
  struct net_device * vlan;
  u32 sta_flags_mask;
  u32 sta_flags_set;
  u32 sta_modify_mask;
  int listen_interval;
  u16 aid;
  u8 supported_rates_len;
  u8 plink_action;
  u8 plink_state;
  const struct ieee80211_ht_cap * ht_capa;
  const struct ieee80211_vht_cap * vht_capa;
  u8 uapsd_queues;
  u8 max_sp;
  enum nl80211_mesh_power_mode local_pm;
  u16 capability;
  const u8 * ext_capab;
  u8 ext_capab_len;
  const u8 * supported_channels;
  u8 supported_channels_len;
  const u8 * supported_oper_classes;
  u8 supported_oper_classes_len;
  u8 opmode_notif;
  bool opmode_notif_used;
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>supported_rates</term>
      <listitem><para>
supported rates in IEEE 802.11 format
(or NULL for no change)
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>vlan</term>
      <listitem><para>
vlan interface station should belong to
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>sta_flags_mask</term>
      <listitem><para>
station flags that changed
(bitmask of BIT(NL80211_STA_FLAG_...))
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>sta_flags_set</term>
      <listitem><para>
station flags values
(bitmask of BIT(NL80211_STA_FLAG_...))
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>sta_modify_mask</term>
      <listitem><para>
bitmap indicating which parameters changed
(for those that don't have a natural <quote>no change</quote> value),
see <structname>enum</structname> station_parameters_apply_mask
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>listen_interval</term>
      <listitem><para>
listen interval or -1 for no change
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>aid</term>
      <listitem><para>
AID or zero for no change
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>supported_rates_len</term>
      <listitem><para>
number of supported rates
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>plink_action</term>
      <listitem><para>
plink action to take
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>plink_state</term>
      <listitem><para>
set the peer link state for a station
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>ht_capa</term>
      <listitem><para>
HT capabilities of station
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>vht_capa</term>
      <listitem><para>
VHT capabilities of station
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>uapsd_queues</term>
      <listitem><para>
bitmap of queues configured for uapsd. same format
as the AC bitmap in the QoS info field
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>max_sp</term>
      <listitem><para>
max Service Period. same format as the MAX_SP in the
QoS info field (but already shifted down)
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>local_pm</term>
      <listitem><para>
local link-specific mesh power save mode (no change when set
to unknown)
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>capability</term>
      <listitem><para>
station capability
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>ext_capab</term>
      <listitem><para>
extended capabilities of the station
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>ext_capab_len</term>
      <listitem><para>
number of extended capabilities
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>supported_channels</term>
      <listitem><para>
supported channels in IEEE 802.11 format
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>supported_channels_len</term>
      <listitem><para>
number of supported channels
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>supported_oper_classes</term>
      <listitem><para>
supported oper classes in IEEE 802.11 format
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>supported_oper_classes_len</term>
      <listitem><para>
number of supported operating classes
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>opmode_notif</term>
      <listitem><para>
operating mode field from Operating Mode Notification
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>opmode_notif_used</term>
      <listitem><para>
information if operating mode field is used
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
<refsect1>
<title>Description</title>
<para>
   </para><para>

   Used to change and create a new station.
</para>
</refsect1>
</refentry>

<refentry id="API-enum-station-info-flags">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>enum station_info_flags</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>enum station_info_flags</refname>
 <refpurpose>
  station information flags
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
enum station_info_flags {
  STATION_INFO_INACTIVE_TIME,
  STATION_INFO_RX_BYTES,
  STATION_INFO_TX_BYTES,
  STATION_INFO_LLID,
  STATION_INFO_PLID,
  STATION_INFO_PLINK_STATE,
  STATION_INFO_SIGNAL,
  STATION_INFO_TX_BITRATE,
  STATION_INFO_RX_PACKETS,
  STATION_INFO_TX_PACKETS,
  STATION_INFO_TX_RETRIES,
  STATION_INFO_TX_FAILED,
  STATION_INFO_RX_DROP_MISC,
  STATION_INFO_SIGNAL_AVG,
  STATION_INFO_RX_BITRATE,
  STATION_INFO_BSS_PARAM,
  STATION_INFO_CONNECTED_TIME,
  STATION_INFO_ASSOC_REQ_IES,
  STATION_INFO_STA_FLAGS,
  STATION_INFO_BEACON_LOSS_COUNT,
  STATION_INFO_T_OFFSET,
  STATION_INFO_LOCAL_PM,
  STATION_INFO_PEER_PM,
  STATION_INFO_NONPEER_PM,
  STATION_INFO_RX_BYTES64,
  STATION_INFO_TX_BYTES64,
  STATION_INFO_CHAIN_SIGNAL,
  STATION_INFO_CHAIN_SIGNAL_AVG,
  STATION_INFO_EXPECTED_THROUGHPUT
};  </programlisting>
</refsynopsisdiv>
<refsect1>
 <title>Constants</title>
  <variablelist>
    <varlistentry>      <term>STATION_INFO_INACTIVE_TIME</term>
      <listitem><para>
<parameter>inactive_time</parameter> filled
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>STATION_INFO_RX_BYTES</term>
      <listitem><para>
<parameter>rx_bytes</parameter> filled
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>STATION_INFO_TX_BYTES</term>
      <listitem><para>
<parameter>tx_bytes</parameter> filled
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>STATION_INFO_LLID</term>
      <listitem><para>
<parameter>llid</parameter> filled
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>STATION_INFO_PLID</term>
      <listitem><para>
<parameter>plid</parameter> filled
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>STATION_INFO_PLINK_STATE</term>
      <listitem><para>
<parameter>plink_state</parameter> filled
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>STATION_INFO_SIGNAL</term>
      <listitem><para>
<parameter>signal</parameter> filled
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>STATION_INFO_TX_BITRATE</term>
      <listitem><para>
<parameter>txrate</parameter> fields are filled
(tx_bitrate, tx_bitrate_flags and tx_bitrate_mcs)
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>STATION_INFO_RX_PACKETS</term>
      <listitem><para>
<parameter>rx_packets</parameter> filled with 32-bit value
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>STATION_INFO_TX_PACKETS</term>
      <listitem><para>
<parameter>tx_packets</parameter> filled with 32-bit value
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>STATION_INFO_TX_RETRIES</term>
      <listitem><para>
<parameter>tx_retries</parameter> filled
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>STATION_INFO_TX_FAILED</term>
      <listitem><para>
<parameter>tx_failed</parameter> filled
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>STATION_INFO_RX_DROP_MISC</term>
      <listitem><para>
<parameter>rx_dropped_misc</parameter> filled
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>STATION_INFO_SIGNAL_AVG</term>
      <listitem><para>
<parameter>signal_avg</parameter> filled
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>STATION_INFO_RX_BITRATE</term>
      <listitem><para>
<parameter>rxrate</parameter> fields are filled
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>STATION_INFO_BSS_PARAM</term>
      <listitem><para>
<parameter>bss_param</parameter> filled
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>STATION_INFO_CONNECTED_TIME</term>
      <listitem><para>
<parameter>connected_time</parameter> filled
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>STATION_INFO_ASSOC_REQ_IES</term>
      <listitem><para>
<parameter>assoc_req_ies</parameter> filled
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>STATION_INFO_STA_FLAGS</term>
      <listitem><para>
<parameter>sta_flags</parameter> filled
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>STATION_INFO_BEACON_LOSS_COUNT</term>
      <listitem><para>
<parameter>beacon_loss_count</parameter> filled
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>STATION_INFO_T_OFFSET</term>
      <listitem><para>
<parameter>t_offset</parameter> filled
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>STATION_INFO_LOCAL_PM</term>
      <listitem><para>
<parameter>local_pm</parameter> filled
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>STATION_INFO_PEER_PM</term>
      <listitem><para>
<parameter>peer_pm</parameter> filled
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>STATION_INFO_NONPEER_PM</term>
      <listitem><para>
<parameter>nonpeer_pm</parameter> filled
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>STATION_INFO_RX_BYTES64</term>
      <listitem><para>
<parameter>rx_bytes</parameter> filled with 64-bit value
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>STATION_INFO_TX_BYTES64</term>
      <listitem><para>
<parameter>tx_bytes</parameter> filled with 64-bit value
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>STATION_INFO_CHAIN_SIGNAL</term>
      <listitem><para>
<parameter>chain_signal</parameter> filled
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>STATION_INFO_CHAIN_SIGNAL_AVG</term>
      <listitem><para>
<parameter>chain_signal_avg</parameter> filled
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>STATION_INFO_EXPECTED_THROUGHPUT</term>
      <listitem><para>
<parameter>expected_throughput</parameter> filled
      </para></listitem>
    </varlistentry>
  </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   </para><para>

   Used by the driver to indicate which info in <structname>struct station_info</structname>
   it has filled in during <function>get_station</function> or <function>dump_station</function>.
</para>
</refsect1>
</refentry>

<refentry id="API-enum-rate-info-flags">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>enum rate_info_flags</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>enum rate_info_flags</refname>
 <refpurpose>
  bitrate info flags
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
enum rate_info_flags {
  RATE_INFO_FLAGS_MCS,
  RATE_INFO_FLAGS_VHT_MCS,
  RATE_INFO_FLAGS_40_MHZ_WIDTH,
  RATE_INFO_FLAGS_80_MHZ_WIDTH,
  RATE_INFO_FLAGS_80P80_MHZ_WIDTH,
  RATE_INFO_FLAGS_160_MHZ_WIDTH,
  RATE_INFO_FLAGS_SHORT_GI,
  RATE_INFO_FLAGS_60G
};  </programlisting>
</refsynopsisdiv>
<refsect1>
 <title>Constants</title>
  <variablelist>
    <varlistentry>      <term>RATE_INFO_FLAGS_MCS</term>
      <listitem><para>
mcs field filled with HT MCS
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>RATE_INFO_FLAGS_VHT_MCS</term>
      <listitem><para>
mcs field filled with VHT MCS
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>RATE_INFO_FLAGS_40_MHZ_WIDTH</term>
      <listitem><para>
40 MHz width transmission
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>RATE_INFO_FLAGS_80_MHZ_WIDTH</term>
      <listitem><para>
80 MHz width transmission
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>RATE_INFO_FLAGS_80P80_MHZ_WIDTH</term>
      <listitem><para>
80+80 MHz width transmission
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>RATE_INFO_FLAGS_160_MHZ_WIDTH</term>
      <listitem><para>
160 MHz width transmission
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>RATE_INFO_FLAGS_SHORT_GI</term>
      <listitem><para>
400ns guard interval
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>RATE_INFO_FLAGS_60G</term>
      <listitem><para>
60GHz MCS
      </para></listitem>
    </varlistentry>
  </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   </para><para>

   Used by the driver to indicate the specific rate transmission
   type for 802.11n transmissions.
</para>
</refsect1>
</refentry>

<refentry id="API-struct-rate-info">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct rate_info</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct rate_info</refname>
 <refpurpose>
  bitrate information
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct rate_info {
  u8 flags;
  u8 mcs;
  u16 legacy;
  u8 nss;
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>flags</term>
      <listitem><para>
bitflag of flags from <structname>enum</structname> rate_info_flags
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>mcs</term>
      <listitem><para>
mcs index if struct describes a 802.11n bitrate
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>legacy</term>
      <listitem><para>
bitrate in 100kbit/s for 802.11abg
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>nss</term>
      <listitem><para>
number of streams (VHT only)
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
<refsect1>
<title>Description</title>
<para>
   </para><para>

   Information about a receiving or transmitting bitrate
</para>
</refsect1>
</refentry>

<refentry id="API-struct-station-info">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct station_info</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct station_info</refname>
 <refpurpose>
  station information
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct station_info {
  u32 filled;
  u32 connected_time;
  u32 inactive_time;
  u64 rx_bytes;
  u64 tx_bytes;
  u16 llid;
  u16 plid;
  u8 plink_state;
  s8 signal;
  s8 signal_avg;
  u8 chains;
  s8 chain_signal[IEEE80211_MAX_CHAINS];
  s8 chain_signal_avg[IEEE80211_MAX_CHAINS];
  struct rate_info txrate;
  struct rate_info rxrate;
  u32 rx_packets;
  u32 tx_packets;
  u32 tx_retries;
  u32 tx_failed;
  u32 rx_dropped_misc;
  struct sta_bss_parameters bss_param;
  struct nl80211_sta_flag_update sta_flags;
  int generation;
  const u8 * assoc_req_ies;
  size_t assoc_req_ies_len;
  u32 beacon_loss_count;
  s64 t_offset;
  enum nl80211_mesh_power_mode local_pm;
  enum nl80211_mesh_power_mode peer_pm;
  enum nl80211_mesh_power_mode nonpeer_pm;
  u32 expected_throughput;
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>filled</term>
      <listitem><para>
bitflag of flags from <structname>enum</structname> station_info_flags
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>connected_time</term>
      <listitem><para>
time(in secs) since a station is last connected
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>inactive_time</term>
      <listitem><para>
time since last station activity (tx/rx) in milliseconds
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>rx_bytes</term>
      <listitem><para>
bytes received from this station
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>tx_bytes</term>
      <listitem><para>
bytes transmitted to this station
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>llid</term>
      <listitem><para>
mesh local link id
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>plid</term>
      <listitem><para>
mesh peer link id
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>plink_state</term>
      <listitem><para>
mesh peer link state
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>signal</term>
      <listitem><para>
The signal strength, type depends on the wiphy's signal_type.
For CFG80211_SIGNAL_TYPE_MBM, value is expressed in _dBm_.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>signal_avg</term>
      <listitem><para>
Average signal strength, type depends on the wiphy's signal_type.
For CFG80211_SIGNAL_TYPE_MBM, value is expressed in _dBm_.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>chains</term>
      <listitem><para>
bitmask for filled values in <parameter>chain_signal</parameter>, <parameter>chain_signal_avg</parameter>
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>chain_signal[IEEE80211_MAX_CHAINS]</term>
      <listitem><para>
per-chain signal strength of last received packet in dBm
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>chain_signal_avg[IEEE80211_MAX_CHAINS]</term>
      <listitem><para>
per-chain signal strength average in dBm
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>txrate</term>
      <listitem><para>
current unicast bitrate from this station
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>rxrate</term>
      <listitem><para>
current unicast bitrate to this station
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>rx_packets</term>
      <listitem><para>
packets received from this station
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>tx_packets</term>
      <listitem><para>
packets transmitted to this station
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>tx_retries</term>
      <listitem><para>
cumulative retry counts
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>tx_failed</term>
      <listitem><para>
number of failed transmissions (retries exceeded, no ACK)
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>rx_dropped_misc</term>
      <listitem><para>
Dropped for un-specified reason.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>bss_param</term>
      <listitem><para>
current BSS parameters
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>sta_flags</term>
      <listitem><para>
station flags mask &amp; values
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>generation</term>
      <listitem><para>
generation number for nl80211 dumps.
This number should increase every time the list of stations
changes, i.e. when a station is added or removed, so that
userspace can tell whether it got a consistent snapshot.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>assoc_req_ies</term>
      <listitem><para>
IEs from (Re)Association Request.
This is used only when in AP mode with drivers that do not use
user space MLME/SME implementation. The information is provided for
the <function>cfg80211_new_sta</function> calls to notify user space of the IEs.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>assoc_req_ies_len</term>
      <listitem><para>
Length of assoc_req_ies buffer in octets.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>beacon_loss_count</term>
      <listitem><para>
Number of times beacon loss event has triggered.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>t_offset</term>
      <listitem><para>
Time offset of the station relative to this host.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>local_pm</term>
      <listitem><para>
local mesh STA power save mode
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>peer_pm</term>
      <listitem><para>
peer mesh STA power save mode
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>nonpeer_pm</term>
      <listitem><para>
non-peer mesh STA power save mode
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>expected_throughput</term>
      <listitem><para>
expected throughput in kbps (including 802.11 headers)
towards this station.
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
<refsect1>
<title>Description</title>
<para>
   </para><para>

   Station information filled by driver for <function>get_station</function> and dump_station.
</para>
</refsect1>
</refentry>

<refentry id="API-enum-monitor-flags">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>enum monitor_flags</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>enum monitor_flags</refname>
 <refpurpose>
  monitor flags
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
enum monitor_flags {
  MONITOR_FLAG_FCSFAIL,
  MONITOR_FLAG_PLCPFAIL,
  MONITOR_FLAG_CONTROL,
  MONITOR_FLAG_OTHER_BSS,
  MONITOR_FLAG_COOK_FRAMES,
  MONITOR_FLAG_ACTIVE
};  </programlisting>
</refsynopsisdiv>
<refsect1>
 <title>Constants</title>
  <variablelist>
    <varlistentry>      <term>MONITOR_FLAG_FCSFAIL</term>
      <listitem><para>
pass frames with bad FCS
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>MONITOR_FLAG_PLCPFAIL</term>
      <listitem><para>
pass frames with bad PLCP
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>MONITOR_FLAG_CONTROL</term>
      <listitem><para>
pass control frames
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>MONITOR_FLAG_OTHER_BSS</term>
      <listitem><para>
disable BSSID filtering
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>MONITOR_FLAG_COOK_FRAMES</term>
      <listitem><para>
report frames after processing
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>MONITOR_FLAG_ACTIVE</term>
      <listitem><para>
active monitor, ACKs frames on its MAC address
      </para></listitem>
    </varlistentry>
  </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   </para><para>

   Monitor interface configuration flags. Note that these must be the bits
   according to the nl80211 flags.
</para>
</refsect1>
</refentry>

<refentry id="API-enum-mpath-info-flags">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>enum mpath_info_flags</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>enum mpath_info_flags</refname>
 <refpurpose>
  mesh path information flags
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
enum mpath_info_flags {
  MPATH_INFO_FRAME_QLEN,
  MPATH_INFO_SN,
  MPATH_INFO_METRIC,
  MPATH_INFO_EXPTIME,
  MPATH_INFO_DISCOVERY_TIMEOUT,
  MPATH_INFO_DISCOVERY_RETRIES,
  MPATH_INFO_FLAGS
};  </programlisting>
</refsynopsisdiv>
<refsect1>
 <title>Constants</title>
  <variablelist>
    <varlistentry>      <term>MPATH_INFO_FRAME_QLEN</term>
      <listitem><para>
<parameter>frame_qlen</parameter> filled
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>MPATH_INFO_SN</term>
      <listitem><para>
<parameter>sn</parameter> filled
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>MPATH_INFO_METRIC</term>
      <listitem><para>
<parameter>metric</parameter> filled
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>MPATH_INFO_EXPTIME</term>
      <listitem><para>
<parameter>exptime</parameter> filled
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>MPATH_INFO_DISCOVERY_TIMEOUT</term>
      <listitem><para>
<parameter>discovery_timeout</parameter> filled
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>MPATH_INFO_DISCOVERY_RETRIES</term>
      <listitem><para>
<parameter>discovery_retries</parameter> filled
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>MPATH_INFO_FLAGS</term>
      <listitem><para>
<parameter>flags</parameter> filled
      </para></listitem>
    </varlistentry>
  </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   </para><para>

   Used by the driver to indicate which info in <structname>struct mpath_info</structname> it has filled
   in during <function>get_station</function> or <function>dump_station</function>.
</para>
</refsect1>
</refentry>

<refentry id="API-struct-mpath-info">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct mpath_info</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct mpath_info</refname>
 <refpurpose>
  mesh path information
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct mpath_info {
  u32 filled;
  u32 frame_qlen;
  u32 sn;
  u32 metric;
  u32 exptime;
  u32 discovery_timeout;
  u8 discovery_retries;
  u8 flags;
  int generation;
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>filled</term>
      <listitem><para>
bitfield of flags from <structname>enum</structname> mpath_info_flags
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>frame_qlen</term>
      <listitem><para>
number of queued frames for this destination
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>sn</term>
      <listitem><para>
target sequence number
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>metric</term>
      <listitem><para>
metric (cost) of this mesh path
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>exptime</term>
      <listitem><para>
expiration time for the mesh path from now, in msecs
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>discovery_timeout</term>
      <listitem><para>
total mesh path discovery timeout, in msecs
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>discovery_retries</term>
      <listitem><para>
mesh path discovery retries
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>flags</term>
      <listitem><para>
mesh path flags
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>generation</term>
      <listitem><para>
generation number for nl80211 dumps.
This number should increase every time the list of mesh paths
changes, i.e. when a station is added or removed, so that
userspace can tell whether it got a consistent snapshot.
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
<refsect1>
<title>Description</title>
<para>
   </para><para>

   Mesh path information filled by driver for <function>get_mpath</function> and <function>dump_mpath</function>.
</para>
</refsect1>
</refentry>

<refentry id="API-struct-bss-parameters">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct bss_parameters</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct bss_parameters</refname>
 <refpurpose>
  BSS parameters
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct bss_parameters {
  int use_cts_prot;
  int use_short_preamble;
  int use_short_slot_time;
  const u8 * basic_rates;
  u8 basic_rates_len;
  int ap_isolate;
  int ht_opmode;
  s8 p2p_ctwindow;
  s8 p2p_opp_ps;
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>use_cts_prot</term>
      <listitem><para>
Whether to use CTS protection
(0 = no, 1 = yes, -1 = do not change)
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>use_short_preamble</term>
      <listitem><para>
Whether the use of short preambles is allowed
(0 = no, 1 = yes, -1 = do not change)
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>use_short_slot_time</term>
      <listitem><para>
Whether the use of short slot time is allowed
(0 = no, 1 = yes, -1 = do not change)
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>basic_rates</term>
      <listitem><para>
basic rates in IEEE 802.11 format
(or NULL for no change)
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>basic_rates_len</term>
      <listitem><para>
number of basic rates
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>ap_isolate</term>
      <listitem><para>
do not forward packets between connected stations
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>ht_opmode</term>
      <listitem><para>
HT Operation mode
(u16 = opmode, -1 = do not change)
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>p2p_ctwindow</term>
      <listitem><para>
P2P CT Window (-1 = no change)
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>p2p_opp_ps</term>
      <listitem><para>
P2P opportunistic PS (-1 = no change)
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
<refsect1>
<title>Description</title>
<para>
   </para><para>

   Used to change BSS parameters (mainly for AP mode).
</para>
</refsect1>
</refentry>

<refentry id="API-struct-ieee80211-txq-params">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct ieee80211_txq_params</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct ieee80211_txq_params</refname>
 <refpurpose>
  TX queue parameters
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct ieee80211_txq_params {
  enum nl80211_ac ac;
  u16 txop;
  u16 cwmin;
  u16 cwmax;
  u8 aifs;
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>ac</term>
      <listitem><para>
AC identifier
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>txop</term>
      <listitem><para>
Maximum burst time in units of 32 usecs, 0 meaning disabled
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>cwmin</term>
      <listitem><para>
Minimum contention window [a value of the form 2^n-1 in the range
1..32767]
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>cwmax</term>
      <listitem><para>
Maximum contention window [a value of the form 2^n-1 in the range
1..32767]
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>aifs</term>
      <listitem><para>
Arbitration interframe space [0..255]
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
</refentry>

<refentry id="API-struct-cfg80211-crypto-settings">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct cfg80211_crypto_settings</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct cfg80211_crypto_settings</refname>
 <refpurpose>
  Crypto settings
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct cfg80211_crypto_settings {
  u32 wpa_versions;
  u32 cipher_group;
  int n_ciphers_pairwise;
  u32 ciphers_pairwise[NL80211_MAX_NR_CIPHER_SUITES];
  int n_akm_suites;
  u32 akm_suites[NL80211_MAX_NR_AKM_SUITES];
  bool control_port;
  __be16 control_port_ethertype;
  bool control_port_no_encrypt;
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>wpa_versions</term>
      <listitem><para>
indicates which, if any, WPA versions are enabled
(from enum nl80211_wpa_versions)
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>cipher_group</term>
      <listitem><para>
group key cipher suite (or 0 if unset)
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>n_ciphers_pairwise</term>
      <listitem><para>
number of AP supported unicast ciphers
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>ciphers_pairwise[NL80211_MAX_NR_CIPHER_SUITES]</term>
      <listitem><para>
unicast key cipher suites
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>n_akm_suites</term>
      <listitem><para>
number of AKM suites
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>akm_suites[NL80211_MAX_NR_AKM_SUITES]</term>
      <listitem><para>
AKM suites
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>control_port</term>
      <listitem><para>
Whether user space controls IEEE 802.1X port, i.e.,
sets/clears <constant>NL80211_STA_FLAG_AUTHORIZED</constant>. If true, the driver is
required to assume that the port is unauthorized until authorized by
user space. Otherwise, port is marked authorized by default.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>control_port_ethertype</term>
      <listitem><para>
the control port protocol that should be
allowed through even on unauthorized ports
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>control_port_no_encrypt</term>
      <listitem><para>
TRUE to prevent encryption of control port
protocol frames.
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
</refentry>

<refentry id="API-struct-cfg80211-auth-request">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct cfg80211_auth_request</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct cfg80211_auth_request</refname>
 <refpurpose>
  Authentication request data
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct cfg80211_auth_request {
  struct cfg80211_bss * bss;
  const u8 * ie;
  size_t ie_len;
  enum nl80211_auth_type auth_type;
  const u8 * key;
  u8 key_len;
  u8 key_idx;
  const u8 * sae_data;
  size_t sae_data_len;
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>bss</term>
      <listitem><para>
The BSS to authenticate with, the callee must obtain a reference
to it if it needs to keep it.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>ie</term>
      <listitem><para>
Extra IEs to add to Authentication frame or <constant>NULL</constant>
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>ie_len</term>
      <listitem><para>
Length of ie buffer in octets
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>auth_type</term>
      <listitem><para>
Authentication type (algorithm)
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>key</term>
      <listitem><para>
WEP key for shared key authentication
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>key_len</term>
      <listitem><para>
length of WEP key for shared key authentication
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>key_idx</term>
      <listitem><para>
index of WEP key for shared key authentication
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>sae_data</term>
      <listitem><para>
Non-IE data to use with SAE or <constant>NULL</constant>. This starts with
Authentication transaction sequence number field.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>sae_data_len</term>
      <listitem><para>
Length of sae_data buffer in octets
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
<refsect1>
<title>Description</title>
<para>
   </para><para>

   This structure provides information needed to complete IEEE 802.11
   authentication.
</para>
</refsect1>
</refentry>

<refentry id="API-struct-cfg80211-assoc-request">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct cfg80211_assoc_request</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct cfg80211_assoc_request</refname>
 <refpurpose>
  (Re)Association request data
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct cfg80211_assoc_request {
  struct cfg80211_bss * bss;
  const u8 * ie;
  const u8 * prev_bssid;
  size_t ie_len;
  struct cfg80211_crypto_settings crypto;
  bool use_mfp;
  u32 flags;
  struct ieee80211_ht_cap ht_capa;
  struct ieee80211_ht_cap ht_capa_mask;
  struct ieee80211_vht_cap vht_capa;
  struct ieee80211_vht_cap vht_capa_mask;
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>bss</term>
      <listitem><para>
The BSS to associate with. If the call is successful the driver is
given a reference that it must give back to <function>cfg80211_send_rx_assoc</function>
or to <function>cfg80211_assoc_timeout</function>. To ensure proper refcounting, new
association requests while already associating must be rejected.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>ie</term>
      <listitem><para>
Extra IEs to add to (Re)Association Request frame or <constant>NULL</constant>
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>prev_bssid</term>
      <listitem><para>
previous BSSID, if not <constant>NULL</constant> use reassociate frame
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>ie_len</term>
      <listitem><para>
Length of ie buffer in octets
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>crypto</term>
      <listitem><para>
crypto settings
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>use_mfp</term>
      <listitem><para>
Use management frame protection (IEEE 802.11w) in this association
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>flags</term>
      <listitem><para>
See <structname>enum</structname> cfg80211_assoc_req_flags
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>ht_capa</term>
      <listitem><para>
HT Capabilities over-rides.  Values set in ht_capa_mask
will be used in ht_capa.  Un-supported values will be ignored.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>ht_capa_mask</term>
      <listitem><para>
The bits of ht_capa which are to be used.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>vht_capa</term>
      <listitem><para>
VHT capability override
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>vht_capa_mask</term>
      <listitem><para>
VHT capability mask indicating which fields to use
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
<refsect1>
<title>Description</title>
<para>
   </para><para>

   This structure provides information needed to complete IEEE 802.11
   (re)association.
</para>
</refsect1>
</refentry>

<refentry id="API-struct-cfg80211-deauth-request">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct cfg80211_deauth_request</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct cfg80211_deauth_request</refname>
 <refpurpose>
  Deauthentication request data
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct cfg80211_deauth_request {
  const u8 * bssid;
  const u8 * ie;
  size_t ie_len;
  u16 reason_code;
  bool local_state_change;
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>bssid</term>
      <listitem><para>
the BSSID of the BSS to deauthenticate from
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>ie</term>
      <listitem><para>
Extra IEs to add to Deauthentication frame or <constant>NULL</constant>
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>ie_len</term>
      <listitem><para>
Length of ie buffer in octets
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>reason_code</term>
      <listitem><para>
The reason code for the deauthentication
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>local_state_change</term>
      <listitem><para>
if set, change local state only and
do not set a deauth frame
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
<refsect1>
<title>Description</title>
<para>
   </para><para>

   This structure provides information needed to complete IEEE 802.11
   deauthentication.
</para>
</refsect1>
</refentry>

<refentry id="API-struct-cfg80211-disassoc-request">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct cfg80211_disassoc_request</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct cfg80211_disassoc_request</refname>
 <refpurpose>
  Disassociation request data
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct cfg80211_disassoc_request {
  struct cfg80211_bss * bss;
  const u8 * ie;
  size_t ie_len;
  u16 reason_code;
  bool local_state_change;
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>bss</term>
      <listitem><para>
the BSS to disassociate from
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>ie</term>
      <listitem><para>
Extra IEs to add to Disassociation frame or <constant>NULL</constant>
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>ie_len</term>
      <listitem><para>
Length of ie buffer in octets
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>reason_code</term>
      <listitem><para>
The reason code for the disassociation
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>local_state_change</term>
      <listitem><para>
This is a request for a local state only, i.e., no
Disassociation frame is to be transmitted.
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
<refsect1>
<title>Description</title>
<para>
   </para><para>

   This structure provides information needed to complete IEEE 802.11
   disassocation.
</para>
</refsect1>
</refentry>

<refentry id="API-struct-cfg80211-ibss-params">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct cfg80211_ibss_params</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct cfg80211_ibss_params</refname>
 <refpurpose>
  IBSS parameters
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct cfg80211_ibss_params {
  const u8 * ssid;
  const u8 * bssid;
  struct cfg80211_chan_def chandef;
  const u8 * ie;
  u8 ssid_len;
  u8 ie_len;
  u16 beacon_interval;
  u32 basic_rates;
  bool channel_fixed;
  bool privacy;
  bool control_port;
  bool userspace_handles_dfs;
  int mcast_rate[IEEE80211_NUM_BANDS];
  struct ieee80211_ht_cap ht_capa;
  struct ieee80211_ht_cap ht_capa_mask;
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>ssid</term>
      <listitem><para>
The SSID, will always be non-null.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>bssid</term>
      <listitem><para>
Fixed BSSID requested, maybe be <constant>NULL</constant>, if set do not
search for IBSSs with a different BSSID.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>chandef</term>
      <listitem><para>
defines the channel to use if no other IBSS to join can be found
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>ie</term>
      <listitem><para>
information element(s) to include in the beacon
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>ssid_len</term>
      <listitem><para>
The length of the SSID, will always be non-zero.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>ie_len</term>
      <listitem><para>
length of that
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>beacon_interval</term>
      <listitem><para>
beacon interval to use
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>basic_rates</term>
      <listitem><para>
bitmap of basic rates to use when creating the IBSS
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>channel_fixed</term>
      <listitem><para>
The channel should be fixed -- do not search for
IBSSs to join on other channels.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>privacy</term>
      <listitem><para>
this is a protected network, keys will be configured
after joining
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>control_port</term>
      <listitem><para>
whether user space controls IEEE 802.1X port, i.e.,
sets/clears <constant>NL80211_STA_FLAG_AUTHORIZED</constant>. If true, the driver is
required to assume that the port is unauthorized until authorized by
user space. Otherwise, port is marked authorized by default.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>userspace_handles_dfs</term>
      <listitem><para>
whether user space controls DFS operation, i.e.
changes the channel when a radar is detected. This is required
to operate on DFS channels.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>mcast_rate[IEEE80211_NUM_BANDS]</term>
      <listitem><para>
per-band multicast rate index + 1 (0: disabled)
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>ht_capa</term>
      <listitem><para>
HT Capabilities over-rides.  Values set in ht_capa_mask
will be used in ht_capa.  Un-supported values will be ignored.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>ht_capa_mask</term>
      <listitem><para>
The bits of ht_capa which are to be used.
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
<refsect1>
<title>Description</title>
<para>
   </para><para>

   This structure defines the IBSS parameters for the <function>join_ibss</function>
   method.
</para>
</refsect1>
</refentry>

<refentry id="API-struct-cfg80211-connect-params">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct cfg80211_connect_params</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct cfg80211_connect_params</refname>
 <refpurpose>
  Connection parameters
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct cfg80211_connect_params {
  struct ieee80211_channel * channel;
  struct ieee80211_channel * channel_hint;
  const u8 * bssid;
  const u8 * bssid_hint;
  const u8 * ssid;
  size_t ssid_len;
  enum nl80211_auth_type auth_type;
  const u8 * ie;
  size_t ie_len;
  bool privacy;
  enum nl80211_mfp mfp;
  struct cfg80211_crypto_settings crypto;
  const u8 * key;
  u8 key_len;
  u8 key_idx;
  u32 flags;
  int bg_scan_period;
  struct ieee80211_ht_cap ht_capa;
  struct ieee80211_ht_cap ht_capa_mask;
  struct ieee80211_vht_cap vht_capa;
  struct ieee80211_vht_cap vht_capa_mask;
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>channel</term>
      <listitem><para>
The channel to use or <constant>NULL</constant> if not specified (auto-select based
on scan results)
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>channel_hint</term>
      <listitem><para>
The channel of the recommended BSS for initial connection or
<constant>NULL</constant> if not specified
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>bssid</term>
      <listitem><para>
The AP BSSID or <constant>NULL</constant> if not specified (auto-select based on scan
results)
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>bssid_hint</term>
      <listitem><para>
The recommended AP BSSID for initial connection to the BSS or
<constant>NULL</constant> if not specified. Unlike the <parameter>bssid</parameter> parameter, the driver is
allowed to ignore this <parameter>bssid_hint</parameter> if it has knowledge of a better BSS
to use.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>ssid</term>
      <listitem><para>
SSID
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>ssid_len</term>
      <listitem><para>
Length of ssid in octets
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>auth_type</term>
      <listitem><para>
Authentication type (algorithm)
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>ie</term>
      <listitem><para>
IEs for association request
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>ie_len</term>
      <listitem><para>
Length of assoc_ie in octets
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>privacy</term>
      <listitem><para>
indicates whether privacy-enabled APs should be used
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>mfp</term>
      <listitem><para>
indicate whether management frame protection is used
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>crypto</term>
      <listitem><para>
crypto settings
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>key</term>
      <listitem><para>
WEP key for shared key authentication
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>key_len</term>
      <listitem><para>
length of WEP key for shared key authentication
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>key_idx</term>
      <listitem><para>
index of WEP key for shared key authentication
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>flags</term>
      <listitem><para>
See <structname>enum</structname> cfg80211_assoc_req_flags
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>bg_scan_period</term>
      <listitem><para>
Background scan period in seconds
or -1 to indicate that default value is to be used.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>ht_capa</term>
      <listitem><para>
HT Capabilities over-rides.  Values set in ht_capa_mask
will be used in ht_capa.  Un-supported values will be ignored.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>ht_capa_mask</term>
      <listitem><para>
The bits of ht_capa which are to be used.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>vht_capa</term>
      <listitem><para>
VHT Capability overrides
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>vht_capa_mask</term>
      <listitem><para>
The bits of vht_capa which are to be used.
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
<refsect1>
<title>Description</title>
<para>
   </para><para>

   This structure provides information needed to complete IEEE 802.11
   authentication and association.
</para>
</refsect1>
</refentry>

<refentry id="API-struct-cfg80211-pmksa">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct cfg80211_pmksa</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct cfg80211_pmksa</refname>
 <refpurpose>
  PMK Security Association
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct cfg80211_pmksa {
  const u8 * bssid;
  const u8 * pmkid;
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>bssid</term>
      <listitem><para>
The AP's BSSID.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>pmkid</term>
      <listitem><para>
The PMK material itself.
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
<refsect1>
<title>Description</title>
<para>
   </para><para>

   This structure is passed to the set/<function>del_pmksa</function> method for PMKSA
   caching.
</para>
</refsect1>
</refentry>

<refentry id="API-cfg80211-rx-mlme-mgmt">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>cfg80211_rx_mlme_mgmt</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>cfg80211_rx_mlme_mgmt</refname>
 <refpurpose>
  notification of processed MLME management frame
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>cfg80211_rx_mlme_mgmt </function></funcdef>
   <paramdef>struct net_device * <parameter>dev</parameter></paramdef>
   <paramdef>const u8 * <parameter>buf</parameter></paramdef>
   <paramdef>size_t <parameter>len</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     network device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>buf</parameter></term>
   <listitem>
    <para>
     authentication frame (header + body)
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>len</parameter></term>
   <listitem>
    <para>
     length of the frame data
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This function is called whenever an authentication, disassociation or
   deauthentication frame has been received and processed in station mode.
</para>
</refsect1>
<refsect1>
<title>After being asked to authenticate via cfg80211_ops</title>
<para>
   :<function>auth</function> the driver must
   call either this function or <function>cfg80211_auth_timeout</function>.
</para>
</refsect1>
<refsect1>
<title>After being asked to associate via cfg80211_ops</title>
<para>
   :<function>assoc</function> the driver must
   call either this function or <function>cfg80211_auth_timeout</function>.
   While connected, the driver must calls this for received and processed
   disassociation and deauthentication frames. If the frame couldn't be used
   because it was unprotected, the driver must call the function
   <function>cfg80211_rx_unprot_mlme_mgmt</function> instead.
   </para><para>

   This function may sleep. The caller must hold the corresponding wdev's mutex.
</para>
</refsect1>
</refentry>

<refentry id="API-cfg80211-auth-timeout">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>cfg80211_auth_timeout</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>cfg80211_auth_timeout</refname>
 <refpurpose>
  notification of timed out authentication
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>cfg80211_auth_timeout </function></funcdef>
   <paramdef>struct net_device * <parameter>dev</parameter></paramdef>
   <paramdef>const u8 * <parameter>addr</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     network device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>addr</parameter></term>
   <listitem>
    <para>
     The MAC address of the device with which the authentication timed out
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This function may sleep. The caller must hold the corresponding wdev's
   mutex.
</para>
</refsect1>
</refentry>

<refentry id="API-cfg80211-rx-assoc-resp">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>cfg80211_rx_assoc_resp</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>cfg80211_rx_assoc_resp</refname>
 <refpurpose>
  notification of processed association response
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>cfg80211_rx_assoc_resp </function></funcdef>
   <paramdef>struct net_device * <parameter>dev</parameter></paramdef>
   <paramdef>struct cfg80211_bss * <parameter>bss</parameter></paramdef>
   <paramdef>const u8 * <parameter>buf</parameter></paramdef>
   <paramdef>size_t <parameter>len</parameter></paramdef>
   <paramdef>int <parameter>uapsd_queues</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     network device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>bss</parameter></term>
   <listitem>
    <para>
     the BSS that association was requested with, ownership of the pointer
     moves to cfg80211 in this call
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>buf</parameter></term>
   <listitem>
    <para>
     authentication frame (header + body)
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>len</parameter></term>
   <listitem>
    <para>
     length of the frame data
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>uapsd_queues</parameter></term>
   <listitem>
    <para>
     bitmap of ACs configured to uapsd. -1 if n/a.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>After being asked to associate via cfg80211_ops</title>
<para>
   :<function>assoc</function> the driver must
   call either this function or <function>cfg80211_auth_timeout</function>.
   </para><para>

   This function may sleep. The caller must hold the corresponding wdev's mutex.
</para>
</refsect1>
</refentry>

<refentry id="API-cfg80211-assoc-timeout">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>cfg80211_assoc_timeout</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>cfg80211_assoc_timeout</refname>
 <refpurpose>
  notification of timed out association
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>cfg80211_assoc_timeout </function></funcdef>
   <paramdef>struct net_device * <parameter>dev</parameter></paramdef>
   <paramdef>struct cfg80211_bss * <parameter>bss</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     network device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>bss</parameter></term>
   <listitem>
    <para>
     The BSS entry with which association timed out.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This function may sleep. The caller must hold the corresponding wdev's mutex.
</para>
</refsect1>
</refentry>

<refentry id="API-cfg80211-tx-mlme-mgmt">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>cfg80211_tx_mlme_mgmt</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>cfg80211_tx_mlme_mgmt</refname>
 <refpurpose>
  notification of transmitted deauth/disassoc frame
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>cfg80211_tx_mlme_mgmt </function></funcdef>
   <paramdef>struct net_device * <parameter>dev</parameter></paramdef>
   <paramdef>const u8 * <parameter>buf</parameter></paramdef>
   <paramdef>size_t <parameter>len</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     network device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>buf</parameter></term>
   <listitem>
    <para>
     802.11 frame (header + body)
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>len</parameter></term>
   <listitem>
    <para>
     length of the frame data
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This function is called whenever deauthentication has been processed in
   station mode. This includes both received deauthentication frames and
   locally generated ones. This function may sleep. The caller must hold the
   corresponding wdev's mutex.
</para>
</refsect1>
</refentry>

<refentry id="API-cfg80211-ibss-joined">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>cfg80211_ibss_joined</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>cfg80211_ibss_joined</refname>
 <refpurpose>
  notify cfg80211 that device joined an IBSS
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>cfg80211_ibss_joined </function></funcdef>
   <paramdef>struct net_device * <parameter>dev</parameter></paramdef>
   <paramdef>const u8 * <parameter>bssid</parameter></paramdef>
   <paramdef>struct ieee80211_channel * <parameter>channel</parameter></paramdef>
   <paramdef>gfp_t <parameter>gfp</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     network device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>bssid</parameter></term>
   <listitem>
    <para>
     the BSSID of the IBSS joined
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>channel</parameter></term>
   <listitem>
    <para>
     the channel of the IBSS joined
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>gfp</parameter></term>
   <listitem>
    <para>
     allocation flags
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This function notifies cfg80211 that the device joined an IBSS or
   switched to a different BSSID. Before this function can be called,
   either a beacon has to have been received from the IBSS, or one of
   the cfg80211_inform_bss{,_frame} functions must have been called
   with the locally generated beacon -- this guarantees that there is
   always a scan result for this IBSS. cfg80211 will handle the rest.
</para>
</refsect1>
</refentry>

<refentry id="API-cfg80211-connect-result">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>cfg80211_connect_result</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>cfg80211_connect_result</refname>
 <refpurpose>
  notify cfg80211 of connection result
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>cfg80211_connect_result </function></funcdef>
   <paramdef>struct net_device * <parameter>dev</parameter></paramdef>
   <paramdef>const u8 * <parameter>bssid</parameter></paramdef>
   <paramdef>const u8 * <parameter>req_ie</parameter></paramdef>
   <paramdef>size_t <parameter>req_ie_len</parameter></paramdef>
   <paramdef>const u8 * <parameter>resp_ie</parameter></paramdef>
   <paramdef>size_t <parameter>resp_ie_len</parameter></paramdef>
   <paramdef>u16 <parameter>status</parameter></paramdef>
   <paramdef>gfp_t <parameter>gfp</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     network device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>bssid</parameter></term>
   <listitem>
    <para>
     the BSSID of the AP
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>req_ie</parameter></term>
   <listitem>
    <para>
     association request IEs (maybe be <constant>NULL</constant>)
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>req_ie_len</parameter></term>
   <listitem>
    <para>
     association request IEs length
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>resp_ie</parameter></term>
   <listitem>
    <para>
     association response IEs (may be <constant>NULL</constant>)
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>resp_ie_len</parameter></term>
   <listitem>
    <para>
     assoc response IEs length
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>status</parameter></term>
   <listitem>
    <para>
     status code, 0 for successful connection, use
     <constant>WLAN_STATUS_UNSPECIFIED_FAILURE</constant> if your device cannot give you
     the real status code for failures.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>gfp</parameter></term>
   <listitem>
    <para>
     allocation flags
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   It should be called by the underlying driver whenever <function>connect</function> has
   succeeded.
</para>
</refsect1>
</refentry>

<refentry id="API-cfg80211-roamed">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>cfg80211_roamed</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>cfg80211_roamed</refname>
 <refpurpose>
  notify cfg80211 of roaming
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>cfg80211_roamed </function></funcdef>
   <paramdef>struct net_device * <parameter>dev</parameter></paramdef>
   <paramdef>struct ieee80211_channel * <parameter>channel</parameter></paramdef>
   <paramdef>const u8 * <parameter>bssid</parameter></paramdef>
   <paramdef>const u8 * <parameter>req_ie</parameter></paramdef>
   <paramdef>size_t <parameter>req_ie_len</parameter></paramdef>
   <paramdef>const u8 * <parameter>resp_ie</parameter></paramdef>
   <paramdef>size_t <parameter>resp_ie_len</parameter></paramdef>
   <paramdef>gfp_t <parameter>gfp</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     network device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>channel</parameter></term>
   <listitem>
    <para>
     the channel of the new AP
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>bssid</parameter></term>
   <listitem>
    <para>
     the BSSID of the new AP
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>req_ie</parameter></term>
   <listitem>
    <para>
     association request IEs (maybe be <constant>NULL</constant>)
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>req_ie_len</parameter></term>
   <listitem>
    <para>
     association request IEs length
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>resp_ie</parameter></term>
   <listitem>
    <para>
     association response IEs (may be <constant>NULL</constant>)
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>resp_ie_len</parameter></term>
   <listitem>
    <para>
     assoc response IEs length
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>gfp</parameter></term>
   <listitem>
    <para>
     allocation flags
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   It should be called by the underlying driver whenever it roamed
   from one AP to another while connected.
</para>
</refsect1>
</refentry>

<refentry id="API-cfg80211-disconnected">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>cfg80211_disconnected</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>cfg80211_disconnected</refname>
 <refpurpose>
  notify cfg80211 that connection was dropped
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>cfg80211_disconnected </function></funcdef>
   <paramdef>struct net_device * <parameter>dev</parameter></paramdef>
   <paramdef>u16 <parameter>reason</parameter></paramdef>
   <paramdef>const u8 * <parameter>ie</parameter></paramdef>
   <paramdef>size_t <parameter>ie_len</parameter></paramdef>
   <paramdef>gfp_t <parameter>gfp</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     network device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>reason</parameter></term>
   <listitem>
    <para>
     reason code for the disconnection, set it to 0 if unknown
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>ie</parameter></term>
   <listitem>
    <para>
     information elements of the deauth/disassoc frame (may be <constant>NULL</constant>)
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>ie_len</parameter></term>
   <listitem>
    <para>
     length of IEs
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>gfp</parameter></term>
   <listitem>
    <para>
     allocation flags
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   After it calls this function, the driver should enter an idle state
   and not try to connect to any AP any more.
</para>
</refsect1>
</refentry>

<refentry id="API-cfg80211-ready-on-channel">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>cfg80211_ready_on_channel</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>cfg80211_ready_on_channel</refname>
 <refpurpose>
  notification of remain_on_channel start
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>cfg80211_ready_on_channel </function></funcdef>
   <paramdef>struct wireless_dev * <parameter>wdev</parameter></paramdef>
   <paramdef>u64 <parameter>cookie</parameter></paramdef>
   <paramdef>struct ieee80211_channel * <parameter>chan</parameter></paramdef>
   <paramdef>unsigned int <parameter>duration</parameter></paramdef>
   <paramdef>gfp_t <parameter>gfp</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>wdev</parameter></term>
   <listitem>
    <para>
     wireless device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>cookie</parameter></term>
   <listitem>
    <para>
     the request cookie
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>chan</parameter></term>
   <listitem>
    <para>
     The current channel (from remain_on_channel request)
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>duration</parameter></term>
   <listitem>
    <para>
     Duration in milliseconds that the driver intents to remain on the
     channel
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>gfp</parameter></term>
   <listitem>
    <para>
     allocation flags
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-cfg80211-remain-on-channel-expired">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>cfg80211_remain_on_channel_expired</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>cfg80211_remain_on_channel_expired</refname>
 <refpurpose>
  remain_on_channel duration expired
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>cfg80211_remain_on_channel_expired </function></funcdef>
   <paramdef>struct wireless_dev * <parameter>wdev</parameter></paramdef>
   <paramdef>u64 <parameter>cookie</parameter></paramdef>
   <paramdef>struct ieee80211_channel * <parameter>chan</parameter></paramdef>
   <paramdef>gfp_t <parameter>gfp</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>wdev</parameter></term>
   <listitem>
    <para>
     wireless device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>cookie</parameter></term>
   <listitem>
    <para>
     the request cookie
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>chan</parameter></term>
   <listitem>
    <para>
     The current channel (from remain_on_channel request)
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>gfp</parameter></term>
   <listitem>
    <para>
     allocation flags
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-cfg80211-new-sta">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>cfg80211_new_sta</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>cfg80211_new_sta</refname>
 <refpurpose>
  notify userspace about station
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>cfg80211_new_sta </function></funcdef>
   <paramdef>struct net_device * <parameter>dev</parameter></paramdef>
   <paramdef>const u8 * <parameter>mac_addr</parameter></paramdef>
   <paramdef>struct station_info * <parameter>sinfo</parameter></paramdef>
   <paramdef>gfp_t <parameter>gfp</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     the netdev
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>mac_addr</parameter></term>
   <listitem>
    <para>
     the station's address
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>sinfo</parameter></term>
   <listitem>
    <para>
     the station information
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>gfp</parameter></term>
   <listitem>
    <para>
     allocation flags
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-cfg80211-rx-mgmt">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>cfg80211_rx_mgmt</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>cfg80211_rx_mgmt</refname>
 <refpurpose>
  notification of received, unprocessed management frame
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>bool <function>cfg80211_rx_mgmt </function></funcdef>
   <paramdef>struct wireless_dev * <parameter>wdev</parameter></paramdef>
   <paramdef>int <parameter>freq</parameter></paramdef>
   <paramdef>int <parameter>sig_dbm</parameter></paramdef>
   <paramdef>const u8 * <parameter>buf</parameter></paramdef>
   <paramdef>size_t <parameter>len</parameter></paramdef>
   <paramdef>u32 <parameter>flags</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>wdev</parameter></term>
   <listitem>
    <para>
     wireless device receiving the frame
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>freq</parameter></term>
   <listitem>
    <para>
     Frequency on which the frame was received in MHz
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>sig_dbm</parameter></term>
   <listitem>
    <para>
     signal strength in mBm, or 0 if unknown
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>buf</parameter></term>
   <listitem>
    <para>
     Management frame (header + body)
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>len</parameter></term>
   <listitem>
    <para>
     length of the frame data
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>flags</parameter></term>
   <listitem>
    <para>
     flags, as defined in enum nl80211_rxmgmt_flags
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This function is called whenever an Action frame is received for a station
   mode interface, but is not processed in kernel.
</para>
</refsect1>
<refsect1>
<title>Return</title>
<para>
   <constant>true</constant> if a user space application has registered for this frame.
   For action frames, that makes it responsible for rejecting unrecognized
   action frames; <constant>false</constant> otherwise, in which case for action frames the
   driver is responsible for rejecting the frame.
</para>
</refsect1>
</refentry>

<refentry id="API-cfg80211-mgmt-tx-status">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>cfg80211_mgmt_tx_status</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>cfg80211_mgmt_tx_status</refname>
 <refpurpose>
  notification of TX status for management frame
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>cfg80211_mgmt_tx_status </function></funcdef>
   <paramdef>struct wireless_dev * <parameter>wdev</parameter></paramdef>
   <paramdef>u64 <parameter>cookie</parameter></paramdef>
   <paramdef>const u8 * <parameter>buf</parameter></paramdef>
   <paramdef>size_t <parameter>len</parameter></paramdef>
   <paramdef>bool <parameter>ack</parameter></paramdef>
   <paramdef>gfp_t <parameter>gfp</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>wdev</parameter></term>
   <listitem>
    <para>
     wireless device receiving the frame
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>cookie</parameter></term>
   <listitem>
    <para>
     Cookie returned by cfg80211_ops::<function>mgmt_tx</function>
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>buf</parameter></term>
   <listitem>
    <para>
     Management frame (header + body)
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>len</parameter></term>
   <listitem>
    <para>
     length of the frame data
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>ack</parameter></term>
   <listitem>
    <para>
     Whether frame was acknowledged
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>gfp</parameter></term>
   <listitem>
    <para>
     context flags
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This function is called whenever a management frame was requested to be
</para>
</refsect1>
<refsect1>
<title>transmitted with cfg80211_ops</title>
<para>
   :<function>mgmt_tx</function> to report the TX status of the
   transmission attempt.
</para>
</refsect1>
</refentry>

<refentry id="API-cfg80211-cqm-rssi-notify">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>cfg80211_cqm_rssi_notify</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>cfg80211_cqm_rssi_notify</refname>
 <refpurpose>
  connection quality monitoring rssi event
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>cfg80211_cqm_rssi_notify </function></funcdef>
   <paramdef>struct net_device * <parameter>dev</parameter></paramdef>
   <paramdef>enum nl80211_cqm_rssi_threshold_event <parameter>rssi_event</parameter></paramdef>
   <paramdef>gfp_t <parameter>gfp</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     network device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>rssi_event</parameter></term>
   <listitem>
    <para>
     the triggered RSSI event
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>gfp</parameter></term>
   <listitem>
    <para>
     context flags
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This function is called when a configured connection quality monitoring
   rssi threshold reached event occurs.
</para>
</refsect1>
</refentry>

<refentry id="API-cfg80211-cqm-pktloss-notify">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>cfg80211_cqm_pktloss_notify</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>cfg80211_cqm_pktloss_notify</refname>
 <refpurpose>
  notify userspace about packetloss to peer
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>cfg80211_cqm_pktloss_notify </function></funcdef>
   <paramdef>struct net_device * <parameter>dev</parameter></paramdef>
   <paramdef>const u8 * <parameter>peer</parameter></paramdef>
   <paramdef>u32 <parameter>num_packets</parameter></paramdef>
   <paramdef>gfp_t <parameter>gfp</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     network device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>peer</parameter></term>
   <listitem>
    <para>
     peer's MAC address
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>num_packets</parameter></term>
   <listitem>
    <para>
     how many packets were lost -- should be a fixed threshold
     but probably no less than maybe 50, or maybe a throughput dependent
     threshold (to account for temporary interference)
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>gfp</parameter></term>
   <listitem>
    <para>
     context flags
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-cfg80211-michael-mic-failure">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>cfg80211_michael_mic_failure</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>cfg80211_michael_mic_failure</refname>
 <refpurpose>
  notification of Michael MIC failure (TKIP)
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>cfg80211_michael_mic_failure </function></funcdef>
   <paramdef>struct net_device * <parameter>dev</parameter></paramdef>
   <paramdef>const u8 * <parameter>addr</parameter></paramdef>
   <paramdef>enum nl80211_key_type <parameter>key_type</parameter></paramdef>
   <paramdef>int <parameter>key_id</parameter></paramdef>
   <paramdef>const u8 * <parameter>tsc</parameter></paramdef>
   <paramdef>gfp_t <parameter>gfp</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     network device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>addr</parameter></term>
   <listitem>
    <para>
     The source MAC address of the frame
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>key_type</parameter></term>
   <listitem>
    <para>
     The key type that the received frame used
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>key_id</parameter></term>
   <listitem>
    <para>
     Key identifier (0..3). Can be -1 if missing.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>tsc</parameter></term>
   <listitem>
    <para>
     The TSC value of the frame that generated the MIC failure (6 octets)
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>gfp</parameter></term>
   <listitem>
    <para>
     allocation flags
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This function is called whenever the local MAC detects a MIC failure in a
   received frame. This matches with MLME-MICHAELMICFAILURE.<function>indication</function>
   primitive.
</para>
</refsect1>
</refentry>

      </chapter>
      <chapter>
      <title>Scanning and BSS list handling</title>
<para>
   </para><para>
   The scanning process itself is fairly simple, but cfg80211 offers quite
   a bit of helper functionality. To start a scan, the scan operation will
   be invoked with a scan definition. This scan definition contains the
   channels to scan, and the SSIDs to send probe requests for (including the
   wildcard, if desired). A passive scan is indicated by having no SSIDs to
   probe. Additionally, a scan request may contain extra information elements
   that should be added to the probe request. The IEs are guaranteed to be
   well-formed, and will not exceed the maximum length the driver advertised
   in the wiphy structure.
   </para><para>
   When scanning finds a BSS, cfg80211 needs to be notified of that, because
   it is responsible for maintaining the BSS list; the driver should not
   maintain a list itself. For this notification, various functions exist.
   </para><para>
   Since drivers do not maintain a BSS list, there are also a number of
   functions to search for a BSS and obtain information about it from the
   BSS structure cfg80211 maintains. The BSS list is also made available
   to userspace.
</para>

<refentry id="API-struct-cfg80211-ssid">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct cfg80211_ssid</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct cfg80211_ssid</refname>
 <refpurpose>
  SSID description
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct cfg80211_ssid {
  u8 ssid[IEEE80211_MAX_SSID_LEN];
  u8 ssid_len;
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>ssid[IEEE80211_MAX_SSID_LEN]</term>
      <listitem><para>
the SSID
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>ssid_len</term>
      <listitem><para>
length of the ssid
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
</refentry>

<refentry id="API-struct-cfg80211-scan-request">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct cfg80211_scan_request</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct cfg80211_scan_request</refname>
 <refpurpose>
  scan request description
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct cfg80211_scan_request {
  struct cfg80211_ssid * ssids;
  int n_ssids;
  u32 n_channels;
  enum nl80211_bss_scan_width scan_width;
  const u8 * ie;
  size_t ie_len;
  u32 flags;
  u32 rates[IEEE80211_NUM_BANDS];
  struct wireless_dev * wdev;
  struct wiphy * wiphy;
  unsigned long scan_start;
  bool aborted;
  bool notified;
  bool no_cck;
  struct ieee80211_channel * channels[0];
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>ssids</term>
      <listitem><para>
SSIDs to scan for (active scan only)
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>n_ssids</term>
      <listitem><para>
number of SSIDs
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>n_channels</term>
      <listitem><para>
total number of channels to scan
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>scan_width</term>
      <listitem><para>
channel width for scanning
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>ie</term>
      <listitem><para>
optional information element(s) to add into Probe Request or <constant>NULL</constant>
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>ie_len</term>
      <listitem><para>
length of ie in octets
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>flags</term>
      <listitem><para>
bit field of flags controlling operation
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>rates[IEEE80211_NUM_BANDS]</term>
      <listitem><para>
bitmap of rates to advertise for each band
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>wdev</term>
      <listitem><para>
the wireless device to scan for
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>wiphy</term>
      <listitem><para>
the wiphy this was for
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>scan_start</term>
      <listitem><para>
time (in jiffies) when the scan started
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>aborted</term>
      <listitem><para>
(internal) scan request was notified as aborted
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>notified</term>
      <listitem><para>
(internal) scan request was notified as done or aborted
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>no_cck</term>
      <listitem><para>
used to send probe requests at non CCK rate in 2GHz band
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>channels[0]</term>
      <listitem><para>
channels to scan on.
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
</refentry>

<refentry id="API-cfg80211-scan-done">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>cfg80211_scan_done</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>cfg80211_scan_done</refname>
 <refpurpose>
  notify that scan finished
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>cfg80211_scan_done </function></funcdef>
   <paramdef>struct cfg80211_scan_request * <parameter>request</parameter></paramdef>
   <paramdef>bool <parameter>aborted</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>request</parameter></term>
   <listitem>
    <para>
     the corresponding scan request
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>aborted</parameter></term>
   <listitem>
    <para>
     set to true if the scan was aborted for any reason,
     userspace will be notified of that
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-struct-cfg80211-bss">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct cfg80211_bss</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct cfg80211_bss</refname>
 <refpurpose>
  BSS description
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct cfg80211_bss {
  struct ieee80211_channel * channel;
  enum nl80211_bss_scan_width scan_width;
  const struct cfg80211_bss_ies __rcu * ies;
  const struct cfg80211_bss_ies __rcu * beacon_ies;
  const struct cfg80211_bss_ies __rcu * proberesp_ies;
  struct cfg80211_bss * hidden_beacon_bss;
  s32 signal;
  u16 beacon_interval;
  u16 capability;
  u8 bssid[ETH_ALEN];
  u8 priv[0];
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>channel</term>
      <listitem><para>
channel this BSS is on
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>scan_width</term>
      <listitem><para>
width of the control channel
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>ies</term>
      <listitem><para>
the information elements (Note that there is no guarantee that these
are well-formed!); this is a pointer to either the beacon_ies or
proberesp_ies depending on whether Probe Response frame has been
received. It is always non-<constant>NULL</constant>.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>beacon_ies</term>
      <listitem><para>
the information elements from the last Beacon frame
(implementation note: if <parameter>hidden_beacon_bss</parameter> is set this struct doesn't
own the beacon_ies, but they're just pointers to the ones from the
<parameter>hidden_beacon_bss</parameter> struct)
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>proberesp_ies</term>
      <listitem><para>
the information elements from the last Probe Response frame
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>hidden_beacon_bss</term>
      <listitem><para>
in case this BSS struct represents a probe response from
a BSS that hides the SSID in its beacon, this points to the BSS struct
that holds the beacon data. <parameter>beacon_ies</parameter> is still valid, of course, and
points to the same data as hidden_beacon_bss-&gt;beacon_ies in that case.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>signal</term>
      <listitem><para>
signal strength value (type depends on the wiphy's signal_type)
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>beacon_interval</term>
      <listitem><para>
the beacon interval as from the frame
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>capability</term>
      <listitem><para>
the capability field in host byte order
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>bssid[ETH_ALEN]</term>
      <listitem><para>
BSSID of the BSS
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>priv[0]</term>
      <listitem><para>
private area for driver use, has at least wiphy-&gt;bss_priv_size bytes
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
<refsect1>
<title>Description</title>
<para>
   </para><para>

   This structure describes a BSS (which may also be a mesh network)
   for use in scan results and similar.
</para>
</refsect1>
</refentry>

<refentry id="API-cfg80211-inform-bss-width-frame">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>cfg80211_inform_bss_width_frame</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>cfg80211_inform_bss_width_frame</refname>
 <refpurpose>
  inform cfg80211 of a received BSS frame
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct cfg80211_bss * <function>cfg80211_inform_bss_width_frame </function></funcdef>
   <paramdef>struct wiphy * <parameter>wiphy</parameter></paramdef>
   <paramdef>struct ieee80211_channel * <parameter>rx_channel</parameter></paramdef>
   <paramdef>enum nl80211_bss_scan_width <parameter>scan_width</parameter></paramdef>
   <paramdef>struct ieee80211_mgmt * <parameter>mgmt</parameter></paramdef>
   <paramdef>size_t <parameter>len</parameter></paramdef>
   <paramdef>s32 <parameter>signal</parameter></paramdef>
   <paramdef>gfp_t <parameter>gfp</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>wiphy</parameter></term>
   <listitem>
    <para>
     the wiphy reporting the BSS
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>rx_channel</parameter></term>
   <listitem>
    <para>
     The channel the frame was received on
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>scan_width</parameter></term>
   <listitem>
    <para>
     width of the control channel
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>mgmt</parameter></term>
   <listitem>
    <para>
     the management frame (probe response or beacon)
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>len</parameter></term>
   <listitem>
    <para>
     length of the management frame
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>signal</parameter></term>
   <listitem>
    <para>
     the signal strength, type depends on the wiphy's signal_type
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>gfp</parameter></term>
   <listitem>
    <para>
     context flags
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This informs cfg80211 that BSS information was found and
   the BSS should be updated/added.
</para>
</refsect1>
<refsect1>
<title>Return</title>
<para>
   A referenced struct, must be released with <function>cfg80211_put_bss</function>!
   Or <constant>NULL</constant> on error.
</para>
</refsect1>
</refentry>

<refentry id="API-cfg80211-inform-bss-width">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>cfg80211_inform_bss_width</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>cfg80211_inform_bss_width</refname>
 <refpurpose>
  inform cfg80211 of a new BSS
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct cfg80211_bss * <function>cfg80211_inform_bss_width </function></funcdef>
   <paramdef>struct wiphy * <parameter>wiphy</parameter></paramdef>
   <paramdef>struct ieee80211_channel * <parameter>rx_channel</parameter></paramdef>
   <paramdef>enum nl80211_bss_scan_width <parameter>scan_width</parameter></paramdef>
   <paramdef>enum cfg80211_bss_frame_type <parameter>ftype</parameter></paramdef>
   <paramdef>const u8 * <parameter>bssid</parameter></paramdef>
   <paramdef>u64 <parameter>tsf</parameter></paramdef>
   <paramdef>u16 <parameter>capability</parameter></paramdef>
   <paramdef>u16 <parameter>beacon_interval</parameter></paramdef>
   <paramdef>const u8 * <parameter>ie</parameter></paramdef>
   <paramdef>size_t <parameter>ielen</parameter></paramdef>
   <paramdef>s32 <parameter>signal</parameter></paramdef>
   <paramdef>gfp_t <parameter>gfp</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>wiphy</parameter></term>
   <listitem>
    <para>
     the wiphy reporting the BSS
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>rx_channel</parameter></term>
   <listitem>
    <para>
     The channel the frame was received on
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>scan_width</parameter></term>
   <listitem>
    <para>
     width of the control channel
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>ftype</parameter></term>
   <listitem>
    <para>
     frame type (if known)
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>bssid</parameter></term>
   <listitem>
    <para>
     the BSSID of the BSS
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>tsf</parameter></term>
   <listitem>
    <para>
     the TSF sent by the peer in the beacon/probe response (or 0)
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>capability</parameter></term>
   <listitem>
    <para>
     the capability field sent by the peer
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>beacon_interval</parameter></term>
   <listitem>
    <para>
     the beacon interval announced by the peer
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>ie</parameter></term>
   <listitem>
    <para>
     additional IEs sent by the peer
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>ielen</parameter></term>
   <listitem>
    <para>
     length of the additional IEs
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>signal</parameter></term>
   <listitem>
    <para>
     the signal strength, type depends on the wiphy's signal_type
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>gfp</parameter></term>
   <listitem>
    <para>
     context flags
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This informs cfg80211 that BSS information was found and
   the BSS should be updated/added.
</para>
</refsect1>
<refsect1>
<title>Return</title>
<para>
   A referenced struct, must be released with <function>cfg80211_put_bss</function>!
   Or <constant>NULL</constant> on error.
</para>
</refsect1>
</refentry>

<refentry id="API-cfg80211-unlink-bss">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>cfg80211_unlink_bss</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>cfg80211_unlink_bss</refname>
 <refpurpose>
  unlink BSS from internal data structures
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>cfg80211_unlink_bss </function></funcdef>
   <paramdef>struct wiphy * <parameter>wiphy</parameter></paramdef>
   <paramdef>struct cfg80211_bss * <parameter>bss</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>wiphy</parameter></term>
   <listitem>
    <para>
     the wiphy
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>bss</parameter></term>
   <listitem>
    <para>
     the bss to remove
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This function removes the given BSS from the internal data structures
   thereby making it no longer show up in scan results etc. Use this
   function when you detect a BSS is gone. Normally BSSes will also time
   out, so it is not necessary to use this function at all.
</para>
</refsect1>
</refentry>

<refentry id="API-cfg80211-find-ie">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>cfg80211_find_ie</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>cfg80211_find_ie</refname>
 <refpurpose>
  find information element in data
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>const u8 * <function>cfg80211_find_ie </function></funcdef>
   <paramdef>u8 <parameter>eid</parameter></paramdef>
   <paramdef>const u8 * <parameter>ies</parameter></paramdef>
   <paramdef>int <parameter>len</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>eid</parameter></term>
   <listitem>
    <para>
     element ID
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>ies</parameter></term>
   <listitem>
    <para>
     data consisting of IEs
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>len</parameter></term>
   <listitem>
    <para>
     length of data
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Return</title>
<para>
   <constant>NULL</constant> if the element ID could not be found or if
   the element is invalid (claims to be longer than the given
   data), or a pointer to the first byte of the requested
   element, that is the byte containing the element ID.
</para>
</refsect1>
<refsect1>
<title>Note</title>
<para>
   There are no checks on the element length other than
   having to fit into the given data.
</para>
</refsect1>
</refentry>

<refentry id="API-ieee80211-bss-get-ie">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ieee80211_bss_get_ie</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ieee80211_bss_get_ie</refname>
 <refpurpose>
  find IE with given ID
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>const u8 * <function>ieee80211_bss_get_ie </function></funcdef>
   <paramdef>struct cfg80211_bss * <parameter>bss</parameter></paramdef>
   <paramdef>u8 <parameter>ie</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>bss</parameter></term>
   <listitem>
    <para>
     the bss to search
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>ie</parameter></term>
   <listitem>
    <para>
     the IE ID
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Note that the return value is an RCU-protected pointer, so
   <function>rcu_read_lock</function> must be held when calling this function.
</para>
</refsect1>
<refsect1>
<title>Return</title>
<para>
   <constant>NULL</constant> if not found.
</para>
</refsect1>
</refentry>

      </chapter>
      <chapter>
      <title>Utility functions</title>
<para>
   </para><para>
   cfg80211 offers a number of utility functions that can be useful.
</para>

<refentry id="API-ieee80211-channel-to-frequency">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ieee80211_channel_to_frequency</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ieee80211_channel_to_frequency</refname>
 <refpurpose>
  convert channel number to frequency
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>ieee80211_channel_to_frequency </function></funcdef>
   <paramdef>int <parameter>chan</parameter></paramdef>
   <paramdef>enum ieee80211_band <parameter>band</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>chan</parameter></term>
   <listitem>
    <para>
     channel number
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>band</parameter></term>
   <listitem>
    <para>
     band, necessary due to channel number overlap
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Return</title>
<para>
   The corresponding frequency (in MHz), or 0 if the conversion failed.
</para>
</refsect1>
</refentry>

<refentry id="API-ieee80211-frequency-to-channel">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ieee80211_frequency_to_channel</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ieee80211_frequency_to_channel</refname>
 <refpurpose>
  convert frequency to channel number
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>ieee80211_frequency_to_channel </function></funcdef>
   <paramdef>int <parameter>freq</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>freq</parameter></term>
   <listitem>
    <para>
     center frequency
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Return</title>
<para>
   The corresponding channel, or 0 if the conversion failed.
</para>
</refsect1>
</refentry>

<refentry id="API-ieee80211-get-channel">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ieee80211_get_channel</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ieee80211_get_channel</refname>
 <refpurpose>
  get channel struct from wiphy for specified frequency
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct ieee80211_channel * <function>ieee80211_get_channel </function></funcdef>
   <paramdef>struct wiphy * <parameter>wiphy</parameter></paramdef>
   <paramdef>int <parameter>freq</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>wiphy</parameter></term>
   <listitem>
    <para>
     the struct wiphy to get the channel for
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>freq</parameter></term>
   <listitem>
    <para>
     the center frequency of the channel
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Return</title>
<para>
   The channel struct from <parameter>wiphy</parameter> at <parameter>freq</parameter>.
</para>
</refsect1>
</refentry>

<refentry id="API-ieee80211-get-response-rate">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ieee80211_get_response_rate</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ieee80211_get_response_rate</refname>
 <refpurpose>
  get basic rate for a given rate
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct ieee80211_rate * <function>ieee80211_get_response_rate </function></funcdef>
   <paramdef>struct ieee80211_supported_band * <parameter>sband</parameter></paramdef>
   <paramdef>u32 <parameter>basic_rates</parameter></paramdef>
   <paramdef>int <parameter>bitrate</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>sband</parameter></term>
   <listitem>
    <para>
     the band to look for rates in
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>basic_rates</parameter></term>
   <listitem>
    <para>
     bitmap of basic rates
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>bitrate</parameter></term>
   <listitem>
    <para>
     the bitrate for which to find the basic rate
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Return</title>
<para>
   The basic rate corresponding to a given bitrate, that
   is the next lower bitrate contained in the basic rate map,
   which is, for this function, given as a bitmap of indices of
   rates in the band's bitrate table.
</para>
</refsect1>
</refentry>

<refentry id="API-ieee80211-hdrlen">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ieee80211_hdrlen</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ieee80211_hdrlen</refname>
 <refpurpose>
  get header length in bytes from frame control
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>unsigned int __attribute_const__ <function>ieee80211_hdrlen </function></funcdef>
   <paramdef>__le16 <parameter>fc</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>fc</parameter></term>
   <listitem>
    <para>
     frame control field in little-endian format
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Return</title>
<para>
   The header length in bytes.
</para>
</refsect1>
</refentry>

<refentry id="API-ieee80211-get-hdrlen-from-skb">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ieee80211_get_hdrlen_from_skb</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ieee80211_get_hdrlen_from_skb</refname>
 <refpurpose>
  get header length from data
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>unsigned int <function>ieee80211_get_hdrlen_from_skb </function></funcdef>
   <paramdef>const struct sk_buff * <parameter>skb</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>skb</parameter></term>
   <listitem>
    <para>
     the frame
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Given an skb with a raw 802.11 header at the data pointer this function
   returns the 802.11 header length.
</para>
</refsect1>
<refsect1>
<title>Return</title>
<para>
   The 802.11 header length in bytes (not including encryption
   headers). Or 0 if the data in the sk_buff is too short to contain a valid
   802.11 header.
</para>
</refsect1>
</refentry>

<refentry id="API-struct-ieee80211-radiotap-iterator">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct ieee80211_radiotap_iterator</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct ieee80211_radiotap_iterator</refname>
 <refpurpose>
  tracks walk thru present radiotap args
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct ieee80211_radiotap_iterator {
  struct ieee80211_radiotap_header * _rtheader;
  const struct ieee80211_radiotap_vendor_namespaces * _vns;
  const struct ieee80211_radiotap_namespace * current_namespace;
  unsigned char * _arg;
  unsigned char * _next_ns_data;
  __le32 * _next_bitmap;
  unsigned char * this_arg;
  int this_arg_index;
  int this_arg_size;
  int is_radiotap_ns;
  int _max_length;
  int _arg_index;
  uint32_t _bitmap_shifter;
  int _reset_on_ext;
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>_rtheader</term>
      <listitem><para>
pointer to the radiotap header we are walking through
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>_vns</term>
      <listitem><para>
vendor namespace definitions
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>current_namespace</term>
      <listitem><para>
pointer to the current namespace definition
(or internally <constant>NULL</constant> if the current namespace is unknown)
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>_arg</term>
      <listitem><para>
next argument pointer
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>_next_ns_data</term>
      <listitem><para>
beginning of the next namespace's data
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>_next_bitmap</term>
      <listitem><para>
internal pointer to next present u32
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>this_arg</term>
      <listitem><para>
pointer to current radiotap arg; it is valid after each
call to <function>ieee80211_radiotap_iterator_next</function> but also after
<function>ieee80211_radiotap_iterator_init</function> where it will point to
the beginning of the actual data portion
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>this_arg_index</term>
      <listitem><para>
index of current arg, valid after each successful call
to <function>ieee80211_radiotap_iterator_next</function>
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>this_arg_size</term>
      <listitem><para>
length of the current arg, for convenience
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>is_radiotap_ns</term>
      <listitem><para>
indicates whether the current namespace is the default
radiotap namespace or not
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>_max_length</term>
      <listitem><para>
length of radiotap header in cpu byte ordering
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>_arg_index</term>
      <listitem><para>
next argument index
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>_bitmap_shifter</term>
      <listitem><para>
internal shifter for curr u32 bitmap, b0 set == arg present
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>_reset_on_ext</term>
      <listitem><para>
internal; reset the arg index to 0 when going to the
next bitmap word
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
<refsect1>
<title>Description</title>
<para>
   Describes the radiotap parser state. Fields prefixed with an underscore
   must not be used by users of the parser, only by the parser internally.
</para>
</refsect1>
</refentry>

      </chapter>
      <chapter>
      <title>Data path helpers</title>
<para>
   </para><para>
   In addition to generic utilities, cfg80211 also offers
   functions that help implement the data path for devices
   that do not do the 802.11/802.3 conversion on the device.
</para>

<refentry id="API-ieee80211-data-to-8023">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ieee80211_data_to_8023</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ieee80211_data_to_8023</refname>
 <refpurpose>
  convert an 802.11 data frame to 802.3
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>ieee80211_data_to_8023 </function></funcdef>
   <paramdef>struct sk_buff * <parameter>skb</parameter></paramdef>
   <paramdef>const u8 * <parameter>addr</parameter></paramdef>
   <paramdef>enum nl80211_iftype <parameter>iftype</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>skb</parameter></term>
   <listitem>
    <para>
     the 802.11 data frame
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>addr</parameter></term>
   <listitem>
    <para>
     the device MAC address
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>iftype</parameter></term>
   <listitem>
    <para>
     the virtual interface type
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Return</title>
<para>
   0 on success. Non-zero on error.
</para>
</refsect1>
</refentry>

<refentry id="API-ieee80211-data-from-8023">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ieee80211_data_from_8023</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ieee80211_data_from_8023</refname>
 <refpurpose>
  convert an 802.3 frame to 802.11
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>ieee80211_data_from_8023 </function></funcdef>
   <paramdef>struct sk_buff * <parameter>skb</parameter></paramdef>
   <paramdef>const u8 * <parameter>addr</parameter></paramdef>
   <paramdef>enum nl80211_iftype <parameter>iftype</parameter></paramdef>
   <paramdef>const u8 * <parameter>bssid</parameter></paramdef>
   <paramdef>bool <parameter>qos</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>skb</parameter></term>
   <listitem>
    <para>
     the 802.3 frame
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>addr</parameter></term>
   <listitem>
    <para>
     the device MAC address
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>iftype</parameter></term>
   <listitem>
    <para>
     the virtual interface type
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>bssid</parameter></term>
   <listitem>
    <para>
     the network bssid (used only for iftype STATION and ADHOC)
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>qos</parameter></term>
   <listitem>
    <para>
     build 802.11 QoS data frame
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Return</title>
<para>
   0 on success, or a negative error code.
</para>
</refsect1>
</refentry>

<refentry id="API-ieee80211-amsdu-to-8023s">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ieee80211_amsdu_to_8023s</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ieee80211_amsdu_to_8023s</refname>
 <refpurpose>
  decode an IEEE 802.11n A-MSDU frame
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>ieee80211_amsdu_to_8023s </function></funcdef>
   <paramdef>struct sk_buff * <parameter>skb</parameter></paramdef>
   <paramdef>struct sk_buff_head * <parameter>list</parameter></paramdef>
   <paramdef>const u8 * <parameter>addr</parameter></paramdef>
   <paramdef>enum nl80211_iftype <parameter>iftype</parameter></paramdef>
   <paramdef>const unsigned int <parameter>extra_headroom</parameter></paramdef>
   <paramdef>bool <parameter>has_80211_header</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>skb</parameter></term>
   <listitem>
    <para>
     The input IEEE 802.11n A-MSDU frame.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>list</parameter></term>
   <listitem>
    <para>
     The output list of 802.3 frames. It must be allocated and
     initialized by by the caller.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>addr</parameter></term>
   <listitem>
    <para>
     The device MAC address.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>iftype</parameter></term>
   <listitem>
    <para>
     The device interface type.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>extra_headroom</parameter></term>
   <listitem>
    <para>
     The hardware extra headroom for SKBs in the <parameter>list</parameter>.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>has_80211_header</parameter></term>
   <listitem>
    <para>
     Set it true if SKB is with IEEE 802.11 header.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   </para><para>

   Decode an IEEE 802.11n A-MSDU frame and convert it to a list of
   802.3 frames. The <parameter>list</parameter> will be empty if the decode fails. The
   <parameter>skb</parameter> is consumed after the function returns.
</para>
</refsect1>
</refentry>

<refentry id="API-cfg80211-classify8021d">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>cfg80211_classify8021d</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>cfg80211_classify8021d</refname>
 <refpurpose>
  determine the 802.1p/1d tag for a data frame
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>unsigned int <function>cfg80211_classify8021d </function></funcdef>
   <paramdef>struct sk_buff * <parameter>skb</parameter></paramdef>
   <paramdef>struct cfg80211_qos_map * <parameter>qos_map</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>skb</parameter></term>
   <listitem>
    <para>
     the data frame
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>qos_map</parameter></term>
   <listitem>
    <para>
     Interworking QoS mapping or <constant>NULL</constant> if not in use
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Return</title>
<para>
   The 802.1p/1d tag.
</para>
</refsect1>
</refentry>

      </chapter>
      <chapter>
      <title>Regulatory enforcement infrastructure</title>
<para>
   </para><para>
   TODO
</para>

<refentry id="API-regulatory-hint">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>regulatory_hint</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>regulatory_hint</refname>
 <refpurpose>
  driver hint to the wireless core a regulatory domain
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>regulatory_hint </function></funcdef>
   <paramdef>struct wiphy * <parameter>wiphy</parameter></paramdef>
   <paramdef>const char * <parameter>alpha2</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>wiphy</parameter></term>
   <listitem>
    <para>
     the wireless device giving the hint (used only for reporting
     conflicts)
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>alpha2</parameter></term>
   <listitem>
    <para>
     the ISO/IEC 3166 alpha2 the driver claims its regulatory domain
     should be in. If <parameter>rd</parameter> is set this should be NULL. Note that if you
     set this to NULL you should still set rd-&gt;alpha2 to some accepted
     alpha2.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Wireless drivers can use this function to hint to the wireless core
   what it believes should be the current regulatory domain by
   giving it an ISO/IEC 3166 alpha2 country code it knows its regulatory
   domain should be in or by providing a completely build regulatory domain.
   If the driver provides an ISO/IEC 3166 alpha2 userspace will be queried
   for a regulatory domain structure for the respective country.
   </para><para>

   The wiphy must have been registered to cfg80211 prior to this call.
   For cfg80211 drivers this means you must first use <function>wiphy_register</function>,
   for mac80211 drivers you must first use <function>ieee80211_register_hw</function>.
   </para><para>

   Drivers should check the return value, its possible you can get
   an -ENOMEM.
</para>
</refsect1>
<refsect1>
<title>Return</title>
<para>
   0 on success. -ENOMEM.
</para>
</refsect1>
</refentry>

<refentry id="API-wiphy-apply-custom-regulatory">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>wiphy_apply_custom_regulatory</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>wiphy_apply_custom_regulatory</refname>
 <refpurpose>
  apply a custom driver regulatory domain
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>wiphy_apply_custom_regulatory </function></funcdef>
   <paramdef>struct wiphy * <parameter>wiphy</parameter></paramdef>
   <paramdef>const struct ieee80211_regdomain * <parameter>regd</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>wiphy</parameter></term>
   <listitem>
    <para>
     the wireless device we want to process the regulatory domain on
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>regd</parameter></term>
   <listitem>
    <para>
     the custom regulatory domain to use for this wiphy
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Drivers can sometimes have custom regulatory domains which do not apply
   to a specific country. Drivers can use this to apply such custom regulatory
   domains. This routine must be called prior to wiphy registration. The
   custom regulatory domain will be trusted completely and as such previous
   default channel settings will be disregarded. If no rule is found for a
   channel on the regulatory domain the channel will be disabled.
   Drivers using this for a wiphy should also set the wiphy flag
   REGULATORY_CUSTOM_REG or cfg80211 will set it for the wiphy
   that called this helper.
</para>
</refsect1>
</refentry>

<refentry id="API-freq-reg-info">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>freq_reg_info</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>freq_reg_info</refname>
 <refpurpose>
  get regulatory information for the given frequency
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>const struct ieee80211_reg_rule * <function>freq_reg_info </function></funcdef>
   <paramdef>struct wiphy * <parameter>wiphy</parameter></paramdef>
   <paramdef>u32 <parameter>center_freq</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>wiphy</parameter></term>
   <listitem>
    <para>
     the wiphy for which we want to process this rule for
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>center_freq</parameter></term>
   <listitem>
    <para>
     Frequency in KHz for which we want regulatory information for
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Use this function to get the regulatory rule for a specific frequency on
   a given wireless device. If the device has a specific regulatory domain
   it wants to follow we respect that unless a country IE has been received
   and processed already.
</para>
</refsect1>
<refsect1>
<title>Return</title>
<para>
   A valid pointer, or, when an error occurs, for example if no rule
   can be found, the return value is encoded using <function>ERR_PTR</function>. Use <function>IS_ERR</function> to
   check and <function>PTR_ERR</function> to obtain the numeric return value. The numeric return
   value will be -ERANGE if we determine the given center_freq does not even
   have a regulatory rule for a frequency range in the center_freq's band.
   See <function>freq_in_rule_band</function> for our current definition of a band -- this is
   purely subjective and right now it's 802.11 specific.
</para>
</refsect1>
</refentry>

      </chapter>
      <chapter>
      <title>RFkill integration</title>
<para>
   </para><para>
   RFkill integration in cfg80211 is almost invisible to drivers,
   as cfg80211 automatically registers an rfkill instance for each
   wireless device it knows about. Soft kill is also translated
   into disconnecting and turning all interfaces off, drivers are
   expected to turn off the device when all interfaces are down.
   </para><para>
   However, devices may have a hard RFkill line, in which case they
   also need to interact with the rfkill subsystem, via cfg80211.
   They can do this with a few helper functions documented here.
</para>

<refentry id="API-wiphy-rfkill-set-hw-state">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>wiphy_rfkill_set_hw_state</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>wiphy_rfkill_set_hw_state</refname>
 <refpurpose>
  notify cfg80211 about hw block state
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>wiphy_rfkill_set_hw_state </function></funcdef>
   <paramdef>struct wiphy * <parameter>wiphy</parameter></paramdef>
   <paramdef>bool <parameter>blocked</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>wiphy</parameter></term>
   <listitem>
    <para>
     the wiphy
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>blocked</parameter></term>
   <listitem>
    <para>
     block status
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-wiphy-rfkill-start-polling">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>wiphy_rfkill_start_polling</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>wiphy_rfkill_start_polling</refname>
 <refpurpose>
  start polling rfkill
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>wiphy_rfkill_start_polling </function></funcdef>
   <paramdef>struct wiphy * <parameter>wiphy</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>wiphy</parameter></term>
   <listitem>
    <para>
     the wiphy
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-wiphy-rfkill-stop-polling">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>wiphy_rfkill_stop_polling</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>wiphy_rfkill_stop_polling</refname>
 <refpurpose>
  stop polling rfkill
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>wiphy_rfkill_stop_polling </function></funcdef>
   <paramdef>struct wiphy * <parameter>wiphy</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>wiphy</parameter></term>
   <listitem>
    <para>
     the wiphy
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

      </chapter>
      <chapter>
      <title>Test mode</title>
<para>
   </para><para>
   Test mode is a set of utility functions to allow drivers to
   interact with driver-specific tools to aid, for instance,
   factory programming.
   </para><para>
   This chapter describes how drivers interact with it, for more
   information see the nl80211 book's chapter on it.
</para>

<refentry id="API-cfg80211-testmode-alloc-reply-skb">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>cfg80211_testmode_alloc_reply_skb</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>cfg80211_testmode_alloc_reply_skb</refname>
 <refpurpose>
  allocate testmode reply
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct sk_buff * <function>cfg80211_testmode_alloc_reply_skb </function></funcdef>
   <paramdef>struct wiphy * <parameter>wiphy</parameter></paramdef>
   <paramdef>int <parameter>approxlen</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>wiphy</parameter></term>
   <listitem>
    <para>
     the wiphy
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>approxlen</parameter></term>
   <listitem>
    <para>
     an upper bound of the length of the data that will
     be put into the skb
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This function allocates and pre-fills an skb for a reply to
   the testmode command. Since it is intended for a reply, calling
   it outside of the <parameter>testmode_cmd</parameter> operation is invalid.
   </para><para>

   The returned skb is pre-filled with the wiphy index and set up in
   a way that any data that is put into the skb (with <function>skb_put</function>,
   <function>nla_put</function> or similar) will end up being within the
   <constant>NL80211_ATTR_TESTDATA</constant> attribute, so all that needs to be done
   with the skb is adding data for the corresponding userspace tool
   which can then read that data out of the testdata attribute. You
   must not modify the skb in any other way.
   </para><para>

   When done, call <function>cfg80211_testmode_reply</function> with the skb and return
   its error code as the result of the <parameter>testmode_cmd</parameter> operation.
</para>
</refsect1>
<refsect1>
<title>Return</title>
<para>
   An allocated and pre-filled skb. <constant>NULL</constant> if any errors happen.
</para>
</refsect1>
</refentry>

<refentry id="API-cfg80211-testmode-reply">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>cfg80211_testmode_reply</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>cfg80211_testmode_reply</refname>
 <refpurpose>
  send the reply skb
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>cfg80211_testmode_reply </function></funcdef>
   <paramdef>struct sk_buff * <parameter>skb</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>skb</parameter></term>
   <listitem>
    <para>
     The skb, must have been allocated with
     <function>cfg80211_testmode_alloc_reply_skb</function>
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Since calling this function will usually be the last thing
   before returning from the <parameter>testmode_cmd</parameter> you should return
   the error code.  Note that this function consumes the skb
   regardless of the return value.
</para>
</refsect1>
<refsect1>
<title>Return</title>
<para>
   An error code or 0 on success.
</para>
</refsect1>
</refentry>

<refentry id="API-cfg80211-testmode-alloc-event-skb">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>cfg80211_testmode_alloc_event_skb</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>cfg80211_testmode_alloc_event_skb</refname>
 <refpurpose>
  allocate testmode event
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct sk_buff * <function>cfg80211_testmode_alloc_event_skb </function></funcdef>
   <paramdef>struct wiphy * <parameter>wiphy</parameter></paramdef>
   <paramdef>int <parameter>approxlen</parameter></paramdef>
   <paramdef>gfp_t <parameter>gfp</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>wiphy</parameter></term>
   <listitem>
    <para>
     the wiphy
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>approxlen</parameter></term>
   <listitem>
    <para>
     an upper bound of the length of the data that will
     be put into the skb
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>gfp</parameter></term>
   <listitem>
    <para>
     allocation flags
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This function allocates and pre-fills an skb for an event on the
   testmode multicast group.
   </para><para>

   The returned skb is set up in the same way as with
   <function>cfg80211_testmode_alloc_reply_skb</function> but prepared for an event. As
   there, you should simply add data to it that will then end up in the
   <constant>NL80211_ATTR_TESTDATA</constant> attribute. Again, you must not modify the skb
   in any other way.
   </para><para>

   When done filling the skb, call <function>cfg80211_testmode_event</function> with the
   skb to send the event.
</para>
</refsect1>
<refsect1>
<title>Return</title>
<para>
   An allocated and pre-filled skb. <constant>NULL</constant> if any errors happen.
</para>
</refsect1>
</refentry>

<refentry id="API-cfg80211-testmode-event">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>cfg80211_testmode_event</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>cfg80211_testmode_event</refname>
 <refpurpose>
  send the event
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>cfg80211_testmode_event </function></funcdef>
   <paramdef>struct sk_buff * <parameter>skb</parameter></paramdef>
   <paramdef>gfp_t <parameter>gfp</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>skb</parameter></term>
   <listitem>
    <para>
     The skb, must have been allocated with
     <function>cfg80211_testmode_alloc_event_skb</function>
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>gfp</parameter></term>
   <listitem>
    <para>
     allocation flags
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This function sends the given <parameter>skb</parameter>, which must have been allocated
   by <function>cfg80211_testmode_alloc_event_skb</function>, as an event. It always
   consumes it.
</para>
</refsect1>
</refentry>

      </chapter>
  </book>
  <book id="mac80211-developers-guide">
    <bookinfo>
      <title>The mac80211 subsystem</title>
      <abstract>
<para>
   </para><para>
   mac80211 is the Linux stack for 802.11 hardware that implements
   only partial functionality in hard- or firmware. This document
   defines the interface between mac80211 and low-level hardware
   drivers.
</para>

<para>
   </para><para>
   If you're reading this document and not the header file itself, it will
   be incomplete because not all documentation has been converted yet.
</para>

      </abstract>
    </bookinfo>

    <toc></toc>

  <!--
  Generally, this document shall be ordered by increasing complexity.
  It is important to note that readers should be able to read only
  the first few sections to get a working driver and only advanced
  usage should require reading the full document.
  -->

    <part>
      <title>The basic mac80211 driver interface</title>
      <partintro>
        <para>
          You should read and understand the information contained
          within this part of the book while implementing a driver.
          In some chapters, advanced usage is noted, that may be
          skipped at first.
        </para>
        <para>
          This part of the book only covers station and monitor mode
          functionality, additional information required to implement
          the other modes is covered in the second part of the book.
        </para>
      </partintro>

      <chapter id="basics">
        <title>Basic hardware handling</title>
        <para>TBD</para>
        <para>
          This chapter shall contain information on getting a hw
          struct allocated and registered with mac80211.
        </para>
        <para>
          Since it is required to allocate rates/modes before registering
          a hw struct, this chapter shall also contain information on setting
          up the rate/mode structs.
        </para>
        <para>
          Additionally, some discussion about the callbacks and
          the general programming model should be in here, including
          the definition of ieee80211_ops which will be referred to
          a lot.
        </para>
        <para>
          Finally, a discussion of hardware capabilities should be done
          with references to other parts of the book.
        </para>
  <!-- intentionally multiple !F lines to get proper order -->
<refentry id="API-struct-ieee80211-hw">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct ieee80211_hw</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct ieee80211_hw</refname>
 <refpurpose>
  hardware information and state
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct ieee80211_hw {
  struct ieee80211_conf conf;
  struct wiphy * wiphy;
  const char * rate_control_algorithm;
  void * priv;
  u32 flags;
  unsigned int extra_tx_headroom;
  unsigned int extra_beacon_tailroom;
  int vif_data_size;
  int sta_data_size;
  int chanctx_data_size;
  u16 queues;
  u16 max_listen_interval;
  s8 max_signal;
  u8 max_rates;
  u8 max_report_rates;
  u8 max_rate_tries;
  u8 max_rx_aggregation_subframes;
  u8 max_tx_aggregation_subframes;
  u8 offchannel_tx_hw_queue;
  u8 radiotap_mcs_details;
  u16 radiotap_vht_details;
  netdev_features_t netdev_features;
  u8 uapsd_queues;
  u8 uapsd_max_sp_len;
  u8 n_cipher_schemes;
  const struct ieee80211_cipher_scheme * cipher_schemes;
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>conf</term>
      <listitem><para>
<structname>struct ieee80211_conf</structname>, device configuration, don't use.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>wiphy</term>
      <listitem><para>
This points to the <structname>struct wiphy</structname> allocated for this
802.11 PHY. You must fill in the <parameter>perm_addr</parameter> and <parameter>dev</parameter>
members of this structure using <function>SET_IEEE80211_DEV</function>
and <function>SET_IEEE80211_PERM_ADDR</function>. Additionally, all supported
bands (with channels, bitrates) are registered here.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>rate_control_algorithm</term>
      <listitem><para>
rate control algorithm for this hardware.
If unset (NULL), the default algorithm will be used. Must be
set before calling <function>ieee80211_register_hw</function>.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>priv</term>
      <listitem><para>
pointer to private area that was allocated for driver use
along with this structure.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>flags</term>
      <listitem><para>
hardware flags, see <structname>enum</structname> ieee80211_hw_flags.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>extra_tx_headroom</term>
      <listitem><para>
headroom to reserve in each transmit skb
for use by the driver (e.g. for transmit headers.)
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>extra_beacon_tailroom</term>
      <listitem><para>
tailroom to reserve in each beacon tx skb.
Can be used by drivers to add extra IEs.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>vif_data_size</term>
      <listitem><para>
size (in bytes) of the drv_priv data area
within <structname>struct ieee80211_vif</structname>.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>sta_data_size</term>
      <listitem><para>
size (in bytes) of the drv_priv data area
within <structname>struct ieee80211_sta</structname>.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>chanctx_data_size</term>
      <listitem><para>
size (in bytes) of the drv_priv data area
within <structname>struct ieee80211_chanctx_conf</structname>.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>queues</term>
      <listitem><para>
number of available hardware transmit queues for
data packets. WMM/QoS requires at least four, these
queues need to have configurable access parameters.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>max_listen_interval</term>
      <listitem><para>
max listen interval in units of beacon interval
that HW supports
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>max_signal</term>
      <listitem><para>
Maximum value for signal (rssi) in RX information, used
only when <parameter>IEEE80211_HW_SIGNAL_UNSPEC</parameter> or <parameter>IEEE80211_HW_SIGNAL_DB</parameter>
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>max_rates</term>
      <listitem><para>
maximum number of alternate rate retry stages the hw
can handle.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>max_report_rates</term>
      <listitem><para>
maximum number of alternate rate retry stages
the hw can report back.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>max_rate_tries</term>
      <listitem><para>
maximum number of tries for each stage
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>max_rx_aggregation_subframes</term>
      <listitem><para>
maximum buffer size (number of
sub-frames) to be used for A-MPDU block ack receiver
aggregation.
This is only relevant if the device has restrictions on the
number of subframes, if it relies on mac80211 to do reordering
it shouldn't be set.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>max_tx_aggregation_subframes</term>
      <listitem><para>
maximum number of subframes in an
aggregate an HT driver will transmit, used by the peer as a
hint to size its reorder buffer.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>offchannel_tx_hw_queue</term>
      <listitem><para>
HW queue ID to use for offchannel TX
(if <constant>IEEE80211_HW_QUEUE_CONTROL</constant> is set)
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>radiotap_mcs_details</term>
      <listitem><para>
lists which MCS information can the HW
reports, by default it is set to _MCS, _GI and _BW but doesn't
include _FMT. Use <constant>IEEE80211_RADIOTAP_MCS_HAVE_</constant>* values, only
adding _BW is supported today.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>radiotap_vht_details</term>
      <listitem><para>
lists which VHT MCS information the HW reports,
the default is _GI | _BANDWIDTH.
Use the <constant>IEEE80211_RADIOTAP_VHT_KNOWN_</constant>* values.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>netdev_features</term>
      <listitem><para>
netdev features to be set in each netdev created
from this HW. Note only HW checksum features are currently
compatible with mac80211. Other feature bits will be rejected.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>uapsd_queues</term>
      <listitem><para>
This bitmap is included in (re)association frame to indicate
for each access category if it is uAPSD trigger-enabled and delivery-
enabled. Use IEEE80211_WMM_IE_STA_QOSINFO_AC_* to set this bitmap.
Each bit corresponds to different AC. Value '1' in specific bit means
that corresponding AC is both trigger- and delivery-enabled. '0' means
neither enabled.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>uapsd_max_sp_len</term>
      <listitem><para>
maximum number of total buffered frames the WMM AP may
deliver to a WMM STA during any Service Period triggered by the WMM STA.
Use IEEE80211_WMM_IE_STA_QOSINFO_SP_* for correct values.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>n_cipher_schemes</term>
      <listitem><para>
a size of an array of cipher schemes definitions.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>cipher_schemes</term>
      <listitem><para>
a pointer to an array of cipher scheme definitions
supported by HW.
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
<refsect1>
<title>Description</title>
<para>
   </para><para>

   This structure contains the configuration and hardware
   information for an 802.11 PHY.
</para>
</refsect1>
</refentry>

<refentry id="API-enum-ieee80211-hw-flags">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>enum ieee80211_hw_flags</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>enum ieee80211_hw_flags</refname>
 <refpurpose>
  hardware flags
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
enum ieee80211_hw_flags {
  IEEE80211_HW_HAS_RATE_CONTROL,
  IEEE80211_HW_RX_INCLUDES_FCS,
  IEEE80211_HW_HOST_BROADCAST_PS_BUFFERING,
  IEEE80211_HW_2GHZ_SHORT_SLOT_INCAPABLE,
  IEEE80211_HW_2GHZ_SHORT_PREAMBLE_INCAPABLE,
  IEEE80211_HW_SIGNAL_UNSPEC,
  IEEE80211_HW_SIGNAL_DBM,
  IEEE80211_HW_NEED_DTIM_BEFORE_ASSOC,
  IEEE80211_HW_SPECTRUM_MGMT,
  IEEE80211_HW_AMPDU_AGGREGATION,
  IEEE80211_HW_SUPPORTS_PS,
  IEEE80211_HW_PS_NULLFUNC_STACK,
  IEEE80211_HW_SUPPORTS_DYNAMIC_PS,
  IEEE80211_HW_MFP_CAPABLE,
  IEEE80211_HW_WANT_MONITOR_VIF,
  IEEE80211_HW_SUPPORTS_UAPSD,
  IEEE80211_HW_REPORTS_TX_ACK_STATUS,
  IEEE80211_HW_CONNECTION_MONITOR,
  IEEE80211_HW_QUEUE_CONTROL,
  IEEE80211_HW_SUPPORTS_PER_STA_GTK,
  IEEE80211_HW_AP_LINK_PS,
  IEEE80211_HW_TX_AMPDU_SETUP_IN_HW,
  IEEE80211_HW_SUPPORTS_RC_TABLE,
  IEEE80211_HW_P2P_DEV_ADDR_FOR_INTF,
  IEEE80211_HW_TIMING_BEACON_ONLY,
  IEEE80211_HW_SUPPORTS_HT_CCK_RATES,
  IEEE80211_HW_CHANCTX_STA_CSA,
  IEEE80211_HW_SUPPORTS_CLONED_SKBS,
  IEEE80211_SINGLE_HW_SCAN_ON_ALL_BANDS
};  </programlisting>
</refsynopsisdiv>
<refsect1>
 <title>Constants</title>
  <variablelist>
    <varlistentry>      <term>IEEE80211_HW_HAS_RATE_CONTROL</term>
      <listitem><para>
The hardware or firmware includes rate control, and cannot be
controlled by the stack. As such, no rate control algorithm
should be instantiated, and the TX rate reported to userspace
will be taken from the TX status instead of the rate control
algorithm.
Note that this requires that the driver implement a number of
callbacks so it has the correct information, it needs to have
the <parameter>set_rts_threshold</parameter> callback and must look at the BSS config
<parameter>use_cts_prot</parameter> for G/N protection, <parameter>use_short_slot</parameter> for slot
timing in 2.4 GHz and <parameter>use_short_preamble</parameter> for preambles for
CCK frames.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>IEEE80211_HW_RX_INCLUDES_FCS</term>
      <listitem><para>
Indicates that received frames passed to the stack include
the FCS at the end.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>IEEE80211_HW_HOST_BROADCAST_PS_BUFFERING</term>
      <listitem><para>
Some wireless LAN chipsets buffer broadcast/multicast frames
for power saving stations in the hardware/firmware and others
rely on the host system for such buffering. This option is used
to configure the IEEE 802.11 upper layer to buffer broadcast and
multicast frames when there are power saving stations so that
the driver can fetch them with <function>ieee80211_get_buffered_bc</function>.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>IEEE80211_HW_2GHZ_SHORT_SLOT_INCAPABLE</term>
      <listitem><para>
Hardware is not capable of short slot operation on the 2.4 GHz band.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>IEEE80211_HW_2GHZ_SHORT_PREAMBLE_INCAPABLE</term>
      <listitem><para>
Hardware is not capable of receiving frames with short preamble on
the 2.4 GHz band.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>IEEE80211_HW_SIGNAL_UNSPEC</term>
      <listitem><para>
Hardware can provide signal values but we don't know its units. We
expect values between 0 and <parameter>max_signal</parameter>.
If possible please provide dB or dBm instead.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>IEEE80211_HW_SIGNAL_DBM</term>
      <listitem><para>
Hardware gives signal values in dBm, decibel difference from
one milliwatt. This is the preferred method since it is standardized
between different devices. <parameter>max_signal</parameter> does not need to be set.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>IEEE80211_HW_NEED_DTIM_BEFORE_ASSOC</term>
      <listitem><para>
This device needs to get data from beacon before association (i.e.
dtim_period).
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>IEEE80211_HW_SPECTRUM_MGMT</term>
      <listitem><para>
Hardware supports spectrum management defined in 802.11h
Measurement, Channel Switch, Quieting, TPC
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>IEEE80211_HW_AMPDU_AGGREGATION</term>
      <listitem><para>
Hardware supports 11n A-MPDU aggregation.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>IEEE80211_HW_SUPPORTS_PS</term>
      <listitem><para>
Hardware has power save support (i.e. can go to sleep).
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>IEEE80211_HW_PS_NULLFUNC_STACK</term>
      <listitem><para>
Hardware requires nullfunc frame handling in stack, implies
stack support for dynamic PS.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>IEEE80211_HW_SUPPORTS_DYNAMIC_PS</term>
      <listitem><para>
Hardware has support for dynamic PS.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>IEEE80211_HW_MFP_CAPABLE</term>
      <listitem><para>
Hardware supports management frame protection (MFP, IEEE 802.11w).
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>IEEE80211_HW_WANT_MONITOR_VIF</term>
      <listitem><para>
The driver would like to be informed of
a virtual monitor interface when monitor interfaces are the only
active interfaces.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>IEEE80211_HW_SUPPORTS_UAPSD</term>
      <listitem><para>
Hardware supports Unscheduled Automatic Power Save Delivery
(U-APSD) in managed mode. The mode is configured with
<function>conf_tx</function> operation.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>IEEE80211_HW_REPORTS_TX_ACK_STATUS</term>
      <listitem><para>
Hardware can provide ack status reports of Tx frames to
the stack.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>IEEE80211_HW_CONNECTION_MONITOR</term>
      <listitem><para>
The hardware performs its own connection monitoring, including
periodic keep-alives to the AP and probing the AP on beacon loss.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>IEEE80211_HW_QUEUE_CONTROL</term>
      <listitem><para>
The driver wants to control per-interface
queue mapping in order to use different queues (not just one per AC)
for different virtual interfaces. See the doc section on HW queue
control for more details.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>IEEE80211_HW_SUPPORTS_PER_STA_GTK</term>
      <listitem><para>
The device's crypto engine supports
per-station GTKs as used by IBSS RSN or during fast transition. If
the device doesn't support per-station GTKs, but can be asked not
to decrypt group addressed frames, then IBSS RSN support is still
possible but software crypto will be used. Advertise the wiphy flag
only in that case.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>IEEE80211_HW_AP_LINK_PS</term>
      <listitem><para>
When operating in AP mode the device
autonomously manages the PS status of connected stations. When
this flag is set mac80211 will not trigger PS mode for connected
stations based on the PM bit of incoming frames.
Use <function>ieee80211_start_ps</function>/<function>ieee8021_end_ps</function> to manually configure
the PS mode of connected stations.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>IEEE80211_HW_TX_AMPDU_SETUP_IN_HW</term>
      <listitem><para>
The device handles TX A-MPDU session
setup strictly in HW. mac80211 should not attempt to do this in
software.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>IEEE80211_HW_SUPPORTS_RC_TABLE</term>
      <listitem><para>
The driver supports using a rate
selection table provided by the rate control algorithm.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>IEEE80211_HW_P2P_DEV_ADDR_FOR_INTF</term>
      <listitem><para>
Use the P2P Device address for any
P2P Interface. This will be honoured even if more than one interface
is supported.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>IEEE80211_HW_TIMING_BEACON_ONLY</term>
      <listitem><para>
Use sync timing from beacon frames
only, to allow getting TBTT of a DTIM beacon.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>IEEE80211_HW_SUPPORTS_HT_CCK_RATES</term>
      <listitem><para>
Hardware supports mixing HT/CCK rates
and can cope with CCK rates in an aggregation session (e.g. by not
using aggregation for such frames.)
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>IEEE80211_HW_CHANCTX_STA_CSA</term>
      <listitem><para>
Support 802.11h based channel-switch (CSA)
for a single active channel while using channel contexts. When support
is not enabled the default action is to disconnect when getting the
CSA frame.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>IEEE80211_HW_SUPPORTS_CLONED_SKBS</term>
      <listitem><para>
The driver will never modify the payload
or tailroom of TX skbs without copying them first.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>IEEE80211_SINGLE_HW_SCAN_ON_ALL_BANDS</term>
      <listitem><para>
The HW supports scanning on all bands
in one command, mac80211 doesn't have to run separate scans per band.
      </para></listitem>
    </varlistentry>
  </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   </para><para>

   These flags are used to indicate hardware capabilities to
   the stack. Generally, flags here should have their meaning
   done in a way that the simplest hardware doesn't need setting
   any particular flags. There are some exceptions to this rule,
   however, so you are advised to review these flags carefully.
</para>
</refsect1>
</refentry>

<refentry id="API-SET-IEEE80211-DEV">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>SET_IEEE80211_DEV</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>SET_IEEE80211_DEV</refname>
 <refpurpose>
  set device for 802.11 hardware
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>SET_IEEE80211_DEV </function></funcdef>
   <paramdef>struct ieee80211_hw * <parameter>hw</parameter></paramdef>
   <paramdef>struct device * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>hw</parameter></term>
   <listitem>
    <para>
     the <structname>struct ieee80211_hw</structname> to set the device for
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     the <structname>struct device</structname> of this 802.11 device
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-SET-IEEE80211-PERM-ADDR">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>SET_IEEE80211_PERM_ADDR</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>SET_IEEE80211_PERM_ADDR</refname>
 <refpurpose>
  set the permanent MAC address for 802.11 hardware
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>SET_IEEE80211_PERM_ADDR </function></funcdef>
   <paramdef>struct ieee80211_hw * <parameter>hw</parameter></paramdef>
   <paramdef>u8 * <parameter>addr</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>hw</parameter></term>
   <listitem>
    <para>
     the <structname>struct ieee80211_hw</structname> to set the MAC address for
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>addr</parameter></term>
   <listitem>
    <para>
     the address to set
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-struct-ieee80211-ops">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct ieee80211_ops</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct ieee80211_ops</refname>
 <refpurpose>
  callbacks from mac80211 to the driver
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct ieee80211_ops {
  void (* tx) (struct ieee80211_hw *hw,struct ieee80211_tx_control *control,struct sk_buff *skb);
  int (* start) (struct ieee80211_hw *hw);
  void (* stop) (struct ieee80211_hw *hw);
#ifdef CONFIG_PM
  int (* suspend) (struct ieee80211_hw *hw, struct cfg80211_wowlan *wowlan);
  int (* resume) (struct ieee80211_hw *hw);
  void (* set_wakeup) (struct ieee80211_hw *hw, bool enabled);
#endif
  int (* add_interface) (struct ieee80211_hw *hw,struct ieee80211_vif *vif);
  int (* change_interface) (struct ieee80211_hw *hw,struct ieee80211_vif *vif,enum nl80211_iftype new_type, bool p2p);
  void (* remove_interface) (struct ieee80211_hw *hw,struct ieee80211_vif *vif);
  int (* config) (struct ieee80211_hw *hw, u32 changed);
  void (* bss_info_changed) (struct ieee80211_hw *hw,struct ieee80211_vif *vif,struct ieee80211_bss_conf *info,u32 changed);
  int (* start_ap) (struct ieee80211_hw *hw, struct ieee80211_vif *vif);
  void (* stop_ap) (struct ieee80211_hw *hw, struct ieee80211_vif *vif);
  u64 (* prepare_multicast) (struct ieee80211_hw *hw,struct netdev_hw_addr_list *mc_list);
  void (* configure_filter) (struct ieee80211_hw *hw,unsigned int changed_flags,unsigned int *total_flags,u64 multicast);
  int (* set_tim) (struct ieee80211_hw *hw, struct ieee80211_sta *sta,bool set);
  int (* set_key) (struct ieee80211_hw *hw, enum set_key_cmd cmd,struct ieee80211_vif *vif, struct ieee80211_sta *sta,struct ieee80211_key_conf *key);
  void (* update_tkip_key) (struct ieee80211_hw *hw,struct ieee80211_vif *vif,struct ieee80211_key_conf *conf,struct ieee80211_sta *sta,u32 iv32, u16 *phase1key);
  void (* set_rekey_data) (struct ieee80211_hw *hw,struct ieee80211_vif *vif,struct cfg80211_gtk_rekey_data *data);
  void (* set_default_unicast_key) (struct ieee80211_hw *hw,struct ieee80211_vif *vif, int idx);
  int (* hw_scan) (struct ieee80211_hw *hw, struct ieee80211_vif *vif,struct ieee80211_scan_request *req);
  void (* cancel_hw_scan) (struct ieee80211_hw *hw,struct ieee80211_vif *vif);
  int (* sched_scan_start) (struct ieee80211_hw *hw,struct ieee80211_vif *vif,struct cfg80211_sched_scan_request *req,struct ieee80211_scan_ies *ies);
  int (* sched_scan_stop) (struct ieee80211_hw *hw,struct ieee80211_vif *vif);
  void (* sw_scan_start) (struct ieee80211_hw *hw);
  void (* sw_scan_complete) (struct ieee80211_hw *hw);
  int (* get_stats) (struct ieee80211_hw *hw,struct ieee80211_low_level_stats *stats);
  void (* get_tkip_seq) (struct ieee80211_hw *hw, u8 hw_key_idx,u32 *iv32, u16 *iv16);
  int (* set_frag_threshold) (struct ieee80211_hw *hw, u32 value);
  int (* set_rts_threshold) (struct ieee80211_hw *hw, u32 value);
  int (* sta_add) (struct ieee80211_hw *hw, struct ieee80211_vif *vif,struct ieee80211_sta *sta);
  int (* sta_remove) (struct ieee80211_hw *hw, struct ieee80211_vif *vif,struct ieee80211_sta *sta);
#ifdef CONFIG_MAC80211_DEBUGFS
  void (* sta_add_debugfs) (struct ieee80211_hw *hw,struct ieee80211_vif *vif,struct ieee80211_sta *sta,struct dentry *dir);
  void (* sta_remove_debugfs) (struct ieee80211_hw *hw,struct ieee80211_vif *vif,struct ieee80211_sta *sta,struct dentry *dir);
#endif
  void (* sta_notify) (struct ieee80211_hw *hw, struct ieee80211_vif *vif,enum sta_notify_cmd, struct ieee80211_sta *sta);
  int (* sta_state) (struct ieee80211_hw *hw, struct ieee80211_vif *vif,struct ieee80211_sta *sta,enum ieee80211_sta_state old_state,enum ieee80211_sta_state new_state);
  void (* sta_pre_rcu_remove) (struct ieee80211_hw *hw,struct ieee80211_vif *vif,struct ieee80211_sta *sta);
  void (* sta_rc_update) (struct ieee80211_hw *hw,struct ieee80211_vif *vif,struct ieee80211_sta *sta,u32 changed);
  int (* conf_tx) (struct ieee80211_hw *hw,struct ieee80211_vif *vif, u16 ac,const struct ieee80211_tx_queue_params *params);
  u64 (* get_tsf) (struct ieee80211_hw *hw, struct ieee80211_vif *vif);
  void (* set_tsf) (struct ieee80211_hw *hw, struct ieee80211_vif *vif,u64 tsf);
  void (* reset_tsf) (struct ieee80211_hw *hw, struct ieee80211_vif *vif);
  int (* tx_last_beacon) (struct ieee80211_hw *hw);
  int (* ampdu_action) (struct ieee80211_hw *hw,struct ieee80211_vif *vif,enum ieee80211_ampdu_mlme_action action,struct ieee80211_sta *sta, u16 tid, u16 *ssn,u8 buf_size);
  int (* get_survey) (struct ieee80211_hw *hw, int idx,struct survey_info *survey);
  void (* rfkill_poll) (struct ieee80211_hw *hw);
  void (* set_coverage_class) (struct ieee80211_hw *hw, s16 coverage_class);
#ifdef CONFIG_NL80211_TESTMODE
  int (* testmode_cmd) (struct ieee80211_hw *hw, struct ieee80211_vif *vif,void *data, int len);
  int (* testmode_dump) (struct ieee80211_hw *hw, struct sk_buff *skb,struct netlink_callback *cb,void *data, int len);
#endif
  void (* flush) (struct ieee80211_hw *hw, struct ieee80211_vif *vif,u32 queues, bool drop);
  void (* channel_switch) (struct ieee80211_hw *hw,struct ieee80211_channel_switch *ch_switch);
  int (* set_antenna) (struct ieee80211_hw *hw, u32 tx_ant, u32 rx_ant);
  int (* get_antenna) (struct ieee80211_hw *hw, u32 *tx_ant, u32 *rx_ant);
  int (* remain_on_channel) (struct ieee80211_hw *hw,struct ieee80211_vif *vif,struct ieee80211_channel *chan,int duration,enum ieee80211_roc_type type);
  int (* cancel_remain_on_channel) (struct ieee80211_hw *hw);
  int (* set_ringparam) (struct ieee80211_hw *hw, u32 tx, u32 rx);
  void (* get_ringparam) (struct ieee80211_hw *hw,u32 *tx, u32 *tx_max, u32 *rx, u32 *rx_max);
  bool (* tx_frames_pending) (struct ieee80211_hw *hw);
  int (* set_bitrate_mask) (struct ieee80211_hw *hw, struct ieee80211_vif *vif,const struct cfg80211_bitrate_mask *mask);
  void (* rssi_callback) (struct ieee80211_hw *hw,struct ieee80211_vif *vif,enum ieee80211_rssi_event rssi_event);
  void (* allow_buffered_frames) (struct ieee80211_hw *hw,struct ieee80211_sta *sta,u16 tids, int num_frames,enum ieee80211_frame_release_type reason,bool more_data);
  void (* release_buffered_frames) (struct ieee80211_hw *hw,struct ieee80211_sta *sta,u16 tids, int num_frames,enum ieee80211_frame_release_type reason,bool more_data);
  int (* get_et_sset_count) (struct ieee80211_hw *hw,struct ieee80211_vif *vif, int sset);
  void (* get_et_stats) (struct ieee80211_hw *hw,struct ieee80211_vif *vif,struct ethtool_stats *stats, u64 *data);
  void (* get_et_strings) (struct ieee80211_hw *hw,struct ieee80211_vif *vif,u32 sset, u8 *data);
  int (* get_rssi) (struct ieee80211_hw *hw, struct ieee80211_vif *vif,struct ieee80211_sta *sta, s8 *rssi_dbm);
  void (* mgd_prepare_tx) (struct ieee80211_hw *hw,struct ieee80211_vif *vif);
  void (* mgd_protect_tdls_discover) (struct ieee80211_hw *hw,struct ieee80211_vif *vif);
  int (* add_chanctx) (struct ieee80211_hw *hw,struct ieee80211_chanctx_conf *ctx);
  void (* remove_chanctx) (struct ieee80211_hw *hw,struct ieee80211_chanctx_conf *ctx);
  void (* change_chanctx) (struct ieee80211_hw *hw,struct ieee80211_chanctx_conf *ctx,u32 changed);
  int (* assign_vif_chanctx) (struct ieee80211_hw *hw,struct ieee80211_vif *vif,struct ieee80211_chanctx_conf *ctx);
  void (* unassign_vif_chanctx) (struct ieee80211_hw *hw,struct ieee80211_vif *vif,struct ieee80211_chanctx_conf *ctx);
  int (* switch_vif_chanctx) (struct ieee80211_hw *hw,struct ieee80211_vif_chanctx_switch *vifs,int n_vifs,enum ieee80211_chanctx_switch_mode mode);
  void (* restart_complete) (struct ieee80211_hw *hw);
#if IS_ENABLED(CONFIG_IPV6)
  void (* ipv6_addr_change) (struct ieee80211_hw *hw,struct ieee80211_vif *vif,struct inet6_dev *idev);
#endif
  void (* channel_switch_beacon) (struct ieee80211_hw *hw,struct ieee80211_vif *vif,struct cfg80211_chan_def *chandef);
  int (* join_ibss) (struct ieee80211_hw *hw, struct ieee80211_vif *vif);
  void (* leave_ibss) (struct ieee80211_hw *hw, struct ieee80211_vif *vif);
  u32 (* get_expected_throughput) (struct ieee80211_sta *sta);
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>tx</term>
      <listitem><para>
Handler that 802.11 module calls for each transmitted frame.
skb contains the buffer starting from the IEEE 802.11 header.
The low-level driver should send the frame out based on
configuration in the TX control data. This handler should,
preferably, never fail and stop queues appropriately.
Must be atomic.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>start</term>
      <listitem><para>
Called before the first netdevice attached to the hardware
is enabled. This should turn on the hardware and must turn on
frame reception (for possibly enabled monitor interfaces.)
Returns negative error codes, these may be seen in userspace,
or zero.
When the device is started it should not have a MAC address
to avoid acknowledging frames before a non-monitor device
is added.
Must be implemented and can sleep.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>stop</term>
      <listitem><para>
Called after last netdevice attached to the hardware
is disabled. This should turn off the hardware (at least
it must turn off frame reception.)
May be called right after add_interface if that rejects
an interface. If you added any work onto the mac80211 workqueue
you should ensure to cancel it on this callback.
Must be implemented and can sleep.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>suspend</term>
      <listitem><para>
Suspend the device; mac80211 itself will quiesce before and
stop transmitting and doing any other configuration, and then
ask the device to suspend. This is only invoked when WoWLAN is
configured, otherwise the device is deconfigured completely and
reconfigured at resume time.
The driver may also impose special conditions under which it
wants to use the <quote>normal</quote> suspend (deconfigure), say if it only
supports WoWLAN when the device is associated. In this case, it
must return 1 from this function.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>resume</term>
      <listitem><para>
If WoWLAN was configured, this indicates that mac80211 is
now resuming its operation, after this the device must be fully
functional again. If this returns an error, the only way out is
to also unregister the device. If it returns 1, then mac80211
will also go through the regular complete restart on resume.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>set_wakeup</term>
      <listitem><para>
Enable or disable wakeup when WoWLAN configuration is
modified. The reason is that <function>device_set_wakeup_enable</function> is
supposed to be called when the configuration changes, not only
in <function>suspend</function>.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>add_interface</term>
      <listitem><para>
Called when a netdevice attached to the hardware is
enabled. Because it is not called for monitor mode devices, <parameter>start</parameter>
and <parameter>stop</parameter> must be implemented.
The driver should perform any initialization it needs before
the device can be enabled. The initial configuration for the
interface is given in the conf parameter.
The callback may refuse to add an interface by returning a
negative error code (which will be seen in userspace.)
Must be implemented and can sleep.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>change_interface</term>
      <listitem><para>
Called when a netdevice changes type. This callback
is optional, but only if it is supported can interface types be
switched while the interface is UP. The callback may sleep.
Note that while an interface is being switched, it will not be
found by the interface iteration callbacks.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>remove_interface</term>
      <listitem><para>
Notifies a driver that an interface is going down.
The <parameter>stop</parameter> callback is called after this if it is the last interface
and no monitor interfaces are present.
When all interfaces are removed, the MAC address in the hardware
must be cleared so the device no longer acknowledges packets,
the mac_addr member of the conf structure is, however, set to the
MAC address of the device going away.
Hence, this callback must be implemented. It can sleep.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>config</term>
      <listitem><para>
Handler for configuration requests. IEEE 802.11 code calls this
function to change hardware configuration, e.g., channel.
This function should never fail but returns a negative error code
if it does. The callback can sleep.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>bss_info_changed</term>
      <listitem><para>
Handler for configuration requests related to BSS
parameters that may vary during BSS's lifespan, and may affect low
level driver (e.g. assoc/disassoc status, erp parameters).
This function should not be used if no BSS has been set, unless
for association indication. The <parameter>changed</parameter> parameter indicates which
of the bss parameters has changed when a call is made. The callback
can sleep.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>start_ap</term>
      <listitem><para>
Start operation on the AP interface, this is called after all the
information in bss_conf is set and beacon can be retrieved. A channel
context is bound before this is called. Note that if the driver uses
software scan or ROC, this (and <parameter>stop_ap</parameter>) isn't called when the AP is
just <quote>paused</quote> for scanning/ROC, which is indicated by the beacon being
disabled/enabled via <parameter>bss_info_changed</parameter>.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>stop_ap</term>
      <listitem><para>
Stop operation on the AP interface.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>prepare_multicast</term>
      <listitem><para>
Prepare for multicast filter configuration.
This callback is optional, and its return value is passed
to <function>configure_filter</function>. This callback must be atomic.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>configure_filter</term>
      <listitem><para>
Configure the device's RX filter.
See the section <quote>Frame filtering</quote> for more information.
This callback must be implemented and can sleep.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>set_tim</term>
      <listitem><para>
Set TIM bit. mac80211 calls this function when a TIM bit
must be set or cleared for a given STA. Must be atomic.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>set_key</term>
      <listitem><para>
See the section <quote>Hardware crypto acceleration</quote>
This callback is only called between add_interface and
remove_interface calls, i.e. while the given virtual interface
is enabled.
Returns a negative error code if the key can't be added.
The callback can sleep.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>update_tkip_key</term>
      <listitem><para>
See the section <quote>Hardware crypto acceleration</quote>
This callback will be called in the context of Rx. Called for drivers
which set IEEE80211_KEY_FLAG_TKIP_REQ_RX_P1_KEY.
The callback must be atomic.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>set_rekey_data</term>
      <listitem><para>
If the device supports GTK rekeying, for example while the
host is suspended, it can assign this callback to retrieve the data
necessary to do GTK rekeying, this is the KEK, KCK and replay counter.
After rekeying was done it should (for example during resume) notify
userspace of the new replay counter using <function>ieee80211_gtk_rekey_notify</function>.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>set_default_unicast_key</term>
      <listitem><para>
Set the default (unicast) key index, useful for
WEP when the device sends data packets autonomously, e.g. for ARP
offloading. The index can be 0-3, or -1 for unsetting it.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>hw_scan</term>
      <listitem><para>
Ask the hardware to service the scan request, no need to start
the scan state machine in stack. The scan must honour the channel
configuration done by the regulatory agent in the wiphy's
registered bands. The hardware (or the driver) needs to make sure
that power save is disabled.
The <parameter>req</parameter> ie/ie_len members are rewritten by mac80211 to contain the
entire IEs after the SSID, so that drivers need not look at these
at all but just send them after the SSID -- mac80211 includes the
(extended) supported rates and HT information (where applicable).
When the scan finishes, <function>ieee80211_scan_completed</function> must be called;
note that it also must be called when the scan cannot finish due to
any error unless this callback returned a negative error code.
The callback can sleep.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>cancel_hw_scan</term>
      <listitem><para>
Ask the low-level tp cancel the active hw scan.
The driver should ask the hardware to cancel the scan (if possible),
but the scan will be completed only after the driver will call
<function>ieee80211_scan_completed</function>.
This callback is needed for wowlan, to prevent enqueueing a new
scan_work after the low-level driver was already suspended.
The callback can sleep.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>sched_scan_start</term>
      <listitem><para>
Ask the hardware to start scanning repeatedly at
specific intervals.  The driver must call the
<function>ieee80211_sched_scan_results</function> function whenever it finds results.
This process will continue until sched_scan_stop is called.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>sched_scan_stop</term>
      <listitem><para>
Tell the hardware to stop an ongoing scheduled scan.
In this case, <function>ieee80211_sched_scan_stopped</function> must not be called.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>sw_scan_start</term>
      <listitem><para>
Notifier function that is called just before a software scan
is started. Can be NULL, if the driver doesn't need this notification.
The callback can sleep.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>sw_scan_complete</term>
      <listitem><para>
Notifier function that is called just after a
software scan finished. Can be NULL, if the driver doesn't need
this notification.
The callback can sleep.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>get_stats</term>
      <listitem><para>
Return low-level statistics.
Returns zero if statistics are available.
The callback can sleep.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>get_tkip_seq</term>
      <listitem><para>
If your device implements TKIP encryption in hardware this
callback should be provided to read the TKIP transmit IVs (both IV32
and IV16) for the given key from hardware.
The callback must be atomic.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>set_frag_threshold</term>
      <listitem><para>
Configuration of fragmentation threshold. Assign this
if the device does fragmentation by itself; if this callback is
implemented then the stack will not do fragmentation.
The callback can sleep.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>set_rts_threshold</term>
      <listitem><para>
Configuration of RTS threshold (if device needs it)
The callback can sleep.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>sta_add</term>
      <listitem><para>
Notifies low level driver about addition of an associated station,
AP, IBSS/WDS/mesh peer etc. This callback can sleep.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>sta_remove</term>
      <listitem><para>
Notifies low level driver about removal of an associated
station, AP, IBSS/WDS/mesh peer etc. Note that after the callback
returns it isn't safe to use the pointer, not even RCU protected;
no RCU grace period is guaranteed between returning here and freeing
the station. See <parameter>sta_pre_rcu_remove</parameter> if needed.
This callback can sleep.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>sta_add_debugfs</term>
      <listitem><para>
Drivers can use this callback to add debugfs files
when a station is added to mac80211's station list. This callback
and <parameter>sta_remove_debugfs</parameter> should be within a CONFIG_MAC80211_DEBUGFS
conditional. This callback can sleep.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>sta_remove_debugfs</term>
      <listitem><para>
Remove the debugfs files which were added using
<parameter>sta_add_debugfs</parameter>. This callback can sleep.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>sta_notify</term>
      <listitem><para>
Notifies low level driver about power state transition of an
associated station, AP,  IBSS/WDS/mesh peer etc. For a VIF operating
in AP mode, this callback will not be called when the flag
<constant>IEEE80211_HW_AP_LINK_PS</constant> is set. Must be atomic.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>sta_state</term>
      <listitem><para>
Notifies low level driver about state transition of a
station (which can be the AP, a client, IBSS/WDS/mesh peer etc.)
This callback is mutually exclusive with <parameter>sta_add</parameter>/<parameter>sta_remove</parameter>.
It must not fail for down transitions but may fail for transitions
up the list of states. Also note that after the callback returns it
isn't safe to use the pointer, not even RCU protected - no RCU grace
period is guaranteed between returning here and freeing the station.
See <parameter>sta_pre_rcu_remove</parameter> if needed.
The callback can sleep.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>sta_pre_rcu_remove</term>
      <listitem><para>
Notify driver about station removal before RCU
synchronisation. This is useful if a driver needs to have station
pointers protected using RCU, it can then use this call to clear
the pointers instead of waiting for an RCU grace period to elapse
in <parameter>sta_state</parameter>.
The callback can sleep.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>sta_rc_update</term>
      <listitem><para>
Notifies the driver of changes to the bitrates that can be
used to transmit to the station. The changes are advertised with bits
from <structname>enum</structname> ieee80211_rate_control_changed and the values are reflected
in the station data. This callback should only be used when the driver
uses hardware rate control (<constant>IEEE80211_HW_HAS_RATE_CONTROL</constant>) since
otherwise the rate control algorithm is notified directly.
Must be atomic.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>conf_tx</term>
      <listitem><para>
Configure TX queue parameters (EDCF (aifs, cw_min, cw_max),
bursting) for a hardware TX queue.
Returns a negative error code on failure.
The callback can sleep.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>get_tsf</term>
      <listitem><para>
Get the current TSF timer value from firmware/hardware. Currently,
this is only used for IBSS mode BSSID merging and debugging. Is not a
required function.
The callback can sleep.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>set_tsf</term>
      <listitem><para>
Set the TSF timer to the specified value in the firmware/hardware.
Currently, this is only used for IBSS mode debugging. Is not a
required function.
The callback can sleep.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>reset_tsf</term>
      <listitem><para>
Reset the TSF timer and allow firmware/hardware to synchronize
with other STAs in the IBSS. This is only used in IBSS mode. This
function is optional if the firmware/hardware takes full care of
TSF synchronization.
The callback can sleep.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>tx_last_beacon</term>
      <listitem><para>
Determine whether the last IBSS beacon was sent by us.
This is needed only for IBSS mode and the result of this function is
used to determine whether to reply to Probe Requests.
Returns non-zero if this device sent the last beacon.
The callback can sleep.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>ampdu_action</term>
      <listitem><para>
Perform a certain A-MPDU action
The RA/TID combination determines the destination and TID we want
the ampdu action to be performed for. The action is defined through
ieee80211_ampdu_mlme_action. Starting sequence number (<parameter>ssn</parameter>)
is the first frame we expect to perform the action on. Notice
that TX/RX_STOP can pass NULL for this parameter.
The <parameter>buf_size</parameter> parameter is only valid when the action is set to
<constant>IEEE80211_AMPDU_TX_OPERATIONAL</constant> and indicates the peer's reorder
buffer size (number of subframes) for this session -- the driver
may neither send aggregates containing more subframes than this
nor send aggregates in a way that lost frames would exceed the
buffer size. If just limiting the aggregate size, this would be
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>get_survey</term>
      <listitem><para>
Return per-channel survey information
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>rfkill_poll</term>
      <listitem><para>
Poll rfkill hardware state. If you need this, you also
need to set wiphy-&gt;rfkill_poll to <constant>true</constant> before registration,
and need to call <function>wiphy_rfkill_set_hw_state</function> in the callback.
The callback can sleep.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>set_coverage_class</term>
      <listitem><para>
Set slot time for given coverage class as specified
in IEEE 802.11-2007 section 17.3.8.6 and modify ACK timeout
accordingly; coverage class equals to -1 to enable ACK timeout
estimation algorithm (dynack). To disable dynack set valid value for
coverage class. This callback is not required and may sleep.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>testmode_cmd</term>
      <listitem><para>
Implement a cfg80211 test mode command. The passed <parameter>vif</parameter> may
be <constant>NULL</constant>. The callback can sleep.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>testmode_dump</term>
      <listitem><para>
Implement a cfg80211 test mode dump. The callback can sleep.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>flush</term>
      <listitem><para>
Flush all pending frames from the hardware queue, making sure
that the hardware queues are empty. The <parameter>queues</parameter> parameter is a bitmap
of queues to flush, which is useful if different virtual interfaces
use different hardware queues; it may also indicate all queues.
If the parameter <parameter>drop</parameter> is set to <constant>true</constant>, pending frames may be dropped.
Note that vif can be NULL.
The callback can sleep.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>channel_switch</term>
      <listitem><para>
Drivers that need (or want) to offload the channel
switch operation for CSAs received from the AP may implement this
callback. They must then call <function>ieee80211_chswitch_done</function> to indicate
completion of the channel switch.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>set_antenna</term>
      <listitem><para>
Set antenna configuration (tx_ant, rx_ant) on the device.
Parameters are bitmaps of allowed antennas to use for TX/RX. Drivers may
reject TX/RX mask combinations they cannot support by returning -EINVAL
(also see nl80211.h <parameter>NL80211_ATTR_WIPHY_ANTENNA_TX</parameter>).
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>get_antenna</term>
      <listitem><para>
Get current antenna configuration from device (tx_ant, rx_ant).
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>remain_on_channel</term>
      <listitem><para>
Starts an off-channel period on the given channel, must
call back to <function>ieee80211_ready_on_channel</function> when on that channel. Note
that normal channel traffic is not stopped as this is intended for hw
offload. Frames to transmit on the off-channel channel are transmitted
normally except for the <constant>IEEE80211_TX_CTL_TX_OFFCHAN</constant> flag. When the
duration (which will always be non-zero) expires, the driver must call
<function>ieee80211_remain_on_channel_expired</function>.
Note that this callback may be called while the device is in IDLE and
must be accepted in this case.
This callback may sleep.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>cancel_remain_on_channel</term>
      <listitem><para>
Requests that an ongoing off-channel period is
aborted before it expires. This callback may sleep.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>set_ringparam</term>
      <listitem><para>
Set tx and rx ring sizes.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>get_ringparam</term>
      <listitem><para>
Get tx and rx ring current and maximum sizes.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>tx_frames_pending</term>
      <listitem><para>
Check if there is any pending frame in the hardware
queues before entering power save.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>set_bitrate_mask</term>
      <listitem><para>
Set a mask of rates to be used for rate control selection
when transmitting a frame. Currently only legacy rates are handled.
The callback can sleep.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>rssi_callback</term>
      <listitem><para>
Notify driver when the average RSSI goes above/below
thresholds that were registered previously. The callback can sleep.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>allow_buffered_frames</term>
      <listitem><para>
Prepare device to allow the given number of frames
to go out to the given station. The frames will be sent by mac80211
via the usual TX path after this call. The TX information for frames
released will also have the <constant>IEEE80211_TX_CTL_NO_PS_BUFFER</constant> flag set
and the last one will also have <constant>IEEE80211_TX_STATUS_EOSP</constant> set. In case
frames from multiple TIDs are released and the driver might reorder
them between the TIDs, it must set the <constant>IEEE80211_TX_STATUS_EOSP</constant> flag
on the last frame and clear it on all others and also handle the EOSP
bit in the QoS header correctly. Alternatively, it can also call the
<function>ieee80211_sta_eosp</function> function.
The <parameter>tids</parameter> parameter is a bitmap and tells the driver which TIDs the
frames will be on; it will at most have two bits set.
This callback must be atomic.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>release_buffered_frames</term>
      <listitem><para>
Release buffered frames according to the given
parameters. In the case where the driver buffers some frames for
sleeping stations mac80211 will use this callback to tell the driver
to release some frames, either for PS-poll or uAPSD.
Note that if the <parameter>more_data</parameter> parameter is <constant>false</constant> the driver must check
if there are more frames on the given TIDs, and if there are more than
the frames being released then it must still set the more-data bit in
the frame. If the <parameter>more_data</parameter> parameter is <constant>true</constant>, then of course the
more-data bit must always be set.
The <parameter>tids</parameter> parameter tells the driver which TIDs to release frames
from, for PS-poll it will always have only a single bit set.
In the case this is used for a PS-poll initiated release, the
<parameter>num_frames</parameter> parameter will always be 1 so code can be shared. In
this case the driver must also set <constant>IEEE80211_TX_STATUS_EOSP</constant> flag
on the TX status (and must report TX status) so that the PS-poll
period is properly ended. This is used to avoid sending multiple
responses for a retried PS-poll frame.
In the case this is used for uAPSD, the <parameter>num_frames</parameter> parameter may be
bigger than one, but the driver may send fewer frames (it must send
at least one, however). In this case it is also responsible for
setting the EOSP flag in the QoS header of the frames. Also, when the
service period ends, the driver must set <constant>IEEE80211_TX_STATUS_EOSP</constant>
on the last frame in the SP. Alternatively, it may call the function
<function>ieee80211_sta_eosp</function> to inform mac80211 of the end of the SP.
This callback must be atomic.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>get_et_sset_count</term>
      <listitem><para>
Ethtool API to get string-set count.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>get_et_stats</term>
      <listitem><para>
Ethtool API to get a set of u64 stats.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>get_et_strings</term>
      <listitem><para>
Ethtool API to get a set of strings to describe stats
and perhaps other supported types of ethtool data-sets.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>get_rssi</term>
      <listitem><para>
Get current signal strength in dBm, the function is optional
and can sleep.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>mgd_prepare_tx</term>
      <listitem><para>
Prepare for transmitting a management frame for association
before associated. In multi-channel scenarios, a virtual interface is
bound to a channel before it is associated, but as it isn't associated
yet it need not necessarily be given airtime, in particular since any
transmission to a P2P GO needs to be synchronized against the GO's
powersave state. mac80211 will call this function before transmitting a
management frame prior to having successfully associated to allow the
driver to give it channel time for the transmission, to get a response
and to be able to synchronize with the GO.
The callback will be called before each transmission and upon return
mac80211 will transmit the frame right away.
The callback is optional and can (should!) sleep.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>mgd_protect_tdls_discover</term>
      <listitem><para>
Protect a TDLS discovery session. After sending
a TDLS discovery-request, we expect a reply to arrive on the AP's
channel. We must stay on the channel (no PSM, scan, etc.), since a TDLS
setup-response is a direct packet not buffered by the AP.
mac80211 will call this function just before the transmission of a TDLS
discovery-request. The recommended period of protection is at least
2 * (DTIM period).
The callback is optional and can sleep.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>add_chanctx</term>
      <listitem><para>
Notifies device driver about new channel context creation.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>remove_chanctx</term>
      <listitem><para>
Notifies device driver about channel context destruction.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>change_chanctx</term>
      <listitem><para>
Notifies device driver about channel context changes that
may happen when combining different virtual interfaces on the same
channel context with different settings
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>assign_vif_chanctx</term>
      <listitem><para>
Notifies device driver about channel context being bound
to vif. Possible use is for hw queue remapping.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>unassign_vif_chanctx</term>
      <listitem><para>
Notifies device driver about channel context being
unbound from vif.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>switch_vif_chanctx</term>
      <listitem><para>
switch a number of vifs from one chanctx to
another, as specified in the list of
<parameter>ieee80211_vif_chanctx_switch</parameter> passed to the driver, according
to the mode defined in <structname>ieee80211_chanctx_switch_mode</structname>.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>restart_complete</term>
      <listitem><para>
Called after a call to <function>ieee80211_restart_hw</function>, when the
reconfiguration has completed. This can help the driver implement the
reconfiguration step. Also called when reconfiguring because the
driver's resume function returned 1, as this is just like an <quote>inline</quote>
hardware restart. This callback may sleep.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>ipv6_addr_change</term>
      <listitem><para>
IPv6 address assignment on the given interface changed.
Currently, this is only called for managed or P2P client interfaces.
This callback is optional; it must not sleep.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>channel_switch_beacon</term>
      <listitem><para>
Starts a channel switch to a new channel.
Beacons are modified to include CSA or ECSA IEs before calling this
function. The corresponding count fields in these IEs must be
decremented, and when they reach 1 the driver must call
<function>ieee80211_csa_finish</function>. Drivers which use <function>ieee80211_beacon_get</function>
get the csa counter decremented by mac80211, but must check if it is
1 using <function>ieee80211_csa_is_complete</function> after the beacon has been
transmitted and then call <function>ieee80211_csa_finish</function>.
If the CSA count starts as zero or 1, this function will not be called,
since there won't be any time to beacon before the switch anyway.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>join_ibss</term>
      <listitem><para>
Join an IBSS (on an IBSS interface); this is called after all
information in bss_conf is set up and the beacon can be retrieved. A
channel context is bound before this is called.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>leave_ibss</term>
      <listitem><para>
Leave the IBSS again.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>get_expected_throughput</term>
      <listitem><para>
extract the expected throughput towards the
specified station. The returned value is expressed in Kbps. It returns 0
if the RC algorithm does not have proper data to provide.
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
<refsect1>
<title>Description</title>
<para>
   </para><para>

   This structure contains various callbacks that the driver may
   handle or, in some cases, must handle, for example to configure
   the hardware to a new channel or to transmit a frame.
</para>
</refsect1>
<refsect1>
<title>possible with a buf_size of 8</title>
<para>
   - TX: 1.....7
   - RX:  2....7 (lost frame #1)
   - TX:        8..1...
   which is invalid since #1 was now re-transmitted well past the
   buffer size of 8. Correct ways to retransmit #1 would be:
   - TX:       1 or 18 or 81
   Even <quote>189</quote> would be wrong since 1 could be lost again.
   </para><para>

   Returns a negative error code on failure.
   The callback can sleep.
</para>
</refsect1>
</refentry>

<refentry id="API-ieee80211-alloc-hw">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ieee80211_alloc_hw</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ieee80211_alloc_hw</refname>
 <refpurpose>
  Allocate a new hardware device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct ieee80211_hw * <function>ieee80211_alloc_hw </function></funcdef>
   <paramdef>size_t <parameter>priv_data_len</parameter></paramdef>
   <paramdef>const struct ieee80211_ops * <parameter>ops</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>priv_data_len</parameter></term>
   <listitem>
    <para>
     length of private data
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>ops</parameter></term>
   <listitem>
    <para>
     callbacks for this device
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   </para><para>

   This must be called once for each hardware device. The returned pointer
   must be used to refer to this device when calling other functions.
   mac80211 allocates a private data area for the driver pointed to by
   <parameter>priv</parameter> in <structname>struct ieee80211_hw</structname>, the size of this area is given as
   <parameter>priv_data_len</parameter>.
</para>
</refsect1>
<refsect1>
<title>Return</title>
<para>
   A pointer to the new hardware device, or <constant>NULL</constant> on error.
</para>
</refsect1>
</refentry>

<refentry id="API-ieee80211-register-hw">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ieee80211_register_hw</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ieee80211_register_hw</refname>
 <refpurpose>
  Register hardware device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>ieee80211_register_hw </function></funcdef>
   <paramdef>struct ieee80211_hw * <parameter>hw</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>hw</parameter></term>
   <listitem>
    <para>
     the device to register as returned by <function>ieee80211_alloc_hw</function>
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   </para><para>

   You must call this function before any other functions in
   mac80211. Note that before a hardware can be registered, you
   need to fill the contained wiphy's information.
</para>
</refsect1>
<refsect1>
<title>Return</title>
<para>
   0 on success. An error code otherwise.
</para>
</refsect1>
</refentry>

<refentry id="API-ieee80211-unregister-hw">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ieee80211_unregister_hw</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ieee80211_unregister_hw</refname>
 <refpurpose>
  Unregister a hardware device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>ieee80211_unregister_hw </function></funcdef>
   <paramdef>struct ieee80211_hw * <parameter>hw</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>hw</parameter></term>
   <listitem>
    <para>
     the hardware to unregister
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   </para><para>

   This function instructs mac80211 to free allocated resources
   and unregister netdevices from the networking subsystem.
</para>
</refsect1>
</refentry>

<refentry id="API-ieee80211-free-hw">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ieee80211_free_hw</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ieee80211_free_hw</refname>
 <refpurpose>
  free hardware descriptor
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>ieee80211_free_hw </function></funcdef>
   <paramdef>struct ieee80211_hw * <parameter>hw</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>hw</parameter></term>
   <listitem>
    <para>
     the hardware to free
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   </para><para>

   This function frees everything that was allocated, including the
   private data for the driver. You must call <function>ieee80211_unregister_hw</function>
   before calling this function.
</para>
</refsect1>
</refentry>

      </chapter>

      <chapter id="phy-handling">
        <title>PHY configuration</title>
        <para>TBD</para>
        <para>
          This chapter should describe PHY handling including
          start/stop callbacks and the various structures used.
        </para>
<refentry id="API-struct-ieee80211-conf">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct ieee80211_conf</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct ieee80211_conf</refname>
 <refpurpose>
  configuration of the device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct ieee80211_conf {
  u32 flags;
  int power_level;
  int dynamic_ps_timeout;
  int max_sleep_period;
  u16 listen_interval;
  u8 ps_dtim_period;
  u8 long_frame_max_tx_count;
  u8 short_frame_max_tx_count;
  struct cfg80211_chan_def chandef;
  bool radar_enabled;
  enum ieee80211_smps_mode smps_mode;
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>flags</term>
      <listitem><para>
configuration flags defined above
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>power_level</term>
      <listitem><para>
requested transmit power (in dBm), backward compatibility
value only that is set to the minimum of all interfaces
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>dynamic_ps_timeout</term>
      <listitem><para>
The dynamic powersave timeout (in ms), see the
powersave documentation below. This variable is valid only when
the CONF_PS flag is set.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>max_sleep_period</term>
      <listitem><para>
the maximum number of beacon intervals to sleep for
before checking the beacon for a TIM bit (managed mode only); this
value will be only achievable between DTIM frames, the hardware
needs to check for the multicast traffic bit in DTIM beacons.
This variable is valid only when the CONF_PS flag is set.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>listen_interval</term>
      <listitem><para>
listen interval in units of beacon interval
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>ps_dtim_period</term>
      <listitem><para>
The DTIM period of the AP we're connected to, for use
in power saving. Power saving will not be enabled until a beacon
has been received and the DTIM period is known.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>long_frame_max_tx_count</term>
      <listitem><para>
Maximum number of transmissions for a <quote>long</quote> frame
(a frame not RTS protected), called <quote>dot11LongRetryLimit</quote> in 802.11,
but actually means the number of transmissions not the number of retries
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>short_frame_max_tx_count</term>
      <listitem><para>
Maximum number of transmissions for a <quote>short</quote>
frame, called <quote>dot11ShortRetryLimit</quote> in 802.11, but actually means the
number of transmissions not the number of retries
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>chandef</term>
      <listitem><para>
the channel definition to tune to
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>radar_enabled</term>
      <listitem><para>
whether radar detection is enabled
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>smps_mode</term>
      <listitem><para>
spatial multiplexing powersave mode; note that
<constant>IEEE80211_SMPS_STATIC</constant> is used when the device is not
configured for an HT channel.
Note that this is only valid if channel contexts are not used,
otherwise each channel context has the number of chains listed.
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
<refsect1>
<title>Description</title>
<para>
   </para><para>

   This struct indicates how the driver shall configure the hardware.
</para>
</refsect1>
</refentry>

<refentry id="API-enum-ieee80211-conf-flags">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>enum ieee80211_conf_flags</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>enum ieee80211_conf_flags</refname>
 <refpurpose>
  configuration flags
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
enum ieee80211_conf_flags {
  IEEE80211_CONF_MONITOR,
  IEEE80211_CONF_PS,
  IEEE80211_CONF_IDLE,
  IEEE80211_CONF_OFFCHANNEL
};  </programlisting>
</refsynopsisdiv>
<refsect1>
 <title>Constants</title>
  <variablelist>
    <varlistentry>      <term>IEEE80211_CONF_MONITOR</term>
      <listitem><para>
there's a monitor interface present -- use this
to determine for example whether to calculate timestamps for packets
or not, do not use instead of filter flags!
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>IEEE80211_CONF_PS</term>
      <listitem><para>
Enable 802.11 power save mode (managed mode only).
This is the power save mode defined by IEEE 802.11-2007 section 11.2,
meaning that the hardware still wakes up for beacons, is able to
transmit frames and receive the possible acknowledgment frames.
Not to be confused with hardware specific wakeup/sleep states,
driver is responsible for that. See the section <quote>Powersave support</quote>
for more.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>IEEE80211_CONF_IDLE</term>
      <listitem><para>
The device is running, but idle; if the flag is set
the driver should be prepared to handle configuration requests but
may turn the device off as much as possible. Typically, this flag will
be set when an interface is set UP but not associated or scanning, but
it can also be unset in that case when monitor interfaces are active.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>IEEE80211_CONF_OFFCHANNEL</term>
      <listitem><para>
The device is currently not on its main
operating channel.
      </para></listitem>
    </varlistentry>
  </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   </para><para>

   Flags to define PHY configuration options
</para>
</refsect1>
</refentry>

      </chapter>

      <chapter id="iface-handling">
        <title>Virtual interfaces</title>
        <para>TBD</para>
        <para>
          This chapter should describe virtual interface basics
          that are relevant to the driver (VLANs, MGMT etc are not.)
          It should explain the use of the add_iface/remove_iface
          callbacks as well as the interface configuration callbacks.
        </para>
        <para>Things related to AP mode should be discussed there.</para>
        <para>
          Things related to supporting multiple interfaces should be
          in the appropriate chapter, a BIG FAT note should be here about
          this though and the recommendation to allow only a single
          interface in STA mode at first!
        </para>
<refentry id="API-struct-ieee80211-vif">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct ieee80211_vif</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct ieee80211_vif</refname>
 <refpurpose>
  per-interface data
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct ieee80211_vif {
  enum nl80211_iftype type;
  struct ieee80211_bss_conf bss_conf;
  u8 addr[ETH_ALEN];
  bool p2p;
  bool csa_active;
  u8 cab_queue;
  u8 hw_queue[IEEE80211_NUM_ACS];
  struct ieee80211_chanctx_conf __rcu * chanctx_conf;
  u32 driver_flags;
#ifdef CONFIG_MAC80211_DEBUGFS
  struct dentry * debugfs_dir;
#endif
  u8 drv_priv[0];
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>type</term>
      <listitem><para>
type of this virtual interface
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>bss_conf</term>
      <listitem><para>
BSS configuration for this interface, either our own
or the BSS we're associated to
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>addr[ETH_ALEN]</term>
      <listitem><para>
address of this interface
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>p2p</term>
      <listitem><para>
indicates whether this AP or STA interface is a p2p
interface, i.e. a GO or p2p-sta respectively
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>csa_active</term>
      <listitem><para>
marks whether a channel switch is going on. Internally it is
write-protected by sdata_lock and local-&gt;mtx so holding either is fine
for read access.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>cab_queue</term>
      <listitem><para>
content-after-beacon (DTIM beacon really) queue, AP mode only
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>hw_queue[IEEE80211_NUM_ACS]</term>
      <listitem><para>
hardware queue for each AC
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>chanctx_conf</term>
      <listitem><para>
The channel context this interface is assigned to, or <constant>NULL</constant>
when it is not assigned. This pointer is RCU-protected due to the TX
path needing to access it; even though the netdev carrier will always
be off when it is <constant>NULL</constant> there can still be races and packets could be
processed after it switches back to <constant>NULL</constant>.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>driver_flags</term>
      <listitem><para>
flags/capabilities the driver has for this interface,
these need to be set (or cleared) when the interface is added
or, if supported by the driver, the interface type is changed
at runtime, mac80211 will never touch this field
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>debugfs_dir</term>
      <listitem><para>
debugfs dentry, can be used by drivers to create own per
interface debug files. Note that it will be NULL for the virtual
monitor interface (if that is requested.)
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>drv_priv[0]</term>
      <listitem><para>
data area for driver use, will always be aligned to
sizeof(void *).
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
<refsect1>
<title>Description</title>
<para>
   </para><para>

   Data in this structure is continually present for driver
   use during the life of a virtual interface.
</para>
</refsect1>
</refentry>

      </chapter>

      <chapter id="rx-tx">
        <title>Receive and transmit processing</title>
        <sect1>
          <title>what should be here</title>
          <para>TBD</para>
          <para>
            This should describe the receive and transmit
            paths in mac80211/the drivers as well as
            transmit status handling.
          </para>
        </sect1>
        <sect1>
          <title>Frame format</title>
<para>
   </para><para>
   As a general rule, when frames are passed between mac80211 and the driver,
   they start with the IEEE 802.11 header and include the same octets that are
   sent over the air except for the FCS which should be calculated by the
   hardware.
   </para><para>
   There are, however, various exceptions to this rule for advanced features:
   </para><para>
   The first exception is for hardware encryption and decryption offload
   where the IV/ICV may or may not be generated in hardware.
   </para><para>
   Secondly, when the hardware handles fragmentation, the frame handed to
   the driver from mac80211 is the MSDU, not the MPDU.
</para>

        </sect1>
        <sect1>
          <title>Packet alignment</title>
<para>
   </para><para>
   Drivers always need to pass packets that are aligned to two-byte boundaries
   to the stack.
   </para><para>
   Additionally, should, if possible, align the payload data in a way that
   guarantees that the contained IP header is aligned to a four-byte
   boundary. In the case of regular frames, this simply means aligning the
   payload to a four-byte boundary (because either the IP header is directly
   contained, or IV/RFC1042 headers that have a length divisible by four are
   in front of it).  If the payload data is not properly aligned and the
   architecture doesn't support efficient unaligned operations, mac80211
   will align the data.
   </para><para>
   With A-MSDU frames, however, the payload data address must yield two modulo
   four because there are 14-byte 802.3 headers within the A-MSDU frames that
   push the IP header further back to a multiple of four again. Thankfully, the
   specs were sane enough this time around to require padding each A-MSDU
   subframe to a length that is a multiple of four.
   </para><para>
   Padding like Atheros hardware adds which is between the 802.11 header and
   the payload is not supported, the driver is required to move the 802.11
   header to be directly in front of the payload in that case.
</para>

        </sect1>
        <sect1>
          <title>Calling into mac80211 from interrupts</title>
<para>
   </para><para>
   Only <function>ieee80211_tx_status_irqsafe</function> and <function>ieee80211_rx_irqsafe</function> can be
   called in hardware interrupt context. The low-level driver must not call any
   other functions in hardware interrupt context. If there is a need for such
   call, the low-level driver should first ACK the interrupt and perform the
   IEEE 802.11 code call after this, e.g. from a scheduled workqueue or even
   tasklet function.
   </para><para>
   NOTE: If the driver opts to use the <function>_irqsafe</function> functions, it may not also
   use the non-IRQ-safe functions!
</para>

        </sect1>
        <sect1>
          <title>functions/definitions</title>
<refentry id="API-struct-ieee80211-rx-status">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct ieee80211_rx_status</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct ieee80211_rx_status</refname>
 <refpurpose>
  receive status
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct ieee80211_rx_status {
  u64 mactime;
  u32 device_timestamp;
  u32 ampdu_reference;
  u32 flag;
  u16 freq;
  u8 vht_flag;
  u8 rate_idx;
  u8 vht_nss;
  u8 rx_flags;
  u8 band;
  u8 antenna;
  s8 signal;
  u8 chains;
  s8 chain_signal[IEEE80211_MAX_CHAINS];
  u8 ampdu_delimiter_crc;
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>mactime</term>
      <listitem><para>
value in microseconds of the 64-bit Time Synchronization Function
(TSF) timer when the first data symbol (MPDU) arrived at the hardware.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>device_timestamp</term>
      <listitem><para>
arbitrary timestamp for the device, mac80211 doesn't use
it but can store it and pass it back to the driver for synchronisation
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>ampdu_reference</term>
      <listitem><para>
A-MPDU reference number, must be a different value for
each A-MPDU but the same for each subframe within one A-MPDU
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>flag</term>
      <listitem><para>
<constant>RX_FLAG_</constant>*
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>freq</term>
      <listitem><para>
frequency the radio was tuned to when receiving this frame, in MHz
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>vht_flag</term>
      <listitem><para>
<constant>RX_VHT_FLAG_</constant>*
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>rate_idx</term>
      <listitem><para>
index of data rate into band's supported rates or MCS index if
HT or VHT is used (<constant>RX_FLAG_HT</constant>/<constant>RX_FLAG_VHT</constant>)
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>vht_nss</term>
      <listitem><para>
number of streams (VHT only)
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>rx_flags</term>
      <listitem><para>
internal RX flags for mac80211
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>band</term>
      <listitem><para>
the active band when this frame was received
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>antenna</term>
      <listitem><para>
antenna used
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>signal</term>
      <listitem><para>
signal strength when receiving this frame, either in dBm, in dB or
unspecified depending on the hardware capabilities flags
<parameter>IEEE80211_HW_SIGNAL_</parameter>*
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>chains</term>
      <listitem><para>
bitmask of receive chains for which separate signal strength
values were filled.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>chain_signal[IEEE80211_MAX_CHAINS]</term>
      <listitem><para>
per-chain signal strength, in dBm (unlike <parameter>signal</parameter>, doesn't
support dB or unspecified units)
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>ampdu_delimiter_crc</term>
      <listitem><para>
A-MPDU delimiter CRC
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
<refsect1>
<title>Description</title>
<para>
   </para><para>

   The low-level driver should provide this information (the subset
   supported by hardware) to the 802.11 code with each received
   frame, in the skb's control buffer (cb).
</para>
</refsect1>
</refentry>

<refentry id="API-enum-mac80211-rx-flags">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>enum mac80211_rx_flags</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>enum mac80211_rx_flags</refname>
 <refpurpose>
  receive flags
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
enum mac80211_rx_flags {
  RX_FLAG_MMIC_ERROR,
  RX_FLAG_DECRYPTED,
  RX_FLAG_MMIC_STRIPPED,
  RX_FLAG_IV_STRIPPED,
  RX_FLAG_FAILED_FCS_CRC,
  RX_FLAG_FAILED_PLCP_CRC,
  RX_FLAG_MACTIME_START,
  RX_FLAG_SHORTPRE,
  RX_FLAG_HT,
  RX_FLAG_40MHZ,
  RX_FLAG_SHORT_GI,
  RX_FLAG_NO_SIGNAL_VAL,
  RX_FLAG_HT_GF,
  RX_FLAG_AMPDU_DETAILS,
  RX_FLAG_AMPDU_REPORT_ZEROLEN,
  RX_FLAG_AMPDU_IS_ZEROLEN,
  RX_FLAG_AMPDU_LAST_KNOWN,
  RX_FLAG_AMPDU_IS_LAST,
  RX_FLAG_AMPDU_DELIM_CRC_ERROR,
  RX_FLAG_AMPDU_DELIM_CRC_KNOWN,
  RX_FLAG_MACTIME_END,
  RX_FLAG_VHT,
  RX_FLAG_LDPC,
  RX_FLAG_STBC_MASK,
  RX_FLAG_10MHZ,
  RX_FLAG_5MHZ,
  RX_FLAG_AMSDU_MORE
};  </programlisting>
</refsynopsisdiv>
<refsect1>
 <title>Constants</title>
  <variablelist>
    <varlistentry>      <term>RX_FLAG_MMIC_ERROR</term>
      <listitem><para>
Michael MIC error was reported on this frame.
Use together with <constant>RX_FLAG_MMIC_STRIPPED</constant>.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>RX_FLAG_DECRYPTED</term>
      <listitem><para>
This frame was decrypted in hardware.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>RX_FLAG_MMIC_STRIPPED</term>
      <listitem><para>
the Michael MIC is stripped off this frame,
verification has been done by the hardware.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>RX_FLAG_IV_STRIPPED</term>
      <listitem><para>
The IV/ICV are stripped from this frame.
If this flag is set, the stack cannot do any replay detection
hence the driver or hardware will have to do that.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>RX_FLAG_FAILED_FCS_CRC</term>
      <listitem><para>
Set this flag if the FCS check failed on
the frame.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>RX_FLAG_FAILED_PLCP_CRC</term>
      <listitem><para>
Set this flag if the PCLP check failed on
the frame.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>RX_FLAG_MACTIME_START</term>
      <listitem><para>
The timestamp passed in the RX status (<parameter>mactime</parameter>
field) is valid and contains the time the first symbol of the MPDU
was received. This is useful in monitor mode and for proper IBSS
merging.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>RX_FLAG_SHORTPRE</term>
      <listitem><para>
Short preamble was used for this frame
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>RX_FLAG_HT</term>
      <listitem><para>
HT MCS was used and rate_idx is MCS index
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>RX_FLAG_40MHZ</term>
      <listitem><para>
HT40 (40 MHz) was used
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>RX_FLAG_SHORT_GI</term>
      <listitem><para>
Short guard interval was used
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>RX_FLAG_NO_SIGNAL_VAL</term>
      <listitem><para>
The signal strength value is not present.
Valid only for data frames (mainly A-MPDU)
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>RX_FLAG_HT_GF</term>
      <listitem><para>
This frame was received in a HT-greenfield transmission, if
the driver fills this value it should add <constant>IEEE80211_RADIOTAP_MCS_HAVE_FMT</constant>
to hw.radiotap_mcs_details to advertise that fact
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>RX_FLAG_AMPDU_DETAILS</term>
      <listitem><para>
A-MPDU details are known, in particular the reference
number (<parameter>ampdu_reference</parameter>) must be populated and be a distinct number for
each A-MPDU
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>RX_FLAG_AMPDU_REPORT_ZEROLEN</term>
      <listitem><para>
driver reports 0-length subframes
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>RX_FLAG_AMPDU_IS_ZEROLEN</term>
      <listitem><para>
This is a zero-length subframe, for
monitoring purposes only
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>RX_FLAG_AMPDU_LAST_KNOWN</term>
      <listitem><para>
last subframe is known, should be set on all
subframes of a single A-MPDU
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>RX_FLAG_AMPDU_IS_LAST</term>
      <listitem><para>
this subframe is the last subframe of the A-MPDU
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>RX_FLAG_AMPDU_DELIM_CRC_ERROR</term>
      <listitem><para>
A delimiter CRC error has been detected
on this subframe
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>RX_FLAG_AMPDU_DELIM_CRC_KNOWN</term>
      <listitem><para>
The delimiter CRC field is known (the CRC
is stored in the <parameter>ampdu_delimiter_crc</parameter> field)
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>RX_FLAG_MACTIME_END</term>
      <listitem><para>
The timestamp passed in the RX status (<parameter>mactime</parameter>
field) is valid and contains the time the last symbol of the MPDU
(including FCS) was received.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>RX_FLAG_VHT</term>
      <listitem><para>
VHT MCS was used and rate_index is MCS index
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>RX_FLAG_LDPC</term>
      <listitem><para>
LDPC was used
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>RX_FLAG_STBC_MASK</term>
      <listitem><para>
STBC 2 bit bitmask. 1 - Nss=1, 2 - Nss=2, 3 - Nss=3
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>RX_FLAG_10MHZ</term>
      <listitem><para>
10 MHz (half channel) was used
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>RX_FLAG_5MHZ</term>
      <listitem><para>
5 MHz (quarter channel) was used
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>RX_FLAG_AMSDU_MORE</term>
      <listitem><para>
Some drivers may prefer to report separate A-MSDU
subframes instead of a one huge frame for performance reasons.
All, but the last MSDU from an A-MSDU should have this flag set. E.g.
if an A-MSDU has 3 frames, the first 2 must have the flag set, while
the 3rd (last) one must not have this flag set. The flag is used to
deal with retransmission/duplication recovery properly since A-MSDU
subframes share the same sequence number. Reported subframes can be
either regular MSDU or singly A-MSDUs. Subframes must not be
interleaved with other frames.
      </para></listitem>
    </varlistentry>
  </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   </para><para>

   These flags are used with the <parameter>flag</parameter> member of <structname>struct ieee80211_rx_status</structname>.
</para>
</refsect1>
</refentry>

<refentry id="API-enum-mac80211-tx-info-flags">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>enum mac80211_tx_info_flags</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>enum mac80211_tx_info_flags</refname>
 <refpurpose>
  flags to describe transmission information/status
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
enum mac80211_tx_info_flags {
  IEEE80211_TX_CTL_REQ_TX_STATUS,
  IEEE80211_TX_CTL_ASSIGN_SEQ,
  IEEE80211_TX_CTL_NO_ACK,
  IEEE80211_TX_CTL_CLEAR_PS_FILT,
  IEEE80211_TX_CTL_FIRST_FRAGMENT,
  IEEE80211_TX_CTL_SEND_AFTER_DTIM,
  IEEE80211_TX_CTL_AMPDU,
  IEEE80211_TX_CTL_INJECTED,
  IEEE80211_TX_STAT_TX_FILTERED,
  IEEE80211_TX_STAT_ACK,
  IEEE80211_TX_STAT_AMPDU,
  IEEE80211_TX_STAT_AMPDU_NO_BACK,
  IEEE80211_TX_CTL_RATE_CTRL_PROBE,
  IEEE80211_TX_INTFL_OFFCHAN_TX_OK,
  IEEE80211_TX_INTFL_NEED_TXPROCESSING,
  IEEE80211_TX_INTFL_RETRIED,
  IEEE80211_TX_INTFL_DONT_ENCRYPT,
  IEEE80211_TX_CTL_NO_PS_BUFFER,
  IEEE80211_TX_CTL_MORE_FRAMES,
  IEEE80211_TX_INTFL_RETRANSMISSION,
  IEEE80211_TX_INTFL_MLME_CONN_TX,
  IEEE80211_TX_INTFL_NL80211_FRAME_TX,
  IEEE80211_TX_CTL_LDPC,
  IEEE80211_TX_CTL_STBC,
  IEEE80211_TX_CTL_TX_OFFCHAN,
  IEEE80211_TX_INTFL_TKIP_MIC_FAILURE,
  IEEE80211_TX_CTL_NO_CCK_RATE,
  IEEE80211_TX_STATUS_EOSP,
  IEEE80211_TX_CTL_USE_MINRATE,
  IEEE80211_TX_CTL_DONTFRAG,
  IEEE80211_TX_CTL_PS_RESPONSE
};  </programlisting>
</refsynopsisdiv>
<refsect1>
 <title>Constants</title>
  <variablelist>
    <varlistentry>      <term>IEEE80211_TX_CTL_REQ_TX_STATUS</term>
      <listitem><para>
require TX status callback for this frame.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>IEEE80211_TX_CTL_ASSIGN_SEQ</term>
      <listitem><para>
The driver has to assign a sequence
number to this frame, taking care of not overwriting the fragment
number and increasing the sequence number only when the
IEEE80211_TX_CTL_FIRST_FRAGMENT flag is set. mac80211 will properly
assign sequence numbers to QoS-data frames but cannot do so correctly
for non-QoS-data and management frames because beacons need them from
that counter as well and mac80211 cannot guarantee proper sequencing.
If this flag is set, the driver should instruct the hardware to
assign a sequence number to the frame or assign one itself. Cf. IEEE
802.11-2007 7.1.3.4.1 paragraph 3. This flag will always be set for
beacons and always be clear for frames without a sequence number field.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>IEEE80211_TX_CTL_NO_ACK</term>
      <listitem><para>
tell the low level not to wait for an ack
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>IEEE80211_TX_CTL_CLEAR_PS_FILT</term>
      <listitem><para>
clear powersave filter for destination
station
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>IEEE80211_TX_CTL_FIRST_FRAGMENT</term>
      <listitem><para>
this is a first fragment of the frame
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>IEEE80211_TX_CTL_SEND_AFTER_DTIM</term>
      <listitem><para>
send this frame after DTIM beacon
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>IEEE80211_TX_CTL_AMPDU</term>
      <listitem><para>
this frame should be sent as part of an A-MPDU
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>IEEE80211_TX_CTL_INJECTED</term>
      <listitem><para>
Frame was injected, internal to mac80211.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>IEEE80211_TX_STAT_TX_FILTERED</term>
      <listitem><para>
The frame was not transmitted
because the destination STA was in powersave mode. Note that to
avoid race conditions, the filter must be set by the hardware or
firmware upon receiving a frame that indicates that the station
went to sleep (must be done on device to filter frames already on
the queue) and may only be unset after mac80211 gives the OK for
that by setting the IEEE80211_TX_CTL_CLEAR_PS_FILT (see above),
since only then is it guaranteed that no more frames are in the
hardware queue.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>IEEE80211_TX_STAT_ACK</term>
      <listitem><para>
Frame was acknowledged
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>IEEE80211_TX_STAT_AMPDU</term>
      <listitem><para>
The frame was aggregated, so status
is for the whole aggregation.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>IEEE80211_TX_STAT_AMPDU_NO_BACK</term>
      <listitem><para>
no block ack was returned,
so consider using block ack request (BAR).
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>IEEE80211_TX_CTL_RATE_CTRL_PROBE</term>
      <listitem><para>
internal to mac80211, can be
set by rate control algorithms to indicate probe rate, will
be cleared for fragmented frames (except on the last fragment)
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>IEEE80211_TX_INTFL_OFFCHAN_TX_OK</term>
      <listitem><para>
Internal to mac80211. Used to indicate
that a frame can be transmitted while the queues are stopped for
off-channel operation.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>IEEE80211_TX_INTFL_NEED_TXPROCESSING</term>
      <listitem><para>
completely internal to mac80211,
used to indicate that a pending frame requires TX processing before
it can be sent out.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>IEEE80211_TX_INTFL_RETRIED</term>
      <listitem><para>
completely internal to mac80211,
used to indicate that a frame was already retried due to PS
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>IEEE80211_TX_INTFL_DONT_ENCRYPT</term>
      <listitem><para>
completely internal to mac80211,
used to indicate frame should not be encrypted
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>IEEE80211_TX_CTL_NO_PS_BUFFER</term>
      <listitem><para>
This frame is a response to a poll
frame (PS-Poll or uAPSD) or a non-bufferable MMPDU and must
be sent although the station is in powersave mode.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>IEEE80211_TX_CTL_MORE_FRAMES</term>
      <listitem><para>
More frames will be passed to the
transmit function after the current frame, this can be used
by drivers to kick the DMA queue only if unset or when the
queue gets full.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>IEEE80211_TX_INTFL_RETRANSMISSION</term>
      <listitem><para>
This frame is being retransmitted
after TX status because the destination was asleep, it must not
be modified again (no seqno assignment, crypto, etc.)
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>IEEE80211_TX_INTFL_MLME_CONN_TX</term>
      <listitem><para>
This frame was transmitted by the MLME
code for connection establishment, this indicates that its status
should kick the MLME state machine.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>IEEE80211_TX_INTFL_NL80211_FRAME_TX</term>
      <listitem><para>
Frame was requested through nl80211
MLME command (internal to mac80211 to figure out whether to send TX
status to user space)
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>IEEE80211_TX_CTL_LDPC</term>
      <listitem><para>
tells the driver to use LDPC for this frame
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>IEEE80211_TX_CTL_STBC</term>
      <listitem><para>
Enables Space-Time Block Coding (STBC) for this
frame and selects the maximum number of streams that it can use.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>IEEE80211_TX_CTL_TX_OFFCHAN</term>
      <listitem><para>
Marks this packet to be transmitted on
the off-channel channel when a remain-on-channel offload is done
in hardware -- normal packets still flow and are expected to be
handled properly by the device.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>IEEE80211_TX_INTFL_TKIP_MIC_FAILURE</term>
      <listitem><para>
Marks this packet to be used for TKIP
testing. It will be sent out with incorrect Michael MIC key to allow
TKIP countermeasures to be tested.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>IEEE80211_TX_CTL_NO_CCK_RATE</term>
      <listitem><para>
This frame will be sent at non CCK rate.
This flag is actually used for management frame especially for P2P
frames not being sent at CCK rate in 2GHz band.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>IEEE80211_TX_STATUS_EOSP</term>
      <listitem><para>
This packet marks the end of service period,
when its status is reported the service period ends. For frames in
an SP that mac80211 transmits, it is already set; for driver frames
the driver may set this flag. It is also used to do the same for
PS-Poll responses.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>IEEE80211_TX_CTL_USE_MINRATE</term>
      <listitem><para>
This frame will be sent at lowest rate.
This flag is used to send nullfunc frame at minimum rate when
the nullfunc is used for connection monitoring purpose.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>IEEE80211_TX_CTL_DONTFRAG</term>
      <listitem><para>
Don't fragment this packet even if it
would be fragmented by size (this is optional, only used for
monitor injection).
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>IEEE80211_TX_CTL_PS_RESPONSE</term>
      <listitem><para>
This frame is a response to a poll
frame (PS-Poll or uAPSD).
      </para></listitem>
    </varlistentry>
  </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   </para><para>

   These flags are used with the <parameter>flags</parameter> member of <structname>ieee80211_tx_info</structname>.
</para>
</refsect1>
<refsect1>
<title>Note</title>
<para>
   If you have to add new flags to the enumeration, then don't
   forget to update <constant>IEEE80211_TX_TEMPORARY_FLAGS</constant> when necessary.
</para>
</refsect1>
</refentry>

<refentry id="API-enum-mac80211-tx-control-flags">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>enum mac80211_tx_control_flags</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>enum mac80211_tx_control_flags</refname>
 <refpurpose>
  flags to describe transmit control
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
enum mac80211_tx_control_flags {
  IEEE80211_TX_CTRL_PORT_CTRL_PROTO
};  </programlisting>
</refsynopsisdiv>
<refsect1>
 <title>Constants</title>
  <variablelist>
    <varlistentry>      <term>IEEE80211_TX_CTRL_PORT_CTRL_PROTO</term>
      <listitem><para>
this frame is a port control
protocol frame (e.g. EAP)
      </para></listitem>
    </varlistentry>
  </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   These flags are used in tx_info-&gt;control.flags.
</para>
</refsect1>
</refentry>

<refentry id="API-enum-mac80211-rate-control-flags">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>enum mac80211_rate_control_flags</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>enum mac80211_rate_control_flags</refname>
 <refpurpose>
  per-rate flags set by the Rate Control algorithm.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
enum mac80211_rate_control_flags {
  IEEE80211_TX_RC_USE_RTS_CTS,
  IEEE80211_TX_RC_USE_CTS_PROTECT,
  IEEE80211_TX_RC_USE_SHORT_PREAMBLE,
  IEEE80211_TX_RC_MCS,
  IEEE80211_TX_RC_GREEN_FIELD,
  IEEE80211_TX_RC_40_MHZ_WIDTH,
  IEEE80211_TX_RC_DUP_DATA,
  IEEE80211_TX_RC_SHORT_GI,
  IEEE80211_TX_RC_VHT_MCS,
  IEEE80211_TX_RC_80_MHZ_WIDTH,
  IEEE80211_TX_RC_160_MHZ_WIDTH
};  </programlisting>
</refsynopsisdiv>
<refsect1>
 <title>Constants</title>
  <variablelist>
    <varlistentry>      <term>IEEE80211_TX_RC_USE_RTS_CTS</term>
      <listitem><para>
Use RTS/CTS exchange for this rate.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>IEEE80211_TX_RC_USE_CTS_PROTECT</term>
      <listitem><para>
CTS-to-self protection is required.
This is set if the current BSS requires ERP protection.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>IEEE80211_TX_RC_USE_SHORT_PREAMBLE</term>
      <listitem><para>
Use short preamble.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>IEEE80211_TX_RC_MCS</term>
      <listitem><para>
HT rate.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>IEEE80211_TX_RC_GREEN_FIELD</term>
      <listitem><para>
Indicates whether this rate should be used in
Greenfield mode.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>IEEE80211_TX_RC_40_MHZ_WIDTH</term>
      <listitem><para>
Indicates if the Channel Width should be 40 MHz.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>IEEE80211_TX_RC_DUP_DATA</term>
      <listitem><para>
The frame should be transmitted on both of the
adjacent 20 MHz channels, if the current channel type is
NL80211_CHAN_HT40MINUS or NL80211_CHAN_HT40PLUS.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>IEEE80211_TX_RC_SHORT_GI</term>
      <listitem><para>
Short Guard interval should be used for this rate.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>IEEE80211_TX_RC_VHT_MCS</term>
      <listitem><para>
VHT MCS rate, in this case the idx field is split
into a higher 4 bits (Nss) and lower 4 bits (MCS number)
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>IEEE80211_TX_RC_80_MHZ_WIDTH</term>
      <listitem><para>
Indicates 80 MHz transmission
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>IEEE80211_TX_RC_160_MHZ_WIDTH</term>
      <listitem><para>
Indicates 160 MHz transmission
(80+80 isn't supported yet)
      </para></listitem>
    </varlistentry>
  </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   </para><para>

   These flags are set by the Rate control algorithm for each rate during tx,
   in the <parameter>flags</parameter> member of struct ieee80211_tx_rate.
</para>
</refsect1>
</refentry>

<refentry id="API-struct-ieee80211-tx-rate">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct ieee80211_tx_rate</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct ieee80211_tx_rate</refname>
 <refpurpose>
  rate selection/status
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct ieee80211_tx_rate {
  s8 idx;
  u16 count:5;
  u16 flags:11;
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>idx</term>
      <listitem><para>
rate index to attempt to send with
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>count</term>
      <listitem><para>
number of tries in this rate before going to the next rate
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>flags</term>
      <listitem><para>
rate control flags (<structname>enum</structname> mac80211_rate_control_flags)
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
<refsect1>
<title>Description</title>
<para>
   A value of -1 for <parameter>idx</parameter> indicates an invalid rate and, if used
   in an array of retry rates, that no more rates should be tried.
   </para><para>

   When used for transmit status reporting, the driver should
   always report the rate along with the flags it used.
   </para><para>

   <structname>struct ieee80211_tx_info</structname> contains an array of these structs
   in the control information, and it will be filled by the rate
   control algorithm according to what should be sent. For example,
   if this array contains, in the format { &lt;idx&gt;, &lt;count&gt; } the
   information
   { 3, 2 }, { 2, 2 }, { 1, 4 }, { -1, 0 }, { -1, 0 }
   then this means that the frame should be transmitted
   up to twice at rate 3, up to twice at rate 2, and up to four
   times at rate 1 if it doesn't get acknowledged. Say it gets
   acknowledged by the peer after the fifth attempt, the status
   information should then contain
   { 3, 2 }, { 2, 2 }, { 1, 1 }, { -1, 0 } ...
   since it was transmitted twice at rate 3, twice at rate 2
   and once at rate 1 after which we received an acknowledgement.
</para>
</refsect1>
</refentry>

<refentry id="API-struct-ieee80211-tx-info">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct ieee80211_tx_info</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct ieee80211_tx_info</refname>
 <refpurpose>
  skb transmit information
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct ieee80211_tx_info {
  u32 flags;
  u8 band;
  u8 hw_queue;
  u16 ack_frame_id;
  union {unnamed_union};
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>flags</term>
      <listitem><para>
transmit info flags, defined above
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>band</term>
      <listitem><para>
the band to transmit on (use for checking for races)
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>hw_queue</term>
      <listitem><para>
HW queue to put the frame on, <function>skb_get_queue_mapping</function> gives the AC
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>ack_frame_id</term>
      <listitem><para>
internal frame ID for TX status, used internally
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>{unnamed_union}</term>
      <listitem><para>
anonymous
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
<refsect1>
<title>Description</title>
<para>
   </para><para>

   This structure is placed in skb-&gt;cb for three uses:
   (1) mac80211 TX control - mac80211 tells the driver what to do
   (2) driver internal use (if applicable)
   (3) TX status information - driver tells mac80211 what happened
</para>
</refsect1>
</refentry>

<refentry id="API-ieee80211-tx-info-clear-status">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ieee80211_tx_info_clear_status</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ieee80211_tx_info_clear_status</refname>
 <refpurpose>
  clear TX status
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>ieee80211_tx_info_clear_status </function></funcdef>
   <paramdef>struct ieee80211_tx_info * <parameter>info</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>info</parameter></term>
   <listitem>
    <para>
     The <structname>struct ieee80211_tx_info</structname> to be cleared.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   When the driver passes an skb back to mac80211, it must report
   a number of things in TX status. This function clears everything
   in the TX status but the rate control information (it does clear
   the count since you need to fill that in anyway).
</para>
</refsect1>
<refsect1>
<title>NOTE</title>
<para>
   You can only use this function if you do NOT use
   info-&gt;driver_data! Use info-&gt;rate_driver_data
   instead if you need only the less space that allows.
</para>
</refsect1>
</refentry>

<refentry id="API-ieee80211-rx">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ieee80211_rx</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ieee80211_rx</refname>
 <refpurpose>
  receive frame
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>ieee80211_rx </function></funcdef>
   <paramdef>struct ieee80211_hw * <parameter>hw</parameter></paramdef>
   <paramdef>struct sk_buff * <parameter>skb</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>hw</parameter></term>
   <listitem>
    <para>
     the hardware this frame came in on
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>skb</parameter></term>
   <listitem>
    <para>
     the buffer to receive, owned by mac80211 after this call
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   </para><para>

   Use this function to hand received frames to mac80211. The receive
   buffer in <parameter>skb</parameter> must start with an IEEE 802.11 header. In case of a
   paged <parameter>skb</parameter> is used, the driver is recommended to put the ieee80211
   header of the frame on the linear part of the <parameter>skb</parameter> to avoid memory
   allocation and/or memcpy by the stack.
   </para><para>

   This function may not be called in IRQ context. Calls to this function
   for a single hardware must be synchronized against each other. Calls to
   this function, <function>ieee80211_rx_ni</function> and <function>ieee80211_rx_irqsafe</function> may not be
   mixed for a single hardware. Must not run concurrently with
   <function>ieee80211_tx_status</function> or <function>ieee80211_tx_status_ni</function>.
   </para><para>

   In process context use instead <function>ieee80211_rx_ni</function>.
</para>
</refsect1>
</refentry>

<refentry id="API-ieee80211-rx-ni">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ieee80211_rx_ni</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ieee80211_rx_ni</refname>
 <refpurpose>
  receive frame (in process context)
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>ieee80211_rx_ni </function></funcdef>
   <paramdef>struct ieee80211_hw * <parameter>hw</parameter></paramdef>
   <paramdef>struct sk_buff * <parameter>skb</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>hw</parameter></term>
   <listitem>
    <para>
     the hardware this frame came in on
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>skb</parameter></term>
   <listitem>
    <para>
     the buffer to receive, owned by mac80211 after this call
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   </para><para>

   Like <function>ieee80211_rx</function> but can be called in process context
   (internally disables bottom halves).
   </para><para>

   Calls to this function, <function>ieee80211_rx</function> and <function>ieee80211_rx_irqsafe</function> may
   not be mixed for a single hardware. Must not run concurrently with
   <function>ieee80211_tx_status</function> or <function>ieee80211_tx_status_ni</function>.
</para>
</refsect1>
</refentry>

<refentry id="API-ieee80211-rx-irqsafe">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ieee80211_rx_irqsafe</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ieee80211_rx_irqsafe</refname>
 <refpurpose>
  receive frame
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>ieee80211_rx_irqsafe </function></funcdef>
   <paramdef>struct ieee80211_hw * <parameter>hw</parameter></paramdef>
   <paramdef>struct sk_buff * <parameter>skb</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>hw</parameter></term>
   <listitem>
    <para>
     the hardware this frame came in on
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>skb</parameter></term>
   <listitem>
    <para>
     the buffer to receive, owned by mac80211 after this call
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   </para><para>

   Like <function>ieee80211_rx</function> but can be called in IRQ context
   (internally defers to a tasklet.)
   </para><para>

   Calls to this function, <function>ieee80211_rx</function> or <function>ieee80211_rx_ni</function> may not
   be mixed for a single hardware.Must not run concurrently with
   <function>ieee80211_tx_status</function> or <function>ieee80211_tx_status_ni</function>.
</para>
</refsect1>
</refentry>

<refentry id="API-ieee80211-tx-status">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ieee80211_tx_status</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ieee80211_tx_status</refname>
 <refpurpose>
  transmit status callback
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>ieee80211_tx_status </function></funcdef>
   <paramdef>struct ieee80211_hw * <parameter>hw</parameter></paramdef>
   <paramdef>struct sk_buff * <parameter>skb</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>hw</parameter></term>
   <listitem>
    <para>
     the hardware the frame was transmitted by
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>skb</parameter></term>
   <listitem>
    <para>
     the frame that was transmitted, owned by mac80211 after this call
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   </para><para>

   Call this function for all transmitted frames after they have been
   transmitted. It is permissible to not call this function for
   multicast frames but this can affect statistics.
   </para><para>

   This function may not be called in IRQ context. Calls to this function
   for a single hardware must be synchronized against each other. Calls
   to this function, <function>ieee80211_tx_status_ni</function> and <function>ieee80211_tx_status_irqsafe</function>
   may not be mixed for a single hardware. Must not run concurrently with
   <function>ieee80211_rx</function> or <function>ieee80211_rx_ni</function>.
</para>
</refsect1>
</refentry>

<refentry id="API-ieee80211-tx-status-ni">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ieee80211_tx_status_ni</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ieee80211_tx_status_ni</refname>
 <refpurpose>
  transmit status callback (in process context)
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>ieee80211_tx_status_ni </function></funcdef>
   <paramdef>struct ieee80211_hw * <parameter>hw</parameter></paramdef>
   <paramdef>struct sk_buff * <parameter>skb</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>hw</parameter></term>
   <listitem>
    <para>
     the hardware the frame was transmitted by
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>skb</parameter></term>
   <listitem>
    <para>
     the frame that was transmitted, owned by mac80211 after this call
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   </para><para>

   Like <function>ieee80211_tx_status</function> but can be called in process context.
   </para><para>

   Calls to this function, <function>ieee80211_tx_status</function> and
   <function>ieee80211_tx_status_irqsafe</function> may not be mixed
   for a single hardware.
</para>
</refsect1>
</refentry>

<refentry id="API-ieee80211-tx-status-irqsafe">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ieee80211_tx_status_irqsafe</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ieee80211_tx_status_irqsafe</refname>
 <refpurpose>
  IRQ-safe transmit status callback
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>ieee80211_tx_status_irqsafe </function></funcdef>
   <paramdef>struct ieee80211_hw * <parameter>hw</parameter></paramdef>
   <paramdef>struct sk_buff * <parameter>skb</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>hw</parameter></term>
   <listitem>
    <para>
     the hardware the frame was transmitted by
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>skb</parameter></term>
   <listitem>
    <para>
     the frame that was transmitted, owned by mac80211 after this call
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   </para><para>

   Like <function>ieee80211_tx_status</function> but can be called in IRQ context
   (internally defers to a tasklet.)
   </para><para>

   Calls to this function, <function>ieee80211_tx_status</function> and
   <function>ieee80211_tx_status_ni</function> may not be mixed for a single hardware.
</para>
</refsect1>
</refentry>

<refentry id="API-ieee80211-rts-get">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ieee80211_rts_get</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ieee80211_rts_get</refname>
 <refpurpose>
  RTS frame generation function
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>ieee80211_rts_get </function></funcdef>
   <paramdef>struct ieee80211_hw * <parameter>hw</parameter></paramdef>
   <paramdef>struct ieee80211_vif * <parameter>vif</parameter></paramdef>
   <paramdef>const void * <parameter>frame</parameter></paramdef>
   <paramdef>size_t <parameter>frame_len</parameter></paramdef>
   <paramdef>const struct ieee80211_tx_info * <parameter>frame_txctl</parameter></paramdef>
   <paramdef>struct ieee80211_rts * <parameter>rts</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>hw</parameter></term>
   <listitem>
    <para>
     pointer obtained from <function>ieee80211_alloc_hw</function>.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>vif</parameter></term>
   <listitem>
    <para>
     <structname>struct ieee80211_vif</structname> pointer from the add_interface callback.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>frame</parameter></term>
   <listitem>
    <para>
     pointer to the frame that is going to be protected by the RTS.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>frame_len</parameter></term>
   <listitem>
    <para>
     the frame length (in octets).
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>frame_txctl</parameter></term>
   <listitem>
    <para>
     <structname>struct ieee80211_tx_info</structname> of the frame.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>rts</parameter></term>
   <listitem>
    <para>
     The buffer where to store the RTS frame.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   If the RTS frames are generated by the host system (i.e., not in
   hardware/firmware), the low-level driver uses this function to receive
   the next RTS frame from the 802.11 code. The low-level is responsible
   for calling this function before and RTS frame is needed.
</para>
</refsect1>
</refentry>

<refentry id="API-ieee80211-rts-duration">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ieee80211_rts_duration</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ieee80211_rts_duration</refname>
 <refpurpose>
  Get the duration field for an RTS frame
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>__le16 <function>ieee80211_rts_duration </function></funcdef>
   <paramdef>struct ieee80211_hw * <parameter>hw</parameter></paramdef>
   <paramdef>struct ieee80211_vif * <parameter>vif</parameter></paramdef>
   <paramdef>size_t <parameter>frame_len</parameter></paramdef>
   <paramdef>const struct ieee80211_tx_info * <parameter>frame_txctl</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>hw</parameter></term>
   <listitem>
    <para>
     pointer obtained from <function>ieee80211_alloc_hw</function>.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>vif</parameter></term>
   <listitem>
    <para>
     <structname>struct ieee80211_vif</structname> pointer from the add_interface callback.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>frame_len</parameter></term>
   <listitem>
    <para>
     the length of the frame that is going to be protected by the RTS.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>frame_txctl</parameter></term>
   <listitem>
    <para>
     <structname>struct ieee80211_tx_info</structname> of the frame.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   If the RTS is generated in firmware, but the host system must provide
   the duration field, the low-level driver uses this function to receive
   the duration field value in little-endian byteorder.
</para>
</refsect1>
<refsect1>
<title>Return</title>
<para>
   The duration.
</para>
</refsect1>
</refentry>

<refentry id="API-ieee80211-ctstoself-get">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ieee80211_ctstoself_get</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ieee80211_ctstoself_get</refname>
 <refpurpose>
  CTS-to-self frame generation function
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>ieee80211_ctstoself_get </function></funcdef>
   <paramdef>struct ieee80211_hw * <parameter>hw</parameter></paramdef>
   <paramdef>struct ieee80211_vif * <parameter>vif</parameter></paramdef>
   <paramdef>const void * <parameter>frame</parameter></paramdef>
   <paramdef>size_t <parameter>frame_len</parameter></paramdef>
   <paramdef>const struct ieee80211_tx_info * <parameter>frame_txctl</parameter></paramdef>
   <paramdef>struct ieee80211_cts * <parameter>cts</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>hw</parameter></term>
   <listitem>
    <para>
     pointer obtained from <function>ieee80211_alloc_hw</function>.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>vif</parameter></term>
   <listitem>
    <para>
     <structname>struct ieee80211_vif</structname> pointer from the add_interface callback.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>frame</parameter></term>
   <listitem>
    <para>
     pointer to the frame that is going to be protected by the CTS-to-self.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>frame_len</parameter></term>
   <listitem>
    <para>
     the frame length (in octets).
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>frame_txctl</parameter></term>
   <listitem>
    <para>
     <structname>struct ieee80211_tx_info</structname> of the frame.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>cts</parameter></term>
   <listitem>
    <para>
     The buffer where to store the CTS-to-self frame.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   If the CTS-to-self frames are generated by the host system (i.e., not in
   hardware/firmware), the low-level driver uses this function to receive
   the next CTS-to-self frame from the 802.11 code. The low-level is responsible
   for calling this function before and CTS-to-self frame is needed.
</para>
</refsect1>
</refentry>

<refentry id="API-ieee80211-ctstoself-duration">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ieee80211_ctstoself_duration</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ieee80211_ctstoself_duration</refname>
 <refpurpose>
  Get the duration field for a CTS-to-self frame
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>__le16 <function>ieee80211_ctstoself_duration </function></funcdef>
   <paramdef>struct ieee80211_hw * <parameter>hw</parameter></paramdef>
   <paramdef>struct ieee80211_vif * <parameter>vif</parameter></paramdef>
   <paramdef>size_t <parameter>frame_len</parameter></paramdef>
   <paramdef>const struct ieee80211_tx_info * <parameter>frame_txctl</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>hw</parameter></term>
   <listitem>
    <para>
     pointer obtained from <function>ieee80211_alloc_hw</function>.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>vif</parameter></term>
   <listitem>
    <para>
     <structname>struct ieee80211_vif</structname> pointer from the add_interface callback.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>frame_len</parameter></term>
   <listitem>
    <para>
     the length of the frame that is going to be protected by the CTS-to-self.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>frame_txctl</parameter></term>
   <listitem>
    <para>
     <structname>struct ieee80211_tx_info</structname> of the frame.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   If the CTS-to-self is generated in firmware, but the host system must provide
   the duration field, the low-level driver uses this function to receive
   the duration field value in little-endian byteorder.
</para>
</refsect1>
<refsect1>
<title>Return</title>
<para>
   The duration.
</para>
</refsect1>
</refentry>

<refentry id="API-ieee80211-generic-frame-duration">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ieee80211_generic_frame_duration</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ieee80211_generic_frame_duration</refname>
 <refpurpose>
  Calculate the duration field for a frame
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>__le16 <function>ieee80211_generic_frame_duration </function></funcdef>
   <paramdef>struct ieee80211_hw * <parameter>hw</parameter></paramdef>
   <paramdef>struct ieee80211_vif * <parameter>vif</parameter></paramdef>
   <paramdef>enum ieee80211_band <parameter>band</parameter></paramdef>
   <paramdef>size_t <parameter>frame_len</parameter></paramdef>
   <paramdef>struct ieee80211_rate * <parameter>rate</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>hw</parameter></term>
   <listitem>
    <para>
     pointer obtained from <function>ieee80211_alloc_hw</function>.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>vif</parameter></term>
   <listitem>
    <para>
     <structname>struct ieee80211_vif</structname> pointer from the add_interface callback.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>band</parameter></term>
   <listitem>
    <para>
     the band to calculate the frame duration on
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>frame_len</parameter></term>
   <listitem>
    <para>
     the length of the frame.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>rate</parameter></term>
   <listitem>
    <para>
     the rate at which the frame is going to be transmitted.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Calculate the duration field of some generic frame, given its
   length and transmission rate (in 100kbps).
</para>
</refsect1>
<refsect1>
<title>Return</title>
<para>
   The duration.
</para>
</refsect1>
</refentry>

<refentry id="API-ieee80211-wake-queue">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ieee80211_wake_queue</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ieee80211_wake_queue</refname>
 <refpurpose>
  wake specific queue
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>ieee80211_wake_queue </function></funcdef>
   <paramdef>struct ieee80211_hw * <parameter>hw</parameter></paramdef>
   <paramdef>int <parameter>queue</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>hw</parameter></term>
   <listitem>
    <para>
     pointer as obtained from <function>ieee80211_alloc_hw</function>.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>queue</parameter></term>
   <listitem>
    <para>
     queue number (counted from zero).
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Drivers should use this function instead of netif_wake_queue.
</para>
</refsect1>
</refentry>

<refentry id="API-ieee80211-stop-queue">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ieee80211_stop_queue</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ieee80211_stop_queue</refname>
 <refpurpose>
  stop specific queue
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>ieee80211_stop_queue </function></funcdef>
   <paramdef>struct ieee80211_hw * <parameter>hw</parameter></paramdef>
   <paramdef>int <parameter>queue</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>hw</parameter></term>
   <listitem>
    <para>
     pointer as obtained from <function>ieee80211_alloc_hw</function>.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>queue</parameter></term>
   <listitem>
    <para>
     queue number (counted from zero).
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Drivers should use this function instead of netif_stop_queue.
</para>
</refsect1>
</refentry>

<refentry id="API-ieee80211-wake-queues">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ieee80211_wake_queues</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ieee80211_wake_queues</refname>
 <refpurpose>
  wake all queues
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>ieee80211_wake_queues </function></funcdef>
   <paramdef>struct ieee80211_hw * <parameter>hw</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>hw</parameter></term>
   <listitem>
    <para>
     pointer as obtained from <function>ieee80211_alloc_hw</function>.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Drivers should use this function instead of netif_wake_queue.
</para>
</refsect1>
</refentry>

<refentry id="API-ieee80211-stop-queues">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ieee80211_stop_queues</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ieee80211_stop_queues</refname>
 <refpurpose>
  stop all queues
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>ieee80211_stop_queues </function></funcdef>
   <paramdef>struct ieee80211_hw * <parameter>hw</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>hw</parameter></term>
   <listitem>
    <para>
     pointer as obtained from <function>ieee80211_alloc_hw</function>.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Drivers should use this function instead of netif_stop_queue.
</para>
</refsect1>
</refentry>

<refentry id="API-ieee80211-queue-stopped">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ieee80211_queue_stopped</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ieee80211_queue_stopped</refname>
 <refpurpose>
  test status of the queue
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>ieee80211_queue_stopped </function></funcdef>
   <paramdef>struct ieee80211_hw * <parameter>hw</parameter></paramdef>
   <paramdef>int <parameter>queue</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>hw</parameter></term>
   <listitem>
    <para>
     pointer as obtained from <function>ieee80211_alloc_hw</function>.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>queue</parameter></term>
   <listitem>
    <para>
     queue number (counted from zero).
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Drivers should use this function instead of netif_stop_queue.
</para>
</refsect1>
<refsect1>
<title>Return</title>
<para>
   <constant>true</constant> if the queue is stopped. <constant>false</constant> otherwise.
</para>
</refsect1>
</refentry>

        </sect1>
      </chapter>

      <chapter id="filters">
        <title>Frame filtering</title>
<para>
   </para><para>
   mac80211 requires to see many management frames for proper
   operation, and users may want to see many more frames when
   in monitor mode. However, for best CPU usage and power consumption,
   having as few frames as possible percolate through the stack is
   desirable. Hence, the hardware should filter as much as possible.
   </para><para>
   To achieve this, mac80211 uses filter flags (see below) to tell
   the driver's <function>configure_filter</function> function which frames should be
   passed to mac80211 and which should be filtered out.
   </para><para>
   Before <function>configure_filter</function> is invoked, the <function>prepare_multicast</function>
   callback is invoked with the parameters <parameter>mc_count</parameter> and <parameter>mc_list</parameter>
   for the combined multicast address list of all virtual interfaces.
   It's use is optional, and it returns a u64 that is passed to
   <function>configure_filter</function>. Additionally, <function>configure_filter</function> has the
   arguments <parameter>changed_flags</parameter> telling which flags were changed and
   <parameter>total_flags</parameter> with the new flag states.
   </para><para>
   If your device has no multicast address filters your driver will
   need to check both the <constant>FIF_ALLMULTI</constant> flag and the <parameter>mc_count</parameter>
   parameter to see whether multicast frames should be accepted
   or dropped.
   </para><para>
   All unsupported flags in <parameter>total_flags</parameter> must be cleared.
   Hardware does not support a flag if it is incapable of _passing_
   the frame to the stack. Otherwise the driver must ignore
   the flag, but not clear it.
   You must _only_ clear the flag (announce no support for the
   flag to mac80211) if you are not able to pass the packet type
   to the stack (so the hardware always filters it).
   So for example, you should clear <parameter>FIF_CONTROL</parameter>, if your hardware
   always filters control frames. If your hardware always passes
   control frames to the kernel and is incapable of filtering them,
   you do _not_ clear the <parameter>FIF_CONTROL</parameter> flag.
   This rule applies to all other FIF flags as well.
</para>

<refentry id="API-enum-ieee80211-filter-flags">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>enum ieee80211_filter_flags</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>enum ieee80211_filter_flags</refname>
 <refpurpose>
  hardware filter flags
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
enum ieee80211_filter_flags {
  FIF_PROMISC_IN_BSS,
  FIF_ALLMULTI,
  FIF_FCSFAIL,
  FIF_PLCPFAIL,
  FIF_BCN_PRBRESP_PROMISC,
  FIF_CONTROL,
  FIF_OTHER_BSS,
  FIF_PSPOLL,
  FIF_PROBE_REQ
};  </programlisting>
</refsynopsisdiv>
<refsect1>
 <title>Constants</title>
  <variablelist>
    <varlistentry>      <term>FIF_PROMISC_IN_BSS</term>
      <listitem><para>
promiscuous mode within your BSS,
think of the BSS as your network segment and then this corresponds
to the regular ethernet device promiscuous mode.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>FIF_ALLMULTI</term>
      <listitem><para>
pass all multicast frames, this is used if requested
by the user or if the hardware is not capable of filtering by
multicast address.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>FIF_FCSFAIL</term>
      <listitem><para>
pass frames with failed FCS (but you need to set the
<constant>RX_FLAG_FAILED_FCS_CRC</constant> for them)
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>FIF_PLCPFAIL</term>
      <listitem><para>
pass frames with failed PLCP CRC (but you need to set
the <constant>RX_FLAG_FAILED_PLCP_CRC</constant> for them
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>FIF_BCN_PRBRESP_PROMISC</term>
      <listitem><para>
This flag is set during scanning to indicate
to the hardware that it should not filter beacons or probe responses
by BSSID. Filtering them can greatly reduce the amount of processing
mac80211 needs to do and the amount of CPU wakeups, so you should
honour this flag if possible.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>FIF_CONTROL</term>
      <listitem><para>
pass control frames (except for PS Poll), if PROMISC_IN_BSS
is not set then only those addressed to this station.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>FIF_OTHER_BSS</term>
      <listitem><para>
pass frames destined to other BSSes
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>FIF_PSPOLL</term>
      <listitem><para>
pass PS Poll frames, if PROMISC_IN_BSS is not set then only
those addressed to this station.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>FIF_PROBE_REQ</term>
      <listitem><para>
pass probe request frames
      </para></listitem>
    </varlistentry>
  </variablelist>
</refsect1>
<refsect1>
<title>HW queue control</title>
<para>
   </para><para>

   These flags determine what the filter in hardware should be
   programmed to let through and what should not be passed to the
   stack. It is always safe to pass more frames than requested,
   but this has negative impact on power consumption.
</para>
</refsect1>
</refentry>

      </chapter>

      <chapter id="workqueue">
        <title>The mac80211 workqueue</title>
<para>
   </para><para>
   mac80211 provides its own workqueue for drivers and internal mac80211 use.
   The workqueue is a single threaded workqueue and can only be accessed by
   helpers for sanity checking. Drivers must ensure all work added onto the
   mac80211 workqueue should be cancelled on the driver <function>stop</function> callback.
   </para><para>
   mac80211 will flushed the workqueue upon interface removal and during
   suspend.
   </para><para>
   All work performed on the mac80211 workqueue must not acquire the RTNL lock.
   </para><para>
</para>

<refentry id="API-ieee80211-queue-work">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ieee80211_queue_work</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ieee80211_queue_work</refname>
 <refpurpose>
  add work onto the mac80211 workqueue
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>ieee80211_queue_work </function></funcdef>
   <paramdef>struct ieee80211_hw * <parameter>hw</parameter></paramdef>
   <paramdef>struct work_struct * <parameter>work</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>hw</parameter></term>
   <listitem>
    <para>
     the hardware struct for the interface we are adding work for
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>work</parameter></term>
   <listitem>
    <para>
     the work we want to add onto the mac80211 workqueue
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   </para><para>

   Drivers and mac80211 use this to add work onto the mac80211 workqueue.
   This helper ensures drivers are not queueing work when they should not be.
</para>
</refsect1>
</refentry>

<refentry id="API-ieee80211-queue-delayed-work">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ieee80211_queue_delayed_work</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ieee80211_queue_delayed_work</refname>
 <refpurpose>
  add work onto the mac80211 workqueue
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>ieee80211_queue_delayed_work </function></funcdef>
   <paramdef>struct ieee80211_hw * <parameter>hw</parameter></paramdef>
   <paramdef>struct delayed_work * <parameter>dwork</parameter></paramdef>
   <paramdef>unsigned long <parameter>delay</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>hw</parameter></term>
   <listitem>
    <para>
     the hardware struct for the interface we are adding work for
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>dwork</parameter></term>
   <listitem>
    <para>
     delayable work to queue onto the mac80211 workqueue
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>delay</parameter></term>
   <listitem>
    <para>
     number of jiffies to wait before queueing
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   </para><para>

   Drivers and mac80211 use this to queue delayed work onto the mac80211
   workqueue.
</para>
</refsect1>
</refentry>

      </chapter>
    </part>

    <part id="advanced">
      <title>Advanced driver interface</title>
      <partintro>
        <para>
         Information contained within this part of the book is
         of interest only for advanced interaction of mac80211
         with drivers to exploit more hardware capabilities and
         improve performance.
        </para>
      </partintro>

      <chapter id="led-support">
        <title>LED support</title>
        <para>
         Mac80211 supports various ways of blinking LEDs. Wherever possible,
         device LEDs should be exposed as LED class devices and hooked up to
         the appropriate trigger, which will then be triggered appropriately
         by mac80211.
        </para>
<refentry id="API-ieee80211-get-tx-led-name">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ieee80211_get_tx_led_name</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ieee80211_get_tx_led_name</refname>
 <refpurpose>
  get name of TX LED
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>char * <function>ieee80211_get_tx_led_name </function></funcdef>
   <paramdef>struct ieee80211_hw * <parameter>hw</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>hw</parameter></term>
   <listitem>
    <para>
     the hardware to get the LED trigger name for
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   </para><para>

   mac80211 creates a transmit LED trigger for each wireless hardware
   that can be used to drive LEDs if your driver registers a LED device.
   This function returns the name (or <constant>NULL</constant> if not configured for LEDs)
   of the trigger so you can automatically link the LED device.
</para>
</refsect1>
<refsect1>
<title>Return</title>
<para>
   The name of the LED trigger. <constant>NULL</constant> if not configured for LEDs.
</para>
</refsect1>
</refentry>

<refentry id="API-ieee80211-get-rx-led-name">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ieee80211_get_rx_led_name</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ieee80211_get_rx_led_name</refname>
 <refpurpose>
  get name of RX LED
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>char * <function>ieee80211_get_rx_led_name </function></funcdef>
   <paramdef>struct ieee80211_hw * <parameter>hw</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>hw</parameter></term>
   <listitem>
    <para>
     the hardware to get the LED trigger name for
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   </para><para>

   mac80211 creates a receive LED trigger for each wireless hardware
   that can be used to drive LEDs if your driver registers a LED device.
   This function returns the name (or <constant>NULL</constant> if not configured for LEDs)
   of the trigger so you can automatically link the LED device.
</para>
</refsect1>
<refsect1>
<title>Return</title>
<para>
   The name of the LED trigger. <constant>NULL</constant> if not configured for LEDs.
</para>
</refsect1>
</refentry>

<refentry id="API-ieee80211-get-assoc-led-name">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ieee80211_get_assoc_led_name</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ieee80211_get_assoc_led_name</refname>
 <refpurpose>
  get name of association LED
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>char * <function>ieee80211_get_assoc_led_name </function></funcdef>
   <paramdef>struct ieee80211_hw * <parameter>hw</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>hw</parameter></term>
   <listitem>
    <para>
     the hardware to get the LED trigger name for
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   </para><para>

   mac80211 creates a association LED trigger for each wireless hardware
   that can be used to drive LEDs if your driver registers a LED device.
   This function returns the name (or <constant>NULL</constant> if not configured for LEDs)
   of the trigger so you can automatically link the LED device.
</para>
</refsect1>
<refsect1>
<title>Return</title>
<para>
   The name of the LED trigger. <constant>NULL</constant> if not configured for LEDs.
</para>
</refsect1>
</refentry>

<refentry id="API-ieee80211-get-radio-led-name">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ieee80211_get_radio_led_name</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ieee80211_get_radio_led_name</refname>
 <refpurpose>
  get name of radio LED
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>char * <function>ieee80211_get_radio_led_name </function></funcdef>
   <paramdef>struct ieee80211_hw * <parameter>hw</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>hw</parameter></term>
   <listitem>
    <para>
     the hardware to get the LED trigger name for
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   </para><para>

   mac80211 creates a radio change LED trigger for each wireless hardware
   that can be used to drive LEDs if your driver registers a LED device.
   This function returns the name (or <constant>NULL</constant> if not configured for LEDs)
   of the trigger so you can automatically link the LED device.
</para>
</refsect1>
<refsect1>
<title>Return</title>
<para>
   The name of the LED trigger. <constant>NULL</constant> if not configured for LEDs.
</para>
</refsect1>
</refentry>

<refentry id="API-struct-ieee80211-tpt-blink">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct ieee80211_tpt_blink</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct ieee80211_tpt_blink</refname>
 <refpurpose>
  throughput blink description
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct ieee80211_tpt_blink {
  int throughput;
  int blink_time;
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>throughput</term>
      <listitem><para>
throughput in Kbit/sec
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>blink_time</term>
      <listitem><para>
blink time in milliseconds
(full cycle, ie. one off + one on period)
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
</refentry>

<refentry id="API-enum-ieee80211-tpt-led-trigger-flags">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>enum ieee80211_tpt_led_trigger_flags</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>enum ieee80211_tpt_led_trigger_flags</refname>
 <refpurpose>
  throughput trigger flags
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
enum ieee80211_tpt_led_trigger_flags {
  IEEE80211_TPT_LEDTRIG_FL_RADIO,
  IEEE80211_TPT_LEDTRIG_FL_WORK,
  IEEE80211_TPT_LEDTRIG_FL_CONNECTED
};  </programlisting>
</refsynopsisdiv>
<refsect1>
 <title>Constants</title>
  <variablelist>
    <varlistentry>      <term>IEEE80211_TPT_LEDTRIG_FL_RADIO</term>
      <listitem><para>
enable blinking with radio
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>IEEE80211_TPT_LEDTRIG_FL_WORK</term>
      <listitem><para>
enable blinking when working
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>IEEE80211_TPT_LEDTRIG_FL_CONNECTED</term>
      <listitem><para>
enable blinking when at least one
interface is connected in some way, including being an AP
      </para></listitem>
    </varlistentry>
  </variablelist>
</refsect1>
</refentry>

<refentry id="API-ieee80211-create-tpt-led-trigger">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ieee80211_create_tpt_led_trigger</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ieee80211_create_tpt_led_trigger</refname>
 <refpurpose>
  create throughput LED trigger
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>char * <function>ieee80211_create_tpt_led_trigger </function></funcdef>
   <paramdef>struct ieee80211_hw * <parameter>hw</parameter></paramdef>
   <paramdef>unsigned int <parameter>flags</parameter></paramdef>
   <paramdef>const struct ieee80211_tpt_blink * <parameter>blink_table</parameter></paramdef>
   <paramdef>unsigned int <parameter>blink_table_len</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>hw</parameter></term>
   <listitem>
    <para>
     the hardware to create the trigger for
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>flags</parameter></term>
   <listitem>
    <para>
     trigger flags, see <structname>enum</structname> ieee80211_tpt_led_trigger_flags
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>blink_table</parameter></term>
   <listitem>
    <para>
     the blink table -- needs to be ordered by throughput
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>blink_table_len</parameter></term>
   <listitem>
    <para>
     size of the blink table
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Return</title>
<para>
   <constant>NULL</constant> (in case of error, or if no LED triggers are
   configured) or the name of the new trigger.
</para>
</refsect1>
<refsect1>
<title>Note</title>
<para>
   This function must be called before <function>ieee80211_register_hw</function>.
</para>
</refsect1>
</refentry>

      </chapter>

      <chapter id="hardware-crypto-offload">
        <title>Hardware crypto acceleration</title>
<para>
   </para><para>
   mac80211 is capable of taking advantage of many hardware
   acceleration designs for encryption and decryption operations.
   </para><para>
   The <function>set_key</function> callback in the <structname>struct ieee80211_ops</structname> for a given
   device is called to enable hardware acceleration of encryption and
   decryption. The callback takes a <parameter>sta</parameter> parameter that will be NULL
   for default keys or keys used for transmission only, or point to
   the station information for the peer for individual keys.
   Multiple transmission keys with the same key index may be used when
   VLANs are configured for an access point.
   </para><para>
   When transmitting, the TX control data will use the <parameter>hw_key_idx</parameter>
   selected by the driver by modifying the <structname>struct ieee80211_key_conf</structname>
   pointed to by the <parameter>key</parameter> parameter to the <function>set_key</function> function.
   </para><para>
   The <function>set_key</function> call for the <constant>SET_KEY</constant> command should return 0 if
   the key is now in use, -<constant>EOPNOTSUPP</constant> or -<constant>ENOSPC</constant> if it couldn't be
   added; if you return 0 then hw_key_idx must be assigned to the
   hardware key index, you are free to use the full u8 range.
   </para><para>
   When the cmd is <constant>DISABLE_KEY</constant> then it must succeed.
   </para><para>
   Note that it is permissible to not decrypt a frame even if a key
   for it has been uploaded to hardware, the stack will not make any
   decision based on whether a key has been uploaded or not but rather
   based on the receive flags.
   </para><para>
   The <structname>struct ieee80211_key_conf</structname> structure pointed to by the <parameter>key</parameter>
   parameter is guaranteed to be valid until another call to <function>set_key</function>
   removes it, but it can only be used as a cookie to differentiate
   keys.
   </para><para>
   In TKIP some HW need to be provided a phase 1 key, for RX decryption
   acceleration (i.e. iwlwifi). Those drivers should provide update_tkip_key
   handler.
   The <function>update_tkip_key</function> call updates the driver with the new phase 1 key.
   This happens every time the iv16 wraps around (every 65536 packets). The
   <function>set_key</function> call will happen only once for each key (unless the AP did
   rekeying), it will not include a valid phase 1 key. The valid phase 1 key is
   provided by update_tkip_key only. The trigger that makes mac80211 call this
   handler is software decryption with wrap around of iv16.
   </para><para>
   The <function>set_default_unicast_key</function> call updates the default WEP key index
   configured to the hardware for WEP encryption type. This is required
   for devices that support offload of data packets (e.g. ARP responses).
</para>

  <!-- intentionally multiple !F lines to get proper order -->
<refentry id="API-enum-set-key-cmd">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>enum set_key_cmd</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>enum set_key_cmd</refname>
 <refpurpose>
  key command
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
enum set_key_cmd {
  SET_KEY,
  DISABLE_KEY
};  </programlisting>
</refsynopsisdiv>
<refsect1>
 <title>Constants</title>
  <variablelist>
    <varlistentry>      <term>SET_KEY</term>
      <listitem><para>
a key is set
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>DISABLE_KEY</term>
      <listitem><para>
a key must be disabled
      </para></listitem>
    </varlistentry>
  </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   </para><para>

   Used with the <function>set_key</function> callback in <structname>struct ieee80211_ops</structname>, this
   indicates whether a key is being removed or added.
</para>
</refsect1>
</refentry>

<refentry id="API-struct-ieee80211-key-conf">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct ieee80211_key_conf</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct ieee80211_key_conf</refname>
 <refpurpose>
  key information
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct ieee80211_key_conf {
  u32 cipher;
  u8 icv_len;
  u8 iv_len;
  u8 hw_key_idx;
  u8 flags;
  s8 keyidx;
  u8 keylen;
  u8 key[0];
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>cipher</term>
      <listitem><para>
The key's cipher suite selector.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>icv_len</term>
      <listitem><para>
The ICV length for this key type
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>iv_len</term>
      <listitem><para>
The IV length for this key type
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>hw_key_idx</term>
      <listitem><para>
To be set by the driver, this is the key index the driver
wants to be given when a frame is transmitted and needs to be
encrypted in hardware.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>flags</term>
      <listitem><para>
key flags, see <structname>enum</structname> ieee80211_key_flags.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>keyidx</term>
      <listitem><para>
the key index (0-3)
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>keylen</term>
      <listitem><para>
key material length
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>key[0]</term>
      <listitem><para>
key material. For ALG_TKIP the key is encoded as a 256-bit (32 byte)
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
<refsect1>
<title>Description</title>
<para>
   </para><para>

   This key information is given by mac80211 to the driver by
   the <function>set_key</function> callback in <structname>struct ieee80211_ops</structname>.
</para>
</refsect1>
<refsect1>
<title>data block</title>
<para>
   - Temporal Encryption Key (128 bits)
   - Temporal Authenticator Tx MIC Key (64 bits)
   - Temporal Authenticator Rx MIC Key (64 bits)
</para>
</refsect1>
</refentry>

<refentry id="API-enum-ieee80211-key-flags">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>enum ieee80211_key_flags</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>enum ieee80211_key_flags</refname>
 <refpurpose>
  key flags
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
enum ieee80211_key_flags {
  IEEE80211_KEY_FLAG_GENERATE_IV_MGMT,
  IEEE80211_KEY_FLAG_GENERATE_IV,
  IEEE80211_KEY_FLAG_GENERATE_MMIC,
  IEEE80211_KEY_FLAG_PAIRWISE,
  IEEE80211_KEY_FLAG_SW_MGMT_TX,
  IEEE80211_KEY_FLAG_PUT_IV_SPACE,
  IEEE80211_KEY_FLAG_RX_MGMT
};  </programlisting>
</refsynopsisdiv>
<refsect1>
 <title>Constants</title>
  <variablelist>
    <varlistentry>      <term>IEEE80211_KEY_FLAG_GENERATE_IV_MGMT</term>
      <listitem><para>
This flag should be set by the
driver for a CCMP key to indicate that is requires IV generation
only for managment frames (MFP).
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>IEEE80211_KEY_FLAG_GENERATE_IV</term>
      <listitem><para>
This flag should be set by the
driver to indicate that it requires IV generation for this
particular key.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>IEEE80211_KEY_FLAG_GENERATE_MMIC</term>
      <listitem><para>
This flag should be set by
the driver for a TKIP key if it requires Michael MIC
generation in software.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>IEEE80211_KEY_FLAG_PAIRWISE</term>
      <listitem><para>
Set by mac80211, this flag indicates
that the key is pairwise rather then a shared key.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>IEEE80211_KEY_FLAG_SW_MGMT_TX</term>
      <listitem><para>
This flag should be set by the driver for a
CCMP key if it requires CCMP encryption of management frames (MFP) to
be done in software.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>IEEE80211_KEY_FLAG_PUT_IV_SPACE</term>
      <listitem><para>
This flag should be set by the driver
if space should be prepared for the IV, but the IV
itself should not be generated. Do not set together with
<parameter>IEEE80211_KEY_FLAG_GENERATE_IV</parameter> on the same key.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>IEEE80211_KEY_FLAG_RX_MGMT</term>
      <listitem><para>
This key will be used to decrypt received
management frames. The flag can help drivers that have a hardware
crypto implementation that doesn't deal with management frames
properly by allowing them to not upload the keys to hardware and
fall back to software crypto. Note that this flag deals only with
RX, if your crypto engine can't deal with TX you can also set the
<constant>IEEE80211_KEY_FLAG_SW_MGMT_TX</constant> flag to encrypt such frames in SW.
      </para></listitem>
    </varlistentry>
  </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   </para><para>

   These flags are used for communication about keys between the driver
   and mac80211, with the <parameter>flags</parameter> parameter of <structname>struct ieee80211_key_conf</structname>.
</para>
</refsect1>
</refentry>

<refentry id="API-ieee80211-get-tkip-p1k">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ieee80211_get_tkip_p1k</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ieee80211_get_tkip_p1k</refname>
 <refpurpose>
  get a TKIP phase 1 key
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>ieee80211_get_tkip_p1k </function></funcdef>
   <paramdef>struct ieee80211_key_conf * <parameter>keyconf</parameter></paramdef>
   <paramdef>struct sk_buff * <parameter>skb</parameter></paramdef>
   <paramdef>u16 * <parameter>p1k</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>keyconf</parameter></term>
   <listitem>
    <para>
     the parameter passed with the set key
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>skb</parameter></term>
   <listitem>
    <para>
     the packet to take the IV32 value from that will be encrypted
     with this P1K
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>p1k</parameter></term>
   <listitem>
    <para>
     a buffer to which the key will be written, as 5 u16 values
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   </para><para>

   This function returns the TKIP phase 1 key for the IV32 taken
   from the given packet.
</para>
</refsect1>
</refentry>

<refentry id="API-ieee80211-get-tkip-p1k-iv">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ieee80211_get_tkip_p1k_iv</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ieee80211_get_tkip_p1k_iv</refname>
 <refpurpose>
  get a TKIP phase 1 key for IV32
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>ieee80211_get_tkip_p1k_iv </function></funcdef>
   <paramdef>struct ieee80211_key_conf * <parameter>keyconf</parameter></paramdef>
   <paramdef>u32 <parameter>iv32</parameter></paramdef>
   <paramdef>u16 * <parameter>p1k</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>keyconf</parameter></term>
   <listitem>
    <para>
     the parameter passed with the set key
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>iv32</parameter></term>
   <listitem>
    <para>
     IV32 to get the P1K for
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>p1k</parameter></term>
   <listitem>
    <para>
     a buffer to which the key will be written, as 5 u16 values
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   </para><para>

   This function returns the TKIP phase 1 key for the given IV32.
</para>
</refsect1>
</refentry>

<refentry id="API-ieee80211-get-tkip-p2k">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ieee80211_get_tkip_p2k</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ieee80211_get_tkip_p2k</refname>
 <refpurpose>
  get a TKIP phase 2 key
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>ieee80211_get_tkip_p2k </function></funcdef>
   <paramdef>struct ieee80211_key_conf * <parameter>keyconf</parameter></paramdef>
   <paramdef>struct sk_buff * <parameter>skb</parameter></paramdef>
   <paramdef>u8 * <parameter>p2k</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>keyconf</parameter></term>
   <listitem>
    <para>
     the parameter passed with the set key
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>skb</parameter></term>
   <listitem>
    <para>
     the packet to take the IV32/IV16 values from that will be
     encrypted with this key
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>p2k</parameter></term>
   <listitem>
    <para>
     a buffer to which the key will be written, 16 bytes
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   </para><para>

   This function computes the TKIP RC4 key for the IV values
   in the packet.
</para>
</refsect1>
</refentry>

      </chapter>

      <chapter id="powersave">
        <title>Powersave support</title>
<para>
   </para><para>
   mac80211 has support for various powersave implementations.
   </para><para>
   First, it can support hardware that handles all powersaving by itself,
   such hardware should simply set the <constant>IEEE80211_HW_SUPPORTS_PS</constant> hardware
   flag. In that case, it will be told about the desired powersave mode
   with the <constant>IEEE80211_CONF_PS</constant> flag depending on the association status.
   The hardware must take care of sending nullfunc frames when necessary,
   i.e. when entering and leaving powersave mode. The hardware is required
   to look at the AID in beacons and signal to the AP that it woke up when
   it finds traffic directed to it.
   </para><para>
   <constant>IEEE80211_CONF_PS</constant> flag enabled means that the powersave mode defined in
   IEEE 802.11-2007 section 11.2 is enabled. This is not to be confused
   with hardware wakeup and sleep states. Driver is responsible for waking
   up the hardware before issuing commands to the hardware and putting it
   back to sleep at appropriate times.
   </para><para>
   When PS is enabled, hardware needs to wakeup for beacons and receive the
   buffered multicast/broadcast frames after the beacon. Also it must be
   possible to send frames and receive the acknowledment frame.
   </para><para>
   Other hardware designs cannot send nullfunc frames by themselves and also
   need software support for parsing the TIM bitmap. This is also supported
   by mac80211 by combining the <constant>IEEE80211_HW_SUPPORTS_PS</constant> and
   <constant>IEEE80211_HW_PS_NULLFUNC_STACK</constant> flags. The hardware is of course still
   required to pass up beacons. The hardware is still required to handle
   waking up for multicast traffic; if it cannot the driver must handle that
   as best as it can, mac80211 is too slow to do that.
   </para><para>
   Dynamic powersave is an extension to normal powersave in which the
   hardware stays awake for a user-specified period of time after sending a
   frame so that reply frames need not be buffered and therefore delayed to
   the next wakeup. It's compromise of getting good enough latency when
   there's data traffic and still saving significantly power in idle
   periods.
   </para><para>
   Dynamic powersave is simply supported by mac80211 enabling and disabling
   PS based on traffic. Driver needs to only set <constant>IEEE80211_HW_SUPPORTS_PS</constant>
   flag and mac80211 will handle everything automatically. Additionally,
   hardware having support for the dynamic PS feature may set the
   <constant>IEEE80211_HW_SUPPORTS_DYNAMIC_PS</constant> flag to indicate that it can support
   dynamic PS mode itself. The driver needs to look at the
   <parameter>dynamic_ps_timeout</parameter> hardware configuration value and use it that value
   whenever <constant>IEEE80211_CONF_PS</constant> is set. In this case mac80211 will disable
   dynamic PS feature in stack and will just keep <constant>IEEE80211_CONF_PS</constant>
   enabled whenever user has enabled powersave.
   </para><para>
   Driver informs U-APSD client support by enabling
   <constant>IEEE80211_HW_SUPPORTS_UAPSD</constant> flag. The mode is configured through the
   uapsd parameter in <function>conf_tx</function> operation. Hardware needs to send the QoS
   Nullfunc frames and stay awake until the service period has ended. To
   utilize U-APSD, dynamic powersave is disabled for voip AC and all frames
   from that AC are transmitted with powersave enabled.
   </para><para>
   Note: U-APSD client mode is not yet supported with
   <constant>IEEE80211_HW_PS_NULLFUNC_STACK</constant>.
</para>

      </chapter>

      <chapter id="beacon-filter">
        <title>Beacon filter support</title>
<para>
   </para><para>
   Some hardware have beacon filter support to reduce host cpu wakeups
   which will reduce system power consumption. It usually works so that
   the firmware creates a checksum of the beacon but omits all constantly
   changing elements (TSF, TIM etc). Whenever the checksum changes the
   beacon is forwarded to the host, otherwise it will be just dropped. That
   way the host will only receive beacons where some relevant information
   (for example ERP protection or WMM settings) have changed.
   </para><para>
   Beacon filter support is advertised with the <constant>IEEE80211_VIF_BEACON_FILTER</constant>
   interface capability. The driver needs to enable beacon filter support
   whenever power save is enabled, that is <constant>IEEE80211_CONF_PS</constant> is set. When
   power save is enabled, the stack will not check for beacon loss and the
   driver needs to notify about loss of beacons with <function>ieee80211_beacon_loss</function>.
   </para><para>
   The time (or number of beacons missed) until the firmware notifies the
   driver of a beacon loss event (which in turn causes the driver to call
   <function>ieee80211_beacon_loss</function>) should be configurable and will be controlled
   by mac80211 and the roaming algorithm in the future.
   </para><para>
   Since there may be constantly changing information elements that nothing
   in the software stack cares about, we will, in the future, have mac80211
   tell the driver which information elements are interesting in the sense
   that we want to see changes in them. This will include
   - a list of information element IDs
   - a list of OUIs for the vendor information element
   </para><para>
   Ideally, the hardware would filter out any beacons without changes in the
   requested elements, but if it cannot support that it may, at the expense
   of some efficiency, filter out only a subset. For example, if the device
   doesn't support checking for OUIs it should pass up all changes in all
   vendor information elements.
   </para><para>
   Note that change, for the sake of simplification, also includes information
   elements appearing or disappearing from the beacon.
   </para><para>
   Some hardware supports an <quote>ignore list</quote> instead, just make sure nothing
   that was requested is on the ignore list, and include commonly changing
   information element IDs in the ignore list, for example 11 (BSS load) and
   the various vendor-assigned IEs with unknown contents (128, 129, 133-136,
   149, 150, 155, 156, 173, 176, 178, 179, 219); for forward compatibility
   it could also include some currently unused IDs.
   </para><para>
   </para><para>
   In addition to these capabilities, hardware should support notifying the
   host of changes in the beacon RSSI. This is relevant to implement roaming
   when no traffic is flowing (when traffic is flowing we see the RSSI of
   the received data packets). This can consist in notifying the host when
   the RSSI changes significantly or when it drops below or rises above
   configurable thresholds. In the future these thresholds will also be
   configured by mac80211 (which gets them from userspace) to implement
   them as the roaming algorithm requires.
   </para><para>
   If the hardware cannot implement this, the driver should ask it to
   periodically pass beacon frames to the host so that software can do the
   signal strength threshold checking.
</para>

<refentry id="API-ieee80211-beacon-loss">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ieee80211_beacon_loss</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ieee80211_beacon_loss</refname>
 <refpurpose>
  inform hardware does not receive beacons
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>ieee80211_beacon_loss </function></funcdef>
   <paramdef>struct ieee80211_vif * <parameter>vif</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>vif</parameter></term>
   <listitem>
    <para>
     <structname>struct ieee80211_vif</structname> pointer from the add_interface callback.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   When beacon filtering is enabled with <constant>IEEE80211_VIF_BEACON_FILTER</constant> and
   <constant>IEEE80211_CONF_PS</constant> is set, the driver needs to inform whenever the
   hardware is not receiving beacons with this function.
</para>
</refsect1>
</refentry>

      </chapter>

      <chapter id="qos">
        <title>Multiple queues and QoS support</title>
        <para>TBD</para>
<refentry id="API-struct-ieee80211-tx-queue-params">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct ieee80211_tx_queue_params</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct ieee80211_tx_queue_params</refname>
 <refpurpose>
  transmit queue configuration
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct ieee80211_tx_queue_params {
  u16 txop;
  u16 cw_min;
  u16 cw_max;
  u8 aifs;
  bool acm;
  bool uapsd;
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>txop</term>
      <listitem><para>
maximum burst time in units of 32 usecs, 0 meaning disabled
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>cw_min</term>
      <listitem><para>
minimum contention window [a value of the form
2^n-1 in the range 1..32767]
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>cw_max</term>
      <listitem><para>
maximum contention window [like <parameter>cw_min</parameter>]
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>aifs</term>
      <listitem><para>
arbitration interframe space [0..255]
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>acm</term>
      <listitem><para>
is mandatory admission control required for the access category
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>uapsd</term>
      <listitem><para>
is U-APSD mode enabled for the queue
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
<refsect1>
<title>Description</title>
<para>
   </para><para>

   The information provided in this structure is required for QoS
   transmit queue configuration. Cf. IEEE 802.11 7.3.2.29.
</para>
</refsect1>
</refentry>

      </chapter>

      <chapter id="AP">
        <title>Access point mode support</title>
        <para>TBD</para>
        <para>Some parts of the if_conf should be discussed here instead</para>
        <para>
          Insert notes about VLAN interfaces with hw crypto here or
          in the hw crypto chapter.
        </para>
      <section id="ps-client">
        <title>support for powersaving clients</title>
<para>
   </para><para>
   In order to implement AP and P2P GO modes, mac80211 has support for
   client powersaving, both <quote>legacy</quote> PS (PS-Poll/null data) and uAPSD.
   There currently is no support for sAPSD.
   </para><para>
   There is one assumption that mac80211 makes, namely that a client
   will not poll with PS-Poll and trigger with uAPSD at the same time.
   Both are supported, and both can be used by the same client, but
   they can't be used concurrently by the same client. This simplifies
   the driver code.
   </para><para>
   The first thing to keep in mind is that there is a flag for complete
   driver implementation: <constant>IEEE80211_HW_AP_LINK_PS</constant>. If this flag is set,
   mac80211 expects the driver to handle most of the state machine for
   powersaving clients and will ignore the PM bit in incoming frames.
   Drivers then use <function>ieee80211_sta_ps_transition</function> to inform mac80211 of
   stations' powersave transitions. In this mode, mac80211 also doesn't
   handle PS-Poll/uAPSD.
   </para><para>
   In the mode without <constant>IEEE80211_HW_AP_LINK_PS</constant>, mac80211 will check the
   PM bit in incoming frames for client powersave transitions. When a
   station goes to sleep, we will stop transmitting to it. There is,
   however, a race condition: a station might go to sleep while there is
   data buffered on hardware queues. If the device has support for this
   it will reject frames, and the driver should give the frames back to
   mac80211 with the <constant>IEEE80211_TX_STAT_TX_FILTERED</constant> flag set which will
   cause mac80211 to retry the frame when the station wakes up. The
   driver is also notified of powersave transitions by calling its
   <parameter>sta_notify</parameter> callback.
   </para><para>
   When the station is asleep, it has three choices: it can wake up,
   it can PS-Poll, or it can possibly start a uAPSD service period.
   Waking up is implemented by simply transmitting all buffered (and
   filtered) frames to the station. This is the easiest case. When
   the station sends a PS-Poll or a uAPSD trigger frame, mac80211
   will inform the driver of this with the <parameter>allow_buffered_frames</parameter>
   callback; this callback is optional. mac80211 will then transmit
   the frames as usual and set the <constant>IEEE80211_TX_CTL_NO_PS_BUFFER</constant>
   on each frame. The last frame in the service period (or the only
   response to a PS-Poll) also has <constant>IEEE80211_TX_STATUS_EOSP</constant> set to
   indicate that it ends the service period; as this frame must have
   TX status report it also sets <constant>IEEE80211_TX_CTL_REQ_TX_STATUS</constant>.
   When TX status is reported for this frame, the service period is
   marked has having ended and a new one can be started by the peer.
   </para><para>
   Additionally, non-bufferable MMPDUs can also be transmitted by
   mac80211 with the <constant>IEEE80211_TX_CTL_NO_PS_BUFFER</constant> set in them.
   </para><para>
   Another race condition can happen on some devices like iwlwifi
   when there are frames queued for the station and it wakes up
   or polls; the frames that are already queued could end up being
   transmitted first instead, causing reordering and/or wrong
   processing of the EOSP. The cause is that allowing frames to be
   transmitted to a certain station is out-of-band communication to
   the device. To allow this problem to be solved, the driver can
   call <function>ieee80211_sta_block_awake</function> if frames are buffered when it
   is notified that the station went to sleep. When all these frames
   have been filtered (see above), it must call the function again
   to indicate that the station is no longer blocked.
   </para><para>
   If the driver buffers frames in the driver for aggregation in any
   way, it must use the <function>ieee80211_sta_set_buffered</function> call when it is
   notified of the station going to sleep to inform mac80211 of any
   TIDs that have frames buffered. Note that when a station wakes up
   this information is reset (hence the requirement to call it when
   informed of the station going to sleep). Then, when a service
   period starts for any reason, <parameter>release_buffered_frames</parameter> is called
   with the number of frames to be released and which TIDs they are
   to come from. In this case, the driver is responsible for setting
   the EOSP (for uAPSD) and MORE_DATA bits in the released frames,
   to help the <parameter>more_data</parameter> parameter is passed to tell the driver if
   there is more data on other TIDs -- the TIDs to release frames
   from are ignored since mac80211 doesn't know how many frames the
   buffers for those TIDs contain.
   </para><para>
   If the driver also implement GO mode, where absence periods may
   shorten service periods (or abort PS-Poll responses), it must
   filter those response frames except in the case of frames that
   are buffered in the driver -- those must remain buffered to avoid
   reordering. Because it is possible that no frames are released
   in this case, the driver must call <function>ieee80211_sta_eosp</function>
   to indicate to mac80211 that the service period ended anyway.
   </para><para>
   Finally, if frames from multiple TIDs are released from mac80211
   but the driver might reorder them, it must clear &amp; set the flags
   appropriately (only the last frame may have <constant>IEEE80211_TX_STATUS_EOSP</constant>)
   and also take care of the EOSP and MORE_DATA bits in the frame.
   The driver may also use <function>ieee80211_sta_eosp</function> in this case.
   </para><para>
   Note that if the driver ever buffers frames other than QoS-data
   frames, it must take care to never send a non-QoS-data frame as
   the last frame in a service period, adding a QoS-nulldata frame
   after a non-QoS-data frame if needed.
</para>

      </section>
<refentry id="API-ieee80211-get-buffered-bc">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ieee80211_get_buffered_bc</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ieee80211_get_buffered_bc</refname>
 <refpurpose>
  accessing buffered broadcast and multicast frames
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct sk_buff * <function>ieee80211_get_buffered_bc </function></funcdef>
   <paramdef>struct ieee80211_hw * <parameter>hw</parameter></paramdef>
   <paramdef>struct ieee80211_vif * <parameter>vif</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>hw</parameter></term>
   <listitem>
    <para>
     pointer as obtained from <function>ieee80211_alloc_hw</function>.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>vif</parameter></term>
   <listitem>
    <para>
     <structname>struct ieee80211_vif</structname> pointer from the add_interface callback.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Function for accessing buffered broadcast and multicast frames. If
   hardware/firmware does not implement buffering of broadcast/multicast
   frames when power saving is used, 802.11 code buffers them in the host
   memory. The low-level driver uses this function to fetch next buffered
   frame. In most cases, this is used when generating beacon frame.
</para>
</refsect1>
<refsect1>
<title>Return</title>
<para>
   A pointer to the next buffered skb or NULL if no more buffered
   frames are available.
</para>
</refsect1>
<refsect1>
<title>Note</title>
<para>
   buffered frames are returned only after DTIM beacon frame was
   generated with <function>ieee80211_beacon_get</function> and the low-level driver must thus
   call <function>ieee80211_beacon_get</function> first. <function>ieee80211_get_buffered_bc</function> returns
   NULL if the previous generated beacon was not DTIM, so the low-level driver
   does not need to check for DTIM beacons separately and should be able to
   use common code for all beacons.
</para>
</refsect1>
</refentry>

<refentry id="API-ieee80211-beacon-get">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ieee80211_beacon_get</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ieee80211_beacon_get</refname>
 <refpurpose>
  beacon generation function
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct sk_buff * <function>ieee80211_beacon_get </function></funcdef>
   <paramdef>struct ieee80211_hw * <parameter>hw</parameter></paramdef>
   <paramdef>struct ieee80211_vif * <parameter>vif</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>hw</parameter></term>
   <listitem>
    <para>
     pointer obtained from <function>ieee80211_alloc_hw</function>.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>vif</parameter></term>
   <listitem>
    <para>
     <structname>struct ieee80211_vif</structname> pointer from the add_interface callback.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   See <function>ieee80211_beacon_get_tim</function>.
</para>
</refsect1>
<refsect1>
<title>Return</title>
<para>
   See <function>ieee80211_beacon_get_tim</function>.
</para>
</refsect1>
</refentry>

<refentry id="API-ieee80211-sta-eosp">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ieee80211_sta_eosp</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ieee80211_sta_eosp</refname>
 <refpurpose>
  notify mac80211 about end of SP
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>ieee80211_sta_eosp </function></funcdef>
   <paramdef>struct ieee80211_sta * <parameter>pubsta</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>pubsta</parameter></term>
   <listitem>
    <para>
     the station
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   When a device transmits frames in a way that it can't tell
   mac80211 in the TX status about the EOSP, it must clear the
   <constant>IEEE80211_TX_STATUS_EOSP</constant> bit and call this function instead.
   This applies for PS-Poll as well as uAPSD.
   </para><para>

   Note that just like with <function>_tx_status</function> and <function>_rx</function> drivers must
   not mix calls to irqsafe/non-irqsafe versions, this function
   must not be mixed with those either. Use the all irqsafe, or
   all non-irqsafe, don't mix!
</para>
</refsect1>
<refsect1>
<title>NB</title>
<para>
   the _irqsafe version of this function doesn't exist, no
   driver needs it right now. Don't call this function if
   you'd need the _irqsafe version, look at the git history
   and restore the _irqsafe version!
</para>
</refsect1>
</refentry>

<refentry id="API-enum-ieee80211-frame-release-type">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>enum ieee80211_frame_release_type</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>enum ieee80211_frame_release_type</refname>
 <refpurpose>
  frame release reason
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
enum ieee80211_frame_release_type {
  IEEE80211_FRAME_RELEASE_PSPOLL,
  IEEE80211_FRAME_RELEASE_UAPSD
};  </programlisting>
</refsynopsisdiv>
<refsect1>
 <title>Constants</title>
  <variablelist>
    <varlistentry>      <term>IEEE80211_FRAME_RELEASE_PSPOLL</term>
      <listitem><para>
frame released for PS-Poll
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>IEEE80211_FRAME_RELEASE_UAPSD</term>
      <listitem><para>
frame(s) released due to
frame received on trigger-enabled AC
      </para></listitem>
    </varlistentry>
  </variablelist>
</refsect1>
</refentry>

<refentry id="API-ieee80211-sta-ps-transition">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ieee80211_sta_ps_transition</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ieee80211_sta_ps_transition</refname>
 <refpurpose>
  PS transition for connected sta
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>ieee80211_sta_ps_transition </function></funcdef>
   <paramdef>struct ieee80211_sta * <parameter>sta</parameter></paramdef>
   <paramdef>bool <parameter>start</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>sta</parameter></term>
   <listitem>
    <para>
     currently connected sta
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>start</parameter></term>
   <listitem>
    <para>
     start or stop PS
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   </para><para>

   When operating in AP mode with the <constant>IEEE80211_HW_AP_LINK_PS</constant>
   flag set, use this function to inform mac80211 about a connected station
   entering/leaving PS mode.
   </para><para>

   This function may not be called in IRQ context or with softirqs enabled.
   </para><para>

   Calls to this function for a single hardware must be synchronized against
   each other.
</para>
</refsect1>
<refsect1>
<title>Return</title>
<para>
   0 on success. -EINVAL when the requested PS mode is already set.
</para>
</refsect1>
</refentry>

<refentry id="API-ieee80211-sta-ps-transition-ni">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ieee80211_sta_ps_transition_ni</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ieee80211_sta_ps_transition_ni</refname>
 <refpurpose>
  PS transition for connected sta (in process context)
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>ieee80211_sta_ps_transition_ni </function></funcdef>
   <paramdef>struct ieee80211_sta * <parameter>sta</parameter></paramdef>
   <paramdef>bool <parameter>start</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>sta</parameter></term>
   <listitem>
    <para>
     currently connected sta
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>start</parameter></term>
   <listitem>
    <para>
     start or stop PS
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   </para><para>

   Like <function>ieee80211_sta_ps_transition</function> but can be called in process context
   (internally disables bottom halves). Concurrent call restriction still
   applies.
</para>
</refsect1>
<refsect1>
<title>Return</title>
<para>
   Like <function>ieee80211_sta_ps_transition</function>.
</para>
</refsect1>
</refentry>

<refentry id="API-ieee80211-sta-set-buffered">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ieee80211_sta_set_buffered</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ieee80211_sta_set_buffered</refname>
 <refpurpose>
  inform mac80211 about driver-buffered frames
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>ieee80211_sta_set_buffered </function></funcdef>
   <paramdef>struct ieee80211_sta * <parameter>sta</parameter></paramdef>
   <paramdef>u8 <parameter>tid</parameter></paramdef>
   <paramdef>bool <parameter>buffered</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>sta</parameter></term>
   <listitem>
    <para>
     <structname>struct ieee80211_sta</structname> pointer for the sleeping station
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>tid</parameter></term>
   <listitem>
    <para>
     the TID that has buffered frames
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>buffered</parameter></term>
   <listitem>
    <para>
     indicates whether or not frames are buffered for this TID
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   If a driver buffers frames for a powersave station instead of passing
   them back to mac80211 for retransmission, the station may still need
   to be told that there are buffered frames via the TIM bit.
   </para><para>

   This function informs mac80211 whether or not there are frames that are
   buffered in the driver for a given TID; mac80211 can then use this data
   to set the TIM bit (NOTE: This may call back into the driver's set_tim
   call! Beware of the locking!)
   </para><para>

   If all frames are released to the station (due to PS-poll or uAPSD)
   then the driver needs to inform mac80211 that there no longer are
   frames buffered. However, when the station wakes up mac80211 assumes
   that all buffered frames will be transmitted and clears this data,
   drivers need to make sure they inform mac80211 about all buffered
   frames on the sleep transition (<function>sta_notify</function> with <constant>STA_NOTIFY_SLEEP</constant>).
   </para><para>

   Note that technically mac80211 only needs to know this per AC, not per
   TID, but since driver buffering will inevitably happen per TID (since
   it is related to aggregation) it is easier to make mac80211 map the
   TID to the AC as required instead of keeping track in all drivers that
   use this API.
</para>
</refsect1>
</refentry>

<refentry id="API-ieee80211-sta-block-awake">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ieee80211_sta_block_awake</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ieee80211_sta_block_awake</refname>
 <refpurpose>
  block station from waking up
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>ieee80211_sta_block_awake </function></funcdef>
   <paramdef>struct ieee80211_hw * <parameter>hw</parameter></paramdef>
   <paramdef>struct ieee80211_sta * <parameter>pubsta</parameter></paramdef>
   <paramdef>bool <parameter>block</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>hw</parameter></term>
   <listitem>
    <para>
     the hardware
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>pubsta</parameter></term>
   <listitem>
    <para>
     the station
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>block</parameter></term>
   <listitem>
    <para>
     whether to block or unblock
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Some devices require that all frames that are on the queues
   for a specific station that went to sleep are flushed before
   a poll response or frames after the station woke up can be
   delivered to that it. Note that such frames must be rejected
   by the driver as filtered, with the appropriate status flag.
   </para><para>

   This function allows implementing this mode in a race-free
   manner.
   </para><para>

   To do this, a driver must keep track of the number of frames
   still enqueued for a specific station. If this number is not
   zero when the station goes to sleep, the driver must call
   this function to force mac80211 to consider the station to
   be asleep regardless of the station's actual state. Once the
   number of outstanding frames reaches zero, the driver must
   call this function again to unblock the station. That will
   cause mac80211 to be able to send ps-poll responses, and if
   the station queried in the meantime then frames will also
   be sent out as a result of this. Additionally, the driver
   will be notified that the station woke up some time after
   it is unblocked, regardless of whether the station actually
   woke up while blocked or not.
</para>
</refsect1>
</refentry>

      </chapter>

      <chapter id="multi-iface">
        <title>Supporting multiple virtual interfaces</title>
        <para>TBD</para>
        <para>
          Note: WDS with identical MAC address should almost always be OK
        </para>
        <para>
          Insert notes about having multiple virtual interfaces with
          different MAC addresses here, note which configurations are
          supported by mac80211, add notes about supporting hw crypto
          with it.
        </para>
<refentry id="API-ieee80211-iterate-active-interfaces">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ieee80211_iterate_active_interfaces</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ieee80211_iterate_active_interfaces</refname>
 <refpurpose>
  iterate active interfaces
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>ieee80211_iterate_active_interfaces </function></funcdef>
   <paramdef>struct ieee80211_hw * <parameter>hw</parameter></paramdef>
   <paramdef>u32 <parameter>iter_flags</parameter></paramdef>
   <paramdef>void (*<parameter>iterator</parameter>)
     <funcparams>void *data, u8 *mac, 						struct ieee80211_vif *vif</funcparams></paramdef>
   <paramdef>void * <parameter>data</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>hw</parameter></term>
   <listitem>
    <para>
     the hardware struct of which the interfaces should be iterated over
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>iter_flags</parameter></term>
   <listitem>
    <para>
     iteration flags, see <structname>enum</structname> ieee80211_interface_iteration_flags
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>iterator</parameter></term>
   <listitem>
    <para>
     the iterator function to call
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>data</parameter></term>
   <listitem>
    <para>
     first argument of the iterator function
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   </para><para>

   This function iterates over the interfaces associated with a given
   hardware that are currently active and calls the callback for them.
   This function allows the iterator function to sleep, when the iterator
   function is atomic <parameter>ieee80211_iterate_active_interfaces_atomic</parameter> can
   be used.
   Does not iterate over a new interface during <function>add_interface</function>.
</para>
</refsect1>
</refentry>

<refentry id="API-ieee80211-iterate-active-interfaces-atomic">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ieee80211_iterate_active_interfaces_atomic</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ieee80211_iterate_active_interfaces_atomic</refname>
 <refpurpose>
  iterate active interfaces
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>ieee80211_iterate_active_interfaces_atomic </function></funcdef>
   <paramdef>struct ieee80211_hw * <parameter>hw</parameter></paramdef>
   <paramdef>u32 <parameter>iter_flags</parameter></paramdef>
   <paramdef>void (*<parameter>iterator</parameter>)
     <funcparams>void *data, 						    u8 *mac, 						    struct ieee80211_vif *vif</funcparams></paramdef>
   <paramdef>void * <parameter>data</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>hw</parameter></term>
   <listitem>
    <para>
     the hardware struct of which the interfaces should be iterated over
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>iter_flags</parameter></term>
   <listitem>
    <para>
     iteration flags, see <structname>enum</structname> ieee80211_interface_iteration_flags
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>iterator</parameter></term>
   <listitem>
    <para>
     the iterator function to call, cannot sleep
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>data</parameter></term>
   <listitem>
    <para>
     first argument of the iterator function
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   </para><para>

   This function iterates over the interfaces associated with a given
   hardware that are currently active and calls the callback for them.
   This function requires the iterator callback function to be atomic,
   if that is not desired, use <parameter>ieee80211_iterate_active_interfaces</parameter> instead.
   Does not iterate over a new interface during <function>add_interface</function>.
</para>
</refsect1>
</refentry>

      </chapter>

      <chapter id="station-handling">
        <title>Station handling</title>
        <para>TODO</para>
<refentry id="API-struct-ieee80211-sta">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct ieee80211_sta</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct ieee80211_sta</refname>
 <refpurpose>
  station table entry
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct ieee80211_sta {
  u32 supp_rates[IEEE80211_NUM_BANDS];
  u8 addr[ETH_ALEN];
  u16 aid;
  struct ieee80211_sta_ht_cap ht_cap;
  struct ieee80211_sta_vht_cap vht_cap;
  bool wme;
  u8 uapsd_queues;
  u8 max_sp;
  u8 rx_nss;
  enum ieee80211_sta_rx_bandwidth bandwidth;
  enum ieee80211_smps_mode smps_mode;
  struct ieee80211_sta_rates __rcu * rates;
  bool tdls;
  u8 drv_priv[0];
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>supp_rates[IEEE80211_NUM_BANDS]</term>
      <listitem><para>
Bitmap of supported rates (per band)
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>addr[ETH_ALEN]</term>
      <listitem><para>
MAC address
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>aid</term>
      <listitem><para>
AID we assigned to the station if we're an AP
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>ht_cap</term>
      <listitem><para>
HT capabilities of this STA; restricted to our own capabilities
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>vht_cap</term>
      <listitem><para>
VHT capabilities of this STA; restricted to our own capabilities
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>wme</term>
      <listitem><para>
indicates whether the STA supports QoS/WME.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>uapsd_queues</term>
      <listitem><para>
bitmap of queues configured for uapsd. Only valid
if wme is supported.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>max_sp</term>
      <listitem><para>
max Service Period. Only valid if wme is supported.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>rx_nss</term>
      <listitem><para>
in HT/VHT, the maximum number of spatial streams the
station can receive at the moment, changed by operating mode
notifications and capabilities. The value is only valid after
the station moves to associated state.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>bandwidth</term>
      <listitem><para>
current bandwidth the station can receive with
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>smps_mode</term>
      <listitem><para>
current SMPS mode (off, static or dynamic)
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>rates</term>
      <listitem><para>
rate control selection table
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>tdls</term>
      <listitem><para>
indicates whether the STA is a TDLS peer
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>drv_priv[0]</term>
      <listitem><para>
data area for driver use, will always be aligned to
sizeof(void *), size is determined in hw information.
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
<refsect1>
<title>Description</title>
<para>
   </para><para>

   A station table entry represents a station we are possibly
   communicating with. Since stations are RCU-managed in
   mac80211, any ieee80211_sta pointer you get access to must
   either be protected by <function>rcu_read_lock</function> explicitly or implicitly,
   or you must take good care to not use such a pointer after a
   call to your sta_remove callback that removed it.
</para>
</refsect1>
</refentry>

<refentry id="API-enum-sta-notify-cmd">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>enum sta_notify_cmd</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>enum sta_notify_cmd</refname>
 <refpurpose>
  sta notify command
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
enum sta_notify_cmd {
  STA_NOTIFY_SLEEP,
  STA_NOTIFY_AWAKE
};  </programlisting>
</refsynopsisdiv>
<refsect1>
 <title>Constants</title>
  <variablelist>
    <varlistentry>      <term>STA_NOTIFY_SLEEP</term>
      <listitem><para>
a station is now sleeping
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>STA_NOTIFY_AWAKE</term>
      <listitem><para>
a sleeping station woke up
      </para></listitem>
    </varlistentry>
  </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   </para><para>

   Used with the <function>sta_notify</function> callback in <structname>struct ieee80211_ops</structname>, this
   indicates if an associated station made a power state transition.
</para>
</refsect1>
</refentry>

<refentry id="API-ieee80211-find-sta">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ieee80211_find_sta</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ieee80211_find_sta</refname>
 <refpurpose>
  find a station
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct ieee80211_sta * <function>ieee80211_find_sta </function></funcdef>
   <paramdef>struct ieee80211_vif * <parameter>vif</parameter></paramdef>
   <paramdef>const u8 * <parameter>addr</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>vif</parameter></term>
   <listitem>
    <para>
     virtual interface to look for station on
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>addr</parameter></term>
   <listitem>
    <para>
     station's address
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Return</title>
<para>
   The station, if found. <constant>NULL</constant> otherwise.
</para>
</refsect1>
<refsect1>
<title>Note</title>
<para>
   This function must be called under RCU lock and the
   resulting pointer is only valid under RCU lock as well.
</para>
</refsect1>
</refentry>

<refentry id="API-ieee80211-find-sta-by-ifaddr">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ieee80211_find_sta_by_ifaddr</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ieee80211_find_sta_by_ifaddr</refname>
 <refpurpose>
  find a station on hardware
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct ieee80211_sta * <function>ieee80211_find_sta_by_ifaddr </function></funcdef>
   <paramdef>struct ieee80211_hw * <parameter>hw</parameter></paramdef>
   <paramdef>const u8 * <parameter>addr</parameter></paramdef>
   <paramdef>const u8 * <parameter>localaddr</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>hw</parameter></term>
   <listitem>
    <para>
     pointer as obtained from <function>ieee80211_alloc_hw</function>
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>addr</parameter></term>
   <listitem>
    <para>
     remote station's address
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>localaddr</parameter></term>
   <listitem>
    <para>
     local address (vif-&gt;sdata-&gt;vif.addr). Use NULL for 'any'.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Return</title>
<para>
   The station, if found. <constant>NULL</constant> otherwise.
</para>
</refsect1>
<refsect1>
<title>Note</title>
<para>
   This function must be called under RCU lock and the
   resulting pointer is only valid under RCU lock as well.
</para>
</refsect1>
<refsect1>
<title>NOTE</title>
<para>
   You may pass NULL for localaddr, but then you will just get
   the first STA that matches the remote address 'addr'.
   We can have multiple STA associated with multiple
   logical stations (e.g. consider a station connecting to another
   BSSID on the same AP hardware without disconnecting first).
   In this case, the result of this method with localaddr NULL
   is not reliable.
   </para><para>

   DO NOT USE THIS FUNCTION with localaddr NULL if at all possible.
</para>
</refsect1>
</refentry>

      </chapter>

      <chapter id="hardware-scan-offload">
        <title>Hardware scan offload</title>
        <para>TBD</para>
<refentry id="API-ieee80211-scan-completed">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ieee80211_scan_completed</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ieee80211_scan_completed</refname>
 <refpurpose>
  completed hardware scan
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>ieee80211_scan_completed </function></funcdef>
   <paramdef>struct ieee80211_hw * <parameter>hw</parameter></paramdef>
   <paramdef>bool <parameter>aborted</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>hw</parameter></term>
   <listitem>
    <para>
     the hardware that finished the scan
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>aborted</parameter></term>
   <listitem>
    <para>
     set to true if scan was aborted
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   </para><para>

   When hardware scan offload is used (i.e. the <function>hw_scan</function> callback is
   assigned) this function needs to be called by the driver to notify
   mac80211 that the scan finished. This function can be called from
   any context, including hardirq context.
</para>
</refsect1>
</refentry>

      </chapter>

      <chapter id="aggregation">
        <title>Aggregation</title>
        <sect1>
          <title>TX A-MPDU aggregation</title>
<para>
   </para><para>
   Aggregation on the TX side requires setting the hardware flag
   <constant>IEEE80211_HW_AMPDU_AGGREGATION</constant>. The driver will then be handed
   packets with a flag indicating A-MPDU aggregation. The driver
   or device is responsible for actually aggregating the frames,
   as well as deciding how many and which to aggregate.
   </para><para>
   When TX aggregation is started by some subsystem (usually the rate
   control algorithm would be appropriate) by calling the
   <function>ieee80211_start_tx_ba_session</function> function, the driver will be
   notified via its <parameter>ampdu_action</parameter> function, with the
   <constant>IEEE80211_AMPDU_TX_START</constant> action.
   </para><para>
   In response to that, the driver is later required to call the
   <function>ieee80211_start_tx_ba_cb_irqsafe</function> function, which will really
   start the aggregation session after the peer has also responded.
   If the peer responds negatively, the session will be stopped
   again right away. Note that it is possible for the aggregation
   session to be stopped before the driver has indicated that it
   is done setting it up, in which case it must not indicate the
   setup completion.
   </para><para>
   Also note that, since we also need to wait for a response from
   the peer, the driver is notified of the completion of the
   handshake by the <constant>IEEE80211_AMPDU_TX_OPERATIONAL</constant> action to the
   <parameter>ampdu_action</parameter> callback.
   </para><para>
   Similarly, when the aggregation session is stopped by the peer
   or something calling <function>ieee80211_stop_tx_ba_session</function>, the driver's
   <parameter>ampdu_action</parameter> function will be called with the action
   <constant>IEEE80211_AMPDU_TX_STOP</constant>. In this case, the call must not fail,
   and the driver must later call <function>ieee80211_stop_tx_ba_cb_irqsafe</function>.
   Note that the sta can get destroyed before the BA tear down is
   complete.
</para>

        </sect1>
        <sect1>
          <title>RX A-MPDU aggregation</title>
<para>
   </para><para>
   Aggregation on the RX side requires only implementing the
   <parameter>ampdu_action</parameter> callback that is invoked to start/stop any
   block-ack sessions for RX aggregation.
   </para><para>
   When RX aggregation is started by the peer, the driver is
   notified via <parameter>ampdu_action</parameter> function, with the
   <constant>IEEE80211_AMPDU_RX_START</constant> action, and may reject the request
   in which case a negative response is sent to the peer, if it
   accepts it a positive response is sent.
   </para><para>
   While the session is active, the device/driver are required
   to de-aggregate frames and pass them up one by one to mac80211,
   which will handle the reorder buffer.
   </para><para>
   When the aggregation session is stopped again by the peer or
   ourselves, the driver's <parameter>ampdu_action</parameter> function will be called
   with the action <constant>IEEE80211_AMPDU_RX_STOP</constant>. In this case, the
   call must not fail.
</para>

        </sect1>
<refentry id="API-enum-ieee80211-ampdu-mlme-action">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>enum ieee80211_ampdu_mlme_action</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>enum ieee80211_ampdu_mlme_action</refname>
 <refpurpose>
  A-MPDU actions
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
enum ieee80211_ampdu_mlme_action {
  IEEE80211_AMPDU_RX_START,
  IEEE80211_AMPDU_RX_STOP,
  IEEE80211_AMPDU_TX_START,
  IEEE80211_AMPDU_TX_STOP_CONT,
  IEEE80211_AMPDU_TX_STOP_FLUSH,
  IEEE80211_AMPDU_TX_STOP_FLUSH_CONT,
  IEEE80211_AMPDU_TX_OPERATIONAL
};  </programlisting>
</refsynopsisdiv>
<refsect1>
 <title>Constants</title>
  <variablelist>
    <varlistentry>      <term>IEEE80211_AMPDU_RX_START</term>
      <listitem><para>
start RX aggregation
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>IEEE80211_AMPDU_RX_STOP</term>
      <listitem><para>
stop RX aggregation
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>IEEE80211_AMPDU_TX_START</term>
      <listitem><para>
start TX aggregation
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>IEEE80211_AMPDU_TX_STOP_CONT</term>
      <listitem><para>
stop TX aggregation but continue transmitting
queued packets, now unaggregated. After all packets are transmitted the
driver has to call <function>ieee80211_stop_tx_ba_cb_irqsafe</function>.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>IEEE80211_AMPDU_TX_STOP_FLUSH</term>
      <listitem><para>
stop TX aggregation and flush all packets,
called when the station is removed. There's no need or reason to call
<function>ieee80211_stop_tx_ba_cb_irqsafe</function> in this case as mac80211 assumes the
session is gone and removes the station.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>IEEE80211_AMPDU_TX_STOP_FLUSH_CONT</term>
      <listitem><para>
called when TX aggregation is stopped
but the driver hasn't called <function>ieee80211_stop_tx_ba_cb_irqsafe</function> yet and
now the connection is dropped and the station will be removed. Drivers
should clean up and drop remaining packets when this is called.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>IEEE80211_AMPDU_TX_OPERATIONAL</term>
      <listitem><para>
TX aggregation has become operational
      </para></listitem>
    </varlistentry>
  </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   </para><para>

   These flags are used with the <function>ampdu_action</function> callback in
   <structname>struct ieee80211_ops</structname> to indicate which action is needed.
   </para><para>

   Note that drivers MUST be able to deal with a TX aggregation
   session being stopped even before they OK'ed starting it by
   calling ieee80211_start_tx_ba_cb_irqsafe, because the peer
   might receive the addBA frame and send a delBA right away!
</para>
</refsect1>
</refentry>

      </chapter>

      <chapter id="smps">
        <title>Spatial Multiplexing Powersave (SMPS)</title>
<para>
   </para><para>
   SMPS (Spatial multiplexing power save) is a mechanism to conserve
   power in an 802.11n implementation. For details on the mechanism
   and rationale, please refer to 802.11 (as amended by 802.11n-2009)
   <quote>11.2.3 SM power save</quote>.
   </para><para>
   The mac80211 implementation is capable of sending action frames
   to update the AP about the station's SMPS mode, and will instruct
   the driver to enter the specific mode. It will also announce the
   requested SMPS mode during the association handshake. Hardware
   support for this feature is required, and can be indicated by
   hardware flags.
   </para><para>
   The default mode will be <quote>automatic</quote>, which nl80211/cfg80211
   defines to be dynamic SMPS in (regular) powersave, and SMPS
   turned off otherwise.
   </para><para>
   To support this feature, the driver must set the appropriate
   hardware support flags, and handle the SMPS flag to the <function>config</function>
   operation. It will then with this mechanism be instructed to
   enter the requested SMPS mode while associated to an HT AP.
</para>

<refentry id="API-ieee80211-request-smps">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ieee80211_request_smps</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ieee80211_request_smps</refname>
 <refpurpose>
  request SM PS transition
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>ieee80211_request_smps </function></funcdef>
   <paramdef>struct ieee80211_vif * <parameter>vif</parameter></paramdef>
   <paramdef>enum ieee80211_smps_mode <parameter>smps_mode</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>vif</parameter></term>
   <listitem>
    <para>
     <structname>struct ieee80211_vif</structname> pointer from the add_interface callback.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>smps_mode</parameter></term>
   <listitem>
    <para>
     new SM PS mode
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This allows the driver to request an SM PS transition in managed
   mode. This is useful when the driver has more information than
   the stack about possible interference, for example by bluetooth.
</para>
</refsect1>
</refentry>

<refentry id="API-enum-ieee80211-smps-mode">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>enum ieee80211_smps_mode</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>enum ieee80211_smps_mode</refname>
 <refpurpose>
  spatial multiplexing power save mode
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
enum ieee80211_smps_mode {
  IEEE80211_SMPS_AUTOMATIC,
  IEEE80211_SMPS_OFF,
  IEEE80211_SMPS_STATIC,
  IEEE80211_SMPS_DYNAMIC,
  IEEE80211_SMPS_NUM_MODES
};  </programlisting>
</refsynopsisdiv>
<refsect1>
 <title>Constants</title>
  <variablelist>
    <varlistentry>      <term>IEEE80211_SMPS_AUTOMATIC</term>
      <listitem><para>
automatic
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>IEEE80211_SMPS_OFF</term>
      <listitem><para>
off
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>IEEE80211_SMPS_STATIC</term>
      <listitem><para>
static
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>IEEE80211_SMPS_DYNAMIC</term>
      <listitem><para>
dynamic
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>IEEE80211_SMPS_NUM_MODES</term>
      <listitem><para>
internal, don't use
      </para></listitem>
    </varlistentry>
  </variablelist>
</refsect1>
</refentry>

      </chapter>
    </part>

    <part id="rate-control">
      <title>Rate control interface</title>
      <partintro>
        <para>TBD</para>
        <para>
         This part of the book describes the rate control algorithm
         interface and how it relates to mac80211 and drivers.
        </para>
      </partintro>
      <chapter id="ratecontrol-api">
        <title>Rate Control API</title>
        <para>TBD</para>
<refentry id="API-ieee80211-start-tx-ba-session">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ieee80211_start_tx_ba_session</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ieee80211_start_tx_ba_session</refname>
 <refpurpose>
  Start a tx Block Ack session.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>ieee80211_start_tx_ba_session </function></funcdef>
   <paramdef>struct ieee80211_sta * <parameter>sta</parameter></paramdef>
   <paramdef>u16 <parameter>tid</parameter></paramdef>
   <paramdef>u16 <parameter>timeout</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>sta</parameter></term>
   <listitem>
    <para>
     the station for which to start a BA session
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>tid</parameter></term>
   <listitem>
    <para>
     the TID to BA on.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>timeout</parameter></term>
   <listitem>
    <para>
     session timeout value (in TUs)
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Return</title>
<para>
   success if addBA request was sent, failure otherwise
   </para><para>

   Although mac80211/low level driver/user space application can estimate
   the need to start aggregation on a certain RA/TID, the session level
   will be managed by the mac80211.
</para>
</refsect1>
</refentry>

<refentry id="API-ieee80211-start-tx-ba-cb-irqsafe">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ieee80211_start_tx_ba_cb_irqsafe</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ieee80211_start_tx_ba_cb_irqsafe</refname>
 <refpurpose>
  low level driver ready to aggregate.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>ieee80211_start_tx_ba_cb_irqsafe </function></funcdef>
   <paramdef>struct ieee80211_vif * <parameter>vif</parameter></paramdef>
   <paramdef>const u8 * <parameter>ra</parameter></paramdef>
   <paramdef>u16 <parameter>tid</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>vif</parameter></term>
   <listitem>
    <para>
     <structname>struct ieee80211_vif</structname> pointer from the add_interface callback
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>ra</parameter></term>
   <listitem>
    <para>
     receiver address of the BA session recipient.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>tid</parameter></term>
   <listitem>
    <para>
     the TID to BA on.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This function must be called by low level driver once it has
   finished with preparations for the BA session. It can be called
   from any context.
</para>
</refsect1>
</refentry>

<refentry id="API-ieee80211-stop-tx-ba-session">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ieee80211_stop_tx_ba_session</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ieee80211_stop_tx_ba_session</refname>
 <refpurpose>
  Stop a Block Ack session.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>ieee80211_stop_tx_ba_session </function></funcdef>
   <paramdef>struct ieee80211_sta * <parameter>sta</parameter></paramdef>
   <paramdef>u16 <parameter>tid</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>sta</parameter></term>
   <listitem>
    <para>
     the station whose BA session to stop
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>tid</parameter></term>
   <listitem>
    <para>
     the TID to stop BA.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Return</title>
<para>
   negative error if the TID is invalid, or no aggregation active
   </para><para>

   Although mac80211/low level driver/user space application can estimate
   the need to stop aggregation on a certain RA/TID, the session level
   will be managed by the mac80211.
</para>
</refsect1>
</refentry>

<refentry id="API-ieee80211-stop-tx-ba-cb-irqsafe">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ieee80211_stop_tx_ba_cb_irqsafe</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ieee80211_stop_tx_ba_cb_irqsafe</refname>
 <refpurpose>
  low level driver ready to stop aggregate.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>ieee80211_stop_tx_ba_cb_irqsafe </function></funcdef>
   <paramdef>struct ieee80211_vif * <parameter>vif</parameter></paramdef>
   <paramdef>const u8 * <parameter>ra</parameter></paramdef>
   <paramdef>u16 <parameter>tid</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>vif</parameter></term>
   <listitem>
    <para>
     <structname>struct ieee80211_vif</structname> pointer from the add_interface callback
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>ra</parameter></term>
   <listitem>
    <para>
     receiver address of the BA session recipient.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>tid</parameter></term>
   <listitem>
    <para>
     the desired TID to BA on.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This function must be called by low level driver once it has
   finished with preparations for the BA session tear down. It
   can be called from any context.
</para>
</refsect1>
</refentry>

<refentry id="API-enum-ieee80211-rate-control-changed">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>enum ieee80211_rate_control_changed</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>enum ieee80211_rate_control_changed</refname>
 <refpurpose>
  flags to indicate what changed
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
enum ieee80211_rate_control_changed {
  IEEE80211_RC_BW_CHANGED,
  IEEE80211_RC_SMPS_CHANGED,
  IEEE80211_RC_SUPP_RATES_CHANGED,
  IEEE80211_RC_NSS_CHANGED
};  </programlisting>
</refsynopsisdiv>
<refsect1>
 <title>Constants</title>
  <variablelist>
    <varlistentry>      <term>IEEE80211_RC_BW_CHANGED</term>
      <listitem><para>
The bandwidth that can be used to transmit
to this station changed. The actual bandwidth is in the station
information -- for HT20/40 the IEEE80211_HT_CAP_SUP_WIDTH_20_40
flag changes, for HT and VHT the bandwidth field changes.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>IEEE80211_RC_SMPS_CHANGED</term>
      <listitem><para>
The SMPS state of the station changed.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>IEEE80211_RC_SUPP_RATES_CHANGED</term>
      <listitem><para>
The supported rate set of this peer
changed (in IBSS mode) due to discovering more information about
the peer.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>IEEE80211_RC_NSS_CHANGED</term>
      <listitem><para>
N_SS (number of spatial streams) was changed
by the peer
      </para></listitem>
    </varlistentry>
  </variablelist>
</refsect1>
</refentry>

<refentry id="API-struct-ieee80211-tx-rate-control">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct ieee80211_tx_rate_control</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct ieee80211_tx_rate_control</refname>
 <refpurpose>
  rate control information for/from RC algo
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct ieee80211_tx_rate_control {
  struct ieee80211_hw * hw;
  struct ieee80211_supported_band * sband;
  struct ieee80211_bss_conf * bss_conf;
  struct sk_buff * skb;
  struct ieee80211_tx_rate reported_rate;
  bool rts;
  bool short_preamble;
  u8 max_rate_idx;
  u32 rate_idx_mask;
  u8 * rate_idx_mcs_mask;
  bool bss;
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>hw</term>
      <listitem><para>
The hardware the algorithm is invoked for.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>sband</term>
      <listitem><para>
The band this frame is being transmitted on.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>bss_conf</term>
      <listitem><para>
the current BSS configuration
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>skb</term>
      <listitem><para>
the skb that will be transmitted, the control information in it needs
to be filled in
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>reported_rate</term>
      <listitem><para>
The rate control algorithm can fill this in to indicate
which rate should be reported to userspace as the current rate and
used for rate calculations in the mesh network.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>rts</term>
      <listitem><para>
whether RTS will be used for this frame because it is longer than the
RTS threshold
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>short_preamble</term>
      <listitem><para>
whether mac80211 will request short-preamble transmission
if the selected rate supports it
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>max_rate_idx</term>
      <listitem><para>
user-requested maximum (legacy) rate
(deprecated; this will be removed once drivers get updated to use
rate_idx_mask)
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>rate_idx_mask</term>
      <listitem><para>
user-requested (legacy) rate mask
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>rate_idx_mcs_mask</term>
      <listitem><para>
user-requested MCS rate mask (NULL if not in use)
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>bss</term>
      <listitem><para>
whether this frame is sent out in AP or IBSS mode
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
</refentry>

<refentry id="API-rate-control-send-low">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>rate_control_send_low</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>rate_control_send_low</refname>
 <refpurpose>
  helper for drivers for management/no-ack frames
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>bool <function>rate_control_send_low </function></funcdef>
   <paramdef>struct ieee80211_sta * <parameter>sta</parameter></paramdef>
   <paramdef>void * <parameter>priv_sta</parameter></paramdef>
   <paramdef>struct ieee80211_tx_rate_control * <parameter>txrc</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>sta</parameter></term>
   <listitem>
    <para>
     <structname>struct ieee80211_sta</structname> pointer to the target destination. Note
     that this may be null.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>priv_sta</parameter></term>
   <listitem>
    <para>
     private rate control structure. This may be null.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>txrc</parameter></term>
   <listitem>
    <para>
     rate control information we sholud populate for mac80211.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   </para><para>

   Rate control algorithms that agree to use the lowest rate to
   send management frames and NO_ACK data with the respective hw
   retries should use this in the beginning of their mac80211 get_rate
   callback. If true is returned the rate control can simply return.
   If false is returned we guarantee that sta and sta and priv_sta is
   not null.
   </para><para>

   Rate control algorithms wishing to do more intelligent selection of
   rate for multicast/broadcast frames may choose to not use this.
</para>
</refsect1>
</refentry>

      </chapter>
    </part>

    <part id="internal">
      <title>Internals</title>
      <partintro>
        <para>TBD</para>
        <para>
         This part of the book describes mac80211 internals.
        </para>
      </partintro>

      <chapter id="key-handling">
        <title>Key handling</title>
        <sect1>
          <title>Key handling basics</title>
<para>
   </para><para>
   Key handling in mac80211 is done based on per-interface (sub_if_data)
   keys and per-station keys. Since each station belongs to an interface,
   each station key also belongs to that interface.
   </para><para>
   Hardware acceleration is done on a best-effort basis for algorithms
   that are implemented in software,  for each key the hardware is asked
   to enable that key for offloading but if it cannot do that the key is
   simply kept for software encryption (unless it is for an algorithm
   that isn't implemented in software).
   There is currently no way of knowing whether a key is handled in SW
   or HW except by looking into debugfs.
   </para><para>
   All key management is internally protected by a mutex. Within all
   other parts of mac80211, key references are, just as STA structure
   references, protected by RCU. Note, however, that some things are
   unprotected, namely the key-&gt;sta dereferences within the hardware
   acceleration functions. This means that <function>sta_info_destroy</function> must
   remove the key which waits for an RCU grace period.
</para>

        </sect1>
        <sect1>
          <title>MORE TBD</title>
          <para>TBD</para>
        </sect1>
      </chapter>

      <chapter id="rx-processing">
        <title>Receive processing</title>
        <para>TBD</para>
      </chapter>

      <chapter id="tx-processing">
        <title>Transmit processing</title>
        <para>TBD</para>
      </chapter>

      <chapter id="sta-info">
        <title>Station info handling</title>
        <sect1>
          <title>Programming information</title>
<refentry id="API-struct-sta-info">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct sta_info</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct sta_info</refname>
 <refpurpose>
  STA information
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct sta_info {
  struct list_head list;
  struct list_head free_list;
  struct rcu_head rcu_head;
  struct sta_info __rcu * hnext;
  struct ieee80211_local * local;
  struct ieee80211_sub_if_data * sdata;
  struct ieee80211_key __rcu * gtk[NUM_DEFAULT_KEYS + NUM_DEFAULT_MGMT_KEYS];
  struct ieee80211_key __rcu * ptk[NUM_DEFAULT_KEYS];
  u8 gtk_idx;
  u8 ptk_idx;
  struct rate_control_ref * rate_ctrl;
  void * rate_ctrl_priv;
  spinlock_t lock;
  struct work_struct drv_deliver_wk;
  u16 listen_interval;
  bool dead;
  bool uploaded;
  enum ieee80211_sta_state sta_state;
  unsigned long _flags;
  spinlock_t ps_lock;
  struct sk_buff_head ps_tx_buf[IEEE80211_NUM_ACS];
  struct sk_buff_head tx_filtered[IEEE80211_NUM_ACS];
  unsigned long driver_buffered_tids;
  unsigned long rx_packets;
  u64 rx_bytes;
  unsigned long last_rx;
  long last_connected;
  unsigned long num_duplicates;
  unsigned long rx_fragments;
  unsigned long rx_dropped;
  int last_signal;
  struct ewma avg_signal;
  int last_ack_signal;
  u8 chains;
  s8 chain_signal_last[IEEE80211_MAX_CHAINS];
  struct ewma chain_signal_avg[IEEE80211_MAX_CHAINS];
  __le16 last_seq_ctrl[IEEE80211_NUM_TIDS + 1];
  unsigned long tx_filtered_count;
  unsigned long tx_retry_failed;
  unsigned long tx_retry_count;
  unsigned int fail_avg;
  u32 tx_fragments;
  u64 tx_packets[IEEE80211_NUM_ACS];
  u64 tx_bytes[IEEE80211_NUM_ACS];
  struct ieee80211_tx_rate last_tx_rate;
  int last_rx_rate_idx;
  u32 last_rx_rate_flag;
  u32 last_rx_rate_vht_flag;
  u8 last_rx_rate_vht_nss;
  u16 tid_seq[IEEE80211_QOS_CTL_TID_MASK + 1];
  struct sta_ampdu_mlme ampdu_mlme;
  u8 timer_to_tid[IEEE80211_NUM_TIDS];
  struct ieee80211_tx_latency_stat * tx_lat;
#ifdef CONFIG_MAC80211_MESH
  u16 llid;
  u16 plid;
  u16 reason;
  u8 plink_retries;
  enum nl80211_plink_state plink_state;
  u32 plink_timeout;
  struct timer_list plink_timer;
  s64 t_offset;
  s64 t_offset_setpoint;
  enum nl80211_mesh_power_mode local_pm;
  enum nl80211_mesh_power_mode peer_pm;
  enum nl80211_mesh_power_mode nonpeer_pm;
#endif
#ifdef CONFIG_MAC80211_DEBUGFS
  struct sta_info_debugfsdentries debugfs;
#endif
  enum ieee80211_sta_rx_bandwidth cur_max_bandwidth;
  unsigned int lost_packets;
  unsigned int beacon_loss_count;
  enum ieee80211_smps_mode known_smps_mode;
  const struct ieee80211_cipher_scheme * cipher_scheme;
  unsigned long last_tdls_pkt_time;
  struct ieee80211_sta sta;
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>list</term>
      <listitem><para>
global linked list entry
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>free_list</term>
      <listitem><para>
list entry for keeping track of stations to free
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>rcu_head</term>
      <listitem><para>
RCU head used for freeing this station struct
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>hnext</term>
      <listitem><para>
hash table linked list pointer
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>local</term>
      <listitem><para>
pointer to the global information
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>sdata</term>
      <listitem><para>
virtual interface this station belongs to
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>gtk[NUM_DEFAULT_KEYS + NUM_DEFAULT_MGMT_KEYS]</term>
      <listitem><para>
group keys negotiated with this station, if any
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>ptk[NUM_DEFAULT_KEYS]</term>
      <listitem><para>
peer keys negotiated with this station, if any
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>gtk_idx</term>
      <listitem><para>
last installed group key index
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>ptk_idx</term>
      <listitem><para>
last installed peer key index
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>rate_ctrl</term>
      <listitem><para>
rate control algorithm reference
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>rate_ctrl_priv</term>
      <listitem><para>
rate control private per-STA pointer
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>lock</term>
      <listitem><para>
used for locking all fields that require locking, see comments
in the header file.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>drv_deliver_wk</term>
      <listitem><para>
used for delivering frames after driver PS unblocking
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>listen_interval</term>
      <listitem><para>
listen interval of this station, when we're acting as AP
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>dead</term>
      <listitem><para>
set to true when sta is unlinked
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>uploaded</term>
      <listitem><para>
set to true when sta is uploaded to the driver
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>sta_state</term>
      <listitem><para>
duplicates information about station state (for debug)
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>_flags</term>
      <listitem><para>
STA flags, see <structname>enum</structname> ieee80211_sta_info_flags, do not use directly
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>ps_lock</term>
      <listitem><para>
used for powersave (when mac80211 is the AP) related locking
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>ps_tx_buf[IEEE80211_NUM_ACS]</term>
      <listitem><para>
buffers (per AC) of frames to transmit to this station
when it leaves power saving state or polls
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>tx_filtered[IEEE80211_NUM_ACS]</term>
      <listitem><para>
buffers (per AC) of frames we already tried to
transmit but were filtered by hardware due to STA having
entered power saving state, these are also delivered to
the station when it leaves powersave or polls for frames
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>driver_buffered_tids</term>
      <listitem><para>
bitmap of TIDs the driver has data buffered on
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>rx_packets</term>
      <listitem><para>
Number of MSDUs received from this STA
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>rx_bytes</term>
      <listitem><para>
Number of bytes received from this STA
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>last_rx</term>
      <listitem><para>
time (in jiffies) when last frame was received from this STA
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>last_connected</term>
      <listitem><para>
time (in seconds) when a station got connected
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>num_duplicates</term>
      <listitem><para>
number of duplicate frames received from this STA
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>rx_fragments</term>
      <listitem><para>
number of received MPDUs
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>rx_dropped</term>
      <listitem><para>
number of dropped MPDUs from this STA
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>last_signal</term>
      <listitem><para>
signal of last received frame from this STA
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>avg_signal</term>
      <listitem><para>
moving average of signal of received frames from this STA
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>last_ack_signal</term>
      <listitem><para>
signal of last received Ack frame from this STA
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>chains</term>
      <listitem><para>
chains ever used for RX from this station
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>chain_signal_last[IEEE80211_MAX_CHAINS]</term>
      <listitem><para>
last signal (per chain)
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>chain_signal_avg[IEEE80211_MAX_CHAINS]</term>
      <listitem><para>
signal average (per chain)
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>last_seq_ctrl[IEEE80211_NUM_TIDS + 1]</term>
      <listitem><para>
last received seq/frag number from this STA (per RX queue)
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>tx_filtered_count</term>
      <listitem><para>
number of frames the hardware filtered for this STA
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>tx_retry_failed</term>
      <listitem><para>
number of frames that failed retry
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>tx_retry_count</term>
      <listitem><para>
total number of retries for frames to this STA
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>fail_avg</term>
      <listitem><para>
moving percentage of failed MSDUs
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>tx_fragments</term>
      <listitem><para>
number of transmitted MPDUs
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>tx_packets[IEEE80211_NUM_ACS]</term>
      <listitem><para>
number of RX/TX MSDUs
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>tx_bytes[IEEE80211_NUM_ACS]</term>
      <listitem><para>
number of bytes transmitted to this STA
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>last_tx_rate</term>
      <listitem><para>
rate used for last transmit, to report to userspace as
<quote>the</quote> transmit rate
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>last_rx_rate_idx</term>
      <listitem><para>
rx status rate index of the last data packet
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>last_rx_rate_flag</term>
      <listitem><para>
rx status flag of the last data packet
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>last_rx_rate_vht_flag</term>
      <listitem><para>
rx status vht flag of the last data packet
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>last_rx_rate_vht_nss</term>
      <listitem><para>
rx status nss of last data packet
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>tid_seq[IEEE80211_QOS_CTL_TID_MASK + 1]</term>
      <listitem><para>
per-TID sequence numbers for sending to this STA
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>ampdu_mlme</term>
      <listitem><para>
A-MPDU state machine state
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>timer_to_tid[IEEE80211_NUM_TIDS]</term>
      <listitem><para>
identity mapping to ID timers
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>tx_lat</term>
      <listitem><para>
Tx latency statistics
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>llid</term>
      <listitem><para>
Local link ID
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>plid</term>
      <listitem><para>
Peer link ID
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>reason</term>
      <listitem><para>
Cancel reason on PLINK_HOLDING state
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>plink_retries</term>
      <listitem><para>
Retries in establishment
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>plink_state</term>
      <listitem><para>
peer link state
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>plink_timeout</term>
      <listitem><para>
timeout of peer link
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>plink_timer</term>
      <listitem><para>
peer link watch timer
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>t_offset</term>
      <listitem><para>
timing offset relative to this host
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>t_offset_setpoint</term>
      <listitem><para>
reference timing offset of this sta to be used when
calculating clockdrift
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>local_pm</term>
      <listitem><para>
local link-specific power save mode
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>peer_pm</term>
      <listitem><para>
peer-specific power save mode towards local STA
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>nonpeer_pm</term>
      <listitem><para>
STA power save mode towards non-peer neighbors
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>debugfs</term>
      <listitem><para>
debug filesystem info
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>cur_max_bandwidth</term>
      <listitem><para>
maximum bandwidth to use for TX to the station,
taken from HT/VHT capabilities or VHT operating mode notification
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>lost_packets</term>
      <listitem><para>
number of consecutive lost packets
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>beacon_loss_count</term>
      <listitem><para>
number of times beacon loss has triggered
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>known_smps_mode</term>
      <listitem><para>
the smps_mode the client thinks we are in. Relevant for
AP only.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>cipher_scheme</term>
      <listitem><para>
optional cipher scheme for this station
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>last_tdls_pkt_time</term>
      <listitem><para>
holds the time in jiffies of last TDLS pkt ACKed
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>sta</term>
      <listitem><para>
station information we share with the driver
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
<refsect1>
<title>Description</title>
<para>
   </para><para>

   This structure collects information about a station that
   mac80211 is communicating with.
</para>
</refsect1>
</refentry>

<refentry id="API-enum-ieee80211-sta-info-flags">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>enum ieee80211_sta_info_flags</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>enum ieee80211_sta_info_flags</refname>
 <refpurpose>
  Stations flags
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
enum ieee80211_sta_info_flags {
  WLAN_STA_AUTH,
  WLAN_STA_ASSOC,
  WLAN_STA_PS_STA,
  WLAN_STA_AUTHORIZED,
  WLAN_STA_SHORT_PREAMBLE,
  WLAN_STA_WDS,
  WLAN_STA_CLEAR_PS_FILT,
  WLAN_STA_MFP,
  WLAN_STA_BLOCK_BA,
  WLAN_STA_PS_DRIVER,
  WLAN_STA_PSPOLL,
  WLAN_STA_TDLS_PEER,
  WLAN_STA_TDLS_PEER_AUTH,
  WLAN_STA_TDLS_INITIATOR,
  WLAN_STA_UAPSD,
  WLAN_STA_SP,
  WLAN_STA_4ADDR_EVENT,
  WLAN_STA_INSERTED,
  WLAN_STA_RATE_CONTROL,
  WLAN_STA_TOFFSET_KNOWN,
  WLAN_STA_MPSP_OWNER,
  WLAN_STA_MPSP_RECIPIENT,
  WLAN_STA_PS_DELIVER
};  </programlisting>
</refsynopsisdiv>
<refsect1>
 <title>Constants</title>
  <variablelist>
    <varlistentry>      <term>WLAN_STA_AUTH</term>
      <listitem><para>
Station is authenticated.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>WLAN_STA_ASSOC</term>
      <listitem><para>
Station is associated.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>WLAN_STA_PS_STA</term>
      <listitem><para>
Station is in power-save mode
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>WLAN_STA_AUTHORIZED</term>
      <listitem><para>
Station is authorized to send/receive traffic.
This bit is always checked so needs to be enabled for all stations
when virtual port control is not in use.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>WLAN_STA_SHORT_PREAMBLE</term>
      <listitem><para>
Station is capable of receiving short-preamble
frames.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>WLAN_STA_WDS</term>
      <listitem><para>
Station is one of our WDS peers.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>WLAN_STA_CLEAR_PS_FILT</term>
      <listitem><para>
Clear PS filter in hardware (using the
IEEE80211_TX_CTL_CLEAR_PS_FILT control flag) when the next
frame to this station is transmitted.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>WLAN_STA_MFP</term>
      <listitem><para>
Management frame protection is used with this STA.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>WLAN_STA_BLOCK_BA</term>
      <listitem><para>
Used to deny ADDBA requests (both TX and RX)
during suspend/resume and station removal.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>WLAN_STA_PS_DRIVER</term>
      <listitem><para>
driver requires keeping this station in
power-save mode logically to flush frames that might still
be in the queues
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>WLAN_STA_PSPOLL</term>
      <listitem><para>
Station sent PS-poll while driver was keeping
station in power-save mode, reply when the driver unblocks.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>WLAN_STA_TDLS_PEER</term>
      <listitem><para>
Station is a TDLS peer.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>WLAN_STA_TDLS_PEER_AUTH</term>
      <listitem><para>
This TDLS peer is authorized to send direct
packets. This means the link is enabled.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>WLAN_STA_TDLS_INITIATOR</term>
      <listitem><para>
We are the initiator of the TDLS link with this
station.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>WLAN_STA_UAPSD</term>
      <listitem><para>
Station requested unscheduled SP while driver was
keeping station in power-save mode, reply when the driver
unblocks the station.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>WLAN_STA_SP</term>
      <listitem><para>
Station is in a service period, so don't try to
reply to other uAPSD trigger frames or PS-Poll.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>WLAN_STA_4ADDR_EVENT</term>
      <listitem><para>
4-addr event was already sent for this frame.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>WLAN_STA_INSERTED</term>
      <listitem><para>
This station is inserted into the hash table.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>WLAN_STA_RATE_CONTROL</term>
      <listitem><para>
rate control was initialized for this station.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>WLAN_STA_TOFFSET_KNOWN</term>
      <listitem><para>
toffset calculated for this station is valid.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>WLAN_STA_MPSP_OWNER</term>
      <listitem><para>
local STA is owner of a mesh Peer Service Period.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>WLAN_STA_MPSP_RECIPIENT</term>
      <listitem><para>
local STA is recipient of a MPSP.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>WLAN_STA_PS_DELIVER</term>
      <listitem><para>
station woke up, but we're still blocking TX
until pending frames are delivered
      </para></listitem>
    </varlistentry>
  </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   </para><para>

   These flags are used with <structname>struct sta_info</structname>'s <parameter>flags</parameter> member, but
   only indirectly with <function>set_sta_flag</function> and friends.
</para>
</refsect1>
</refentry>

        </sect1>
        <sect1>
          <title>STA information lifetime rules</title>
<para>
   </para><para>
   STA info structures (<structname>struct sta_info</structname>) are managed in a hash table
   for faster lookup and a list for iteration. They are managed using
   RCU, i.e. access to the list and hash table is protected by RCU.
   </para><para>
   Upon allocating a STA info structure with <function>sta_info_alloc</function>, the caller
   owns that structure. It must then insert it into the hash table using
   either <function>sta_info_insert</function> or <function>sta_info_insert_rcu</function>; only in the latter
   case (which acquires an rcu read section but must not be called from
   within one) will the pointer still be valid after the call. Note that
   the caller may not do much with the STA info before inserting it, in
   particular, it may not start any mesh peer link management or add
   encryption keys.
   </para><para>
   When the insertion fails (<function>sta_info_insert</function>) returns non-zero), the
   structure will have been freed by <function>sta_info_insert</function>!
   </para><para>
   Station entries are added by mac80211 when you establish a link with a
   peer. This means different things for the different type of interfaces
   we support. For a regular station this mean we add the AP sta when we
   receive an association response from the AP. For IBSS this occurs when
   get to know about a peer on the same IBSS. For WDS we add the sta for
   the peer immediately upon device open. When using AP mode we add stations
   for each respective station upon request from userspace through nl80211.
   </para><para>
   In order to remove a STA info structure, various sta_info_destroy_*()
   calls are available.
   </para><para>
   There is no concept of ownership on a STA entry, each structure is
   owned by the global hash table/list until it is removed. All users of
   the structure need to be RCU protected so that the structure won't be
   freed before they are done using it.
</para>

        </sect1>
      </chapter>

      <chapter id="aggregation-internals">
        <title>Aggregation</title>
<refentry id="API-struct-sta-ampdu-mlme">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct sta_ampdu_mlme</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct sta_ampdu_mlme</refname>
 <refpurpose>
  STA aggregation information.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct sta_ampdu_mlme {
  struct mutex mtx;
  struct tid_ampdu_rx __rcu * tid_rx[IEEE80211_NUM_TIDS];
  unsigned long tid_rx_timer_expired[BITS_TO_LONGS(IEEE80211_NUM_TIDS)];
  unsigned long tid_rx_stop_requested[BITS_TO_LONGS(IEEE80211_NUM_TIDS)];
  struct work_struct work;
  struct tid_ampdu_tx __rcu * tid_tx[IEEE80211_NUM_TIDS];
  struct tid_ampdu_tx * tid_start_tx[IEEE80211_NUM_TIDS];
  unsigned long last_addba_req_time[IEEE80211_NUM_TIDS];
  u8 addba_req_num[IEEE80211_NUM_TIDS];
  u8 dialog_token_allocator;
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>mtx</term>
      <listitem><para>
mutex to protect all TX data (except non-NULL assignments
to tid_tx[idx], which are protected by the sta spinlock)
tid_start_tx is also protected by sta-&gt;lock.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>tid_rx[IEEE80211_NUM_TIDS]</term>
      <listitem><para>
aggregation info for Rx per TID -- RCU protected
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>tid_rx_timer_expired[BITS_TO_LONGS(IEEE80211_NUM_TIDS)]</term>
      <listitem><para>
bitmap indicating on which TIDs the
RX timer expired until the work for it runs
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>tid_rx_stop_requested[BITS_TO_LONGS(IEEE80211_NUM_TIDS)]</term>
      <listitem><para>
bitmap indicating which BA sessions per TID the
driver requested to close until the work for it runs
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>work</term>
      <listitem><para>
work struct for starting/stopping aggregation
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>tid_tx[IEEE80211_NUM_TIDS]</term>
      <listitem><para>
aggregation info for Tx per TID
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>tid_start_tx[IEEE80211_NUM_TIDS]</term>
      <listitem><para>
sessions where start was requested
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>last_addba_req_time[IEEE80211_NUM_TIDS]</term>
      <listitem><para>
timestamp of the last addBA request.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>addba_req_num[IEEE80211_NUM_TIDS]</term>
      <listitem><para>
number of times addBA request has been sent.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>dialog_token_allocator</term>
      <listitem><para>
dialog token enumerator for each new session;
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
</refentry>

<refentry id="API-struct-tid-ampdu-tx">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct tid_ampdu_tx</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct tid_ampdu_tx</refname>
 <refpurpose>
  TID aggregation information (Tx).
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct tid_ampdu_tx {
  struct rcu_head rcu_head;
  struct timer_list session_timer;
  struct timer_list addba_resp_timer;
  struct sk_buff_head pending;
  unsigned long state;
  unsigned long last_tx;
  u16 timeout;
  u8 dialog_token;
  u8 stop_initiator;
  bool tx_stop;
  u8 buf_size;
  u16 failed_bar_ssn;
  bool bar_pending;
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>rcu_head</term>
      <listitem><para>
rcu head for freeing structure
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>session_timer</term>
      <listitem><para>
check if we keep Tx-ing on the TID (by timeout value)
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>addba_resp_timer</term>
      <listitem><para>
timer for peer's response to addba request
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>pending</term>
      <listitem><para>
pending frames queue -- use sta's spinlock to protect
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>state</term>
      <listitem><para>
session state (see above)
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>last_tx</term>
      <listitem><para>
jiffies of last tx activity
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>timeout</term>
      <listitem><para>
session timeout value to be filled in ADDBA requests
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>dialog_token</term>
      <listitem><para>
dialog token for aggregation session
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>stop_initiator</term>
      <listitem><para>
initiator of a session stop
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>tx_stop</term>
      <listitem><para>
TX DelBA frame when stopping
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>buf_size</term>
      <listitem><para>
reorder buffer size at receiver
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>failed_bar_ssn</term>
      <listitem><para>
ssn of the last failed BAR tx attempt
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>bar_pending</term>
      <listitem><para>
BAR needs to be re-sent
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
<refsect1>
<title>Description</title>
<para>
   This structure's lifetime is managed by RCU, assignments to
   the array holding it must hold the aggregation mutex.
   </para><para>

   The TX path can access it under RCU lock-free if, and
   only if, the state has the flag <constant>HT_AGG_STATE_OPERATIONAL</constant>
   set. Otherwise, the TX path must also acquire the spinlock
   and re-check the state, see comments in the tx code
   touching it.
</para>
</refsect1>
</refentry>

<refentry id="API-struct-tid-ampdu-rx">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct tid_ampdu_rx</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct tid_ampdu_rx</refname>
 <refpurpose>
  TID aggregation information (Rx).
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct tid_ampdu_rx {
  struct rcu_head rcu_head;
  spinlock_t reorder_lock;
  struct sk_buff_head * reorder_buf;
  unsigned long * reorder_time;
  struct timer_list session_timer;
  struct timer_list reorder_timer;
  unsigned long last_rx;
  u16 head_seq_num;
  u16 stored_mpdu_num;
  u16 ssn;
  u16 buf_size;
  u16 timeout;
  u8 dialog_token;
  bool auto_seq;
  bool removed;
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>rcu_head</term>
      <listitem><para>
RCU head used for freeing this struct
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>reorder_lock</term>
      <listitem><para>
serializes access to reorder buffer, see below.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>reorder_buf</term>
      <listitem><para>
buffer to reorder incoming aggregated MPDUs. An MPDU may be an
A-MSDU with individually reported subframes.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>reorder_time</term>
      <listitem><para>
jiffies when skb was added
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>session_timer</term>
      <listitem><para>
check if peer keeps Tx-ing on the TID (by timeout value)
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>reorder_timer</term>
      <listitem><para>
releases expired frames from the reorder buffer.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>last_rx</term>
      <listitem><para>
jiffies of last rx activity
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>head_seq_num</term>
      <listitem><para>
head sequence number in reordering buffer.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>stored_mpdu_num</term>
      <listitem><para>
number of MPDUs in reordering buffer
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>ssn</term>
      <listitem><para>
Starting Sequence Number expected to be aggregated.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>buf_size</term>
      <listitem><para>
buffer size for incoming A-MPDUs
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>timeout</term>
      <listitem><para>
reset timer value (in TUs).
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>dialog_token</term>
      <listitem><para>
dialog token for aggregation session
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>auto_seq</term>
      <listitem><para>
used for offloaded BA sessions to automatically pick head_seq_and
and ssn.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>removed</term>
      <listitem><para>
this session is removed (but might have been found due to RCU)
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
<refsect1>
<title>Description</title>
<para>
   This structure's lifetime is managed by RCU, assignments to
   the array holding it must hold the aggregation mutex.
   </para><para>

   The <parameter>reorder_lock</parameter> is used to protect the members of this
   struct, except for <parameter>timeout</parameter>, <parameter>buf_size</parameter> and <parameter>dialog_token</parameter>,
   which are constant across the lifetime of the struct (the
   dialog token being used only for debugging).
</para>
</refsect1>
</refentry>

      </chapter>

      <chapter id="synchronisation">
        <title>Synchronisation</title>
        <para>TBD</para>
        <para>Locking, lots of RCU</para>
      </chapter>
    </part>
  </book>
</set>
