<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>struct nand_chip</title><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot"><link rel="home" href="index.html" title="MTD NAND Driver Programming Interface"><link rel="up" href="structs.html" title="Chapter 9. Structures"><link rel="prev" href="API-struct-nand-buffers.html" title="struct nand_buffers"><link rel="next" href="API-struct-nand-flash-dev.html" title="struct nand_flash_dev"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center"><span class="phrase">struct nand_chip</span></th></tr><tr><td width="20%" align="left"><a accesskey="p" href="API-struct-nand-buffers.html">Prev</a> </td><th width="60%" align="center">Chapter 9. Structures</th><td width="20%" align="right"> <a accesskey="n" href="API-struct-nand-flash-dev.html">Next</a></td></tr></table><hr></div><div class="refentry"><a name="API-struct-nand-chip"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>struct nand_chip — 
     NAND Private Flash Chip Data
 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><pre class="programlisting">
struct nand_chip {
  void __iomem * IO_ADDR_R;
  void __iomem * IO_ADDR_W;
  uint8_t (* read_byte) (struct mtd_info *mtd);
  u16 (* read_word) (struct mtd_info *mtd);
  void (* write_byte) (struct mtd_info *mtd, uint8_t byte);
  void (* write_buf) (struct mtd_info *mtd, const uint8_t *buf, int len);
  void (* read_buf) (struct mtd_info *mtd, uint8_t *buf, int len);
  void (* select_chip) (struct mtd_info *mtd, int chip);
  int (* block_bad) (struct mtd_info *mtd, loff_t ofs, int getchip);
  int (* block_markbad) (struct mtd_info *mtd, loff_t ofs);
  void (* cmd_ctrl) (struct mtd_info *mtd, int dat, unsigned int ctrl);
  int (* init_size) (struct mtd_info *mtd, struct nand_chip *this,u8 *id_data);
  int (* dev_ready) (struct mtd_info *mtd);
  void (* cmdfunc) (struct mtd_info *mtd, unsigned command, int column,int page_addr);
  int(* waitfunc) (struct mtd_info *mtd, struct nand_chip *this);
  int (* erase) (struct mtd_info *mtd, int page);
  int (* scan_bbt) (struct mtd_info *mtd);
  int (* errstat) (struct mtd_info *mtd, struct nand_chip *this, int state,int status, int page);
  int (* write_page) (struct mtd_info *mtd, struct nand_chip *chip,uint32_t offset, int data_len, const uint8_t *buf,int oob_required, int page, int cached, int raw);
  int (* onfi_set_features) (struct mtd_info *mtd, struct nand_chip *chip,int feature_addr, uint8_t *subfeature_para);
  int (* onfi_get_features) (struct mtd_info *mtd, struct nand_chip *chip,int feature_addr, uint8_t *subfeature_para);
  int (* setup_read_retry) (struct mtd_info *mtd, int retry_mode);
  int chip_delay;
  unsigned int options;
  unsigned int bbt_options;
  int page_shift;
  int phys_erase_shift;
  int bbt_erase_shift;
  int chip_shift;
  int numchips;
  uint64_t chipsize;
  int pagemask;
  int pagebuf;
  unsigned int pagebuf_bitflips;
  int subpagesize;
  uint8_t bits_per_cell;
  uint16_t ecc_strength_ds;
  uint16_t ecc_step_ds;
  int onfi_timing_mode_default;
  int badblockpos;
  int badblockbits;
  int onfi_version;
  int jedec_version;
  union {unnamed_union};
  int read_retries;
  flstate_t state;
  uint8_t * oob_poi;
  struct nand_hw_control * controller;
  struct nand_ecc_ctrl ecc;
  struct nand_buffers * buffers;
  struct nand_hw_control hwcontrol;
  uint8_t * bbt;
  struct nand_bbt_descr * bbt_td;
  struct nand_bbt_descr * bbt_md;
  struct nand_bbt_descr * badblock_pattern;
  void * priv;
};  </pre></div><div class="refsect1"><a name="idm694"></a><h2>Members</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term">IO_ADDR_R</span></dt><dd><p>
   [BOARDSPECIFIC] address to read the 8 I/O lines of the
   flash device
      </p></dd><dt><span class="term">IO_ADDR_W</span></dt><dd><p>
   [BOARDSPECIFIC] address to write the 8 I/O lines of the
   flash device.
      </p></dd><dt><span class="term">read_byte</span></dt><dd><p>
   [REPLACEABLE] read one byte from the chip
      </p></dd><dt><span class="term">read_word</span></dt><dd><p>
   [REPLACEABLE] read one word from the chip
      </p></dd><dt><span class="term">write_byte</span></dt><dd><p>
   [REPLACEABLE] write a single byte to the chip on the
   low 8 I/O lines
      </p></dd><dt><span class="term">write_buf</span></dt><dd><p>
   [REPLACEABLE] write data from the buffer to the chip
      </p></dd><dt><span class="term">read_buf</span></dt><dd><p>
   [REPLACEABLE] read data from the chip into the buffer
      </p></dd><dt><span class="term">select_chip</span></dt><dd><p>
   [REPLACEABLE] select chip nr
      </p></dd><dt><span class="term">block_bad</span></dt><dd><p>
   [REPLACEABLE] check if a block is bad, using OOB markers
      </p></dd><dt><span class="term">block_markbad</span></dt><dd><p>
   [REPLACEABLE] mark a block bad
      </p></dd><dt><span class="term">cmd_ctrl</span></dt><dd><p>
   [BOARDSPECIFIC] hardwarespecific function for controlling
   ALE/CLE/nCE. Also used to write command and address
      </p></dd><dt><span class="term">init_size</span></dt><dd><p>
   [BOARDSPECIFIC] hardwarespecific function for setting
   mtd-&gt;oobsize, mtd-&gt;writesize and so on.
   <em class="parameter"><code>id_data</code></em> contains the 8 bytes values of NAND_CMD_READID.
   Return with the bus width.
      </p></dd><dt><span class="term">dev_ready</span></dt><dd><p>
   [BOARDSPECIFIC] hardwarespecific function for accessing
   device ready/busy line. If set to NULL no access to
   ready/busy is available and the ready/busy information
   is read from the chip status register.
      </p></dd><dt><span class="term">cmdfunc</span></dt><dd><p>
   [REPLACEABLE] hardwarespecific function for writing
   commands to the chip.
      </p></dd><dt><span class="term">waitfunc</span></dt><dd><p>
   [REPLACEABLE] hardwarespecific function for wait on
   ready.
      </p></dd><dt><span class="term">erase</span></dt><dd><p>
   [REPLACEABLE] erase function
      </p></dd><dt><span class="term">scan_bbt</span></dt><dd><p>
   [REPLACEABLE] function to scan bad block table
      </p></dd><dt><span class="term">errstat</span></dt><dd><p>
   [OPTIONAL] hardware specific function to perform
   additional error status checks (determine if errors are
   correctable).
      </p></dd><dt><span class="term">write_page</span></dt><dd><p>
   [REPLACEABLE] High-level page write function
      </p></dd><dt><span class="term">onfi_set_features</span></dt><dd><p>
   [REPLACEABLE] set the features for ONFI nand
      </p></dd><dt><span class="term">onfi_get_features</span></dt><dd><p>
   [REPLACEABLE] get the features for ONFI nand
      </p></dd><dt><span class="term">setup_read_retry</span></dt><dd><p>
   [FLASHSPECIFIC] flash (vendor) specific function for
   setting the read-retry mode. Mostly needed for MLC NAND.
      </p></dd><dt><span class="term">chip_delay</span></dt><dd><p>
   [BOARDSPECIFIC] chip dependent delay for transferring
   data from array to read regs (tR).
      </p></dd><dt><span class="term">options</span></dt><dd><p>
   [BOARDSPECIFIC] various chip options. They can partly
   be set to inform nand_scan about special functionality.
   See the defines for further explanation.
      </p></dd><dt><span class="term">bbt_options</span></dt><dd><p>
   [INTERN] bad block specific options. All options used
   here must come from bbm.h. By default, these options
   will be copied to the appropriate nand_bbt_descr's.
      </p></dd><dt><span class="term">page_shift</span></dt><dd><p>
   [INTERN] number of address bits in a page (column
   address bits).
      </p></dd><dt><span class="term">phys_erase_shift</span></dt><dd><p>
   [INTERN] number of address bits in a physical eraseblock
      </p></dd><dt><span class="term">bbt_erase_shift</span></dt><dd><p>
   [INTERN] number of address bits in a bbt entry
      </p></dd><dt><span class="term">chip_shift</span></dt><dd><p>
   [INTERN] number of address bits in one chip
      </p></dd><dt><span class="term">numchips</span></dt><dd><p>
   [INTERN] number of physical chips
      </p></dd><dt><span class="term">chipsize</span></dt><dd><p>
   [INTERN] the size of one chip for multichip arrays
      </p></dd><dt><span class="term">pagemask</span></dt><dd><p>
   [INTERN] page number mask = number of (pages / chip) - 1
      </p></dd><dt><span class="term">pagebuf</span></dt><dd><p>
   [INTERN] holds the pagenumber which is currently in
   data_buf.
      </p></dd><dt><span class="term">pagebuf_bitflips</span></dt><dd><p>
   [INTERN] holds the bitflip count for the page which is
   currently in data_buf.
      </p></dd><dt><span class="term">subpagesize</span></dt><dd><p>
   [INTERN] holds the subpagesize
      </p></dd><dt><span class="term">bits_per_cell</span></dt><dd><p>
   [INTERN] number of bits per cell. i.e., 1 means SLC.
      </p></dd><dt><span class="term">ecc_strength_ds</span></dt><dd><p>
   [INTERN] ECC correctability from the datasheet.
   Minimum amount of bit errors per <em class="parameter"><code>ecc_step_ds</code></em> guaranteed
   to be correctable. If unknown, set to zero.
      </p></dd><dt><span class="term">ecc_step_ds</span></dt><dd><p>
   [INTERN] ECC step required by the <em class="parameter"><code>ecc_strength_ds</code></em>,
   also from the datasheet. It is the recommended ECC step
   size, if known; if unknown, set to zero.
      </p></dd><dt><span class="term">onfi_timing_mode_default</span></dt><dd><p>
   [INTERN] default ONFI timing mode. This field is
   either deduced from the datasheet if the NAND
   chip is not ONFI compliant or set to 0 if it is
   (an ONFI chip is always configured in mode 0
   after a NAND reset)
      </p></dd><dt><span class="term">badblockpos</span></dt><dd><p>
   [INTERN] position of the bad block marker in the oob
   area.
      </p></dd><dt><span class="term">badblockbits</span></dt><dd><p>
   [INTERN] minimum number of set bits in a good block's
   bad block marker position; i.e., BBM == 11110111b is
   not bad when badblockbits == 7
      </p></dd><dt><span class="term">onfi_version</span></dt><dd><p>
   [INTERN] holds the chip ONFI version (BCD encoded),
   non 0 if ONFI supported.
      </p></dd><dt><span class="term">jedec_version</span></dt><dd><p>
   [INTERN] holds the chip JEDEC version (BCD encoded),
   non 0 if JEDEC supported.
      </p></dd><dt><span class="term">{unnamed_union}</span></dt><dd><p>
   anonymous
      </p></dd><dt><span class="term">read_retries</span></dt><dd><p>
   [INTERN] the number of read retry modes supported
      </p></dd><dt><span class="term">state</span></dt><dd><p>
   [INTERN] the current state of the NAND device
      </p></dd><dt><span class="term">oob_poi</span></dt><dd><p>
   "poison value buffer," used for laying out OOB data
   before writing
      </p></dd><dt><span class="term">controller</span></dt><dd><p>
   [REPLACEABLE] a pointer to a hardware controller
   structure which is shared among multiple independent
   devices.
      </p></dd><dt><span class="term">ecc</span></dt><dd><p>
   [BOARDSPECIFIC] ECC control structure
      </p></dd><dt><span class="term">buffers</span></dt><dd><p>
   buffer structure for read/write
      </p></dd><dt><span class="term">hwcontrol</span></dt><dd><p>
   platform-specific hardware control structure
      </p></dd><dt><span class="term">bbt</span></dt><dd><p>
   [INTERN] bad block table pointer
      </p></dd><dt><span class="term">bbt_td</span></dt><dd><p>
   [REPLACEABLE] bad block table descriptor for flash
   lookup.
      </p></dd><dt><span class="term">bbt_md</span></dt><dd><p>
   [REPLACEABLE] bad block table mirror descriptor
      </p></dd><dt><span class="term">badblock_pattern</span></dt><dd><p>
   [REPLACEABLE] bad block scan pattern used for initial
   bad block scan.
      </p></dd><dt><span class="term">priv</span></dt><dd><p>
   [OPTIONAL] pointer to private chip data
      </p></dd></dl></div></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="API-struct-nand-buffers.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="structs.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="API-struct-nand-flash-dev.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top"><span class="phrase">struct nand_buffers</span> </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> <span class="phrase">struct nand_flash_dev</span></td></tr></table></div></body></html>
