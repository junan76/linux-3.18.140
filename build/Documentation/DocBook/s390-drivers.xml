<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN"
	"http://www.oasis-open.org/docbook/xml/4.1.2/docbookx.dtd" []>

<book id="s390drivers">
 <bookinfo>
  <title>Writing s390 channel device drivers</title>

  <authorgroup>
   <author>
    <firstname>Cornelia</firstname>
    <surname>Huck</surname>
    <affiliation>
     <address>
       <email>cornelia.huck@de.ibm.com</email>
     </address>
    </affiliation>
   </author>
  </authorgroup>

  <copyright>
   <year>2007</year>
   <holder>IBM Corp.</holder>
  </copyright>

  <legalnotice>
   <para>
     This documentation is free software; you can redistribute
     it and/or modify it under the terms of the GNU General Public
     License as published by the Free Software Foundation; either
     version 2 of the License, or (at your option) any later
     version.
   </para>

   <para>
     This program is distributed in the hope that it will be
     useful, but WITHOUT ANY WARRANTY; without even the implied
     warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
     See the GNU General Public License for more details.
   </para>

   <para>
     You should have received a copy of the GNU General Public
     License along with this program; if not, write to the Free
     Software Foundation, Inc., 59 Temple Place, Suite 330, Boston,
     MA 02111-1307 USA
   </para>

   <para>
     For more details see the file COPYING in the source
     distribution of Linux.
   </para>
  </legalnotice>
 </bookinfo>

<toc></toc>

  <chapter id="intro">
   <title>Introduction</title>
  <para>
    This document describes the interfaces available for device drivers that
    drive s390 based channel attached I/O devices. This includes interfaces for
    interaction with the hardware and interfaces for interacting with the
    common driver core. Those interfaces are provided by the s390 common I/O
    layer.
  </para>
  <para>
    The document assumes a familarity with the technical terms associated
    with the s390 channel I/O architecture. For a description of this
    architecture, please refer to the "z/Architecture: Principles of
    Operation", IBM publication no. SA22-7832.
  </para>
  <para>
    While most I/O devices on a s390 system are typically driven through the
    channel I/O mechanism described here, there are various other methods
    (like the diag interface). These are out of the scope of this document.
  </para>
  <para>
    Some additional information can also be found in the kernel source
    under Documentation/s390/driver-model.txt.
  </para>
  </chapter>
  <chapter id="ccw">
   <title>The ccw bus</title>
  <para>
	The ccw bus typically contains the majority of devices available to
	a s390 system. Named after the channel command word (ccw), the basic
	command structure used to address its devices, the ccw bus contains
	so-called channel attached devices. They are addressed via I/O
	subchannels, visible on the css bus. A device driver for
	channel-attached devices, however, will never interact	with the
	subchannel directly, but only via the I/O device on the ccw bus,
	the ccw device.
  </para>
    <sect1 id="channelIO">
     <title>I/O functions for channel-attached devices</title>
    <para>
      Some hardware structures have been translated into C structures for use
      by the common I/O layer and device drivers. For more information on
      the hardware structures represented here, please consult the Principles
      of Operation.
    </para>
<!-- arch/s390/include/asm/cio.h -->
<refentry id="API-struct-ccw1">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct ccw1</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct ccw1</refname>
 <refpurpose>
  channel command word
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct ccw1 {
  __u8 cmd_code;
  __u8 flags;
  __u16 count;
  __u32 cda;
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>cmd_code</term>
      <listitem><para>
command code
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>flags</term>
      <listitem><para>
flags, like IDA addressing, etc.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>count</term>
      <listitem><para>
byte count
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>cda</term>
      <listitem><para>
data address
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
<refsect1>
<title>Description</title>
<para>
   The ccw is the basic structure to build channel programs that perform
   operations with the device or the control unit. Only Format-1 channel
   command words are supported.
</para>
</refsect1>
</refentry>

<refentry id="API-struct-erw">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct erw</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct erw</refname>
 <refpurpose>
     extended report word
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct erw {
  __u32 res0:3;
  __u32 auth:1;
  __u32 pvrf:1;
  __u32 cpt:1;
  __u32 fsavf:1;
  __u32 cons:1;
  __u32 scavf:1;
  __u32 fsaf:1;
  __u32 scnt:6;
  __u32 res16:16;
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>res0</term>
      <listitem><para>
   reserved
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>auth</term>
      <listitem><para>
   authorization check
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>pvrf</term>
      <listitem><para>
   path-verification-required flag
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>cpt</term>
      <listitem><para>
   channel-path timeout
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>fsavf</term>
      <listitem><para>
   failing storage address validity flag
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>cons</term>
      <listitem><para>
   concurrent sense
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>scavf</term>
      <listitem><para>
   secondary ccw address validity flag
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>fsaf</term>
      <listitem><para>
   failing storage address format
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>scnt</term>
      <listitem><para>
   sense count, if <parameter>cons</parameter> == <constant>1</constant>
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>res16</term>
      <listitem><para>
   reserved
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
</refentry>

<refentry id="API-struct-erw-eadm">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct erw_eadm</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct erw_eadm</refname>
 <refpurpose>
     EADM Subchannel extended report word
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct erw_eadm {
  __u32 b:1;
  __u32 r:1;
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>b</term>
      <listitem><para>
   aob error
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>r</term>
      <listitem><para>
   arsb error
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
</refentry>

<refentry id="API-struct-sublog">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct sublog</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct sublog</refname>
 <refpurpose>
     subchannel logout area
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct sublog {
  __u32 res0:1;
  __u32 esf:7;
  __u32 lpum:8;
  __u32 arep:1;
  __u32 fvf:5;
  __u32 sacc:2;
  __u32 termc:2;
  __u32 devsc:1;
  __u32 serr:1;
  __u32 ioerr:1;
  __u32 seqc:3;
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>res0</term>
      <listitem><para>
   reserved
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>esf</term>
      <listitem><para>
   extended status flags
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>lpum</term>
      <listitem><para>
   last path used mask
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>arep</term>
      <listitem><para>
   ancillary report
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>fvf</term>
      <listitem><para>
   field-validity flags
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>sacc</term>
      <listitem><para>
   storage access code
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>termc</term>
      <listitem><para>
   termination code
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>devsc</term>
      <listitem><para>
   device-status check
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>serr</term>
      <listitem><para>
   secondary error
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>ioerr</term>
      <listitem><para>
   i/o-error alert
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>seqc</term>
      <listitem><para>
   sequence code
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
</refentry>

<refentry id="API-struct-esw0">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct esw0</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct esw0</refname>
 <refpurpose>
     Format 0 Extended Status Word (ESW)
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct esw0 {
  struct sublog sublog;
  struct erw erw;
  __u32 faddr[2];
  __u32 saddr;
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>sublog</term>
      <listitem><para>
   subchannel logout
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>erw</term>
      <listitem><para>
   extended report word
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>faddr[2]</term>
      <listitem><para>
   failing storage address
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>saddr</term>
      <listitem><para>
   secondary ccw address
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
</refentry>

<refentry id="API-struct-esw1">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct esw1</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct esw1</refname>
 <refpurpose>
     Format 1 Extended Status Word (ESW)
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct esw1 {
  __u8 zero0;
  __u8 lpum;
  __u16 zero16;
  struct erw erw;
  __u32 zeros[3];
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>zero0</term>
      <listitem><para>
   reserved zeros
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>lpum</term>
      <listitem><para>
   last path used mask
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>zero16</term>
      <listitem><para>
   reserved zeros
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>erw</term>
      <listitem><para>
   extended report word
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>zeros[3]</term>
      <listitem><para>
   three fullwords of zeros
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
</refentry>

<refentry id="API-struct-esw2">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct esw2</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct esw2</refname>
 <refpurpose>
     Format 2 Extended Status Word (ESW)
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct esw2 {
  __u8 zero0;
  __u8 lpum;
  __u16 dcti;
  struct erw erw;
  __u32 zeros[3];
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>zero0</term>
      <listitem><para>
   reserved zeros
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>lpum</term>
      <listitem><para>
   last path used mask
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>dcti</term>
      <listitem><para>
   device-connect-time interval
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>erw</term>
      <listitem><para>
   extended report word
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>zeros[3]</term>
      <listitem><para>
   three fullwords of zeros
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
</refentry>

<refentry id="API-struct-esw3">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct esw3</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct esw3</refname>
 <refpurpose>
     Format 3 Extended Status Word (ESW)
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct esw3 {
  __u8 zero0;
  __u8 lpum;
  __u16 res;
  struct erw erw;
  __u32 zeros[3];
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>zero0</term>
      <listitem><para>
   reserved zeros
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>lpum</term>
      <listitem><para>
   last path used mask
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>res</term>
      <listitem><para>
   reserved
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>erw</term>
      <listitem><para>
   extended report word
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>zeros[3]</term>
      <listitem><para>
   three fullwords of zeros
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
</refentry>

<refentry id="API-struct-esw-eadm">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct esw_eadm</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct esw_eadm</refname>
 <refpurpose>
     EADM Subchannel Extended Status Word (ESW)
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct esw_eadm {
  __u32 sublog;
  struct erw_eadm erw;
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>sublog</term>
      <listitem><para>
   subchannel logout
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>erw</term>
      <listitem><para>
   extended report word
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
</refentry>

<refentry id="API-struct-irb">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct irb</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct irb</refname>
 <refpurpose>
     interruption response block
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct irb {
  union scsw scsw;
  union esw;
  __u8 ecw[32];
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>scsw</term>
      <listitem><para>
   subchannel status word
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>esw</term>
      <listitem><para>
   extended status word
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>ecw[32]</term>
      <listitem><para>
   extended control word
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
<refsect1>
<title>Description</title>
<para>
   The irb that is handed to the device driver when an interrupt occurs. For
   solicited interrupts, the common I/O layer already performs checks whether
   a field is valid; a field not being valid is always passed as <constant>0</constant>.
   If a unit check occurred, <parameter>ecw</parameter> may contain sense data; this is retrieved
   by the common I/O layer itself if the device doesn't support concurrent
   sense (so that the device driver never needs to perform basic sene itself).
   For unsolicited interrupts, the irb is passed as-is (expect for sense data,
   if applicable).
</para>
</refsect1>
</refentry>

<refentry id="API-struct-ciw">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct ciw</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct ciw</refname>
 <refpurpose>
     command information word (CIW) layout
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct ciw {
  __u32 et:2;
  __u32 reserved:2;
  __u32 ct:4;
  __u32 cmd:8;
  __u32 count:16;
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>et</term>
      <listitem><para>
   entry type
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>reserved</term>
      <listitem><para>
   reserved bits
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>ct</term>
      <listitem><para>
   command type
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>cmd</term>
      <listitem><para>
   command code
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>count</term>
      <listitem><para>
   command count
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
</refentry>

<refentry id="API-struct-ccw-dev-id">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct ccw_dev_id</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct ccw_dev_id</refname>
 <refpurpose>
     unique identifier for ccw devices
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct ccw_dev_id {
  u8 ssid;
  u16 devno;
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>ssid</term>
      <listitem><para>
   subchannel set id
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>devno</term>
      <listitem><para>
   device number
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
<refsect1>
<title>Description</title>
<para>
   This structure is not directly based on any hardware structure. The
   hardware identifies a device by its device number and its subchannel,
   which is in turn identified by its id. In order to get a unique identifier
   for ccw devices across subchannel sets, <parameter>struct</parameter> ccw_dev_id has been
   introduced.
</para>
</refsect1>
</refentry>

<refentry id="API-ccw-dev-id-is-equal">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ccw_dev_id_is_equal</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ccw_dev_id_is_equal</refname>
 <refpurpose>
     compare two ccw_dev_ids
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>ccw_dev_id_is_equal </function></funcdef>
   <paramdef>struct ccw_dev_id * <parameter>dev_id1</parameter></paramdef>
   <paramdef>struct ccw_dev_id * <parameter>dev_id2</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev_id1</parameter></term>
   <listitem>
    <para>
     a ccw_dev_id
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>dev_id2</parameter></term>
   <listitem>
    <para>
     another ccw_dev_id
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Returns</title>
<para>
   <constant>1</constant> if the two structures are equal field-by-field,
   <constant>0</constant> if not.
</para>
</refsect1>
<refsect1>
<title>Context</title>
<para>
   any
</para>
</refsect1>
</refentry>

    </sect1>
    <sect1 id="ccwdev">
     <title>ccw devices</title>
    <para>
      Devices that want to initiate channel I/O need to attach to the ccw bus.
      Interaction with the driver core is done via the common I/O layer, which
      provides the abstractions of ccw devices and ccw device drivers.
    </para>
    <para>
      The functions that initiate or terminate channel I/O all act upon a
      ccw device structure. Device drivers must not bypass those functions
      or strange side effects may happen.
    </para>
<!-- arch/s390/include/asm/ccwdev.h -->
<refentry id="API-struct-ccw-device">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct ccw_device</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct ccw_device</refname>
 <refpurpose>
  channel attached device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct ccw_device {
  spinlock_t * ccwlock;
  struct ccw_device_id id;
  struct ccw_driver * drv;
  struct device dev;
  int online;
  void (* handler) (struct ccw_device *, unsigned long, struct irb *);
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>ccwlock</term>
      <listitem><para>
pointer to device lock
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>id</term>
      <listitem><para>
id of this device
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>drv</term>
      <listitem><para>
ccw driver for this device
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>dev</term>
      <listitem><para>
embedded device structure
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>online</term>
      <listitem><para>
online status of device
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>handler</term>
      <listitem><para>
interrupt handler
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
<refsect1>
<title>Description</title>
<para>
   <parameter>handler</parameter> is a member of the device rather than the driver since a driver
   can have different interrupt handlers for different ccw devices
   (multi-subchannel drivers).
</para>
</refsect1>
</refentry>

<refentry id="API-struct-ccw-driver">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct ccw_driver</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct ccw_driver</refname>
 <refpurpose>
     device driver for channel attached devices
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct ccw_driver {
  struct ccw_device_id * ids;
  int (* probe) (struct ccw_device *);
  void (* remove) (struct ccw_device *);
  int (* set_online) (struct ccw_device *);
  int (* set_offline) (struct ccw_device *);
  int (* notify) (struct ccw_device *, int);
  void (* path_event) (struct ccw_device *, int *);
  void (* shutdown) (struct ccw_device *);
  int (* prepare) (struct ccw_device *);
  void (* complete) (struct ccw_device *);
  int (* freeze) (struct ccw_device *);
  int (* thaw) (struct ccw_device *);
  int (* restore) (struct ccw_device *);
  enum uc_todo (* uc_handler) (struct ccw_device *, struct irb *);
  struct device_driver driver;
  enum interruption_class int_class;
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>ids</term>
      <listitem><para>
   ids supported by this driver
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>probe</term>
      <listitem><para>
   function called on probe
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>remove</term>
      <listitem><para>
   function called on remove
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>set_online</term>
      <listitem><para>
   called when setting device online
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>set_offline</term>
      <listitem><para>
   called when setting device offline
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>notify</term>
      <listitem><para>
   notify driver of device state changes
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>path_event</term>
      <listitem><para>
   notify driver of channel path events
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>shutdown</term>
      <listitem><para>
   called at device shutdown
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>prepare</term>
      <listitem><para>
   prepare for pm state transition
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>complete</term>
      <listitem><para>
   undo work done in <parameter>prepare</parameter>
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>freeze</term>
      <listitem><para>
   callback for freezing during hibernation snapshotting
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>thaw</term>
      <listitem><para>
   undo work done in <parameter>freeze</parameter>
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>restore</term>
      <listitem><para>
   callback for restoring after hibernation
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>uc_handler</term>
      <listitem><para>
   callback for unit check handler
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>driver</term>
      <listitem><para>
   embedded device driver structure
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>int_class</term>
      <listitem><para>
   interruption class to use for accounting interrupts
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
</refentry>

<!-- drivers/s390/cio/device.c -->
<refentry id="API-ccw-device-set-offline">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ccw_device_set_offline</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ccw_device_set_offline</refname>
 <refpurpose>
  disable a ccw device for I/O
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>ccw_device_set_offline </function></funcdef>
   <paramdef>struct ccw_device * <parameter>cdev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>cdev</parameter></term>
   <listitem>
    <para>
     target ccw device
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This function calls the driver's <function>set_offline</function> function for <parameter>cdev</parameter>, if
   given, and then disables <parameter>cdev</parameter>.
</para>
</refsect1>
<refsect1>
<title>Returns</title>
<para>
   <constant>0</constant> on success and a negative error value on failure.
</para>
</refsect1>
<refsect1>
<title>Context</title>
<para>
   enabled, ccw device lock not held
</para>
</refsect1>
</refentry>

<refentry id="API-ccw-device-set-online">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ccw_device_set_online</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ccw_device_set_online</refname>
 <refpurpose>
     enable a ccw device for I/O
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>ccw_device_set_online </function></funcdef>
   <paramdef>struct ccw_device * <parameter>cdev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>cdev</parameter></term>
   <listitem>
    <para>
     target ccw device
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This function first enables <parameter>cdev</parameter> and then calls the driver's <function>set_online</function>
   function for <parameter>cdev</parameter>, if given. If <function>set_online</function> returns an error, <parameter>cdev</parameter> is
   disabled again.
</para>
</refsect1>
<refsect1>
<title>Returns</title>
<para>
   <constant>0</constant> on success and a negative error value on failure.
</para>
</refsect1>
<refsect1>
<title>Context</title>
<para>
   enabled, ccw device lock not held
</para>
</refsect1>
</refentry>

<refentry id="API-get-ccwdev-by-dev-id">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>get_ccwdev_by_dev_id</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>get_ccwdev_by_dev_id</refname>
 <refpurpose>
     obtain device from a ccw device id
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct ccw_device * <function>get_ccwdev_by_dev_id </function></funcdef>
   <paramdef>struct ccw_dev_id * <parameter>dev_id</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev_id</parameter></term>
   <listitem>
    <para>
     id of the device to be searched
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This function searches all devices attached to the ccw bus for a device
   matching <parameter>dev_id</parameter>.
</para>
</refsect1>
<refsect1>
<title>Returns</title>
<para>
   If a device is found its reference count is increased and returned;
   else <constant>NULL</constant> is returned.
</para>
</refsect1>
</refentry>

<refentry id="API-get-ccwdev-by-busid">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>get_ccwdev_by_busid</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>get_ccwdev_by_busid</refname>
 <refpurpose>
     obtain device from a bus id
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct ccw_device * <function>get_ccwdev_by_busid </function></funcdef>
   <paramdef>struct ccw_driver * <parameter>cdrv</parameter></paramdef>
   <paramdef>const char * <parameter>bus_id</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>cdrv</parameter></term>
   <listitem>
    <para>
     driver the device is owned by
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>bus_id</parameter></term>
   <listitem>
    <para>
     bus id of the device to be searched
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This function searches all devices owned by <parameter>cdrv</parameter> for a device with a bus
   id matching <parameter>bus_id</parameter>.
</para>
</refsect1>
<refsect1>
<title>Returns</title>
<para>
   If a match is found, its reference count of the found device is increased
   and it is returned; else <constant>NULL</constant> is returned.
</para>
</refsect1>
</refentry>

<refentry id="API-ccw-driver-register">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ccw_driver_register</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ccw_driver_register</refname>
 <refpurpose>
     register a ccw driver
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>ccw_driver_register </function></funcdef>
   <paramdef>struct ccw_driver * <parameter>cdriver</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>cdriver</parameter></term>
   <listitem>
    <para>
     driver to be registered
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This function is mainly a wrapper around <function>driver_register</function>.
</para>
</refsect1>
<refsect1>
<title>Returns</title>
<para>
   <constant>0</constant> on success and a negative error value on failure.
</para>
</refsect1>
</refentry>

<refentry id="API-ccw-driver-unregister">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ccw_driver_unregister</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ccw_driver_unregister</refname>
 <refpurpose>
     deregister a ccw driver
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>ccw_driver_unregister </function></funcdef>
   <paramdef>struct ccw_driver * <parameter>cdriver</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>cdriver</parameter></term>
   <listitem>
    <para>
     driver to be deregistered
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This function is mainly a wrapper around <function>driver_unregister</function>.
</para>
</refsect1>
</refentry>

<refentry id="API-ccw-device-siosl">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ccw_device_siosl</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ccw_device_siosl</refname>
 <refpurpose>
     initiate logging
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>ccw_device_siosl </function></funcdef>
   <paramdef>struct ccw_device * <parameter>cdev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>cdev</parameter></term>
   <listitem>
    <para>
     ccw device
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This function is used to invoke model-dependent logging within the channel
   subsystem.
</para>
</refsect1>
</refentry>

<!-- drivers/s390/cio/device_ops.c -->
<refentry id="API-ccw-device-set-options-mask">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ccw_device_set_options_mask</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ccw_device_set_options_mask</refname>
 <refpurpose>
  set some options and unset the rest
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>ccw_device_set_options_mask </function></funcdef>
   <paramdef>struct ccw_device * <parameter>cdev</parameter></paramdef>
   <paramdef>unsigned long <parameter>flags</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>cdev</parameter></term>
   <listitem>
    <para>
     device for which the options are to be set
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>flags</parameter></term>
   <listitem>
    <para>
     options to be set
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   All flags specified in <parameter>flags</parameter> are set, all flags not specified in <parameter>flags</parameter>
   are cleared.
</para>
</refsect1>
<refsect1>
<title>Returns</title>
<para>
   <constant>0</constant> on success, -<constant>EINVAL</constant> on an invalid flag combination.
</para>
</refsect1>
</refentry>

<refentry id="API-ccw-device-set-options">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ccw_device_set_options</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ccw_device_set_options</refname>
 <refpurpose>
     set some options
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>ccw_device_set_options </function></funcdef>
   <paramdef>struct ccw_device * <parameter>cdev</parameter></paramdef>
   <paramdef>unsigned long <parameter>flags</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>cdev</parameter></term>
   <listitem>
    <para>
     device for which the options are to be set
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>flags</parameter></term>
   <listitem>
    <para>
     options to be set
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   All flags specified in <parameter>flags</parameter> are set, the remainder is left untouched.
</para>
</refsect1>
<refsect1>
<title>Returns</title>
<para>
   <constant>0</constant> on success, -<constant>EINVAL</constant> if an invalid flag combination would ensue.
</para>
</refsect1>
</refentry>

<refentry id="API-ccw-device-clear-options">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ccw_device_clear_options</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ccw_device_clear_options</refname>
 <refpurpose>
     clear some options
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>ccw_device_clear_options </function></funcdef>
   <paramdef>struct ccw_device * <parameter>cdev</parameter></paramdef>
   <paramdef>unsigned long <parameter>flags</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>cdev</parameter></term>
   <listitem>
    <para>
     device for which the options are to be cleared
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>flags</parameter></term>
   <listitem>
    <para>
     options to be cleared
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   All flags specified in <parameter>flags</parameter> are cleared, the remainder is left untouched.
</para>
</refsect1>
</refentry>

<refentry id="API-ccw-device-is-pathgroup">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ccw_device_is_pathgroup</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ccw_device_is_pathgroup</refname>
 <refpurpose>
     determine if paths to this device are grouped
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>ccw_device_is_pathgroup </function></funcdef>
   <paramdef>struct ccw_device * <parameter>cdev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>cdev</parameter></term>
   <listitem>
    <para>
     ccw device
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Return non-zero if there is a path group, zero otherwise.
</para>
</refsect1>
</refentry>

<refentry id="API-ccw-device-is-multipath">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ccw_device_is_multipath</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ccw_device_is_multipath</refname>
 <refpurpose>
     determine if device is operating in multipath mode
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>ccw_device_is_multipath </function></funcdef>
   <paramdef>struct ccw_device * <parameter>cdev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>cdev</parameter></term>
   <listitem>
    <para>
     ccw device
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Return non-zero if device is operating in multipath mode, zero otherwise.
</para>
</refsect1>
</refentry>

<refentry id="API-ccw-device-clear">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ccw_device_clear</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ccw_device_clear</refname>
 <refpurpose>
     terminate I/O request processing
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>ccw_device_clear </function></funcdef>
   <paramdef>struct ccw_device * <parameter>cdev</parameter></paramdef>
   <paramdef>unsigned long <parameter>intparm</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>cdev</parameter></term>
   <listitem>
    <para>
     target ccw device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>intparm</parameter></term>
   <listitem>
    <para>
     interruption parameter; value is only used if no I/O is
     outstanding, otherwise the intparm associated with the I/O request
     is returned
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   <function>ccw_device_clear</function> calls csch on <parameter>cdev</parameter>'s subchannel.
</para>
</refsect1>
<refsect1>
<title>Returns</title>
<para>
   <constant>0</constant> on success,
   -<constant>ENODEV</constant> on device not operational,
   -<constant>EINVAL</constant> on invalid device state.
</para>
</refsect1>
<refsect1>
<title>Context</title>
<para>
   Interrupts disabled, ccw device lock held
</para>
</refsect1>
</refentry>

<refentry id="API-ccw-device-start-key">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ccw_device_start_key</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ccw_device_start_key</refname>
 <refpurpose>
     start a s390 channel program with key
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>ccw_device_start_key </function></funcdef>
   <paramdef>struct ccw_device * <parameter>cdev</parameter></paramdef>
   <paramdef>struct ccw1 * <parameter>cpa</parameter></paramdef>
   <paramdef>unsigned long <parameter>intparm</parameter></paramdef>
   <paramdef>__u8 <parameter>lpm</parameter></paramdef>
   <paramdef>__u8 <parameter>key</parameter></paramdef>
   <paramdef>unsigned long <parameter>flags</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>cdev</parameter></term>
   <listitem>
    <para>
     target ccw device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>cpa</parameter></term>
   <listitem>
    <para>
     logical start address of channel program
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>intparm</parameter></term>
   <listitem>
    <para>
     user specific interruption parameter; will be presented back to
     <parameter>cdev</parameter>'s interrupt handler. Allows a device driver to associate
     the interrupt with a particular I/O request.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>lpm</parameter></term>
   <listitem>
    <para>
     defines the channel path to be used for a specific I/O request. A
     value of 0 will make cio use the opm.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>key</parameter></term>
   <listitem>
    <para>
     storage key to be used for the I/O
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>flags</parameter></term>
   <listitem>
    <para>
     additional flags; defines the action to be performed for I/O
     processing.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Start a S/390 channel program. When the interrupt arrives, the
   IRQ handler is called, either immediately, delayed (dev-end missing,
   or sense required) or never (no IRQ handler registered).
</para>
</refsect1>
<refsect1>
<title>Returns</title>
<para>
   <constant>0</constant>, if the operation was successful;
   -<constant>EBUSY</constant>, if the device is busy, or status pending;
   -<constant>EACCES</constant>, if no path specified in <parameter>lpm</parameter> is operational;
   -<constant>ENODEV</constant>, if the device is not operational.
</para>
</refsect1>
<refsect1>
<title>Context</title>
<para>
   Interrupts disabled, ccw device lock held
</para>
</refsect1>
</refentry>

<refentry id="API-ccw-device-start-timeout-key">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ccw_device_start_timeout_key</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ccw_device_start_timeout_key</refname>
 <refpurpose>
     start a s390 channel program with timeout and key
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>ccw_device_start_timeout_key </function></funcdef>
   <paramdef>struct ccw_device * <parameter>cdev</parameter></paramdef>
   <paramdef>struct ccw1 * <parameter>cpa</parameter></paramdef>
   <paramdef>unsigned long <parameter>intparm</parameter></paramdef>
   <paramdef>__u8 <parameter>lpm</parameter></paramdef>
   <paramdef>__u8 <parameter>key</parameter></paramdef>
   <paramdef>unsigned long <parameter>flags</parameter></paramdef>
   <paramdef>int <parameter>expires</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>cdev</parameter></term>
   <listitem>
    <para>
     target ccw device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>cpa</parameter></term>
   <listitem>
    <para>
     logical start address of channel program
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>intparm</parameter></term>
   <listitem>
    <para>
     user specific interruption parameter; will be presented back to
     <parameter>cdev</parameter>'s interrupt handler. Allows a device driver to associate
     the interrupt with a particular I/O request.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>lpm</parameter></term>
   <listitem>
    <para>
     defines the channel path to be used for a specific I/O request. A
     value of 0 will make cio use the opm.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>key</parameter></term>
   <listitem>
    <para>
     storage key to be used for the I/O
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>flags</parameter></term>
   <listitem>
    <para>
     additional flags; defines the action to be performed for I/O
     processing.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>expires</parameter></term>
   <listitem>
    <para>
     timeout value in jiffies
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Start a S/390 channel program. When the interrupt arrives, the
   IRQ handler is called, either immediately, delayed (dev-end missing,
   or sense required) or never (no IRQ handler registered).
   This function notifies the device driver if the channel program has not
   completed during the time specified by <parameter>expires</parameter>. If a timeout occurs, the
   channel program is terminated via xsch, hsch or csch, and the device's
   interrupt handler will be called with an irb containing ERR_PTR(-<constant>ETIMEDOUT</constant>).
</para>
</refsect1>
<refsect1>
<title>Returns</title>
<para>
   <constant>0</constant>, if the operation was successful;
   -<constant>EBUSY</constant>, if the device is busy, or status pending;
   -<constant>EACCES</constant>, if no path specified in <parameter>lpm</parameter> is operational;
   -<constant>ENODEV</constant>, if the device is not operational.
</para>
</refsect1>
<refsect1>
<title>Context</title>
<para>
   Interrupts disabled, ccw device lock held
</para>
</refsect1>
</refentry>

<refentry id="API-ccw-device-start">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ccw_device_start</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ccw_device_start</refname>
 <refpurpose>
     start a s390 channel program
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>ccw_device_start </function></funcdef>
   <paramdef>struct ccw_device * <parameter>cdev</parameter></paramdef>
   <paramdef>struct ccw1 * <parameter>cpa</parameter></paramdef>
   <paramdef>unsigned long <parameter>intparm</parameter></paramdef>
   <paramdef>__u8 <parameter>lpm</parameter></paramdef>
   <paramdef>unsigned long <parameter>flags</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>cdev</parameter></term>
   <listitem>
    <para>
     target ccw device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>cpa</parameter></term>
   <listitem>
    <para>
     logical start address of channel program
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>intparm</parameter></term>
   <listitem>
    <para>
     user specific interruption parameter; will be presented back to
     <parameter>cdev</parameter>'s interrupt handler. Allows a device driver to associate
     the interrupt with a particular I/O request.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>lpm</parameter></term>
   <listitem>
    <para>
     defines the channel path to be used for a specific I/O request. A
     value of 0 will make cio use the opm.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>flags</parameter></term>
   <listitem>
    <para>
     additional flags; defines the action to be performed for I/O
     processing.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Start a S/390 channel program. When the interrupt arrives, the
   IRQ handler is called, either immediately, delayed (dev-end missing,
   or sense required) or never (no IRQ handler registered).
</para>
</refsect1>
<refsect1>
<title>Returns</title>
<para>
   <constant>0</constant>, if the operation was successful;
   -<constant>EBUSY</constant>, if the device is busy, or status pending;
   -<constant>EACCES</constant>, if no path specified in <parameter>lpm</parameter> is operational;
   -<constant>ENODEV</constant>, if the device is not operational.
</para>
</refsect1>
<refsect1>
<title>Context</title>
<para>
   Interrupts disabled, ccw device lock held
</para>
</refsect1>
</refentry>

<refentry id="API-ccw-device-start-timeout">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ccw_device_start_timeout</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ccw_device_start_timeout</refname>
 <refpurpose>
     start a s390 channel program with timeout
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>ccw_device_start_timeout </function></funcdef>
   <paramdef>struct ccw_device * <parameter>cdev</parameter></paramdef>
   <paramdef>struct ccw1 * <parameter>cpa</parameter></paramdef>
   <paramdef>unsigned long <parameter>intparm</parameter></paramdef>
   <paramdef>__u8 <parameter>lpm</parameter></paramdef>
   <paramdef>unsigned long <parameter>flags</parameter></paramdef>
   <paramdef>int <parameter>expires</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>cdev</parameter></term>
   <listitem>
    <para>
     target ccw device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>cpa</parameter></term>
   <listitem>
    <para>
     logical start address of channel program
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>intparm</parameter></term>
   <listitem>
    <para>
     user specific interruption parameter; will be presented back to
     <parameter>cdev</parameter>'s interrupt handler. Allows a device driver to associate
     the interrupt with a particular I/O request.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>lpm</parameter></term>
   <listitem>
    <para>
     defines the channel path to be used for a specific I/O request. A
     value of 0 will make cio use the opm.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>flags</parameter></term>
   <listitem>
    <para>
     additional flags; defines the action to be performed for I/O
     processing.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>expires</parameter></term>
   <listitem>
    <para>
     timeout value in jiffies
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Start a S/390 channel program. When the interrupt arrives, the
   IRQ handler is called, either immediately, delayed (dev-end missing,
   or sense required) or never (no IRQ handler registered).
   This function notifies the device driver if the channel program has not
   completed during the time specified by <parameter>expires</parameter>. If a timeout occurs, the
   channel program is terminated via xsch, hsch or csch, and the device's
   interrupt handler will be called with an irb containing ERR_PTR(-<constant>ETIMEDOUT</constant>).
</para>
</refsect1>
<refsect1>
<title>Returns</title>
<para>
   <constant>0</constant>, if the operation was successful;
   -<constant>EBUSY</constant>, if the device is busy, or status pending;
   -<constant>EACCES</constant>, if no path specified in <parameter>lpm</parameter> is operational;
   -<constant>ENODEV</constant>, if the device is not operational.
</para>
</refsect1>
<refsect1>
<title>Context</title>
<para>
   Interrupts disabled, ccw device lock held
</para>
</refsect1>
</refentry>

<refentry id="API-ccw-device-halt">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ccw_device_halt</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ccw_device_halt</refname>
 <refpurpose>
     halt I/O request processing
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>ccw_device_halt </function></funcdef>
   <paramdef>struct ccw_device * <parameter>cdev</parameter></paramdef>
   <paramdef>unsigned long <parameter>intparm</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>cdev</parameter></term>
   <listitem>
    <para>
     target ccw device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>intparm</parameter></term>
   <listitem>
    <para>
     interruption parameter; value is only used if no I/O is
     outstanding, otherwise the intparm associated with the I/O request
     is returned
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   <function>ccw_device_halt</function> calls hsch on <parameter>cdev</parameter>'s subchannel.
</para>
</refsect1>
<refsect1>
<title>Returns</title>
<para>
   <constant>0</constant> on success,
   -<constant>ENODEV</constant> on device not operational,
   -<constant>EINVAL</constant> on invalid device state,
   -<constant>EBUSY</constant> on device busy or interrupt pending.
</para>
</refsect1>
<refsect1>
<title>Context</title>
<para>
   Interrupts disabled, ccw device lock held
</para>
</refsect1>
</refentry>

<refentry id="API-ccw-device-resume">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ccw_device_resume</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ccw_device_resume</refname>
 <refpurpose>
     resume channel program execution
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>ccw_device_resume </function></funcdef>
   <paramdef>struct ccw_device * <parameter>cdev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>cdev</parameter></term>
   <listitem>
    <para>
     target ccw device
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   <function>ccw_device_resume</function> calls rsch on <parameter>cdev</parameter>'s subchannel.
</para>
</refsect1>
<refsect1>
<title>Returns</title>
<para>
   <constant>0</constant> on success,
   -<constant>ENODEV</constant> on device not operational,
   -<constant>EINVAL</constant> on invalid device state,
   -<constant>EBUSY</constant> on device busy or interrupt pending.
</para>
</refsect1>
<refsect1>
<title>Context</title>
<para>
   Interrupts disabled, ccw device lock held
</para>
</refsect1>
</refentry>

<refentry id="API-ccw-device-get-ciw">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ccw_device_get_ciw</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ccw_device_get_ciw</refname>
 <refpurpose>
     Search for CIW command in extended sense data.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct ciw * <function>ccw_device_get_ciw </function></funcdef>
   <paramdef>struct ccw_device * <parameter>cdev</parameter></paramdef>
   <paramdef>__u32 <parameter>ct</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>cdev</parameter></term>
   <listitem>
    <para>
     ccw device to inspect
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>ct</parameter></term>
   <listitem>
    <para>
     command type to look for
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   During SenseID, command information words (CIWs) describing special
   commands available to the device may have been stored in the extended
   sense data. This function searches for CIWs of a specified command
   type in the extended sense data.
</para>
</refsect1>
<refsect1>
<title>Returns</title>
<para>
   <constant>NULL</constant> if no extended sense data has been stored or if no CIW of the
   specified command type could be found,
   else a pointer to the CIW of the specified command type.
</para>
</refsect1>
</refentry>

<refentry id="API-ccw-device-get-path-mask">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ccw_device_get_path_mask</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ccw_device_get_path_mask</refname>
 <refpurpose>
     get currently available paths
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>__u8 <function>ccw_device_get_path_mask </function></funcdef>
   <paramdef>struct ccw_device * <parameter>cdev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>cdev</parameter></term>
   <listitem>
    <para>
     ccw device to be queried
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Returns</title>
<para>
   <constant>0</constant> if no subchannel for the device is available,
   else the mask of currently available paths for the ccw device's subchannel.
</para>
</refsect1>
</refentry>

<refentry id="API-ccw-device-get-chp-desc">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ccw_device_get_chp_desc</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ccw_device_get_chp_desc</refname>
 <refpurpose>
     return newly allocated channel-path descriptor
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct channel_path_desc * <function>ccw_device_get_chp_desc </function></funcdef>
   <paramdef>struct ccw_device * <parameter>cdev</parameter></paramdef>
   <paramdef>int <parameter>chp_idx</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>cdev</parameter></term>
   <listitem>
    <para>
     device to obtain the descriptor for
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>chp_idx</parameter></term>
   <listitem>
    <para>
     index of the channel path
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   On success return a newly allocated copy of the channel-path description
   data associated with the given channel path. Return <constant>NULL</constant> on error.
</para>
</refsect1>
</refentry>

<refentry id="API-ccw-device-get-id">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ccw_device_get_id</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ccw_device_get_id</refname>
 <refpurpose>
     obtain a ccw device id
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>ccw_device_get_id </function></funcdef>
   <paramdef>struct ccw_device * <parameter>cdev</parameter></paramdef>
   <paramdef>struct ccw_dev_id * <parameter>dev_id</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>cdev</parameter></term>
   <listitem>
    <para>
     device to obtain the id for
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>dev_id</parameter></term>
   <listitem>
    <para>
     where to fill in the values
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-ccw-device-tm-start-key">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ccw_device_tm_start_key</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ccw_device_tm_start_key</refname>
 <refpurpose>
     perform start function
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>ccw_device_tm_start_key </function></funcdef>
   <paramdef>struct ccw_device * <parameter>cdev</parameter></paramdef>
   <paramdef>struct tcw * <parameter>tcw</parameter></paramdef>
   <paramdef>unsigned long <parameter>intparm</parameter></paramdef>
   <paramdef>u8 <parameter>lpm</parameter></paramdef>
   <paramdef>u8 <parameter>key</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>cdev</parameter></term>
   <listitem>
    <para>
     ccw device on which to perform the start function
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>tcw</parameter></term>
   <listitem>
    <para>
     transport-command word to be started
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>intparm</parameter></term>
   <listitem>
    <para>
     user defined parameter to be passed to the interrupt handler
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>lpm</parameter></term>
   <listitem>
    <para>
     mask of paths to use
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>key</parameter></term>
   <listitem>
    <para>
     storage key to use for storage access
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Start the tcw on the given ccw device. Return zero on success, non-zero
   otherwise.
</para>
</refsect1>
</refentry>

<refentry id="API-ccw-device-tm-start-timeout-key">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ccw_device_tm_start_timeout_key</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ccw_device_tm_start_timeout_key</refname>
 <refpurpose>
     perform start function
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>ccw_device_tm_start_timeout_key </function></funcdef>
   <paramdef>struct ccw_device * <parameter>cdev</parameter></paramdef>
   <paramdef>struct tcw * <parameter>tcw</parameter></paramdef>
   <paramdef>unsigned long <parameter>intparm</parameter></paramdef>
   <paramdef>u8 <parameter>lpm</parameter></paramdef>
   <paramdef>u8 <parameter>key</parameter></paramdef>
   <paramdef>int <parameter>expires</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>cdev</parameter></term>
   <listitem>
    <para>
     ccw device on which to perform the start function
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>tcw</parameter></term>
   <listitem>
    <para>
     transport-command word to be started
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>intparm</parameter></term>
   <listitem>
    <para>
     user defined parameter to be passed to the interrupt handler
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>lpm</parameter></term>
   <listitem>
    <para>
     mask of paths to use
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>key</parameter></term>
   <listitem>
    <para>
     storage key to use for storage access
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>expires</parameter></term>
   <listitem>
    <para>
     time span in jiffies after which to abort request
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Start the tcw on the given ccw device. Return zero on success, non-zero
   otherwise.
</para>
</refsect1>
</refentry>

<refentry id="API-ccw-device-tm-start">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ccw_device_tm_start</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ccw_device_tm_start</refname>
 <refpurpose>
     perform start function
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>ccw_device_tm_start </function></funcdef>
   <paramdef>struct ccw_device * <parameter>cdev</parameter></paramdef>
   <paramdef>struct tcw * <parameter>tcw</parameter></paramdef>
   <paramdef>unsigned long <parameter>intparm</parameter></paramdef>
   <paramdef>u8 <parameter>lpm</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>cdev</parameter></term>
   <listitem>
    <para>
     ccw device on which to perform the start function
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>tcw</parameter></term>
   <listitem>
    <para>
     transport-command word to be started
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>intparm</parameter></term>
   <listitem>
    <para>
     user defined parameter to be passed to the interrupt handler
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>lpm</parameter></term>
   <listitem>
    <para>
     mask of paths to use
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Start the tcw on the given ccw device. Return zero on success, non-zero
   otherwise.
</para>
</refsect1>
</refentry>

<refentry id="API-ccw-device-tm-start-timeout">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ccw_device_tm_start_timeout</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ccw_device_tm_start_timeout</refname>
 <refpurpose>
     perform start function
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>ccw_device_tm_start_timeout </function></funcdef>
   <paramdef>struct ccw_device * <parameter>cdev</parameter></paramdef>
   <paramdef>struct tcw * <parameter>tcw</parameter></paramdef>
   <paramdef>unsigned long <parameter>intparm</parameter></paramdef>
   <paramdef>u8 <parameter>lpm</parameter></paramdef>
   <paramdef>int <parameter>expires</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>cdev</parameter></term>
   <listitem>
    <para>
     ccw device on which to perform the start function
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>tcw</parameter></term>
   <listitem>
    <para>
     transport-command word to be started
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>intparm</parameter></term>
   <listitem>
    <para>
     user defined parameter to be passed to the interrupt handler
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>lpm</parameter></term>
   <listitem>
    <para>
     mask of paths to use
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>expires</parameter></term>
   <listitem>
    <para>
     time span in jiffies after which to abort request
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Start the tcw on the given ccw device. Return zero on success, non-zero
   otherwise.
</para>
</refsect1>
</refentry>

<refentry id="API-ccw-device-get-mdc">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ccw_device_get_mdc</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ccw_device_get_mdc</refname>
 <refpurpose>
     accumulate max data count
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>ccw_device_get_mdc </function></funcdef>
   <paramdef>struct ccw_device * <parameter>cdev</parameter></paramdef>
   <paramdef>u8 <parameter>mask</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>cdev</parameter></term>
   <listitem>
    <para>
     ccw device for which the max data count is accumulated
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>mask</parameter></term>
   <listitem>
    <para>
     mask of paths to use
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Return the number of 64K-bytes blocks all paths at least support
   for a transport command. Return values &lt;= 0 indicate failures.
</para>
</refsect1>
</refentry>

<refentry id="API-ccw-device-tm-intrg">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ccw_device_tm_intrg</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ccw_device_tm_intrg</refname>
 <refpurpose>
     perform interrogate function
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>ccw_device_tm_intrg </function></funcdef>
   <paramdef>struct ccw_device * <parameter>cdev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>cdev</parameter></term>
   <listitem>
    <para>
     ccw device on which to perform the interrogate function
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Perform an interrogate function on the given ccw device. Return zero on
   success, non-zero otherwise.
</para>
</refsect1>
</refentry>

<refentry id="API-ccw-device-get-schid">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ccw_device_get_schid</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ccw_device_get_schid</refname>
 <refpurpose>
     obtain a subchannel id
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>ccw_device_get_schid </function></funcdef>
   <paramdef>struct ccw_device * <parameter>cdev</parameter></paramdef>
   <paramdef>struct subchannel_id * <parameter>schid</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>cdev</parameter></term>
   <listitem>
    <para>
     device to obtain the id for
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>schid</parameter></term>
   <listitem>
    <para>
     where to fill in the values
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

    </sect1>
    <sect1 id="cmf">
     <title>The channel-measurement facility</title>
  <para>
	The channel-measurement facility provides a means to collect
	measurement data which is made available by the channel subsystem
	for each channel attached device.
  </para>
<!-- arch/s390/include/asm/cmb.h -->
<refentry>
 <refnamediv>
  <refname>
   ..//arch/s390/include/asm/cmb.h
  </refname>
  <refpurpose>
   Document generation inconsistency
  </refpurpose>
 </refnamediv>
 <refsect1>
  <title>
   Oops
  </title>
  <warning>
   <para>
    The template for this document tried to insert
    the structured comment from the file
    <filename>..//arch/s390/include/asm/cmb.h</filename> at this point,
    but none was found.
    This dummy section is inserted to allow
    generation to continue.
   </para>
  </warning>
 </refsect1>
</refentry>
<!-- drivers/s390/cio/cmf.c -->
<refentry id="API-enable-cmf">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>enable_cmf</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>enable_cmf</refname>
 <refpurpose>
  switch on the channel measurement for a specific device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>enable_cmf </function></funcdef>
   <paramdef>struct ccw_device * <parameter>cdev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>cdev</parameter></term>
   <listitem>
    <para>
     The ccw device to be enabled
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Returns <constant>0</constant> for success or a negative error value.
</para>
</refsect1>
<refsect1>
<title>Context</title>
<para>
   non-atomic
</para>
</refsect1>
</refentry>

<refentry id="API-disable-cmf">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>disable_cmf</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>disable_cmf</refname>
 <refpurpose>
     switch off the channel measurement for a specific device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>disable_cmf </function></funcdef>
   <paramdef>struct ccw_device * <parameter>cdev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>cdev</parameter></term>
   <listitem>
    <para>
     The ccw device to be disabled
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Returns <constant>0</constant> for success or a negative error value.
</para>
</refsect1>
<refsect1>
<title>Context</title>
<para>
   non-atomic
</para>
</refsect1>
</refentry>

<refentry id="API-cmf-read">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>cmf_read</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>cmf_read</refname>
 <refpurpose>
     read one value from the current channel measurement block
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>u64 <function>cmf_read </function></funcdef>
   <paramdef>struct ccw_device * <parameter>cdev</parameter></paramdef>
   <paramdef>int <parameter>index</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>cdev</parameter></term>
   <listitem>
    <para>
     the channel to be read
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>index</parameter></term>
   <listitem>
    <para>
     the index of the value to be read
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Returns the value read or <constant>0</constant> if the value cannot be read.
</para>
</refsect1>
<refsect1>
<title>Context</title>
<para>
   any
</para>
</refsect1>
</refentry>

<refentry id="API-cmf-readall">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>cmf_readall</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>cmf_readall</refname>
 <refpurpose>
     read the current channel measurement block
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>cmf_readall </function></funcdef>
   <paramdef>struct ccw_device * <parameter>cdev</parameter></paramdef>
   <paramdef>struct cmbdata * <parameter>data</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>cdev</parameter></term>
   <listitem>
    <para>
     the channel to be read
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>data</parameter></term>
   <listitem>
    <para>
     a pointer to a data block that will be filled
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Returns <constant>0</constant> on success, a negative error value otherwise.
</para>
</refsect1>
<refsect1>
<title>Context</title>
<para>
   any
</para>
</refsect1>
</refentry>

    </sect1>
  </chapter>

  <chapter id="ccwgroup">
   <title>The ccwgroup bus</title>
  <para>
	The ccwgroup bus only contains artificial devices, created by the user.
	Many networking devices (e.g. qeth) are in fact composed of several
	ccw devices (like read, write and data channel for qeth). The
	ccwgroup bus provides a mechanism to create a meta-device which
	contains those ccw devices as slave devices and can be associated
	with the netdevice.
  </para>
   <sect1 id="ccwgroupdevices">
    <title>ccw group devices</title>
<!-- arch/s390/include/asm/ccwgroup.h -->
<refentry id="API-struct-ccwgroup-device">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct ccwgroup_device</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct ccwgroup_device</refname>
 <refpurpose>
  ccw group device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct ccwgroup_device {
  enum state;
  unsigned int count;
  struct device dev;
  struct work_struct ungroup_work;
  struct ccw_device * cdev[0];
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>state</term>
      <listitem><para>
online/offline state
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>count</term>
      <listitem><para>
number of attached slave devices
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>dev</term>
      <listitem><para>
embedded device structure
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>ungroup_work</term>
      <listitem><para>
work to be done when a ccwgroup notifier has action
type <constant>BUS_NOTIFY_UNBIND_DRIVER</constant>
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>cdev[0]</term>
      <listitem><para>
variable number of slave devices, allocated as needed
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
</refentry>

<refentry id="API-struct-ccwgroup-driver">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct ccwgroup_driver</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct ccwgroup_driver</refname>
 <refpurpose>
     driver for ccw group devices
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct ccwgroup_driver {
  int (* setup) (struct ccwgroup_device *);
  void (* remove) (struct ccwgroup_device *);
  int (* set_online) (struct ccwgroup_device *);
  int (* set_offline) (struct ccwgroup_device *);
  void (* shutdown) (struct ccwgroup_device *);
  int (* prepare) (struct ccwgroup_device *);
  void (* complete) (struct ccwgroup_device *);
  int (* freeze) (struct ccwgroup_device *);
  int (* thaw) (struct ccwgroup_device *);
  int (* restore) (struct ccwgroup_device *);
  struct device_driver driver;
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>setup</term>
      <listitem><para>
   function called during device creation to setup the device
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>remove</term>
      <listitem><para>
   function called on remove
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>set_online</term>
      <listitem><para>
   function called when device is set online
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>set_offline</term>
      <listitem><para>
   function called when device is set offline
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>shutdown</term>
      <listitem><para>
   function called when device is shut down
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>prepare</term>
      <listitem><para>
   prepare for pm state transition
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>complete</term>
      <listitem><para>
   undo work done in <parameter>prepare</parameter>
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>freeze</term>
      <listitem><para>
   callback for freezing during hibernation snapshotting
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>thaw</term>
      <listitem><para>
   undo work done in <parameter>freeze</parameter>
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>restore</term>
      <listitem><para>
   callback for restoring after hibernation
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>driver</term>
      <listitem><para>
   embedded driver structure
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
</refentry>

<!-- drivers/s390/cio/ccwgroup.c -->
<refentry id="API-ccwgroup-set-online">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ccwgroup_set_online</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ccwgroup_set_online</refname>
 <refpurpose>
  enable a ccwgroup device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>ccwgroup_set_online </function></funcdef>
   <paramdef>struct ccwgroup_device * <parameter>gdev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>gdev</parameter></term>
   <listitem>
    <para>
     target ccwgroup device
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This function attempts to put the ccwgroup device into the online state.
</para>
</refsect1>
<refsect1>
<title>Returns</title>
<para>
   <constant>0</constant> on success and a negative error value on failure.
</para>
</refsect1>
</refentry>

<refentry id="API-ccwgroup-set-offline">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ccwgroup_set_offline</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ccwgroup_set_offline</refname>
 <refpurpose>
     disable a ccwgroup device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>ccwgroup_set_offline </function></funcdef>
   <paramdef>struct ccwgroup_device * <parameter>gdev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>gdev</parameter></term>
   <listitem>
    <para>
     target ccwgroup device
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This function attempts to put the ccwgroup device into the offline state.
</para>
</refsect1>
<refsect1>
<title>Returns</title>
<para>
   <constant>0</constant> on success and a negative error value on failure.
</para>
</refsect1>
</refentry>

<refentry id="API-ccwgroup-create-dev">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ccwgroup_create_dev</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ccwgroup_create_dev</refname>
 <refpurpose>
     create and register a ccw group device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>ccwgroup_create_dev </function></funcdef>
   <paramdef>struct device * <parameter>parent</parameter></paramdef>
   <paramdef>struct ccwgroup_driver * <parameter>gdrv</parameter></paramdef>
   <paramdef>int <parameter>num_devices</parameter></paramdef>
   <paramdef>const char * <parameter>buf</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>parent</parameter></term>
   <listitem>
    <para>
     parent device for the new device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>gdrv</parameter></term>
   <listitem>
    <para>
     driver for the new group device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>num_devices</parameter></term>
   <listitem>
    <para>
     number of slave devices
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>buf</parameter></term>
   <listitem>
    <para>
     buffer containing comma separated bus ids of slave devices
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Create and register a new ccw group device as a child of <parameter>parent</parameter>. Slave
   devices are obtained from the list of bus ids given in <parameter>buf</parameter>.
</para>
</refsect1>
<refsect1>
<title>Returns</title>
<para>
   <constant>0</constant> on success and an error code on failure.
</para>
</refsect1>
<refsect1>
<title>Context</title>
<para>
   non-atomic
</para>
</refsect1>
</refentry>

<refentry id="API-ccwgroup-driver-register">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ccwgroup_driver_register</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ccwgroup_driver_register</refname>
 <refpurpose>
     register a ccw group driver
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>ccwgroup_driver_register </function></funcdef>
   <paramdef>struct ccwgroup_driver * <parameter>cdriver</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>cdriver</parameter></term>
   <listitem>
    <para>
     driver to be registered
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This function is mainly a wrapper around <function>driver_register</function>.
</para>
</refsect1>
</refentry>

<refentry id="API-ccwgroup-driver-unregister">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ccwgroup_driver_unregister</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ccwgroup_driver_unregister</refname>
 <refpurpose>
     deregister a ccw group driver
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>ccwgroup_driver_unregister </function></funcdef>
   <paramdef>struct ccwgroup_driver * <parameter>cdriver</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>cdriver</parameter></term>
   <listitem>
    <para>
     driver to be deregistered
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This function is mainly a wrapper around <function>driver_unregister</function>.
</para>
</refsect1>
</refentry>

<refentry id="API-ccwgroup-probe-ccwdev">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ccwgroup_probe_ccwdev</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ccwgroup_probe_ccwdev</refname>
 <refpurpose>
     probe function for slave devices
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>ccwgroup_probe_ccwdev </function></funcdef>
   <paramdef>struct ccw_device * <parameter>cdev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>cdev</parameter></term>
   <listitem>
    <para>
     ccw device to be probed
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This is a dummy probe function for ccw devices that are slave devices in
   a ccw group device.
</para>
</refsect1>
<refsect1>
<title>Returns</title>
<para>
   always <constant>0</constant>
</para>
</refsect1>
</refentry>

<refentry id="API-ccwgroup-remove-ccwdev">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ccwgroup_remove_ccwdev</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ccwgroup_remove_ccwdev</refname>
 <refpurpose>
     remove function for slave devices
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>ccwgroup_remove_ccwdev </function></funcdef>
   <paramdef>struct ccw_device * <parameter>cdev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>cdev</parameter></term>
   <listitem>
    <para>
     ccw device to be removed
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This is a remove function for ccw devices that are slave devices in a ccw
   group device. It sets the ccw device offline and also deregisters the
   embedding ccw group device.
</para>
</refsect1>
</refentry>

   </sect1>
  </chapter>

  <chapter id="genericinterfaces">
   <title>Generic interfaces</title>
  <para>
	Some interfaces are available to other drivers that do not necessarily
	have anything to do with the busses described above, but still are
	indirectly using basic infrastructure in the common I/O layer.
	One example is the support for adapter interrupts.
  </para>
<!-- drivers/s390/cio/airq.c -->
<refentry id="API-register-adapter-interrupt">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>register_adapter_interrupt</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>register_adapter_interrupt</refname>
 <refpurpose>
  register adapter interrupt handler
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>register_adapter_interrupt </function></funcdef>
   <paramdef>struct airq_struct * <parameter>airq</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>airq</parameter></term>
   <listitem>
    <para>
     pointer to adapter interrupt descriptor
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Returns 0 on success, or -EINVAL.
</para>
</refsect1>
</refentry>

<refentry id="API-unregister-adapter-interrupt">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>unregister_adapter_interrupt</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>unregister_adapter_interrupt</refname>
 <refpurpose>
     unregister adapter interrupt handler
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>unregister_adapter_interrupt </function></funcdef>
   <paramdef>struct airq_struct * <parameter>airq</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>airq</parameter></term>
   <listitem>
    <para>
     pointer to adapter interrupt descriptor
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-airq-iv-create">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>airq_iv_create</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>airq_iv_create</refname>
 <refpurpose>
     create an interrupt vector
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct airq_iv * <function>airq_iv_create </function></funcdef>
   <paramdef>unsigned long <parameter>bits</parameter></paramdef>
   <paramdef>unsigned long <parameter>flags</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>bits</parameter></term>
   <listitem>
    <para>
     number of bits in the interrupt vector
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>flags</parameter></term>
   <listitem>
    <para>
     allocation flags
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Returns a pointer to an interrupt vector structure
</para>
</refsect1>
</refentry>

<refentry id="API-airq-iv-release">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>airq_iv_release</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>airq_iv_release</refname>
 <refpurpose>
     release an interrupt vector
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>airq_iv_release </function></funcdef>
   <paramdef>struct airq_iv * <parameter>iv</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>iv</parameter></term>
   <listitem>
    <para>
     pointer to interrupt vector structure
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-airq-iv-alloc">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>airq_iv_alloc</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>airq_iv_alloc</refname>
 <refpurpose>
     allocate irq bits from an interrupt vector
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>unsigned long <function>airq_iv_alloc </function></funcdef>
   <paramdef>struct airq_iv * <parameter>iv</parameter></paramdef>
   <paramdef>unsigned long <parameter>num</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>iv</parameter></term>
   <listitem>
    <para>
     pointer to an interrupt vector structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>num</parameter></term>
   <listitem>
    <para>
     number of consecutive irq bits to allocate
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Returns the bit number of the first irq in the allocated block of irqs,
   or -1UL if no bit is available or the AIRQ_IV_ALLOC flag has not been
   specified
</para>
</refsect1>
</refentry>

<refentry id="API-airq-iv-free">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>airq_iv_free</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>airq_iv_free</refname>
 <refpurpose>
     free irq bits of an interrupt vector
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>airq_iv_free </function></funcdef>
   <paramdef>struct airq_iv * <parameter>iv</parameter></paramdef>
   <paramdef>unsigned long <parameter>bit</parameter></paramdef>
   <paramdef>unsigned long <parameter>num</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>iv</parameter></term>
   <listitem>
    <para>
     pointer to interrupt vector structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>bit</parameter></term>
   <listitem>
    <para>
     number of the first irq bit to free
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>num</parameter></term>
   <listitem>
    <para>
     number of consecutive irq bits to free
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-airq-iv-scan">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>January 2024</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>airq_iv_scan</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.18.140</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>airq_iv_scan</refname>
 <refpurpose>
     scan interrupt vector for non-zero bits
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>unsigned long <function>airq_iv_scan </function></funcdef>
   <paramdef>struct airq_iv * <parameter>iv</parameter></paramdef>
   <paramdef>unsigned long <parameter>start</parameter></paramdef>
   <paramdef>unsigned long <parameter>end</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>iv</parameter></term>
   <listitem>
    <para>
     pointer to interrupt vector structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>start</parameter></term>
   <listitem>
    <para>
     bit number to start the search
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>end</parameter></term>
   <listitem>
    <para>
     bit number to end the search
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Returns the bit number of the next non-zero interrupt bit, or
   -1UL if the scan completed without finding any more any non-zero bits.
</para>
</refsect1>
</refentry>

  </chapter>

</book>
